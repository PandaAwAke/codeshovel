%!TEX root = ../paper.tex

\section{Motivation and Background}
\label{sec:motivation}

Using source code history for program understanding tasks may seem somewhat unintuitive to some readers at first. This section motivates that this is in fact very common practice among developers. We first illustrate the big picture with a general high-level scenario in Section~\ref{sec:scenario_general} before we provide compulsory background information on the current tooling landscape in Section~\ref{sec:background}. We then make the general scenario from Section~\ref{sec:scenario_general} more specific using an example method in an open-source repository, demonstrating the little help that these tools provide for certain cases (Section~\ref{sec:scenario_specific}).

% =======================
% Sample scenario
% =======================

\subsection{General Scenario}
\label{sec:scenario_general}

Consider the following scenario: a developer is about to review a pull request that changed a method. 
She has not seen this particular segment of code in a while and lacks understanding of what the method is actually doing. 
Since in-place documentation and comments are insufficient for a clear understanding of the code (e.g.,~\cite{XXX,singer97}), and the author of the pull request is unavailable, she decides to investigate in the version history associated with the method. She believes how the method was evolved previously, and who authored those changes, will provide her a clearer understanding of what the method does and the pitfalls other developers have encountered working on it\footnote{The approach of asking version history for gaining a better understanding being very common among software developers is shown in~\cite{XXX} and~\cite{XXX} and also becomes clearly visible from our survey described in Section~\ref{sec:survey}.}.

She first uses her version control tool to show the history of the file containing the method that was changed.
Unfortunately, the file history contains a large number of changes, among which only a few modified the method of interest in this pull request. 
She cannot think of a way to filter the commits for only the changes relevant to this method so she decides to use her version control tool  to select a line-range based history\footnote{This functionality is built into most version control systems.}.
Due to the file having undergone multiple extensive modifications over its lifespan, this history reports many changes that are not connected to the method she is interested in.
Furthermore, this history stops at a fairly recent commit in which the method was moved from another file.
Consequently, even with this type of history filtering, she is not able to obtain a concise view of the past changes that affected this method without extensive manual traversal of the version control history.

\subsection{File- and Line-Based Source Code History}
\label{sec:background}

The scenario in the previous section uses views provided by modern version control systems to search and filter source code history. The most prominent version control system, \textit{Git}, mainly surfaces the this functionality through \texttt{git log} which includes several different options. Typically, a file path is provided for the history specific to a file. In addition, a line range can be provided if the investigator is only interested in a specific part of a file (\texttt{git log -L BEGIN,END:PATH}). There are other advanced options like the \texttt{-S} option which accepts a search string (this is typically called \textit{pickaxe}) and the view will show only the changes associated with that particular string.

Version control tools that provide more abstract views are usually based on \texttt{git log} and its arguments (e.g., Foo~\footnote{XXX:Link}, and Bar~\footnote{XXX:Link}).
While these views sometimes suggest a semantic notion with their functionality, they remain essentially text- and syntax-based. 
For example, the \textit{Show history for method} feature in IntelliJ has no notion of the method as a semantic unit despite the term \textit{method} in the command name within the IDE.
Rather, IntelliJ simply extracts the line range of the method of interest and shows the history for this line range. 
This lack of semantic awareness makes these views produce a high proportion of false positives and false negatives for files that have been involved in non-trivial evolution. Additionally, these tools often report a unit as being new, where in fact it was just moved from a different file (e.g. during refactoring), even though in reality that unit may have a rich prior evolutionary history.

\subsection{Specific Scenario}
\label{sec:scenario_specific}

We illustrate the challenges involved with investigating source code history of a semantic unit of code using the \textit{Checkstyle}\footnote{We forked this repository to keep it stable at a specific commit for illustration purposes in this writing: https://github.com/ataraxie/checkstyle/. Specific commit diffs can be seen using the URL https://github.com/ataraxie/checkstyle/commit/COMMIT\_HASH} project, a popular syntax validation tool for Java. 

Suppose the developer is facing a pull request with a change to the method \texttt{com.puppycrawl.tools.checkstyle.utils.\-Common\-Utils:::createPattern} which can be found on lines 93---112 in \texttt{CommonUtils.java}. 
She now wants to learn more about this method's history so she can better understand the context of the current pull request.
She uses her version control tool to show the history of \texttt{CommonUtils.java}, but unfortunately the file history shows 47 changes to this file in three years and given that \texttt{createPattern} comprises only XXX\% of this file in its current revision, it is unlikely that \texttt{createPattern} is germane to most of these changes.

She now decides to look at the history of the line range for \texttt{createPattern} and issues the command \texttt{git log -L 93,112:\-PATH}\footnote{Full command: git log -L 93,112:src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtils.java. 
This command (or similar ones) are issued by more advanced features of higher-level version control tools like ``Show history for method'' in IntelliJ.}. 
The result is two commits: \texttt{ce21086} changed the body and \texttt{2864c10} is a false positive because the change just moved the method within the file without modifying it. 
Unfortunately, several other changes are missing as well; through an exhaustive manual analysis, many more changes to this method can be found, as shown in Table~\ref{tbl:motivation:actual_history}. 
While these changes, along with the actual changes, could have helped the developer build the understanding they wanted for their task, it is nearly impossible to identify the changes in a timely fashion with the current tools.  

\begin{table}
	\caption{Actual history of method \texttt{Common\-Utils::\-create\-Pattern}. Rows with $\star$ were returned by the version control line range tool used by the project; other rows are false negative results which should have been returned but were not. One false positive result (2864c10) is not included in the list.}
	\label{tbl:motivation:actual_history}

	\begin{tabular}{ l l r }
		\toprule
		\textbf{SHA} & \textbf{Date} & \textbf{Nature of change} \\
		\midrule
		$\star$~ce21086 & 2017-02-24 & Method body change \\
		f65b17c & 2015-11-22 & Method body change \\
		f2c6263 & 2015-10-29 & Param change + body change  \\
		cdf3e56 & 2015-08-27 & File move/rename  \\
		ed595de & 2015-08-26 & File move/rename  \\
		081c654 & 2015-08-01 & Exception change  \\
		97f0829 & 2015-03-27 & Method body change  \\
		ebd4afd & 2015-03-24 & Method body change  \\
		1c15b6a & 2015-03-13 & Method move to other file  \\
		b94bac0 & 2015-01-11 & Param change + body change \\
		f1efb27 & 2014-02-19 & File move/rename \\
		35d1673 & 2006-07-07 & Method body change \\
		e27489c & 2005-05-11 & Body + return type change + rename \\
		b0db9be & 2002-12-08 & Method body change \\
		419d924 & 2002-12-06 & Exception change \\
		7b849d5 & 2002-05-14 & Method body change \\
		8d6fa33 & 2002-01-14 & Method move to other file \\
		f0f7f3e & 2001-06-28 & Method body change \\
		0fd6959 & 2001-06-22 & Method introduced \\
		\bottomrule
	\end{tabular}
\end{table}

\commentout{
\begin{table*}[t]
	\caption{\fg{I started to add a date and the the method signature for each commit and introduced abbreviations for change types (BC = method body change; PC = parameter change; FR = file or package rename; EC = exception change; MM = method move to other file; MR = method rename; RC = return type change; MI = method was introduced). Until I realized that the table is taking too much space this way and I think I want to revert it. Probably we should keep it one column and still add the dates? Don't know if it's valuable. The signature would have illustrated renames and moves some more...}Actual history of method \texttt{Common\-Utils::\-create\-Pattern}. Rows with $\star$ were returned by the version control line range tool used by the project; other rows are false negative results which should have been returned but were not. One false positive result (2864c10) is not included in the list.}
	\label{tbl:motivation:actual_history}
	\begin{tabular}{ l r r r }
		\toprule
		\textbf{SHA} & \textbf{Date} & \textbf{Method Signature} & \textbf{Nature of change} \\
		\midrule
		$\star$~ce21086 & 2017-02-24 & com.puppycrawl.tools.checkstyle.utils.CommonUtils\#createPattern(String pattern, int flags) & BC \\
		f65b17c & 2015-11-22 & com.puppycrawl.tools.checkstyle.utils.CommonUtils\#createPattern(String pattern, int flags) & BC \\
		f2c6263 & 2015-10-29 & com.puppycrawl.tools.checkstyle.utils.CommonUtils\#createPattern(String pattern, int flags) & PC + BC  \\
		cdf3e56 & 2015-08-27 & com.puppycrawl.tools.checkstyle.utils.CommonUtils\#createPattern(String pattern) & FR  \\
		ed595de & 2015-08-26 & com.puppycrawl.tools.checkstyle.utils.Utils\#createPattern(String pattern) & FR  \\
		081c654 & 2015-08-01 & com.puppycrawl.tools.checkstyle.Utils\#createPattern(String pattern) & EC  \\
		97f0829 & 2015-03-27 & com.puppycrawl.tools.checkstyle.Utils\#createPattern(String pattern) & BC  \\
		ebd4afd & 2015-03-24 & com.puppycrawl.tools.checkstyle.Utils\#createPattern(String pattern) & BC  \\
		1c15b6a & XXX & XXX & MM  \\
		b94bac0 & XXX & XXX & PC + BC \\
		f1efb27 & XXX & XXX & FR \\
		35d1673 & XXX & XXX & BC \\
		e27489c & XXX & XXX & MR + RC + BC \\
		b0db9be & XXX & XXX & BC \\
		419d924 & XXX & XXX & EC \\
		8d6fa33 & XXX & XXX & MM \\
		7b849d5 & XXX & XXX & BC \\
		8d6fa33 & XXX & XXX & MM \\
		f0f7f3e & XXX & XXX & BC \\
		0fd6959 & XXX & XXX & MI \\
		\bottomrule
	\end{tabular}
\end{table*}
}

\commentout{
47 changes to this file in three years\footnote{URL} and given the length of the file, it is unlikely that the method of interest is germaine to most of these changes.

To illustrate the challenges of this undertaking with the current tooling, we have chosen a particular method from the open-source project \textit{Checkstyle}\footnote{URL, accessed XXX; we'll use a fork on Github for subsequent links to keep them stable.}, a popular syntax checker for Java that we have also used for a sample scenario in our survey described in Section~\ref{sec:survey}.

\rth{i think a figure here showing the git log output with a Correct? column with X or Check would be helpful for this}
She discovers that this line range has undergone five revisions over two years and that one of the commits renamed the methods from \texttt{whitespaceBefore} to \texttt{hasWhitespaceBefore}. 
From the commit message from the third commit it is clear that the class of interest, \texttt{CommonUtils}, must also have been renamed: ``Utils class has been splitted [sic] to CommonUtils and TokenUtils''. 
Since this was the first commit that appeared for that file, it is clear that prior history for the method of interest must be captured in the history for a different file.
As the history for the line range ends with a commit message ``Moved all methods from checkstyle.api.utils to checkstyle.utils''; 
this suggests the history of the method could be traced to this other resource.

Further analysis of how this method evolved before this commit and where it was actually introduced becomes challenging. 
While the information is available in source code history, the developer does not see a means to view this information concisely with a feasible amount of effort using available versioning tools.
Only through significant effort and manual history browsing could the authors of this paper reveal that this method was introduced 13 years earlier and that it was edited subsequently \rth{how mnany?} times--all information which could not be discovered with the common versioning tools, despite being potentially useful for the developer. \rth{i think we might want to be more concrete than 'potentially useful'; this will probably tie back to the extra sentence i wanted back in the first para}
\rth{i wonder if we want a graph that shows all of the changes, their dates, and highlighting which ones were included in the git log, which weren't, and what spurious ones there are. if you give me a list of the real commits and the git log output i can try to mock something up?}
}