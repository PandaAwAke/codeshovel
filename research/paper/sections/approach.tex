%!TEX root = ../paper.tex

\section{Approach}
\label{sec:approach}

We implemented a prototype tool \textit{CodeShovel} for generating history summaries for Java and JavaScript methods in Git repositories. We chose \textit{method} as sample code unit because we assessed it as the most important level of abstraction. This was confirmed in our survey in Section~\ref{sec:survey}. We chose Git as version control system because it is by far the most prevalent in practice\cite{XXX}. In this section, we summarize our requirements and provide a brief overview of the core implementation. We shipped our prototype as a Bitbucket\footnote{XXX} add-on and we describe how we applied the core implementation to this specific version control tool.

\subsection{Requirements}
\label{sec:requirements}

From a high-level perspective, CodeShovel can be seen as a black box, taking a number of arguments describing a method in a repository as input and producing the method's history as output. The required inputs are as follows:

\begin{itemize}
	\item \textit{Repository}: path to a repository on the file system or URL to a remote repository.
	\item \textit{StartCommit}: hash of the commit to start from and move backwards through history.
	\item \textit{FilePath}: path of the file containing the method relative to the root folder of the repository.
	\item \textit{MethodName}: name of the target method.
	\item \textit{StartLine}: line number for the start of the method\footnote{There could be different methods with the same name, so this is required to identify the correct method. Files with multiple methods with the same name in the same line cannot be handled by CodeShovel at the moment (see Section~\ref{sec:future_work})}.
\end{itemize}

The output for one such input is the version history specific to this method, essentially as outlined in our Table~\ref{tbl:motivation:actual_history}, but with a natural language description of the changes made in each commit and additional meta-information. The additional information consists of simple commit data like the \textit{message}, \textit{author} and \textit{date}, enriched by more complex data like \textit{number of commits since the last commit that changed the method} (a) for the \textit{file} containing the method or (b) in the whole \textit{repository}. The actual output for our example in Table~\ref{tbl:motivation:actual_history} is shown in Figure~\ref{fig:sample_output}. In contrast to currently prevalent file- and line-range based history tools, this history does not show line range operations that did not actually change the method itself (a commonly found false positive in line-range based tools) but does include the moving of methods between files (a false negative in file-based tools). The latter effectively makes method histories produced by CodeStory much longer and richer than the prevalent tools because histories are not capped when refactoring operations occurred.

\begin{figure}[t!]
  \includegraphics[width=0.98\columnwidth]{figures/sample_output}
  \caption{Actual output for our example in Section~\ref{sec:motivation}}
  \label{fig:sample_output}
\end{figure}

For our field study described in Section~\ref{sec:evaluation} and for general practicability, CodeShovel is integrated in a \textbf{BitBucket add-on}. It provides a user interface for selecting the method of interest and its environment, and an integrated view of the outputs.

\subsection{Implementation}
\label{sec:implementation}

We implemented CodeShovel in Java, mainly because it provided sufficiently capable AST parsers for both Java (\textit{JavaParser}\footnote{XXX}) and JavaScript (\textit{Nashorn}\footnote{XXX}) files. We used the Java Git interface \textit{JGit}\footnote{XXX} for Git operations (e.g. \texttt{git log}, \texttt{git checkout}) and for traversing commits in repositories. Given the required AST parsers in Java, the implementation is easily extensible for other languages: all core components with language-specific functionality were realized with abstract classes and interfaces and concrete language-specific implementations. Consequently, for adding other language 'adapters' the only requirement is an implementation of our interfaces. For example, our interface \texttt{Parser} defines a method signature \texttt{findMethodByNameAndLine(name, line)} which is implemented in our class \texttt{JavaParser} that knows how to find a method entity within a Java file, given its name and start line.

CodeShovel's core components are \textit{Parsers}, \textit{Tasks}, \textit{Interpreters} and \textit{Changes}:
\begin{itemize}
	\item \textit{Parsers}: responsible for AST parsing of language-specific files and extracting relevant components (e.g. methods).
	\item \textit{Tasks}: runtime environments for the execution of history tasks.
	\item \textit{Interpreters}: responsible for interpreting changes found for the target method in one specific commit compared to the previous.
	\item \textit{Changes}: entities representing commit-specific changes to the target method.
	\item \textit{Similarity Algorithms}: algorithms for matching methods in order to identify at what entry points a method history needs to be continued.
\end{itemize}

With these components, one \textbf{CodeShovel execution} with the inputs described in Section~\ref{sec:requirements} can be outlined as follows: a \textit{task} is created that saves the given inputs in its environment. Using \texttt{git log}, the history of the file containing the target method is created and for each commit the target method is identified using a \textit{similarity algorithm}. If the method cannot be identified, this is marked in the commit entity. The enriched file history is now iterated and the matched method of each commit is compared with the matched method of the previous commit using an \textit{in-file interpreter}. The result is one \textit{change} instance for each commit, according to the type hierarchy shown in Figure~\ref{fig:changes_hierarchy}. If no matched method can be found in the previous commit, the change type is \texttt{Introduced} and the \textit{task} is stopped at this point. Now, a \textit{cross-file interpreter} tries to find the method in other files that were changed in the commit using a \textit{similarity algorithm}. If it can find one, a new \textit{task} is created with the inputs being extracted from the identified method in the other file. The new task is executed in the same fashion as the previous one. This pattern is repeated recursively, until the \textit{cross-file interpreter} is unable to identify a method in a different file in the previous commits. In this case, the method was \textit{in fact} introduced in this commit and the recursive task chain will end and the resulting history is shown.

\begin{figure}[t!]
  \includegraphics[width=0.98\columnwidth]{figures/changes_hierarchy}
  \caption{Type hierarchy of changes in CodeShovel}
  \label{fig:changes_hierarchy}
\end{figure}

Our \textbf{similarity algorithms} are currently based on five metrics that we assess to work for most programming languages:
\begin{itemize}
	\item \textit{Body similarity}: textual similarity\footnote{We use the Jaroâ€“Winkler distance algorithm for determining textual similarity.} of the method body.
	\item \textit{Name similarity}: textual similarity of the method name.
	\item \textit{Parameter similarity}: textual similarity of parameter names and equality of parameter types (if supported by the language).
	\item \textit{Scope similarity}: name equality of the scope containing the method, e.g. the class or parent function (only used for in-file comparison).
	\item \textit{Line similiarity}: distance between the start line of the two methods (only used for in-file comparison).
\end{itemize}

Once all metrics are determined for a method pair, an overall similarity is created using weights for each metric. Currently, the weights are (XXX,XXX,XXX,XXX) for in-file comparison and (XXX,XXX) for cross-file comparison in sequence of the metrics in the list above. We have found these metrics and weights to be sufficiently accurate for our prototype implementation.

The integration of the core implementation in our \textbf{BitBucket add-on} was performed using the developer APIs provided by the \textit{Atlassian Plugin SDK}. Whenever a Java or JavaScript method is selected in the BitBucket Web application, a small popup with a link to the method history is shown. A \textit{Method History} view is then shown upon click which was implemented with the \textit{Servlet} component of the Atlassian Plugin SDK\footnote{XXX} (see Figure~\ref{fig:sample_output} for an example).

\begin{figure}[t!]
  \includegraphics[width=0.98\columnwidth]{figures/bitbucket_popup}
  \caption{Popup with link to method history}
  \label{fig:bitbucket_popup}
\end{figure}

