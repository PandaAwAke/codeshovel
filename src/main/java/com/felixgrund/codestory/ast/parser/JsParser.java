package com.felixgrund.codestory.ast.parser;import jdk.nashorn.internal.ir.FunctionNode;import jdk.nashorn.internal.parser.Parser;import jdk.nashorn.internal.runtime.Context;import jdk.nashorn.internal.runtime.ErrorManager;import jdk.nashorn.internal.runtime.Source;import jdk.nashorn.internal.runtime.options.Options;import java.io.IOException;import java.util.List;public class JsParser {	private FunctionNode rootFunctionNode;	public JsParser(String fileName, String fileContent) throws IOException {		Options options = new Options("nashorn");		options.set("anon.functions", true);		options.set("parse.only", true);		options.set("scripting", true);		options.set("language", "es6");		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();		ErrorManager errorManager = new ErrorManager();		Context context = new Context(options, errorManager, classLoader);		Source source = Source.sourceFor(fileName, fileContent);		Parser parser = new Parser(context.getEnv(), source, errorManager);		this.rootFunctionNode = parser.parse();	}	public FunctionNode findFunctionByFunctionPath(String functionPath) {		return findFunction(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				return functionNode.getName().equals(functionPath);			}		});	}	public FunctionNode findFunctionByNameAndLine(String name, int line) {		return findFunction(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				return functionNode.getLineNumber() == line && functionNode.getIdent().getName().equals(name);			}		});	}	private FunctionNode findFunction(FunctionNodeVisitor visitor) {		FunctionNode ret = null;		this.rootFunctionNode.accept(visitor);		List<FunctionNode> matchedNodes = visitor.getMatchedNodes();		if (matchedNodes.size() > 0) {			ret = matchedNodes.get(0);		}		return ret;	}}