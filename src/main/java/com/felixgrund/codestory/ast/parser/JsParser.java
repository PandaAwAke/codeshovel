package com.felixgrund.codestory.ast.parser;import com.felixgrund.codestory.ast.exceptions.ParseException;import com.felixgrund.codestory.ast.util.Utl;import jdk.nashorn.internal.ir.FunctionNode;import jdk.nashorn.internal.ir.IdentNode;import jdk.nashorn.internal.parser.Parser;import jdk.nashorn.internal.runtime.Context;import jdk.nashorn.internal.runtime.ErrorManager;import jdk.nashorn.internal.runtime.Source;import jdk.nashorn.internal.runtime.options.Options;import org.apache.commons.text.similarity.JaroWinklerDistance;import java.io.IOException;import java.util.List;public class JsParser {	private String fileName;	private String fileContent;	private Options parserOptions;	private FunctionNode rootFunctionNode;	public JsParser(String fileName, String fileContent) {		this.parserOptions = new Options("nashorn");		this.parserOptions.set("anon.functions", true);		this.parserOptions.set("parse.only", true);		this.parserOptions.set("scripting", true);		this.parserOptions.set("language", "es6");		this.fileName = fileName;		this.fileContent = fileContent;	}	public void parse() throws ParseException {		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();		ErrorManager errorManager = new ErrorManager();		Context context = new Context(this.parserOptions, errorManager, classLoader);		Source source = Source.sourceFor(this.fileName, this.fileContent);		Parser originalParser = new Parser(context.getEnv(), source, errorManager);		this.rootFunctionNode = originalParser.parse();		if (this.rootFunctionNode == null) {			throw new ParseException("Could not parse root function node", this.fileName, this.fileContent);		}	}	public FunctionNode findFunctionByFunctionPath(String functionPath) {		return findFunction(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				return functionNode.getName().equals(functionPath);			}		});	}	public FunctionNode findFunctionByNameAndLine(String name, int line) {		return findFunction(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				String functionIdent = functionNode.getIdent().getName();				return functionNode.getLineNumber() == line && functionNode.getIdent().getName().equals(name);			}		});	}	public List<FunctionNode> findFunctionByNode(FunctionNode otherNode) {		String functionNameOther = otherNode.getIdent().getName();		return findAllFunctions(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				String functionNameThis = functionNode.getIdent().getName();				boolean nameMatches = functionNameThis.equals(functionNameOther);				boolean paramsMatch = parametersMatch(functionNode, otherNode);				return nameMatches && paramsMatch;			}		});	}	private boolean parametersMatch(FunctionNode node1, FunctionNode node2) {		if (node1.getNumOfParams() != node2.getNumOfParams()) {			return false;		}		for (int i = 0; i < node1.getNumOfParams(); i++) {			String node1ParamName = node1.getParameter(i).getName();			String node2ParamName = node2.getParameter(i).getName();			if (!node1ParamName.equals(node2ParamName)) {				return false;			}		}		return true;	}	public List<FunctionNode> findFunctionsByName(String name) {		return findAllFunctions(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				return functionNode.getIdent().getName().equals(name);			}		});	}	public FunctionNode findFunctionByNameAndBody(String name, String body) {		return findFunction(new FunctionNodeVisitor() {			@Override			public boolean nodeMatches(FunctionNode functionNode) {				if (functionNode.getIdent().getName().equals(name)) {					String bodyString = Utl.getFunctionBody(functionNode);					JaroWinklerDistance distance = new JaroWinklerDistance();					Double score = distance.apply(body, bodyString);					return score > 0.9;				}				return false;			}		});	}	private FunctionNode findFunction(FunctionNodeVisitor visitor) {		FunctionNode ret = null;		this.rootFunctionNode.accept(visitor);		List<FunctionNode> matchedNodes = visitor.getMatchedNodes();		if (matchedNodes.size() > 0) {			ret = matchedNodes.get(0);		}		return ret;	}	private List<FunctionNode> findAllFunctions(FunctionNodeVisitor visitor) {		this.rootFunctionNode.accept(visitor);		return visitor.getMatchedNodes();	}}