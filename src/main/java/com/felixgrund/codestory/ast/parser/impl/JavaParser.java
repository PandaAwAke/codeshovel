package com.felixgrund.codestory.ast.parser.impl;import com.felixgrund.codestory.ast.parser.Yfunction;import com.felixgrund.codestory.ast.entities.Yparameter;import com.felixgrund.codestory.ast.exceptions.ParseException;import com.felixgrund.codestory.ast.parser.AbstractParser;import com.felixgrund.codestory.ast.parser.Yparser;import com.github.javaparser.ast.CompilationUnit;import com.github.javaparser.ast.body.MethodDeclaration;import com.github.javaparser.ast.visitor.VoidVisitorAdapter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;public class JavaParser extends AbstractParser implements Yparser {	private Logger log = LoggerFactory.getLogger(JavaParser.class);	private CompilationUnit rootCompilationUnit;	public JavaParser(String fileName, String fileContent) {		super(fileName, fileContent);	}	@Override	public Yfunction findFunctionByNameAndLine(String name, int line) {		Yfunction ret = null;		MethodDeclaration method = findMethod(new MethodVisitor() {			@Override			public boolean methodMatches(MethodDeclaration method) {				String methodName = method.getNameAsString();				int methodLineNumber = getMethodStartLine(method); // TODO get() ?				return name.equals(methodName) && line == methodLineNumber;			}		});		if (method != null) {			ret = new JavaFunction(method);		}		return ret;	}	@Override	public List<Yfunction> findFunctionsByLineRange(int beginLine, int endLine) {		List<Yfunction> functions = new ArrayList<>();		List<MethodDeclaration> matchedMethods = findAllMethods(new MethodVisitor() {			@Override			public boolean methodMatches(MethodDeclaration method) {				int lineNumber = getMethodStartLine(method);				return lineNumber >= beginLine && lineNumber <= endLine;			}		});		for (MethodDeclaration method : matchedMethods) {			int lineNumber = getMethodStartLine(method);			String name = method.getNameAsString();			functions.add(new JavaFunction(method));		}		return transformMethods(matchedMethods);	}	@Override	public List<Yfunction> getAllFunctions() {		List<MethodDeclaration> matchedMethods = findAllMethods(new MethodVisitor() {			@Override			public boolean methodMatches(MethodDeclaration method) {				return !method.isAbstract();			}		});		return transformMethods(matchedMethods);	}	@Override	public Yfunction findFunctionByOtherFunction(Yfunction otherMethod) {		Yfunction function = null;		String methodNameOther = otherMethod.getName();		List<Yparameter> parametersOther = otherMethod.getParameters();		List<MethodDeclaration> matchedMethods = findAllMethods(new MethodVisitor() {			@Override			public boolean methodMatches(MethodDeclaration method) {				Yfunction yfunction = new JavaFunction(method);				String methodNameThis = yfunction.getName();				List<Yparameter> parametersThis = yfunction.getParameters();				boolean methodNameMatches = methodNameOther.equals(methodNameThis);				boolean parametersMatch = parametersOther.equals(parametersThis);				return methodNameMatches && parametersMatch;			}		});		int numMatches = matchedMethods.size();		if (numMatches > 1) {			log.error("Found more than one matching function. This should not happen in the Java case.");		}		if (numMatches > 0) {			function = new JavaFunction(matchedMethods.get(0));		}		return function;	}	@Override	public Object parse() throws ParseException {		this.rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);		if (this.rootCompilationUnit == null) {			throw new ParseException("Could not parse root compilation unit", this.fileName, this.fileContent);		}		return this.rootCompilationUnit;	}	@Override	public boolean functionNamesConsideredEqual(String aName, String bName) {		return aName != null && aName.equals(bName);	}	private List<Yfunction> transformMethods(List<MethodDeclaration> methods) {		List<Yfunction> functions = new ArrayList<>();		for (MethodDeclaration method : methods) {			functions.add(new JavaFunction(method));		}		return functions;	}	private MethodDeclaration findMethod(MethodVisitor visitor) {		MethodDeclaration ret = null;		List<MethodDeclaration> matchedNodes = findAllMethods(visitor);		if (matchedNodes.size() > 0) {			ret = matchedNodes.get(0);		}		return ret;	}	private List<MethodDeclaration> findAllMethods(MethodVisitor visitor) {		this.rootCompilationUnit.accept(visitor, null);		return visitor.getMatchedNodes();	}	public static int getMethodStartLine(MethodDeclaration method) {		return method.getName().getBegin().get().line;	}	public static abstract class MethodVisitor extends VoidVisitorAdapter<Void> {		private List<MethodDeclaration> matchedNodes = new ArrayList<>();		public abstract boolean methodMatches(MethodDeclaration method);		@Override		public void visit(MethodDeclaration method, Void arg) {			super.visit(method, arg);			if (methodMatches(method)) {				matchedNodes.add(method);			}		}		public List<MethodDeclaration> getMatchedNodes() {			return matchedNodes;		}	}}