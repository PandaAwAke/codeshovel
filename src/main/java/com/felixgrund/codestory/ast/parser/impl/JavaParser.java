package com.felixgrund.codestory.ast.parser.impl;import com.felixgrund.codestory.ast.entities.Yfunction;import com.felixgrund.codestory.ast.entities.Yparameter;import com.felixgrund.codestory.ast.entities.Yreturn;import com.felixgrund.codestory.ast.exceptions.ParseException;import com.felixgrund.codestory.ast.parser.AbstractParser;import com.felixgrund.codestory.ast.parser.Yparser;import com.github.javaparser.ast.CompilationUnit;import com.github.javaparser.ast.body.MethodDeclaration;import com.github.javaparser.ast.body.Parameter;import com.github.javaparser.ast.visitor.VoidVisitorAdapter;import java.util.ArrayList;import java.util.List;public class JavaParser extends AbstractParser implements Yparser {	private CompilationUnit rootCompilationUnit;	public JavaParser(String fileName, String fileContent) {		super(fileName, fileContent);	}	@Override	public Yfunction findFunctionByNameAndLine(String name, int line) {		Yfunction ret = null;		MethodDeclaration method = findMethod(new MethodVisitor() {			@Override			public boolean methodMatches(MethodDeclaration method) {				String methodName = method.getNameAsString();				int methodLineNumber = method.getBegin().get().line; // TODO get() ?				return name.equals(methodName) && line == methodLineNumber;			}		});		if (method != null) {			ret = new Yfunction(name, getMethodBody(method), getMethodParameters(method), getMethodReturn(method));		}		return ret;	}	@Override	public List<Yfunction> findFunctionByOtherFunction(Yfunction otherFunction) {		return null; // TODO!!	}	@Override	public void parse() throws ParseException {		this.rootCompilationUnit = com.github.javaparser.JavaParser.parse(this.fileContent);		if (this.rootCompilationUnit == null) {			throw new ParseException("Could not parse root compilation unit", this.fileName, this.fileContent);		}	}	private Yreturn getMethodReturn(MethodDeclaration method) {		return new Yreturn(method.getTypeAsString());	}	private String getMethodBody(MethodDeclaration method) {		return method.getBody().get().toString(); // TODO get() ?	}	private List<Yparameter> getMethodParameters(MethodDeclaration method) {		List<Yparameter> parameters = new ArrayList<>();		List<Parameter> parameterElements = method.getParameters();		for (Parameter parameterElement : parameterElements) {			Yparameter parameter = new Yparameter(parameterElement.getNameAsString(), parameterElement.getTypeAsString());			parameters.add(parameter);		}		return parameters;	}	private MethodDeclaration findMethod(MethodVisitor visitor) {		MethodDeclaration ret = null;		this.rootCompilationUnit.accept(visitor, null);		List<MethodDeclaration> matchedNodes = visitor.getMatchedNodes();		if (matchedNodes.size() > 0) {			ret = matchedNodes.get(0);		}		return ret;	}	private abstract class MethodVisitor extends VoidVisitorAdapter<Void> {		private List<MethodDeclaration> matchedNodes = new ArrayList<>();		public abstract boolean methodMatches(MethodDeclaration method);		@Override		public void visit(MethodDeclaration method, Void arg) {            /* here you can access the attributes of the method.             this method will be called for all methods in this             CompilationUnit, including inner class methods */			System.out.println(method.getName());			super.visit(method, arg);			if (methodMatches(method)) {				matchedNodes.add(method);			}		}		public List<MethodDeclaration> getMatchedNodes() {			return matchedNodes;		}	}}