{
  "origin": "codeshovel",
  "repositoryName": "commons-io",
  "repositoryPath": "/repos/commons-io/.git",
  "startCommitName": "559de2c461e94ab636c959149c775bb27111fb48",
  "sourceFileName": "Tailer.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "src/main/java/org/apache/commons/io/input/Tailer.java",
  "functionStartLine": 406,
  "functionEndLine": 496,
  "changeHistory": [
    "467386105ad855e793a09632142c00cd01c5dd10",
    "56f2a758983611adea7308e90ae9934c973efa72",
    "45fbfb82fd1f5168a7183e78ece89da7a60e21fe",
    "4dc97b64005f0083b2facaa70f661138a4fa3fc0",
    "7705470ba1ca2bf95f6442f06f68f007f33a4aeb",
    "62a47bf10c42039875bc9bf7790feb470b3205aa",
    "6aa00766b9103d75c763160280429af8e1f0549e",
    "3789b1aa9669cff2f434eba56f57c500662ead10",
    "3db2debddb4840f415570f88fb4a7794724b7930",
    "c395904915ca330d8944d74f9502c0f4bcf65907",
    "199dd8dfd1cef867ad8712c7565f090f81be0e7f",
    "24330e7703383c78411225dd9b99ebfe57b31ad5",
    "59ffcad15d220c2bc1f70f01d58bc31dec04b423",
    "f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6",
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
    "4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8",
    "cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76",
    "230a3c292c67918a019d96f15f2fb30bbb261bc1",
    "25032e70cbf8cb14de334a5002811852867d16dd",
    "a32a395a621098ce652ee8158e6320fa422f9fa3",
    "587f5571c6eb5a55b752fd7bfd66c2c535f5e566"
  ],
  "changeHistoryShort": {
    "467386105ad855e793a09632142c00cd01c5dd10": "Ybodychange",
    "56f2a758983611adea7308e90ae9934c973efa72": "Ybodychange",
    "45fbfb82fd1f5168a7183e78ece89da7a60e21fe": "Ybodychange",
    "4dc97b64005f0083b2facaa70f661138a4fa3fc0": "Ybodychange",
    "7705470ba1ca2bf95f6442f06f68f007f33a4aeb": "Ybodychange",
    "62a47bf10c42039875bc9bf7790feb470b3205aa": "Ybodychange",
    "6aa00766b9103d75c763160280429af8e1f0549e": "Ybodychange",
    "3789b1aa9669cff2f434eba56f57c500662ead10": "Ybodychange",
    "3db2debddb4840f415570f88fb4a7794724b7930": "Ybodychange",
    "c395904915ca330d8944d74f9502c0f4bcf65907": "Ybodychange",
    "199dd8dfd1cef867ad8712c7565f090f81be0e7f": "Ybodychange",
    "24330e7703383c78411225dd9b99ebfe57b31ad5": "Ybodychange",
    "59ffcad15d220c2bc1f70f01d58bc31dec04b423": "Ybodychange",
    "f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6": "Ybodychange",
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a": "Yfilerename",
    "4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8": "Ybodychange",
    "cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76": "Ybodychange",
    "230a3c292c67918a019d96f15f2fb30bbb261bc1": "Ybodychange",
    "25032e70cbf8cb14de334a5002811852867d16dd": "Ybodychange",
    "a32a395a621098ce652ee8158e6320fa422f9fa3": "Ybodychange",
    "587f5571c6eb5a55b752fd7bfd66c2c535f5e566": "Yintroduced"
  },
  "changeHistoryDetails": {
    "467386105ad855e793a09632142c00cd01c5dd10": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t need to nest else clause.",
      "commitDate": 1520353633000,
      "commitName": "467386105ad855e793a09632142c00cd01c5dd10",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": 1506632587000,
      "commitNameOld": "56f2a758983611adea7308e90ae9934c973efa72",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 158.81,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,91 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save \u003d reader) {\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we\u0027re sure that the old file is rotated\n                         // Finish scanning the old file and then we\u0027ll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (final IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position \u003d 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                         Thread.sleep(delayMillis);\n                     }\n                     continue;\n-                } else {\n-                    // File was not rotated\n-                    // See if the file needs to be read again\n-                    if (length \u003e position) {\n-                        // The file has more content than it did last time\n-                        position \u003d readLines(reader);\n-                        last \u003d file.lastModified();\n-                    } else if (newer) {\n-                        /*\n-                         * This can happen if the file is truncated or overwritten with the exact same length of\n-                         * information. In cases like this, the file position needs to be reset\n-                         */\n-                        position \u003d 0;\n-                        reader.seek(position); // cannot be null here\n+                }\n+                // File was not rotated\n+                // See if the file needs to be read again\n+                if (length \u003e position) {\n+                    // The file has more content than it did last time\n+                    position \u003d readLines(reader);\n+                    last \u003d file.lastModified();\n+                } else if (newer) {\n+                    /*\n+                     * This can happen if the file is truncated or overwritten with the exact same length of\n+                     * information. In cases like this, the file position needs to be reset\n+                     */\n+                    position \u003d 0;\n+                    reader.seek(position); // cannot be null here\n \n-                        // Now we can read new lines\n-                        position \u003d readLines(reader);\n-                        last \u003d file.lastModified();\n-                    }\n+                    // Now we can read new lines\n+                    position \u003d readLines(reader);\n+                    last \u003d file.lastModified();\n                 }\n                 if (reOpen \u0026\u0026 reader !\u003d null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader !\u003d null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "56f2a758983611adea7308e90ae9934c973efa72": {
      "type": "Ybodychange",
      "commitMessage": "Consistently use the final modifier with local variables.",
      "commitDate": 1506632587000,
      "commitName": "56f2a758983611adea7308e90ae9934c973efa72",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": 1506535203000,
      "commitNameOld": "a768fe9aacf04cce58441ba5cbe6e0d03c2a11d8",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save \u003d reader) {\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we\u0027re sure that the old file is rotated\n                         // Finish scanning the old file and then we\u0027ll start with the new one\n                         try {\n                             readLines(save);\n-                        }  catch (IOException ioe) {\n+                        }  catch (final IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position \u003d 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                         Thread.sleep(delayMillis);\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     }\n                 }\n                 if (reOpen \u0026\u0026 reader !\u003d null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader !\u003d null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45fbfb82fd1f5168a7183e78ece89da7a60e21fe": {
      "type": "Ybodychange",
      "commitMessage": "IO-528: fix Tailer.run race condition runaway logging (closes #29)\n",
      "commitDate": 1492939771000,
      "commitName": "45fbfb82fd1f5168a7183e78ece89da7a60e21fe",
      "commitAuthor": "Dave Moten",
      "commitDateOld": 1487183873000,
      "commitNameOld": "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030",
      "commitAuthorOld": "Sebastian Kürten",
      "daysBetweenCommits": 66.62,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,92 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save \u003d reader) {\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we\u0027re sure that the old file is rotated\n                         // Finish scanning the old file and then we\u0027ll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position \u003d 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n+                        Thread.sleep(delayMillis);\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     }\n                 }\n                 if (reOpen \u0026\u0026 reader !\u003d null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader !\u003d null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4dc97b64005f0083b2facaa70f661138a4fa3fc0": {
      "type": "Ybodychange",
      "commitMessage": "[IO-505] Deprecated of all IOUtils.closeQuietly() methods and use try-with-resources internally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1742675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1462579617000,
      "commitName": "4dc97b64005f0083b2facaa70f661138a4fa3fc0",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1447344401000,
      "commitNameOld": "e76397c0c7f7889f82a0a59203ad16a673f1e704",
      "commitAuthorOld": "Kristian Rosenvold",
      "daysBetweenCommits": 176.33,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,91 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n-                    // Reopen the reader after rotation\n-                    try {\n-                        // Ensure that the old file is closed iff we re-open it successfully\n-                        final RandomAccessFile save \u003d reader;\n+                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n+                    // successfully\n+                    try (RandomAccessFile save \u003d reader) {\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we\u0027re sure that the old file is rotated\n                         // Finish scanning the old file and then we\u0027ll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position \u003d 0;\n-                        // close old file explicitly rather than relying on GC picking up previous RAF\n-                        IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d file.lastModified();\n                     }\n                 }\n-                if (reOpen) {\n-                    IOUtils.closeQuietly(reader);\n+                if (reOpen \u0026\u0026 reader !\u003d null) {\n+                    reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n-            stop(e);\n+            listener.handle(e);\n         } catch (final Exception e) {\n-            stop(e);\n+            listener.handle(e);\n         } finally {\n-            IOUtils.closeQuietly(reader);\n+            try {\n+                if (reader !\u003d null) {\n+                    reader.close();\n+                }\n+            }\n+            catch (final IOException e) {\n+                listener.handle(e);\n+            }\n+            stop();\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7705470ba1ca2bf95f6442f06f68f007f33a4aeb": {
      "type": "Ybodychange",
      "commitMessage": "IO-279  Tailer erroneously considers file as new.\n        Fix to use file.lastModified() rather than System.currentTimeMillis()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1476097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1366964761000,
      "commitName": "7705470ba1ca2bf95f6442f06f68f007f33a4aeb",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1366845859000,
      "commitNameOld": "effe551657921069b871519156a934e4ef3ae916",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 1.38,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n-                    last \u003d System.currentTimeMillis();\n+                    last \u003d file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         final RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we\u0027re sure that the old file is rotated\n                         // Finish scanning the old file and then we\u0027ll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n-                        last \u003d System.currentTimeMillis();\n+                        last \u003d file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n-                        last \u003d System.currentTimeMillis();\n+                        last \u003d file.lastModified();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             stop(e);\n         } catch (final Exception e) {\n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "62a47bf10c42039875bc9bf7790feb470b3205aa": {
      "type": "Ybodychange",
      "commitMessage": "IO-338 When a file is rotated, finish reading previous file prior to starting new one\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1468723 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1366165563000,
      "commitName": "62a47bf10c42039875bc9bf7790feb470b3205aa",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1366160382000,
      "commitNameOld": "8d52f694da0484cb2783a8b35dad845322af0c07",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,86 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         final RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n+                        // At this point, we\u0027re sure that the old file is rotated\n+                        // Finish scanning the old file and then we\u0027ll start with the new one\n+                        try {\n+                            readLines(save);\n+                        }  catch (IOException ioe) {\n+                            listener.handle(ioe);\n+                        }\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {            \n             Thread.currentThread().interrupt();\n             stop(e);\n         } catch (final Exception e) {            \n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6aa00766b9103d75c763160280429af8e1f0549e": {
      "type": "Ybodychange",
      "commitMessage": "Use final where possible.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1415850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1354308699000,
      "commitName": "6aa00766b9103d75c763160280429af8e1f0549e",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1353544570000,
      "commitNameOld": "3789b1aa9669cff2f434eba56f57c500662ead10",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 8.84,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n-                } catch (FileNotFoundException e) {\n+                } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n-                boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n+                final boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n-                long length \u003d file.length();\n+                final long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n-                        RandomAccessFile save \u003d reader;\n+                        final RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n-                    } catch (FileNotFoundException e) {\n+                    } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n-        } catch (InterruptedException e) {            \n+        } catch (final InterruptedException e) {            \n             Thread.currentThread().interrupt();\n             stop(e);\n-        } catch (Exception e) {            \n+        } catch (final Exception e) {            \n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3789b1aa9669cff2f434eba56f57c500662ead10": {
      "type": "Ybodychange",
      "commitMessage": "[IO-358][Tailer] InterruptedException while the thread is sleeping is silently ignored.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1412391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1353544570000,
      "commitName": "3789b1aa9669cff2f434eba56f57c500662ead10",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1353468542000,
      "commitNameOld": "3225374e9f6362a4a59d0cf8b3da9b92905bbd27",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.88,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,79 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader \u003d\u003d null) {\n-                    try {\n-                        Thread.sleep(delayMillis);\n-                    } catch (InterruptedException e) {\n-                    }\n+                    Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n                 if (length \u003c position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n-                try {\n-                    Thread.sleep(delayMillis);\n-                } catch (InterruptedException e) {\n-                }\n+                Thread.sleep(delayMillis);\n                 if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n-        } catch (Exception e) {\n-            listener.handle(e);\n+        } catch (InterruptedException e) {            \n+            Thread.currentThread().interrupt();\n+            stop(e);\n+        } catch (Exception e) {            \n+            stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3db2debddb4840f415570f88fb4a7794724b7930": {
      "type": "Ybodychange",
      "commitMessage": "[IO-345] Supply a hook method allowing Tailer actively determining stop condition.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1391419 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1348834239000,
      "commitName": "3db2debddb4840f415570f88fb4a7794724b7930",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1339376998000,
      "commitNameOld": "c395904915ca330d8944d74f9502c0f4bcf65907",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 109.46,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n-            while (run \u0026\u0026 reader \u003d\u003d null) {\n+            while (getRun() \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n-            while (run) {\n+            while (getRun()) {\n \n                 boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n \n                     } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n-                if (run \u0026\u0026 reOpen) {\n+                if (getRun() \u0026\u0026 reOpen) {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c395904915ca330d8944d74f9502c0f4bcf65907": {
      "type": "Ybodychange",
      "commitMessage": "[IO-269] Tailer locks file from deletion/rename on Windows.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1348698 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1339376998000,
      "commitName": "c395904915ca330d8944d74f9502c0f4bcf65907",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1339113289000,
      "commitNameOld": "199dd8dfd1cef867ad8712c7565f090f81be0e7f",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 3.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,97 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n                 boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n \n                     } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position \u003d readLines(reader);\n                         last \u003d System.currentTimeMillis();\n                     }\n                 }\n+                if (reOpen) {\n+                    IOUtils.closeQuietly(reader);\n+                }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n+                if (run \u0026\u0026 reOpen) {\n+                    reader \u003d new RandomAccessFile(file, RAF_MODE);\n+                    reader.seek(position);\n+                }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "199dd8dfd1cef867ad8712c7565f090f81be0e7f": {
      "type": "Ybodychange",
      "commitMessage": "IO-279 - Tailer erroneously considers file as new.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1347836 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1339113289000,
      "commitName": "199dd8dfd1cef867ad8712c7565f090f81be0e7f",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1339111428000,
      "commitNameOld": "41dfac731ef973b03f70d8f9c01afc67bc5f311d",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,90 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n+                boolean newer \u003d FileUtils.isFileNewer(file, last); // IO-279, must be done first\n+\n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n-                        last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n+                        last \u003d System.currentTimeMillis();\n \n-                    } else if (FileUtils.isFileNewer(file, last)) {\n+                    } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n-                        last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n+                        last \u003d System.currentTimeMillis();\n                     }\n                 }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "24330e7703383c78411225dd9b99ebfe57b31ad5": {
      "type": "Ybodychange",
      "commitMessage": "Rename delay to delayMillis for param name, Javadoc, and private ivar; accessor remains the same.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1345280 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1338571846000,
      "commitName": "24330e7703383c78411225dd9b99ebfe57b31ad5",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1338571641000,
      "commitNameOld": "59ffcad15d220c2bc1f70f01d58bc31dec04b423",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     try {\n-                        Thread.sleep(delay);\n+                        Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n                 try {\n-                    Thread.sleep(delay);\n+                    Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59ffcad15d220c2bc1f70f01d58bc31dec04b423": {
      "type": "Ybodychange",
      "commitMessage": "[IO-332] Improve tailer\u0027s reading performance.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1345279 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1338571641000,
      "commitName": "59ffcad15d220c2bc1f70f01d58bc31dec04b423",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": 1332449729000,
      "commitNameOld": "cf5c462807a137b823a3155dfe9800b3cbf2303d",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 70.86,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,88 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n-                    reader \u003d new RandomAccessFile(file, \"r\");\n+                    reader \u003d new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     try {\n                         Thread.sleep(delay);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n-                    reader.seek(position);                    \n+                    reader.seek(position);\n                 }\n             }\n \n-\n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n-                        reader \u003d new RandomAccessFile(file, \"r\");\n+                        reader \u003d new RandomAccessFile(file, RAF_MODE);\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n-                        /* This can happen if the file is truncated or overwritten\n-                         * with the exact same length of information. In cases like\n-                         * this, the file position needs to be reset\n+                        /*\n+                         * This can happen if the file is truncated or overwritten with the exact same length of\n+                         * information. In cases like this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n                 try {\n                     Thread.sleep(delay);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6": {
      "type": "Ybodychange",
      "commitMessage": "IO-177 Should be handling InterruptedException when sleeping - not calling the exception handler\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1005921 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1286559718000,
      "commitName": "f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": 1286218476000,
      "commitNameOld": "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 3.95,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,89 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n-                    Thread.sleep(delay);\n+                    try {\n+                        Thread.sleep(delay);\n+                    } catch (InterruptedException e) {\n+                    }\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n-\n-                Thread.sleep(delay);\n+                try {\n+                    Thread.sleep(delay);\n+                } catch (InterruptedException e) {\n+                }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a": {
      "type": "Yfilerename",
      "commitMessage": "Build changes - re-organize to standard m2 layout, remove useless JIRA report and fix some Ant issues\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1004358 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1286218476000,
      "commitName": "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": 1286214840000,
      "commitNameOld": "19f48eb1711427a43a5e10c84bbbf1218a08bdd2",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/io/input/Tailer.java",
        "newPath": "src/main/java/org/apache/commons/io/input/Tailer.java"
      }
    },
    "4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8": {
      "type": "Ybodychange",
      "commitMessage": "Cannot be null\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1003696 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285972689000,
      "commitName": "4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1285865773000,
      "commitNameOld": "70f4ddc09819068a13fcb522ad08340140d48f37",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n-                        reader.seek(position);\n+                        reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76": {
      "type": "Ybodychange",
      "commitMessage": "Original code kept the RAF if the re-open failed.\nRevert to the same behaviour, but explicitly close the file\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002933 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285813847000,
      "commitName": "cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1285812387000,
      "commitNameOld": "230a3c292c67918a019d96f15f2fb30bbb261bc1",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,84 @@\n     public void run() {\n         RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n-                        IOUtils.closeQuietly(reader);\n+                        // Ensure that the old file is closed iff we re-open it successfully\n+                        RandomAccessFile save \u003d reader;\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n+                        // close old file explicitly rather than relying on GC picking up previous RAF\n+                        IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n+                        // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "230a3c292c67918a019d96f15f2fb30bbb261bc1": {
      "type": "Ybodychange",
      "commitMessage": "Ensure file is closed\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002931 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285812387000,
      "commitName": "230a3c292c67918a019d96f15f2fb30bbb261bc1",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1285811029000,
      "commitNameOld": "9f17760e3ea10bc221a006e10728c611f3b8ba01",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,80 @@\n     public void run() {\n+        RandomAccessFile reader \u003d null;\n         try {\n             long last \u003d 0; // The last time the file was checked for changes\n             long position \u003d 0; // position within the file\n-            RandomAccessFile reader \u003d null;\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n+                        IOUtils.closeQuietly(reader);\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         last \u003d System.currentTimeMillis();\n                         position \u003d readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n+        } finally {\n+            IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25032e70cbf8cb14de334a5002811852867d16dd": {
      "type": "Ybodychange",
      "commitMessage": "Localise variables to run() method\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002922 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285810849000,
      "commitName": "25032e70cbf8cb14de334a5002811852867d16dd",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1285808936000,
      "commitNameOld": "a32a395a621098ce652ee8158e6320fa422f9fa3",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,77 @@\n     public void run() {\n         try {\n+            long last \u003d 0; // The last time the file was checked for changes\n+            long position \u003d 0; // position within the file\n+            RandomAccessFile reader \u003d null;\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position \u003d end ? file.length() : 0;\n                     last \u003d System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n-                        readLines();\n+                        last \u003d System.currentTimeMillis();\n+                        position \u003d readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n-                        readLines();\n+                        last \u003d System.currentTimeMillis();\n+                        position \u003d readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a32a395a621098ce652ee8158e6320fa422f9fa3": {
      "type": "Ybodychange",
      "commitMessage": "Add test for and fix NPE if thread stopped with no file found\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002918 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285808936000,
      "commitName": "a32a395a621098ce652ee8158e6320fa422f9fa3",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": 1285806780000,
      "commitNameOld": "317841f44a515e57356fe50d7eb1be15030dfb5b",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n     public void run() {\n         try {\n             // Open the file\n             while (run \u0026\u0026 reader \u003d\u003d null) {\n                 try {\n                     reader \u003d new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader \u003d\u003d null) {\n                     Thread.sleep(delay);\n+                } else {\n+                    // The current position in the file\n+                    position \u003d end ? file.length() : 0;\n+                    last \u003d System.currentTimeMillis();\n+                    reader.seek(position);                    \n                 }\n             }\n \n-            // The current position in the file\n-            position \u003d end ? file.length() : 0;\n-            last \u003d System.currentTimeMillis();\n-            reader.seek(position);\n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length \u003d file.length();\n \n                 if (length \u003c position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         reader \u003d new RandomAccessFile(file, \"r\");\n                         position \u003d 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length \u003e position) {\n \n                         // The file has more content than it did last time\n                         readLines();\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position \u003d 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         readLines();\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "587f5571c6eb5a55b752fd7bfd66c2c535f5e566": {
      "type": "Yintroduced",
      "commitMessage": "IO-177 New Tailer class - Simple implementation of the unix \"tail -f\" functionality - thanks to Jeff Rodriguez for the patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002844 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": 1285793783000,
      "commitName": "587f5571c6eb5a55b752fd7bfd66c2c535f5e566",
      "commitAuthor": "Niall Pemberton"
    }
  }
}