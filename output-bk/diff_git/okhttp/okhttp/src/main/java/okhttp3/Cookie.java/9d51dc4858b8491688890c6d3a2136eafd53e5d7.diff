diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 5b760b51..296d7438 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -1,78 +1,79 @@
 /*
  * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package okhttp3;
 
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collections;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.List;
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 
 import static okhttp3.internal.Util.UTC;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
  *
  * <p>This class doesn't support additional attributes on cookies, like <a
  * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
  * extension</a>.
  */
 public final class Cookie {
   private static final Pattern YEAR_PATTERN
       = Pattern.compile("(\\d{2,4})[^\\d]*");
   private static final Pattern MONTH_PATTERN
       = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
   private static final Pattern DAY_OF_MONTH_PATTERN
       = Pattern.compile("(\\d{1,2})[^\\d]*");
   private static final Pattern TIME_PATTERN
       = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
 
   private final String name;
   private final String value;
   private final long expiresAt;
   private final String domain;
   private final String path;
   private final boolean secure;
   private final boolean httpOnly;
 
   private final boolean persistent; // True if 'expires' or 'max-age' is present.
   private final boolean hostOnly; // True unless 'domain' is present.
 
   private Cookie(String name, String value, long expiresAt, String domain, String path,
       boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
     this.name = name;
     this.value = value;
     this.expiresAt = expiresAt;
     this.domain = domain;
     this.path = path;
     this.secure = secure;
     this.httpOnly = httpOnly;
     this.hostOnly = hostOnly;
     this.persistent = persistent;
   }
 
   Cookie(Builder builder) {
@@ -123,113 +124,111 @@ public final class Cookie {
    * Returns true if this cookie's domain should be interpreted as a single host name, or false if
    * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
    * included a {@code domain} attribute.
    *
    * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
    * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
    * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
    * {@code beta.api.example.com}.
    */
   public boolean hostOnly() {
     return hostOnly;
   }
 
   /**
    * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
    * matches this cookie; otherwise it matches this domain and all subdomains.
    */
   public String domain() {
     return domain;
   }
 
   /**
    * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
    * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
    * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
    */
   public String path() {
     return path;
   }
 
   /**
    * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
    * the cookie from being accessible to scripts.
    */
   public boolean httpOnly() {
     return httpOnly;
   }
 
   /** Returns true if this cookie should be limited to only HTTPS requests. */
   public boolean secure() {
     return secure;
   }
 
   /**
    * Returns true if this cookie should be included on a request to {@code url}. In addition to this
    * check callers should also confirm that this cookie has not expired.
    */
   public boolean matches(HttpUrl url) {
     boolean domainMatch = hostOnly
         ? url.host().equals(domain)
-        : domainMatch(url, domain);
+        : domainMatch(url.host(), domain);
     if (!domainMatch) return false;
 
     if (!pathMatch(url, path)) return false;
 
     if (secure && !url.isHttps()) return false;
 
     return true;
   }
 
-  private static boolean domainMatch(HttpUrl url, String domain) {
-    String urlHost = url.host();
-
+  private static boolean domainMatch(String urlHost, String domain) {
     if (urlHost.equals(domain)) {
       return true; // As in 'example.com' matching 'example.com'.
     }
 
     if (urlHost.endsWith(domain)
         && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
         && !verifyAsIpAddress(urlHost)) {
       return true; // As in 'example.com' matching 'www.example.com'.
     }
 
     return false;
   }
 
   private static boolean pathMatch(HttpUrl url, String path) {
     String urlPath = url.encodedPath();
 
     if (urlPath.equals(path)) {
       return true; // As in '/foo' matching '/foo'.
     }
 
     if (urlPath.startsWith(path)) {
       if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
       if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
     }
 
     return false;
   }
 
   /**
    * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
    * null if {@code setCookie} is not a well-formed cookie.
    */
   public static Cookie parse(HttpUrl url, String setCookie) {
     return parse(System.currentTimeMillis(), url, setCookie);
   }
 
   static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     int pos = 0;
     int limit = setCookie.length();
     int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
 
     int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
     if (pairEqualsSign == cookiePairEnd) return null;
 
     String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
     if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
 
     String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
     if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
 
@@ -252,106 +251,113 @@ public final class Cookie {
           ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
           : "";
 
       if (attributeName.equalsIgnoreCase("expires")) {
         try {
           expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
           persistent = true;
         } catch (IllegalArgumentException e) {
           // Ignore this attribute, it isn't recognizable as a date.
         }
       } else if (attributeName.equalsIgnoreCase("max-age")) {
         try {
           deltaSeconds = parseMaxAge(attributeValue);
           persistent = true;
         } catch (NumberFormatException e) {
           // Ignore this attribute, it isn't recognizable as a max age.
         }
       } else if (attributeName.equalsIgnoreCase("domain")) {
         try {
           domain = parseDomain(attributeValue);
           hostOnly = false;
         } catch (IllegalArgumentException e) {
           // Ignore this attribute, it isn't recognizable as a domain.
         }
       } else if (attributeName.equalsIgnoreCase("path")) {
         path = attributeValue;
       } else if (attributeName.equalsIgnoreCase("secure")) {
         secureOnly = true;
       } else if (attributeName.equalsIgnoreCase("httponly")) {
         httpOnly = true;
       }
 
       pos = attributePairEnd + 1;
     }
 
     // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
     // attributes are declared in the cookie string.
     if (deltaSeconds == Long.MIN_VALUE) {
       expiresAt = Long.MIN_VALUE;
     } else if (deltaSeconds != -1L) {
       long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
           ? deltaSeconds * 1000
           : Long.MAX_VALUE;
       expiresAt = currentTimeMillis + deltaMilliseconds;
       if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
         expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
       }
     }
 
     // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    String urlHost = url.host();
     if (domain == null) {
-      domain = url.host();
-    } else if (!domainMatch(url, domain)) {
+      domain = urlHost;
+    } else if (!domainMatch(urlHost, domain)) {
       return null; // No domain match? This is either incompetence or malice!
     }
 
+    // If the domain is a suffix of the url host, it must not be a public suffix.
+    if (urlHost.length() != domain.length()
+        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+      return null;
+    }
+
     // If the path is absent or didn't start with '/', use the default path. It's a string like
     // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
     if (path == null || !path.startsWith("/")) {
       String encodedPath = url.encodedPath();
       int lastSlash = encodedPath.lastIndexOf('/');
       path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
     }
 
     return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
         hostOnly, persistent);
   }
 
   /** Parse a date as specified in RFC 6265, section 5.1.1. */
   private static long parseExpires(String s, int pos, int limit) {
     pos = dateCharacterOffset(s, pos, limit, false);
 
     int hour = -1;
     int minute = -1;
     int second = -1;
     int dayOfMonth = -1;
     int month = -1;
     int year = -1;
     Matcher matcher = TIME_PATTERN.matcher(s);
 
     while (pos < limit) {
       int end = dateCharacterOffset(s, pos + 1, limit, true);
       matcher.region(pos, end);
 
       if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
         hour = Integer.parseInt(matcher.group(1));
         minute = Integer.parseInt(matcher.group(2));
         second = Integer.parseInt(matcher.group(3));
       } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
         dayOfMonth = Integer.parseInt(matcher.group(1));
       } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
         String monthString = matcher.group(1).toLowerCase(Locale.US);
         month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
       } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
         year = Integer.parseInt(matcher.group(1));
       }
 
       pos = dateCharacterOffset(s, end + 1, limit, false);
     }
 
     // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
     if (year >= 70 && year <= 99) year += 1900;
     if (year >= 0 && year <= 69) year += 2000;
 
     // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
     // seconds are not supported by this syntax.
