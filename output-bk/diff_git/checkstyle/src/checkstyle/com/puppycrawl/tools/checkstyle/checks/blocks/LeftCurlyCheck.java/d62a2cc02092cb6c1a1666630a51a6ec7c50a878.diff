diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
index 6c78d9d60..adcc3d290 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
@@ -88,122 +88,122 @@ public class LeftCurlyCheck
      */
     public void setMaxLineLength(int aMaxLineLength)
     {
         mMaxLineLength = aMaxLineLength;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             // TODO: need to handle....
             //TokenTypes.STATIC_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST startToken;
         final DetailAST brace;
 
         switch (aAST.getType()) {
         case TokenTypes.CTOR_DEF :
         case TokenTypes.METHOD_DEF :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.INTERFACE_DEF :
         case TokenTypes.CLASS_DEF :
         case TokenTypes.ANNOTATION_DEF :
         case TokenTypes.ENUM_DEF :
         case TokenTypes.ENUM_CONSTANT_DEF :
-            startToken = (DetailAST) aAST.getFirstChild();
+            startToken = aAST.getFirstChild();
             final DetailAST objBlock = aAST.findFirstToken(TokenTypes.OBJBLOCK);
             brace = (objBlock == null)
                 ? null
-                : (DetailAST) objBlock.getFirstChild();
+                : objBlock.getFirstChild();
             break;
 
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_SYNCHRONIZED:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_FINALLY:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_IF :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.LITERAL_ELSE :
             startToken = aAST;
-            final DetailAST candidate = (DetailAST) aAST.getFirstChild();
+            final DetailAST candidate = aAST.getFirstChild();
             brace =
                 (candidate.getType() == TokenTypes.SLIST)
                 ? candidate
                 : null; // silently ignore
             break;
 
         case TokenTypes.LITERAL_SWITCH :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.LCURLY);
             break;
 
         default :
             startToken = null;
             brace = null;
         }
 
         if ((brace != null) && (startToken != null)) {
             verifyBrace(brace, startToken);
         }
     }
 
     /**
      * Verifies that a specified left curly brace is placed correctly
      * according to policy.
      * @param aBrace token for left curly brace
      * @param aStartToken token for start of expression
      */
     private void verifyBrace(final DetailAST aBrace,
                              final DetailAST aStartToken)
     {
         final String braceLine = getLines()[aBrace.getLineNo() - 1];
 
         // calculate the previous line length without trailing whitespace. Need
         // to handle the case where there is no previous line, cause the line
         // being check is the first line in the file.
         final int prevLineLen = (aBrace.getLineNo() == 1)
             ? mMaxLineLength
             : Utils.lengthMinusTrailingWhitespace(
                 getLines()[aBrace.getLineNo() - 2]);
 
         // Check for being told to ignore, or have '{}' which is a special case
         if ((braceLine.length() > (aBrace.getColumnNo() + 1))
             && (braceLine.charAt(aBrace.getColumnNo() + 1) == '}'))
         {
             ; // ignore
         }
         else if (getAbstractOption() == LeftCurlyOption.NL) {
             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {
                 log(aBrace.getLineNo(), aBrace.getColumnNo(),
                     "line.new", "{");
