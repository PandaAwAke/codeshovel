diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
index ebe6eb1cd..8d14e46fd 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
@@ -1,107 +1,107 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2007  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks.javadoc;
 
 import java.util.LinkedList;
 import java.util.List;
 
 /**
  * Helper class used to parse HTML tags from a single line of text.
  * Just the beginning of the HTML tag is located.  No attempt is made to
  * parse out the complete tag, particularly since some of the tag
  * parameters could be located on the following line of text.  The
  * <code>hasNextTag</code> and <code>nextTag</code> methods are used
  * to iterate through the HTML tags that were found on the line of text.
  *
  * @author Chris Stillwell
  */
 class TagParser
 {
     /** List of HtmlTags found on the input line of text. */
-    private final List mTags = new LinkedList();
+    private final List<HtmlTag> mTags = new LinkedList<HtmlTag>();
 
     /**
      * Constructs a TagParser and finds the first tag if any.
      * @param aText the line of text to parse.
      * @param aLineNo the source line number.
      */
     public TagParser(String[] aText, int aLineNo)
     {
         parseTags(aText, aLineNo);
     }
 
     /**
      * Returns the next available HtmlTag.
      * @return a HtmlTag or <code>null</code> if none available.
      * @throws IndexOutOfBoundsException if there are no HtmlTags
      *         left to return.
      */
     public HtmlTag nextTag()
     {
-        return (HtmlTag) mTags.remove(0);
+        return mTags.remove(0);
     }
 
     /**
      * Indicates if there are any more HtmlTag to retrieve.
      * @return <code>true</code> if there are more tags.
      */
     public boolean hasNextTag()
     {
         return (mTags.size() > 0);
     }
 
     /**
      * Performs lazy initialization on the internal tags List
      * and adds the tag.
      * @param aTag the HtmlTag to add.
      */
     private void add(HtmlTag aTag)
     {
         mTags.add(aTag);
     }
 
     /**
      * Parses the text line for any HTML tags and adds them to the internal
      * List of tags.
      * @param aText the source line to parse.
      * @param aLineNo the source line number.
      */
     private void parseTags(String[] aText, int aLineNo)
     {
         final int nLines = aText.length;
         Point position = new Point(0, 0);
 
         position = findChar(aText, '<', position);
         while (position.getLineNo() < nLines) {
             // if this is html comment then skip it
             if (isCommentTag(aText, position)) {
                 position = skipHtmlComment(aText, position);
             }
             else if (!isTag(aText, position)) {
                 position = getNextCharPos(aText, position);
             }
             else {
                 // find end of tag
                 final Point endTag = findChar(aText, '>', position);
                 final boolean incompleteTag = (endTag.getLineNo() >= nLines);
                 // get tag id (one word)
                 final String tagId =
                     (incompleteTag ? "" : getTagId(aText, position));
                 // is this closed tag
                 final boolean closedTag =
