diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
index 4e2ff8f67..8c48736a8 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
@@ -27,101 +27,105 @@ import java.util.Iterator;
  * <p>Limitations: this does not handle inner classes very well.</p>
  *
  * @author Oliver Burn
  * @version 1.0
  */
 public class ClassResolver
 {
     /** name of the package to check if the class belongs to **/
     private final String mPkg;
     /** set of imports to check against **/
     private final Set mImports;
     /** use to load classes **/
     private final ClassLoader mLoader;
 
     /**
      * Creates a new <code>ClassResolver</code> instance.
      *
      * @param aLoader the ClassLoader to load classes with.
      * @param aPkg the name of the package the class may belong to
      * @param aImports set of imports to check if the class belongs to
      */
     public ClassResolver(ClassLoader aLoader, String aPkg, Set aImports)
     {
         mLoader = aLoader;
         mPkg = aPkg;
         mImports = aImports;
     }
 
     /**
      * Attempts to resolve the Class for a specified name. The algorithm is
      * to check:
      * - fully qualified name
      * - explicit imports
      * - enclosing package
      * - star imports
      * @param aName name of the class to resolve
      * @return the resolved class
      * @throws ClassNotFoundException if unable to resolve the class
      */
     public Class resolve(String aName) throws ClassNotFoundException
     {
         // See if the class is full qualified
         if (isLoadable(aName)) {
             return safeLoad(aName);
         }
 
         // try matching explicit imports
         Iterator it = mImports.iterator();
         while (it.hasNext()) {
             final String imp = (String) it.next();
-            if (imp.endsWith(aName)) {
+            // Very important to add the "." in the check below. Otherwise you
+            // when checking for "DataException", it will match on
+            // "SecurityDataException". This has been the cause of a very
+            // difficult bug to resolve!
+            if (imp.endsWith("." + aName)) {
                 if (isLoadable(imp)) {
                     return safeLoad(imp);
                 }
                 // perhaps this is a import for inner class
                 // let's try load it.
                 int dot = imp.lastIndexOf(".");
                 if (dot != -1) {
                     final String innerName = imp.substring(0, dot) + "$"
                         + imp.substring(dot + 1);
                     if (isLoadable(innerName)) {
                         return safeLoad(innerName);
                     }
                 }
             }
         }
 
         // See if in the package
         if (mPkg != null) {
             final String fqn = mPkg + "." + aName;
             if (isLoadable(fqn)) {
                 return safeLoad(fqn);
             }
         }
 
         // try "java.lang."
         final String langClass = "java.lang." + aName;
         if (isLoadable(langClass)) {
             return safeLoad(langClass);
         }
 
         // try star imports
         it = mImports.iterator();
         while (it.hasNext()) {
             final String imp = (String) it.next();
             if (imp.endsWith(".*")) {
                 final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1)
                     + aName;
                 if (isLoadable(fqn)) {
                     return safeLoad(fqn);
                 }
             }
         }
 
         // Giving up, the type is unknown, so load the class to generate an
         // exception
         return safeLoad(aName);
     }
 
     /**
      * @return whether a specified class is loadable with safeLoad().
