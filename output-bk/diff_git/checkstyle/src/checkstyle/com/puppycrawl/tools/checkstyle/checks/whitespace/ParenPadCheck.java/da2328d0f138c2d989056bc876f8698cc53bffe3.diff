diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
index 990b88265..12c000d2d 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
@@ -35,80 +35,101 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * defaults to {@link PadOption#NOSPACE}.
  * </p>
  * <p> By default the check will check parentheses that occur with the following
  * tokens:
  *  {@link TokenTypes#CTOR_CALL CTOR_CALL},
  *  {@link TokenTypes#LPAREN LPAREN},
  *  {@link TokenTypes#METHOD_CALL METHOD_CALL},
  *  {@link TokenTypes#RPAREN RPAREN},
  *  {@link TokenTypes#SUPER_CTOR_CALL SUPER_CTOR_CALL},
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="ParenPad"/&gt;
  * </pre>
  * <p>
  * An example of how to configure the check to require spaces for the
  * parentheses of constructor, method, and super constructor invocations is:
  * </p>
  * <pre>
  * &lt;module name="ParenPad"&gt;
  *     &lt;property name="tokens"
  *               value="CTOR_CALL, METHOD_CALL, SUPER_CTOR_CALL"/&gt;
  *     &lt;property name="option" value="space"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Oliver Burn
  * @version 1.0
  */
 public class ParenPadCheck
     extends AbstractParenPadCheck
 {
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.RPAREN,
                           TokenTypes.LPAREN,
                           TokenTypes.CTOR_CALL,
                           TokenTypes.SUPER_CTOR_CALL,
                           TokenTypes.METHOD_CALL,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         // Strange logic in this method to guard against checking RPAREN tokens
         // that are associated with a TYPECAST token.
         if (aAST.getType() != TokenTypes.RPAREN) {
-            processLeft(aAST);
+            if (!isPreceedsEmptyForInit(aAST)) {
+                processLeft(aAST);
+            }
         }
         else if ((aAST.getParent() == null)
                  || (aAST.getParent().getType() != TokenTypes.TYPECAST))
         {
             if (!isFollowsEmptyForIterator(aAST)) {
                 processRight(aAST);
             }
         }
     }
 
     /**
      * @param aAST the token to check
      * @return whether a token follows an empty for iterator
      */
     private boolean isFollowsEmptyForIterator(DetailAST aAST)
     {
         boolean followsEmptyForIterator = false;
         final DetailAST parent = aAST.getParent();
         if ((parent != null)
             && (parent.getType() == TokenTypes.LITERAL_FOR))
         {
             final DetailAST forIterator =
                 parent.findFirstToken(TokenTypes.FOR_ITERATOR);
             followsEmptyForIterator = (forIterator.getChildCount() == 0)
                 && (aAST == forIterator.getNextSibling());
         }
         return followsEmptyForIterator;
     }
+
+    /**
+     * @param aAST the token to check
+     * @return whether a token preceeds an empty for initializer
+     */
+    private boolean isPreceedsEmptyForInit(DetailAST aAST)
+    {
+        boolean preceedsEmptyForInintializer = false;
+        final DetailAST parent = aAST.getParent();
+        if ((parent != null)
+                && (parent.getType() == TokenTypes.LITERAL_FOR))
+        {
+            final DetailAST forIterator =
+                    parent.findFirstToken(TokenTypes.FOR_INIT);
+            preceedsEmptyForInintializer = (forIterator.getChildCount() == 0)
+                    && (aAST == forIterator.getPreviousSibling());
+        }
+        return preceedsEmptyForInintializer;
+    }
 }
