diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java
index 40c174057..83c18fae7 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java
@@ -21,153 +21,153 @@ package com.puppycrawl.tools.checkstyle.checks.indentation;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Handler for method calls.
  *
  * @author jrichard
  */
 public class MethodCallHandler extends ExpressionHandler
 {
     /**
      * Construct an instance of this handler with the given indentation check,
      * abstract syntax tree, and parent handler.
      *
      * @param aIndentCheck   the indentation check
      * @param aAST           the abstract syntax tree
      * @param aParent        the parent handler
      */
     public MethodCallHandler(IndentationCheck aIndentCheck,
         DetailAST aAST, ExpressionHandler aParent)
     {
         super(aIndentCheck,
             aAST.getType() == TokenTypes.METHOD_CALL
                 ? "method call" : "ctor call",
             aAST,
             aParent);
     }
 
     /**
      * Compute the indentation amount for this handler.
      *
      * @return the expected indentation amount
      */
     protected IndentLevel getLevelImpl()
     {
         // if inside a method call's params, this could be part of
         // an expression, so get the previous line's start
         if (getParent() instanceof MethodCallHandler) {
             MethodCallHandler container = ((MethodCallHandler) getParent());
             if (container != null) {
                 if (areOnSameLine(container.getMainAst(), getMainAst())) {
                     return container.getLevel();
                 }
 
                 // we should increase indentation only if this is the first
                 // chained method call which was moved to the next line
                 DetailAST main = getMainAst();
                 DetailAST dot = (DetailAST) main.getFirstChild();
                 DetailAST target = (DetailAST) dot.getFirstChild();
 
-                if (dot.getType() == TokenTypes.DOT
-                    && target.getType() == TokenTypes.METHOD_CALL)
+                if ((dot.getType() == TokenTypes.DOT)
+                    && (target.getType() == TokenTypes.METHOD_CALL))
                 {
                     DetailAST dot1 = (DetailAST) target.getFirstChild();
                     DetailAST target1 = (DetailAST) dot1.getFirstChild();
 
-                    if (dot1.getType() == TokenTypes.DOT
-                        && target1.getType() == TokenTypes.METHOD_CALL)
+                    if ((dot1.getType() == TokenTypes.DOT)
+                        && (target1.getType() == TokenTypes.METHOD_CALL))
                     {
                         return container.getLevel();
                     }
                 }
                 return new IndentLevel(container.getLevel(), getBasicOffset());
             }
 
             // if we get here, we are the child of the left hand side (name
             //  side) of a method call with no "containing" call, use
             //  the first non-method call parent
 
             ExpressionHandler p = getParent();
             while (p instanceof MethodCallHandler) {
                 p = p.getParent();
             }
             return p.suggestedChildLevel(this);
         }
 
         // if our expression isn't first on the line, just use the start
         // of the line
         LineSet lines = new LineSet();
         findSubtreeLines(lines, (DetailAST) getMainAst().getFirstChild(), true);
         int firstCol = lines.firstLineCol();
         int lineStart = getLineStart(getFirstAst(getMainAst()));
         if (lineStart != firstCol) {
             return new IndentLevel(lineStart);
         }
         return super.getLevelImpl();
     }
 
     /**
      * Get the first AST of the specified method call.
      *
      * @param aAst
      *            the method call
      *
      * @return the first AST of the specified method call
      */
     private DetailAST getFirstAst(DetailAST aAst)
     {
         // walk down the first child part of the dots that make up a method
         // call name
 
         DetailAST ast = (DetailAST) aAst.getFirstChild();
-        while (ast != null && ast.getType() == TokenTypes.DOT) {
+        while ((ast != null) && (ast.getType() == TokenTypes.DOT)) {
             ast = (DetailAST) ast.getFirstChild();
         }
 
         if (ast == null) {
             ast = aAst;
         }
 
         return ast;
     }
 
     /**
      * Indentation level suggested for a child element. Children don't have
      * to respect this, but most do.
      *
      * @param aChild  child AST (so suggestion level can differ based on child
      *                  type)
      *
      * @return suggested indentation for child
      */
     public IndentLevel suggestedChildLevel(ExpressionHandler aChild)
     {
         // for whatever reason a method that crosses lines, like asList
         // here:
         //            System.out.println("methods are: " + Arrays.asList(
         //                new String[] {"method"}).toString());
         // will not have the right line num, so just get the child name
 
         DetailAST first = (DetailAST) getMainAst().getFirstChild();
         int indentLevel = getLineStart(first);
         if (!areOnSameLine((DetailAST) aChild.getMainAst().getFirstChild(),
                            (DetailAST) getMainAst().getFirstChild()))
         {
             indentLevel += getBasicOffset();
         }
         return new IndentLevel(indentLevel);
     }
 
     /**
      * Check the indentation of the expression we are handling.
      */
     public void checkIndentation()
     {
         DetailAST methodName = (DetailAST) getMainAst().getFirstChild();
         checkExpressionSubtree(methodName, getLevel(), false, false);
 
         DetailAST lparen = getMainAst();
         DetailAST rparen = getMainAst().findFirstToken(TokenTypes.RPAREN);
         checkLParen(lparen);
 
         if (rparen.getLineNo() == lparen.getLineNo()) {
