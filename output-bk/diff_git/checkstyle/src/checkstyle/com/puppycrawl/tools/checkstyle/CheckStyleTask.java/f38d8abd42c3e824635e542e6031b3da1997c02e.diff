diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
index b8352c477..ac3694a29 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
@@ -261,106 +261,106 @@ public class CheckStyleTask extends Task
         try {
             Thread.currentThread().setContextClassLoader(
                     getClass().getClassLoader());
             realExecute();
         }
         finally {
             Thread.currentThread().setContextClassLoader(loader);
             final long endTime = System.currentTimeMillis();
             log("Total execution took " + (endTime - startTime) + " ms.",
                 Project.MSG_VERBOSE);
         }
     }
 
     /**
      * Helper implementation to perform execution.
      */
     private void realExecute()
     {
         // output version info in debug mode
         final ResourceBundle compilationProperties = ResourceBundle
                 .getBundle("checkstylecompilation");
         final String version = compilationProperties
                 .getString("checkstyle.compile.version");
         final String compileTimestamp = compilationProperties
                 .getString("checkstyle.compile.timestamp");
         log("checkstyle version " + version, Project.MSG_VERBOSE);
         log("compiled on " + compileTimestamp, Project.MSG_VERBOSE);
 
         // Check for no arguments
         if ((mFileName == null) && (mFileSets.size() == 0)) {
             throw new BuildException(
                     "Must specify atleast one of 'file' or nested 'fileset'.",
                     getLocation());
         }
 
         if (mConfigLocation == null) {
             throw new BuildException("Must specify 'config'.", getLocation());
         }
 
         // Create the checker
         Checker c = null;
         try {
             c = createChecker();
 
             final SeverityLevelCounter warningCounter =
                 new SeverityLevelCounter(SeverityLevel.WARNING);
             c.addListener(warningCounter);
 
             // Process the files
             long startTime = System.currentTimeMillis();
-            final File[] files = scanFileSets();
+            final List<File> files = scanFileSets();
             long endTime = System.currentTimeMillis();
             log("To locate the files took " + (endTime - startTime) + " ms.",
                 Project.MSG_VERBOSE);
 
-            log("Running Checkstyle " + version + " on " + files.length
+            log("Running Checkstyle " + version + " on " + files.size()
                     + " files", Project.MSG_INFO);
             log("Using configuration " + mConfigLocation, Project.MSG_VERBOSE);
 
             startTime = System.currentTimeMillis();
             final int numErrs = c.process(files);
             endTime = System.currentTimeMillis();
             log("To process the files took " + (endTime - startTime) + " ms.",
                 Project.MSG_VERBOSE);
             final int numWarnings = warningCounter.getCount();
             final boolean ok = (numErrs <= mMaxErrors)
                     && (numWarnings <= mMaxWarnings);
 
             // Handle the return status
             if (!ok) {
                 final String failureMsg =
                         "Got " + numErrs + " errors and " + numWarnings
                                 + " warnings.";
                 if (mFailureProperty != null) {
                     getProject().setProperty(mFailureProperty, failureMsg);
                 }
 
                 if (mFailOnViolation) {
                     throw new BuildException(failureMsg, getLocation());
                 }
             }
         }
         finally {
             if (c != null) {
                 c.destroy();
             }
         }
     }
 
     /**
      * Creates new instance of <code>Checker</code>.
      * @return new instance of <code>Checker</code>
      */
     private Checker createChecker()
     {
         Checker c = null;
         try {
             final Properties props = createOverridingProperties();
             final Configuration config = ConfigurationLoader.loadConfiguration(
                     mConfigLocation, new PropertiesExpander(props), true);
 
             final DefaultContext context = new DefaultContext();
             final ClassLoader loader = new AntClassLoader(getProject(),
                     mClasspath);
             context.add("classloader", loader);
 
@@ -431,126 +431,126 @@ public class CheckStyleTask extends Task
         final Hashtable<?, ?> antProps = this.getProject().getProperties();
         for (Object name : antProps.keySet()) {
             final String key = (String) name;
             final String value = String.valueOf(antProps.get(key));
             retVal.put(key, value);
         }
 
         // override with properties specified in subelements
         for (Property p : mOverrideProps) {
             retVal.put(p.getKey(), p.getValue());
         }
 
         return retVal;
     }
 
     /**
      * Return the list of listeners set in this task.
      * @return the list of listeners.
      * @throws ClassNotFoundException if an error occurs
      * @throws InstantiationException if an error occurs
      * @throws IllegalAccessException if an error occurs
      * @throws IOException if an error occurs
      */
     protected AuditListener[] getListeners() throws ClassNotFoundException,
             InstantiationException, IllegalAccessException, IOException
     {
         final int formatterCount = Math.max(1, mFormatters.size());
 
         final AuditListener[] listeners = new AuditListener[formatterCount];
 
         // formatters
         if (mFormatters.size() == 0) {
             final OutputStream debug = new LogOutputStream(this,
                     Project.MSG_DEBUG);
             final OutputStream err = new LogOutputStream(this, Project.MSG_ERR);
             listeners[0] = new DefaultLogger(debug, true, err, true);
         }
         else {
             for (int i = 0; i < formatterCount; i++) {
                 final Formatter f = mFormatters.get(i);
                 listeners[i] = f.createListener(this);
             }
         }
         return listeners;
     }
 
     /**
      * returns the list of files (full path name) to process.
      * @return the list of files included via the filesets.
      */
-    protected File[] scanFileSets()
+    protected List<File> scanFileSets()
     {
         final List<File> list = new ArrayList<File>();
         if (mFileName != null) {
             // oops we've got an additional one to process, don't
             // forget it. No sweat, it's fully resolved via the setter.
             log("Adding standalone file for audit", Project.MSG_VERBOSE);
             list.add(new File(mFileName));
         }
         for (int i = 0; i < mFileSets.size(); i++) {
             final FileSet fs = mFileSets.get(i);
             final DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             ds.scan();
 
             final String[] names = ds.getIncludedFiles();
             log(i + ") Adding " + names.length + " files from directory "
                     + ds.getBasedir(), Project.MSG_VERBOSE);
 
             for (String element : names) {
                 final String pathname = ds.getBasedir() + File.separator
                         + element;
                 list.add(new File(pathname));
             }
         }
 
-        return list.toArray(new File[0]);
+        return list;
     }
 
     /**
      * Poor mans enumeration for the formatter types.
      * @author Oliver Burn
      */
     public static class FormatterType extends EnumeratedAttribute
     {
         /** my possible values */
         private static final String[] VALUES = {E_XML, E_PLAIN};
 
         /** {@inheritDoc} */
         @Override
         public String[] getValues()
         {
             return VALUES;
         }
     }
 
     /**
      * Details about a formatter to be used.
      * @author Oliver Burn
      */
     public static class Formatter
     {
         /** the formatter type */
         private FormatterType mFormatterType;
         /** the file to output to */
         private File mToFile;
         /** Whether or not the write to the named file. */
         private boolean mUseFile = true;
 
         /**
          * Set the type of the formatter.
          * @param aType the type
          */
         public void setType(FormatterType aType)
         {
             final String val = aType.getValue();
             if (!E_XML.equals(val) && !E_PLAIN.equals(val)) {
                 throw new BuildException("Invalid formatter type: " + val);
             }
 
             mFormatterType = aType;
         }
 
         /**
          * Set the file to output to.
          * @param aTo the file to output to
          */
