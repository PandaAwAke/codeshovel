diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index 469e3f1b0..91e69a2c5 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -1,237 +1,245 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks;
 
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.Scope;
 import com.puppycrawl.tools.checkstyle.api.ScopeUtils;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
 import org.apache.regexp.RE;
 
 /**
  * <p>
  * Checks the Javadoc of a method or constructor.
  * By default, does not check for unused throws.
- * To check for unused throws, set property checkUnusedThrows to true.
+ * To allow documented <code>java.lang.RuntimeException</code>s
+ * that are not declared, set property allowUndeclaredRTE to true.
  * The scope to verify is specified using the {@link Scope} class and
  * defaults to {@link Scope#PRIVATE}. To verify another scope,
  * set property scope to one of the {@link Scope} constants.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="JavadocMethod"/&gt;
  * </pre>
- * <p> An example of how to configure the check to check for unused imports
+ * <p> An example of how to configure the check to check to allow
+ * documentation of undeclared RuntimeExceptions
  * and for the {@link Scope#PUBLIC} scope is:
  *</p>
  * <pre>
  * &lt;module name="JavadocMethod"&gt;
  *    &lt;property name="scope" value="public"/&gt;
- *    &lt;property name="checkUnusedThrows" value="true"/&gt;
+ *    &lt;property name="allowUndeclaredRTE" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @author Rick Giles
  * @version 1.0
  */
 public class JavadocMethodCheck
     extends AbstractImportCheck
 {
 
        // {{{ Data declarations
     /** the pattern to match Javadoc tags that take an argument **/
     private static final String MATCH_JAVADOC_ARG_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s+\\S";
     /** compiled regexp to match Javadoc tags that take an argument **/
     private static final RE MATCH_JAVADOC_ARG =
         Utils.createRE(MATCH_JAVADOC_ARG_PAT);
 
    /**
     * the pattern to match the first line of a multi-line Javadoc
     * tag that takes an argument. Javadoc with no arguments isn't
     * allowed to go over multiple lines.
     **/
     private static final String MATCH_JAVADOC_MULTILINE_START_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s*$";
     /** compiled regexp to match first part of multilineJavadoc tags **/
     private static final RE MATCH_JAVADOC_MULTILINE_START =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_START_PAT);
 
     /** the pattern that looks for a continuation of the comment **/
     private static final String MATCH_JAVADOC_MULTILINE_CONT_PAT =
         "(\\*/|@|[^\\s\\*])";
     /** compiled regexp to look for a continuation of the comment **/
     private static final RE MATCH_JAVADOC_MULTILINE_CONT =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_CONT_PAT);
     /** Multiline finished at end of comment **/
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc **/
     private static final String NEXT_TAG = "@";
 
     /** the pattern to match Javadoc tags with no argument **/
     private static final String MATCH_JAVADOC_NOARG_PAT =
         "@(return|see|author)\\s+\\S";
     /** compiled regexp to match Javadoc tags with no argument **/
     private static final RE MATCH_JAVADOC_NOARG =
         Utils.createRE(MATCH_JAVADOC_NOARG_PAT);
 
     /** the pattern to match Javadoc tags with no argument and {} **/
     private static final String MATCH_JAVADOC_NOARG_CURLY_PAT =
         "\\{\\s*@(inheritDoc)\\s*\\}";
     /** compiled regexp to match Javadoc tags with no argument and {} **/
     private static final RE MATCH_JAVADOC_NOARG_CURLY =
         Utils.createRE(MATCH_JAVADOC_NOARG_CURLY_PAT);
 
     /** full identifier for package of the method **/
     private FullIdent mPackageFullIdent = null;
 
     /** imports details **/
     private Set mImports = new HashSet();
 
     /** the visibility scope where Javadoc comments are checked **/
     private Scope mScope = Scope.PRIVATE;
 
-    /** check for unused throws **/
-    private boolean mCheckUnusedThrows = false;
+    /**
+     * controls whether to allow documented exceptions that
+     * are not declared if they are a subclass of
+     * java.lang.RuntimeException.
+     **/
+    private boolean mAllowUndeclaredRTE = false;
 
     /**
      * Set the scope.
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
-     * Set whether to check for unused throws.
+     * controls whether to allow documented exceptions that
+     * are not declared if they are a subclass of
+     * java.lang.RuntimeException.
      * @param aFlag a <code>Boolean</code> value
      */
-    public void setCheckUnusedThrows(boolean aFlag)
+    public void setAllowUndeclaredRTE(boolean aFlag)
     {
-        mCheckUnusedThrows = aFlag;
+        mAllowUndeclaredRTE = aFlag;
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree()
     {
         mPackageFullIdent = FullIdent.createFullIdent(null);
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.PACKAGE_DEF) {
-            if (mCheckUnusedThrows) {
+            if (mAllowUndeclaredRTE) {
                 processPackage(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
-            if (mCheckUnusedThrows) {
+            if (mAllowUndeclaredRTE) {
                 processImport(aAST);
             }
         }
         else {
             //TokenTypes.METHOD_DEF or TokenTypes.CTOR_DEF
             processMethod(aAST);
         }
     }
 
 
 
     /**
      * Collects the details of a package.
      * @param aAST node containing the package details
      */
     private void processPackage(DetailAST aAST)
     {
         final DetailAST nameAST = (DetailAST) aAST.getFirstChild();
         mPackageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = getImportText(aAST);
         if (name != null) {
             mImports.add(name.getText());
         }
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     private void processMethod(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope targetScope =
             ScopeUtils.inInterfaceBlock(aAST)
                 ? Scope.PUBLIC
                 : declaredScope;
 
         if (targetScope.isIn(mScope)) {
             final Scope surroundingScope =
                 ScopeUtils.getSurroundingScope(aAST);
 
@@ -463,84 +471,84 @@ public class JavadocMethodCheck
                 if (found) {
                     log(jt.getLineNo(), "javadoc.return.duplicate");
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags
         if (!found) {
             log(aLineNo, "javadoc.return.expected");
         }
     }
 
 
     /**
      * Checks a set of tags for matching throws.
      * @param aTags the tags to check
      * @param aThrows the throws to check
      **/
     private void checkThrowsTags(List aTags, List aThrows)
     {
         // Loop over the tags, checking to see they exist in the throws.
         final Set foundThrows = new HashSet();
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             boolean found = foundThrows.contains(documentedEx);
             final ListIterator throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final FullIdent fi = (FullIdent) throwIt.next();
                 if (fi.getText().equals(documentedEx)) {
                     found = true;
                     throwIt.remove();
                     foundThrows.add(documentedEx);
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
-                if (mCheckUnusedThrows) {
+                if (mAllowUndeclaredRTE) {
                     final ClassResolver cr =
                         new ClassResolver(
                             getClassLoader(),
                             mPackageFullIdent.getText(),
                             mImports);
                     try {
                         final Class clazz = cr.resolve(tag.getArg1());
                         reqd =
                             !RuntimeException.class.isAssignableFrom(clazz)
                                 && !Error.class.isAssignableFrom(clazz);
                     }
                     catch (ClassNotFoundException e) {
                         log(tag.getLineNo(), "javadoc.classInfo",
                                       "@throws", tag.getArg1());
                     }
                 }
 
                 if (reqd) {
                     log(tag.getLineNo(), "javadoc.unusedTag",
                                   "@throws", tag.getArg1());
                 }
             }
         }
 
         // Now dump out all throws without tags
         final ListIterator throwIt = aThrows.listIterator();
         while (throwIt.hasNext()) {
             final FullIdent fi = (FullIdent) throwIt.next();
             log(fi.getLineNo(), fi.getColumnNo(),
                 "javadoc.expectedTag", "@throws", fi.getText());
         }
     }
 }
