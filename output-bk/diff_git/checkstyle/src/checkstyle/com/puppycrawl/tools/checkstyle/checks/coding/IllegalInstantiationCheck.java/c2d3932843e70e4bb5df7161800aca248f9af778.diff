diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index 982d099f0..081e47016 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -162,177 +162,177 @@ public class IllegalInstantiationCheck
         final DetailAST identToken = aAST.findFirstToken(TokenTypes.IDENT);
         final String className = identToken.getText();
         mClassNames.add(className);
     }
 
     /**
      * Perform processing for an import token
      * @param aAST the import token
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(aAST);
         if (name != null) {
             // Note: different from UnusedImportsCheck.processImport(),
             // '.*' imports are also added here
             mImports.add(name);
         }
     }
 
     /**
      * Perform processing for an package token
      * @param aAST the package token
      */
     private void processPackageDef(DetailAST aAST)
     {
         final DetailAST packageNameAST = aAST.getLastChild()
                 .getPreviousSibling();
         final FullIdent packageIdent =
                 FullIdent.createFullIdent(packageNameAST);
         mPkgName = packageIdent.getText();
     }
 
     /**
      * Collects a "new" token.
      * @param aAST the "new" token
      */
     private void processLiteralNew(DetailAST aAST)
     {
         mInstantiations.add(aAST);
     }
 
     /**
      * Processes one of the collected "new" tokens when treewalking
      * has finished.
      * @param aAST the "new" token.
      */
     private void postprocessLiteralNew(DetailAST aAST)
     {
         final DetailAST typeNameAST = (DetailAST) aAST.getFirstChild();
         final AST nameSibling = typeNameAST.getNextSibling();
-        if (nameSibling != null
-                && nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR)
+        if ((nameSibling != null)
+                && (nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR))
         {
             // aAST == "new Boolean[]"
             return;
         }
 
         final FullIdent typeIdent = FullIdent.createFullIdent(typeNameAST);
         final String typeName = typeIdent.getText();
         final int lineNo = aAST.getLineNo();
         final int colNo = aAST.getColumnNo();
         final String fqClassName = getIllegalInstantiation(typeName);
         if (fqClassName != null) {
             log(lineNo, colNo, "instantiation.avoid", fqClassName);
         }
     }
 
     /**
      * Checks illegal instantiations.
      * @param aClassName instantiated class, may or may not be qualified
      * @return the fully qualified class name of aClassName
      * or null if instantiation of aClassName is OK
      */
     private String getIllegalInstantiation(String aClassName)
     {
         final String javaLang = "java.lang.";
 
         if (mIllegalClasses.contains(aClassName)) {
             return aClassName;
         }
 
         final int clsNameLen = aClassName.length();
         final int pkgNameLen = (mPkgName == null) ? 0 : mPkgName.length();
 
         final Iterator illIter = mIllegalClasses.iterator();
         while (illIter.hasNext()) {
             final String illegal = (String) illIter.next();
             final int illegalLen = illegal.length();
 
             // class from java.lang
             if (((illegalLen - javaLang.length()) == clsNameLen)
                 && illegal.endsWith(aClassName)
                 && illegal.startsWith(javaLang))
             {
                 // java.lang needs no import, but a class without import might
                 // also come from the same file or be in the same package.
                 // E.g. if a class defines an inner class "Boolean",
                 // the expression "new Boolean()" refers to that class,
                 // not to java.lang.Boolean
 
                 final boolean isSameFile = mClassNames.contains(aClassName);
 
                 boolean isSamePackage = false;
                 try {
                     final ClassLoader classLoader = getClassLoader();
                     if (classLoader != null) {
                         final String fqName = mPkgName + "." + aClassName;
                         classLoader.loadClass(fqName);
                         // no ClassNotFoundException, fqName is a known class
                         isSamePackage = true;
                     }
                 }
                 catch (ClassNotFoundException ex) {
                     // not a class from the same package
                     isSamePackage = false;
                 }
 
                 if (!(isSameFile || isSamePackage)) {
                     return illegal;
                 }
             }
 
             // class from same package
 
             // the toplevel package (mPkgName == null) is covered by the
             // "illegalInsts.contains(aClassName)" check above
 
             // the test is the "no garbage" version of
             // illegal.equals(mPkgName + "." + aClassName)
-            if (mPkgName != null
-                && clsNameLen == illegalLen - pkgNameLen - 1
-                && illegal.charAt(pkgNameLen) == '.'
+            if ((mPkgName != null)
+                && (clsNameLen == illegalLen - pkgNameLen - 1)
+                && (illegal.charAt(pkgNameLen) == '.')
                 && illegal.endsWith(aClassName)
                 && illegal.startsWith(mPkgName))
             {
                 return illegal;
             }
             // import statements
             final Iterator importIter = mImports.iterator();
             while (importIter.hasNext()) {
                 final FullIdent importLineText = (FullIdent) importIter.next();
                 final String importArg = importLineText.getText();
                 if (importArg.endsWith(".*")) {
                     final String fqClass =
                         importArg.substring(0, importArg.length() - 1)
                         + aClassName;
                     // assume that illegalInsts only contain existing classes
                     // or else we might create a false alarm here
                     if (mIllegalClasses.contains(fqClass)) {
                         return fqClass;
                     }
                 }
                 else {
                     if (Utils.baseClassname(importArg).equals(aClassName)
                         && mIllegalClasses.contains(importArg))
                     {
                         return importArg;
                     }
                 }
             }
         }
         return null;
     }
 
     /**
      * Sets the classes that are illegal to instantiate.
      * @param aClassNames a comma seperate list of class names
      */
     public void setClasses(String aClassNames)
     {
         mIllegalClasses.clear();
         final StringTokenizer tok = new StringTokenizer(aClassNames, ",");
         while (tok.hasMoreTokens()) {
             mIllegalClasses.add(tok.nextToken());
         }
     }
 }
