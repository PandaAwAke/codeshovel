diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java
index 92efed497..5075fe6b3 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java
@@ -95,144 +95,145 @@ public class HandlerFactory
         register(TokenTypes.CTOR_DEF, MethodDefHandler.class);
         register(TokenTypes.CLASS_DEF, ClassDefHandler.class);
         register(TokenTypes.ENUM_DEF, ClassDefHandler.class);
         register(TokenTypes.OBJBLOCK, ObjectBlockHandler.class);
         register(TokenTypes.INTERFACE_DEF, ClassDefHandler.class);
         register(TokenTypes.IMPORT, ImportHandler.class);
         register(TokenTypes.ARRAY_INIT, ArrayInitHandler.class);
         register(TokenTypes.METHOD_CALL, MethodCallHandler.class);
         register(TokenTypes.CTOR_CALL, MethodCallHandler.class);
         register(TokenTypes.LABELED_STAT, LabelHandler.class);
         register(TokenTypes.STATIC_INIT, StaticInitHandler.class);
         register(TokenTypes.INSTANCE_INIT, SlistHandler.class);
         register(TokenTypes.ASSIGN, AssignHandler.class);
         register(TokenTypes.PLUS_ASSIGN, AssignHandler.class);
         register(TokenTypes.MINUS_ASSIGN, AssignHandler.class);
         register(TokenTypes.STAR_ASSIGN, AssignHandler.class);
         register(TokenTypes.DIV_ASSIGN, AssignHandler.class);
         register(TokenTypes.MOD_ASSIGN, AssignHandler.class);
         register(TokenTypes.SR_ASSIGN, AssignHandler.class);
         register(TokenTypes.BSR_ASSIGN, AssignHandler.class);
         register(TokenTypes.SL_ASSIGN, AssignHandler.class);
         register(TokenTypes.BAND_ASSIGN, AssignHandler.class);
         register(TokenTypes.BXOR_ASSIGN, AssignHandler.class);
         register(TokenTypes.BOR_ASSIGN, AssignHandler.class);
         register(TokenTypes.VARIABLE_DEF, MemberDefHandler.class);
         register(TokenTypes.LITERAL_NEW, NewHandler.class);
     }
 
     /**
      * Returns true if this type (form TokenTypes) is handled.
      *
      * @param aType type from TokenTypes
      * @return true if handler is registered, false otherwise
      */
     public boolean isHandledType(int aType)
     {
         final Set<Integer> typeSet = mTypeHandlers.keySet();
         return typeSet.contains(aType);
     }
 
     /**
      * Gets list of registered handler types.
      *
      * @return int[] of TokenType types
      */
     public int[] getHandledTypes()
     {
         final Set<Integer> typeSet = mTypeHandlers.keySet();
         final int[] types = new int[typeSet.size()];
         int index = 0;
-        for (Integer val : typeSet) {
+        for (final Integer val : typeSet) {
             types[index++] = val;
         }
 
         return types;
     }
 
     /**
      * Get the handler for an AST.
      *
      * @param aIndentCheck   the indentation check
      * @param aAst           ast to handle
      * @param aParent        the handler parent of this AST
      *
      * @return the ExpressionHandler for aAst
      */
     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,
         DetailAST aAst, ExpressionHandler aParent)
     {
         final ExpressionHandler handler =
             mCreatedHandlers.get(aAst);
         if (handler != null) {
             return handler;
         }
 
         if (aAst.getType() == TokenTypes.METHOD_CALL) {
             return createMethodCallHandler(aIndentCheck, aAst, aParent);
         }
 
         ExpressionHandler expHandler = null;
         try {
             final Constructor<?> handlerCtor =
                 mTypeHandlers.get(aAst.getType());
             if (handlerCtor != null) {
                 expHandler = (ExpressionHandler) handlerCtor.newInstance(
                         aIndentCheck, aAst, aParent);
             }
         }
         ///CLOVER:OFF
         catch (final InstantiationException e) {
             LOG.debug("couldn't instantiate constructor for " + aAst, e);
             throw new RuntimeException("couldn't instantiate constructor for "
                                        + aAst);
         }
         catch (final IllegalAccessException e) {
             LOG.debug("couldn't access constructor for " + aAst, e);
             throw new RuntimeException("couldn't access constructor for "
                                        + aAst);
         }
         catch (final InvocationTargetException e) {
             LOG.debug("couldn't instantiate constructor for " + aAst, e);
             throw new RuntimeException("couldn't instantiate constructor for "
                                        + aAst);
         }
         if (expHandler == null) {
             throw new RuntimeException("no handler for type " + aAst.getType());
         }
         ///CLOVER:ON
         return expHandler;
     }
 
     /**
      * Create new instance of handler for METHOD_CALL.
      *
      * @param aIndentCheck   the indentation check
      * @param aAst           ast to handle
      * @param aParent        the handler parent of this AST
      *
      * @return new instance.
      */
     ExpressionHandler createMethodCallHandler(IndentationCheck aIndentCheck,
         DetailAST aAst, ExpressionHandler aParent)
     {
+        ExpressionHandler theParent = aParent;
         DetailAST ast = aAst.getFirstChild();
         while ((ast != null) && (ast.getType() == TokenTypes.DOT)) {
             ast = ast.getFirstChild();
         }
         if ((ast != null) && isHandledType(ast.getType())) {
-            aParent = getHandler(aIndentCheck, ast, aParent);
-            mCreatedHandlers.put(ast, aParent);
+            theParent = getHandler(aIndentCheck, ast, theParent);
+            mCreatedHandlers.put(ast, theParent);
         }
-        return new MethodCallHandler(aIndentCheck, aAst, aParent);
+        return new MethodCallHandler(aIndentCheck, aAst, theParent);
     }
 
     /** Clears cache of created handlers. */
     void clearCreatedHandlers()
     {
         mCreatedHandlers.clear();
     }
 
     /** cache for created method call handlers */
     private final Map<DetailAST, ExpressionHandler> mCreatedHandlers =
         Maps.newHashMap();
 }
