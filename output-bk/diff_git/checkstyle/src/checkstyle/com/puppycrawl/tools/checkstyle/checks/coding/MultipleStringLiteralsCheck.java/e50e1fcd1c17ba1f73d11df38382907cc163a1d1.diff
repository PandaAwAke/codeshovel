diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
index cfd858a04..f8a29de3e 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
@@ -55,102 +55,101 @@ public class MultipleStringLiteralsCheck extends Check
      * generated.
      */
     private int mAllowedDuplicates = 1;
 
     /**
      * Sets the maximum allowed duplicates of a string.
      * @param aAllowedDuplicates The maximum number of duplicates.
      */
     public void setAllowedDuplicates(int aAllowedDuplicates)
     {
         mAllowedDuplicates = aAllowedDuplicates;
     }
 
     /**
      * Pattern for matching ignored strings.
      */
     private Pattern mPattern;
 
     /**
      * Construct an instance with default values.
      */
     public MultipleStringLiteralsCheck()
     {
         setIgnoreStringsRegexp("^\"\"$");
         mIgnoreOccurrenceContext.set(TokenTypes.ANNOTATION);
     }
 
     /**
      * Sets regexp pattern for ignored strings.
      * @param aIgnoreStringsRegexp regexp pattern for ignored strings
      */
     public void setIgnoreStringsRegexp(String aIgnoreStringsRegexp)
     {
         if ((aIgnoreStringsRegexp != null)
             && (aIgnoreStringsRegexp.length() > 0))
         {
             mPattern = Utils.getPattern(aIgnoreStringsRegexp);
         }
         else {
             mPattern = null;
         }
     }
 
     /**
      * Adds a set of tokens the check is interested in.
      * @param aStrRep the string representation of the tokens interested in
      */
     public final void setIgnoreOccurrenceContext(String[] aStrRep)
     {
         mIgnoreOccurrenceContext.clear();
-        for (int i = 0; i < aStrRep.length; i++) {
-            final String s = aStrRep[i];
+        for (final String s : aStrRep) {
             final int type = TokenTypes.getTokenId(s);
             mIgnoreOccurrenceContext.set(type);
         }
     }
 
     /** {@inheritDoc} */
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     /** {@inheritDoc} */
     @Override
     public void visitToken(DetailAST aAST)
     {
         if (isInIgnoreOccurrenceContext(aAST)) {
             return;
         }
         final String currentString = aAST.getText();
         if ((mPattern == null) || !mPattern.matcher(currentString).find()) {
             List<StringInfo> hitList = mStringMap.get(currentString);
             if (hitList == null) {
                 hitList = new ArrayList<StringInfo>();
                 mStringMap.put(currentString, hitList);
             }
             final int line = aAST.getLineNo();
             final int col = aAST.getColumnNo();
             hitList.add(new StringInfo(line, col));
         }
     }
 
     /**
      * Analyses the path from the AST root to a given AST for occurrences
      * of the token types in {@link #mIgnoreOccurrenceContext}.
      *
      * @param aAST the node from where to start searching towards the root node
      * @return whether the path from the root node to aAST contains one of the
      * token type in {@link #mIgnoreOccurrenceContext}.
      */
     private boolean isInIgnoreOccurrenceContext(DetailAST aAST)
     {
         for (DetailAST token = aAST;
              token.getParent() != null;
              token = token.getParent())
         {
             final int type = token.getType();
             if (mIgnoreOccurrenceContext.get(type)) {
                 return true;
             }
