diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
index b5aeb6adf..ae804f3ce 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
@@ -40,218 +40,220 @@ import java.util.regex.Pattern;
  * &lt;/module&gt;
  * </pre>
  * <p>
  * And to make sure the same statement appears at the beginning of the file.
  * </p>
  * <pre>
  * &lt;module name="RequiredRegexp"&gt;
  *    &lt;property name="format" value="\AThis code is copyrighted"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Stan Quinn
  */
 public class RegexpCheck extends AbstractFormatCheck
 {
     /** Default duplicate limit */
     private static final int DEFAULT_DUPLICATE_LIMIT = -1;
 
     /** Default error report limit */
     private static final int DEFAULT_ERROR_LIMIT = 100;
 
     /** Error count exceeded message */
     private static final String ERROR_LIMIT_EXCEEDED_MESSAGE =
         "The error limit has been exceeded, "
         + "the check is aborting, there may be more unreported errors.";
 
     /** Custom message for report. */
     private String mMessage = "";
 
     /** Ignore matches within comments? **/
     private boolean mIgnoreComments;
 
     /** Pattern illegal? */
     private boolean mIllegalPattern;
 
     /** Error report limit */
     private int mErrorLimit = DEFAULT_ERROR_LIMIT;
 
     /** Disallow more than x duplicates? */
     private int mDuplicateLimit;
 
     /** Boolean to say if we should check for duplicates. */
     private boolean mCheckForDuplicates;
 
     /** Tracks number of matches made */
     private int mMatchCount;
 
     /** Tracks number of errors */
     private int mErrorCount;
 
     /** Relates StringBuffer positions to line # and column */
-    private final List mCharacters = new ArrayList();
+    private final List<Integer[]> mCharacters = new ArrayList<Integer[]>();
 
     /** The mMatcher */
     private Matcher mMatcher;
 
     /**
      * Instantiates an new RegexpCheck.
      */
     public RegexpCheck()
     {
         super("$^", Pattern.MULTILINE); // the empty language
     }
 
     /**
      * Setter for message property.
      * @param aMessage custom message which should be used in report.
      */
     public void setMessage(String aMessage)
     {
         mMessage = (aMessage == null) ? "" : aMessage;
     }
 
     /**
      * Getter for message property.
      * I'm not sure if this gets used by anything outside,
      * I just included it because GenericIllegalRegexp had it,
      * it's being used in logMessage() so it's covered in EMMA.
      * @return custom message to be used in report.
      */
     public String getMessage()
     {
         return mMessage;
     }
 
     /**
      * Sets if matches within comments should be ignored.
      * @param aIgnoreComments True if comments should be ignored.
      */
     public void setIgnoreComments(boolean aIgnoreComments)
     {
         mIgnoreComments = aIgnoreComments;
     }
 
     /**
      * Sets if pattern is illegal, otherwise pattern is required.
      * @param aIllegalPattern True if pattern is not allowed.
      */
     public void setIllegalPattern(boolean aIllegalPattern)
     {
         mIllegalPattern = aIllegalPattern;
     }
 
     /**
      * Sets the limit on the number of errors to report.
      * @param aErrorLimit the number of errors to report.
      */
     public void setErrorLimit(int aErrorLimit)
     {
         mErrorLimit = aErrorLimit;
     }
 
     /**
      * Sets the maximum number of instances of required pattern allowed.
      * @param aDuplicateLimit negative values mean no duplicate checking,
      * any positive value is used as the limit.
      */
     public void setDuplicateLimit(int aDuplicateLimit)
     {
         mDuplicateLimit = aDuplicateLimit;
         mCheckForDuplicates = (mDuplicateLimit > DEFAULT_DUPLICATE_LIMIT);
     }
 
     /** {@inheritDoc} */
+    @Override
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     /** {@inheritDoc} */
+    @Override
     public void beginTree(DetailAST aRootAST)
     {
         mCharacters.clear();
         final Pattern pattern = getRegexp();
         final String[] lines = getLines();
         final StringBuffer sb = new StringBuffer();
         for (int i = 0; i < lines.length; i++) {
             sb.append(lines[i]);
             sb.append('\n');
             for (int j = 0; j < (lines[i].length() + 1); j++) {
                 mCharacters.add(new Integer[] {
                     new Integer(i + 1), new Integer(j), });
             }
         }
         mMatcher = pattern.matcher(sb.toString());
         mMatchCount = 0;
         mErrorCount = 0;
         findMatch();
     }
 
     /** recursive method that finds the matches. */
     private void findMatch()
     {
         int startLine;
         int startColumn;
         int endLine;
         int endColumn;
         boolean foundMatch;
         boolean ignore = false;
 
         foundMatch = mMatcher.find();
         if (!foundMatch && !mIllegalPattern && (mMatchCount == 0)) {
             logMessage(0);
         }
         else if (foundMatch) {
-            startLine = ((Integer[]) mCharacters.get(mMatcher.start()))[0].
+            startLine = (mCharacters.get(mMatcher.start()))[0].
                     intValue();
-            startColumn = ((Integer[]) mCharacters.get(mMatcher.start()))[1].
+            startColumn = (mCharacters.get(mMatcher.start()))[1].
                     intValue();
-            endLine = ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].
+            endLine = (mCharacters.get(mMatcher.end() - 1))[0].
                     intValue();
-            endColumn = ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].
+            endColumn = (mCharacters.get(mMatcher.end() - 1))[1].
                     intValue();
             if (mIgnoreComments) {
                 final FileContents theFileContents = getFileContents();
                 ignore = theFileContents.hasIntersectionWithComment(startLine,
                     startColumn, endLine, endColumn);
             }
             if (!ignore) {
                 mMatchCount++;
                 if (mIllegalPattern || (mCheckForDuplicates
                         && ((mMatchCount - 1) > mDuplicateLimit)))
                 {
                     mErrorCount++;
                     logMessage(startLine);
                 }
             }
             if ((mErrorCount < mErrorLimit)
                     && (ignore || mIllegalPattern || mCheckForDuplicates))
             {
                 findMatch();
             }
         }
     }
 
     /**
      * Displays the right message.
      * @param aLineNumber the line number the message relates to.
      */
     private void logMessage(int aLineNumber)
     {
         String message = "".equals(getMessage()) ? getFormat() : mMessage;
         if (mErrorCount >= mErrorLimit) {
             message = ERROR_LIMIT_EXCEEDED_MESSAGE + message;
         }
         if (mIllegalPattern) {
             log(aLineNumber, "illegal.regexp", message);
         }
         else {
             if (aLineNumber > 0) {
                 log(aLineNumber, "duplicate.regexp", message);
             }
             else {
                 log(aLineNumber, "required.regexp", message);
             }
         }
     }
 }
 
