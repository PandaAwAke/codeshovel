diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
index 3e9aabb6f..e750194fa 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
@@ -70,54 +70,58 @@ public class NewlineAtEndOfFileCheck
             randomAccessFile = new RandomAccessFile(aFile, "r");
             if (!endsWithNewline(randomAccessFile)) {
                 log(0, "noNewlineAtEOF", aFile.getPath());
             }
         }
         catch (final IOException e) {
             log(0, "unable.open", aFile.getPath());
         }
         finally {
             Utils.closeQuietly(randomAccessFile);
         }
     }
 
     /**
      * Sets the line separator to one of 'crlf', 'lf' or 'cr'.
      *
      * @param aLineSeparator The line separator to set
      * @throws IllegalArgumentException If the specified line separator is not
      *         one of 'crlf', 'lf' or 'cr'
      */
     public void setLineSeparator(String aLineSeparator)
     {
         try {
             mLineSeparator =
                 Enum.valueOf(LineSeparatorOption.class, aLineSeparator.trim()
                     .toUpperCase());
         }
         catch (IllegalArgumentException iae) {
             throw new ConversionException("unable to parse " + aLineSeparator,
                 iae);
         }
     }
 
     /**
      * Checks whether the content provided by the Reader ends with the platform
      * specific line separator.
      * @param aRandomAccessFile The reader for the content to check
      * @return boolean Whether the content ends with a line separator
      * @throws IOException When an IO error occurred while reading from the
      *         provided reader
      */
     private boolean endsWithNewline(RandomAccessFile aRandomAccessFile)
         throws IOException
     {
         final int len = mLineSeparator.length();
         if (aRandomAccessFile.length() < len) {
             return false;
         }
         aRandomAccessFile.seek(aRandomAccessFile.length() - len);
         final byte lastBytes[] = new byte[len];
-        aRandomAccessFile.read(lastBytes);
+        final int readBytes = aRandomAccessFile.read(lastBytes);
+        if (readBytes != len) {
+            throw new IOException("Unable to read " + len + " bytes, got "
+                    + readBytes);
+        }
         return mLineSeparator.matches(lastBytes);
     }
 }
