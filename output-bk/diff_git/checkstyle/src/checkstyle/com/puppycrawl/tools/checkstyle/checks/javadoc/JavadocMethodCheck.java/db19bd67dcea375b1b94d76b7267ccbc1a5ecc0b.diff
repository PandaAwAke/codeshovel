diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index f6fbb9e17..a7ca1fec5 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -241,103 +241,101 @@ public class JavadocMethodCheck
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     protected final void processAST(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope targetScope =
             ScopeUtils.inInterfaceBlock(aAST)
                 ? Scope.PUBLIC
                 : declaredScope;
 
         if (targetScope.isIn(mScope)) {
             final Scope surroundingScope =
                 ScopeUtils.getSurroundingScope(aAST);
 
             if (surroundingScope.isIn(mScope)) {
                 final FileContents contents = getFileContents();
                 final TextBlock cmt =
                     contents.getJavadocBefore(aAST.getLineNo());
 
                 if (cmt == null) {
-                    log(aAST.getLineNo(),
-                        aAST.getColumnNo(),
-                        "javadoc.missing");
+                    log(aAST, "javadoc.missing");
                 }
                 else {
                     checkComment(aAST, cmt);
                 }
             }
         }
     }
 
     /**
      * Checks the Javadoc for a method.
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
      */
     private void checkComment(DetailAST aAST, TextBlock aComment)
     {
         final List tags = getMethodTags(aComment);
 
         // Check for only one @see or inheritDoc tag
         if ((tags.size() == 1)
             && ((JavadocTag) tags.get(0)).isSeeOrInheritDocTag())
         {
             return;
         }
 
         // Check for inheritDoc
         boolean hasInheritDocTag = false;
         Iterator it = tags.iterator();
         while (it.hasNext() && !hasInheritDocTag) {
             hasInheritDocTag |=
                 ((JavadocTag) it.next()).isInheritDocTag();
         }
 
         checkParamTags(tags, getParameters(aAST), !hasInheritDocTag);
         checkThrowsTags(tags, getThrows(aAST), !hasInheritDocTag);
         if (isFunction(aAST)) {
             checkReturnTag(tags, aAST.getLineNo(), !hasInheritDocTag);
         }
 
         // Dump out all unused tags
         it = tags.iterator();
         while (it.hasNext()) {
             final JavadocTag jt = (JavadocTag) it.next();
             if (!jt.isSeeOrInheritDocTag()) {
                 log(jt.getLineNo(), "javadoc.unusedTagGeneral");
             }
         }
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
@@ -461,102 +459,101 @@ public class JavadocMethodCheck
         return retVal;
     }
 
 
     /**
      * Checks a set of tags for matching parameters.
      * @param aTags the tags to check
      * @param aParams the list of parameters to check
      * @param aReportExpectedTags whether we should report if do
      *        not find expected tag
      **/
     private void checkParamTags(List aTags, List aParams,
                                 boolean aReportExpectedTags)
     {
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching param
             boolean found = false;
             final Iterator paramIt = aParams.iterator();
             while (paramIt.hasNext()) {
                 final DetailAST param = (DetailAST) paramIt.next();
                 if (param.getText().equals(tag.getArg1())) {
                     found = true;
                     paramIt.remove();
                     break;
                 }
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), "javadoc.unusedTag",
                               "@param", tag.getArg1());
             }
         }
 
         // Now dump out all parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!mAllowMissingParamTags && aReportExpectedTags) {
             final Iterator paramIt = aParams.iterator();
             while (paramIt.hasNext()) {
                 final DetailAST param = (DetailAST) paramIt.next();
-                log(param.getLineNo(), param.getColumnNo(),
-                    "javadoc.expectedTag", "@param", param.getText());
+                log(param, "javadoc.expectedTag", "@param", param.getText());
             }
         }
     }
 
     /**
      * Checks whether a method is a function.
      * @param aAST the method node.
      * @return whether the method is a function.
      **/
     private boolean isFunction(DetailAST aAST)
     {
         boolean retVal = false;
         if (aAST.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = aAST.findFirstToken(TokenTypes.TYPE);
             if ((typeAST != null)
                 && (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null))
             {
                 retVal = true;
             }
         }
         return retVal;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      * @param aTags the tags to check
      * @param aLineNo the line number of the expected tag
      * @param aReportExpectedTags whether we should report if do
      *        not find expected tag
      **/
     private void checkReturnTag(List aTags, int aLineNo,
                                 boolean aReportExpectedTags)
     {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator it = aTags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = (JavadocTag) it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), "javadoc.return.duplicate");
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
