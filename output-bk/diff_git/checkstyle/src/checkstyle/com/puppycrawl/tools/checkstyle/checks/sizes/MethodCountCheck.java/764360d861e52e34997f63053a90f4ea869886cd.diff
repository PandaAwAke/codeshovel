diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
index 01b11e387..24a93d5d7 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
@@ -63,123 +63,132 @@ public final class MethodCountCheck extends Check
          * Increments to counter by one for the supplied scope.
          * @param aScope the scope counter to increment.
          */
         void increment(Scope aScope)
         {
             mTotal++;
             if (mInInterface) {
                 mCounts.put(Scope.PUBLIC, 1 + value(Scope.PUBLIC));
             }
             else {
                 mCounts.put(aScope, 1 + value(aScope));
             }
         }
 
         /**
          * @return the value of a scope counter
          * @param aScope the scope counter to get the value of
          */
         int value(Scope aScope)
         {
             final Integer value = mCounts.get(aScope);
             return (null == value) ? 0 : value;
         }
 
         /** @return the total number of methods. */
         int getTotal()
         {
             return mTotal;
         }
     };
 
     /** default maximum number of methods */
     private static final int DEFAULT_MAX_METHODS = 999;
     /** Maximum private methods. */
     private int mMaxPrivate = DEFAULT_MAX_METHODS;
     /** Maximum package methods. */
     private int mMaxPackage = DEFAULT_MAX_METHODS;
     /** Maximum protected methods. */
     private int mMaxProtected = DEFAULT_MAX_METHODS;
     /** Maximum public methods. */
     private int mMaxPublic = DEFAULT_MAX_METHODS;
     /** Maximum total number of methods. */
     private int mMaxTotal = DEFAULT_MAX_METHODS;
     /** Maintains stack of counters, to support inner types. */
     private final FastStack<MethodCounter> mCounters =
         new FastStack<MethodCounter>();
 
     @Override
     public int[] getDefaultTokens()
     {
-        return new int[] {TokenTypes.CLASS_DEF, TokenTypes.INTERFACE_DEF,
-                          TokenTypes.METHOD_DEF, };
+        return new int[] {
+            TokenTypes.CLASS_DEF,
+            TokenTypes.ENUM_CONSTANT_DEF,
+            TokenTypes.ENUM_DEF,
+            TokenTypes.INTERFACE_DEF,
+            TokenTypes.METHOD_DEF,
+        };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         if ((TokenTypes.CLASS_DEF == aAST.getType())
-            || (TokenTypes.INTERFACE_DEF == aAST.getType()))
+            || (TokenTypes.INTERFACE_DEF == aAST.getType())
+            || (TokenTypes.ENUM_CONSTANT_DEF == aAST.getType())
+            || (TokenTypes.ENUM_DEF == aAST.getType()))
         {
             mCounters.push(new MethodCounter(
                 TokenTypes.INTERFACE_DEF == aAST.getType()));
         }
         else if (TokenTypes.METHOD_DEF == aAST.getType()) {
             raiseCounter(aAST);
         }
     }
 
     @Override
     public void leaveToken(DetailAST aAST)
     {
         if ((TokenTypes.CLASS_DEF == aAST.getType())
-            || (TokenTypes.INTERFACE_DEF == aAST.getType()))
+            || (TokenTypes.INTERFACE_DEF == aAST.getType())
+            || (TokenTypes.ENUM_CONSTANT_DEF == aAST.getType())
+            || (TokenTypes.ENUM_DEF == aAST.getType()))
         {
             final MethodCounter counter = mCounters.pop();
             checkCounters(counter, aAST);
         }
     }
 
     /**
      * Determine the visibility modifier and raise the corresponding counter.
      * @param aMethod
      *            The method-subtree from the AbstractSyntaxTree.
      */
     private void raiseCounter(DetailAST aMethod)
     {
         final MethodCounter actualCounter = mCounters.peek();
         final DetailAST temp = aMethod.findFirstToken(TokenTypes.MODIFIERS);
         final Scope scope = ScopeUtils.getScopeFromMods(temp);
         actualCounter.increment(scope);
     }
 
     /**
      * Check the counters and report violations.
      * @param aCounter the method counters to check
      * @param aAst to report errors against.
      */
     private void checkCounters(MethodCounter aCounter, DetailAST aAst)
     {
         checkMax(mMaxPrivate, aCounter.value(Scope.PRIVATE),
                  "too.many.privateMethods", aAst);
         checkMax(mMaxPackage, aCounter.value(Scope.PACKAGE),
                  "too.many.packageMethods", aAst);
         checkMax(mMaxProtected, aCounter.value(Scope.PROTECTED),
                  "too.many.protectedMethods", aAst);
         checkMax(mMaxPublic, aCounter.value(Scope.PUBLIC),
                  "too.many.publicMethods", aAst);
         checkMax(mMaxTotal, aCounter.getTotal(), "too.many.methods", aAst);
     }
 
     /**
      * Utility for reporting if a maximum has been exceeded.
      * @param aMax the maximum allowed value
      * @param aValue the actual value
      * @param aMsg the message to log. Takes two arguments of value and maximum.
      * @param aAst the AST to associate with the message.
      */
     private void checkMax(int aMax, int aValue, String aMsg, DetailAST aAst)
     {
         if (aMax < aValue) {
             log(aAst.getLineNo(), aMsg, aValue, aMax);
         }
     }
