diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index 0c811d681..16d3df917 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -153,101 +153,101 @@ public class ImportOrderCheck
      */
     public void setSeparated(boolean aSeparated)
     {
         mSeparated = aSeparated;
     }
 
     /**
      * Sets whether string comparison should be case sensitive or not.
      *
      * @param aCaseSensitive
      *            whether string comparison should be case sensitive.
      */
     public void setCaseSensitive(boolean aCaseSensitive)
     {
         mCaseSensitive = aCaseSensitive;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.IMPORT, TokenTypes.STATIC_IMPORT};
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     @Override
     public void beginTree(DetailAST aRootAST)
     {
         mLastGroup = Integer.MIN_VALUE;
         mLastImportLine = Integer.MIN_VALUE;
         mLastImport = "";
         mLastImportStatic = false;
         mBeforeFirstImport = true;
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final FullIdent ident;
         final boolean isStatic;
 
         if (aAST.getType() == TokenTypes.IMPORT) {
             ident = FullIdent.createFullIdentBelow(aAST);
             isStatic = false;
         }
         else {
-            ident = FullIdent.createFullIdent((DetailAST) aAST.getFirstChild()
+            ident = FullIdent.createFullIdent(aAST.getFirstChild()
                     .getNextSibling());
             isStatic = true;
         }
 
         switch (getAbstractOption()) {
         case TOP:
             if (!isStatic && mLastImportStatic) {
                 mLastGroup = Integer.MIN_VALUE;
                 mLastImport = "";
             }
             // no break;
 
         case ABOVE:
             // previous non-static but current is static
             doVisitToken(ident, isStatic, (!mLastImportStatic && isStatic));
             break;
 
         case INFLOW:
             // previous argument is useless here
             doVisitToken(ident, isStatic, true);
             break;
 
         case BOTTOM:
             if (isStatic && !mLastImportStatic) {
                 mLastGroup = Integer.MIN_VALUE;
                 mLastImport = "";
             }
             // no break;
 
         case UNDER:
             // previous static but current is non-static
             doVisitToken(ident, isStatic, (mLastImportStatic && !isStatic));
             break;
 
         default:
             break;
         }
 
         mLastImportLine = aAST.findFirstToken(TokenTypes.SEMI).getLineNo();
         mLastImportStatic = isStatic;
         mBeforeFirstImport = false;
     }
 
     /**
      * Shares processing...
      *
      * @param aIdent the import to process.
      * @param aIsStatic whether the token is static or not.
      * @param aPrevious previous non-static but current is static (above), or
      *                  previous static but current is non-static (under).
