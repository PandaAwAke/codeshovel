diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java
index ccb4f1737..865e06351 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java
@@ -76,100 +76,102 @@ public class IllegalInstantiationCheck
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.LITERAL_NEW,
             TokenTypes.PACKAGE_DEF
         };
     }
 
     /**
      * Prevent user from changing tokens in the configuration.
      * @see com.puppycrawl.tools.checkstyle.api.Check
      */
     public int[] getAcceptableTokens()
     {
         return new int[] {};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.LITERAL_NEW,
             TokenTypes.PACKAGE_DEF
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree(DetailAST aRootAST)
     {
         super.beginTree(aRootAST);
         mPkgName = null;
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         switch (aAST.getType()) {
             case TokenTypes.LITERAL_NEW:
                 processLiteralNew(aAST);
                 break;
             case TokenTypes.PACKAGE_DEF:
                 processPackageDef(aAST);
                 break;
             case TokenTypes.IMPORT:
                 processImport(aAST);
                 break;
+            default:
+                throw new IllegalArgumentException("Unknown type " + aAST);
         }
     }
 
     /**
      * Perform processing for an import token
      * @param aAST the import token
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = getImportText(aAST);
         if (name != null) {
             // Note: different from UnusedImportsCheck.processImport(),
             // '.*' imports are also added here
             mImports.add(name);
         }
     }
 
     /**
      * Perform processing for an package token
      * @param aAST the package token
      */
     private void processPackageDef(DetailAST aAST)
     {
         final DetailAST packageNameAST = (DetailAST) aAST.getFirstChild();
         final FullIdent packageIdent =
                 FullIdent.createFullIdent(packageNameAST);
         mPkgName = packageIdent.getText();
     }
 
     /**
      * Perform processing for an "new" token
      * @param aAST the "new" token
      */
     private void processLiteralNew(DetailAST aAST)
     {
         final DetailAST typeNameAST = (DetailAST) aAST.getFirstChild();
 
         final AST nameSibling = typeNameAST.getNextSibling();
         if (nameSibling != null
                 && nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR)
         {
             // aAST == "new Boolean[]"
             return;
         }
 
         FullIdent typeIdent = FullIdent.createFullIdent(typeNameAST);
         final String typeName = typeIdent.getText();
         final int lineNo = aAST.getLineNo();
         final int colNo = aAST.getColumnNo();
         final String fqClassName = getIllegalInstantiation(typeName);
