diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index c26e8e701..b95ea5c8a 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -64,156 +64,156 @@ public class VisibilityModifierCheck
 
     /** regexp for public members that should be ignored */
     private Pattern mPublicMemberPattern;
 
     /** Create an instance. */
     public VisibilityModifierCheck()
     {
         setPublicMemberPattern(mPublicMemberFormat);
     }
 
     /** @return whether protected members are allowed */
     public boolean isProtectedAllowed()
     {
         return mProtectedAllowed;
     }
 
     /**
      * Set whether protected members are allowed.
      * @param aProtectedAllowed whether protected members are allowed
      */
     public void setProtectedAllowed(boolean aProtectedAllowed)
     {
         mProtectedAllowed = aProtectedAllowed;
     }
 
     /** @return whether package visible members are allowed */
     public boolean isPackageAllowed()
     {
         return mPackageAllowed;
     }
 
     /**
      * Set whether package visible members are allowed.
      * @param aPackageAllowed whether package visible members are allowed
      */
     public void setPackageAllowed(boolean aPackageAllowed)
     {
         mPackageAllowed = aPackageAllowed;
     }
 
     /**
      * Set the pattern for public members to ignore.
      * @param aPattern pattern for public members to ignore.
      */
     public void setPublicMemberPattern(String aPattern)
     {
         try {
             mPublicMemberPattern = Utils.getPattern(aPattern);
             mPublicMemberFormat = aPattern;
         }
-        catch (PatternSyntaxException e) {
+        catch (final PatternSyntaxException e) {
             throw new ConversionException("unable to parse " + aPattern, e);
         }
     }
 
     /**
      * @return the regexp for public members to ignore.
      */
     private Pattern getPublicMemberRegexp()
     {
         return mPublicMemberPattern;
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
         if ((aAST.getType() != TokenTypes.VARIABLE_DEF)
             || (aAST.getParent().getType() != TokenTypes.OBJBLOCK))
         {
             return;
         }
 
         final DetailAST varNameAST = getVarNameAST(aAST);
         final String varName = varNameAST.getText();
         final boolean inInterfaceOrAnnotationBlock =
             ScopeUtils.inInterfaceOrAnnotationBlock(aAST);
         final Set mods = getModifiers(aAST);
         final String declaredScope = getVisibilityScope(mods);
         final String variableScope =
              inInterfaceOrAnnotationBlock ? "public" : declaredScope;
 
         if (!("private".equals(variableScope)
                 || inInterfaceOrAnnotationBlock // implicitly static and final
                 || (mods.contains("static") && mods.contains("final"))
                 || ("package".equals(variableScope) && isPackageAllowed())
                 || ("protected".equals(variableScope) && isProtectedAllowed())
                 || ("public".equals(variableScope)
                    && getPublicMemberRegexp().matcher(varName).find())))
         {
             log(varNameAST.getLineNo(), varNameAST.getColumnNo(),
                     "variable.notPrivate", varName);
         }
     }
 
     /**
      * Returns the variable name in a VARIABLE_DEF AST.
      * @param aVariableDefAST an AST where type == VARIABLE_DEF AST.
      * @return the variable name in aVariableDefAST
      */
     private DetailAST getVarNameAST(DetailAST aVariableDefAST)
     {
         AST ast = aVariableDefAST.getFirstChild();
         while (ast != null) {
-            AST nextSibling = ast.getNextSibling();
+            final AST nextSibling = ast.getNextSibling();
             if (ast.getType() == TokenTypes.TYPE) {
                 return (DetailAST) nextSibling;
             }
             ast = nextSibling;
         }
         return null;
     }
 
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF AST.
      * @param aVariableDefAST AST for a vraiable definition
      * @return the set of modifier Strings for variableDefAST
      */
     private Set getModifiers(DetailAST aVariableDefAST)
     {
         final AST modifiersAST = aVariableDefAST.getFirstChild();
         if (modifiersAST.getType() != TokenTypes.MODIFIERS) {
             throw new IllegalStateException("Strange parse tree");
         }
         final Set retVal = new HashSet();
         AST modifier = modifiersAST.getFirstChild();
         while (modifier != null) {
             retVal.add(modifier.getText());
             modifier = modifier.getNextSibling();
         }
         return retVal;
 
     }
 
     /**
      * Returns the visibility scope specified with a set of modifiers.
      * @param aModifiers the set of modifier Strings
      * @return one of "public", "private", "protected", "package"
      */
     private String getVisibilityScope(Set aModifiers)
     {
         final String[] explicitModifiers = {"public", "private", "protected"};
         for (int i = 0; i < explicitModifiers.length; i++) {
             final String candidate = explicitModifiers[i];
             if (aModifiers.contains(candidate)) {
                 return candidate;
             }
         }
         return "package";
     }
 }
