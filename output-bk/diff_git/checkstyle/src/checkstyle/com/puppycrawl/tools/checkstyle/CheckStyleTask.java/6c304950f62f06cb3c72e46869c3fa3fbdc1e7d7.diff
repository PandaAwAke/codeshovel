diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
index f174406fd..f6eecb5e7 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
@@ -154,114 +154,122 @@ public class CheckStyleTask
             mConfig.setTypePat(aPat);
         }
         catch (RESyntaxException ex) {
             throw new BuildException("Unable to parse typepattern - " +
                                      ex.getMessage());
         }
     }
 
     /** @param aName header file name **/
     public void setHeaderFile(File aName)
     {
         try {
             mConfig.setHeaderFile(aName.getAbsolutePath());
         }
         catch (IOException ex) {
             throw new BuildException("Unable to read headerfile - " +
                                      ex.getMessage());
         }
     }
 
     /** @param aNum **/
     public void setHeaderIgnoreLine(int aNum)
     {
         mConfig.setHeaderIgnoreLineNo(aNum);
     }
 
     /** @param aRelax whether to be relaxed on Javadoc **/
     public void setRelaxJavadoc(boolean aRelax)
     {
         mConfig.setRelaxJavadoc(aRelax);
     }
 
     /** @param aIgnore whether to ignore import statements **/
     public void setIgnoreImports(boolean aIgnore)
     {
         mConfig.setIgnoreImports(aIgnore);
     }
 
     /** @param aIgnore whether to ignore whitespace **/
     public void setIgnoreWhitespace(boolean aIgnore)
     {
         mConfig.setIgnoreWhitespace(aIgnore);
     }
 
     /** @param aIgnore whether to ignore braces **/
     public void setIgnoreBraces(boolean aIgnore)
     {
         mConfig.setIgnoreBraces(aIgnore);
     }
 
+    /** @param aCacheFile the file to cache which files have been checked **/
+    public void setCacheFile(File aCacheFile)
+    {
+        mConfig.setCacheFile(aCacheFile.getAbsolutePath());
+    }
+
     ////////////////////////////////////////////////////////////////////////////
     // The doers
     ////////////////////////////////////////////////////////////////////////////
 
     /**
      * Actually checks the files specified. All errors are reported to
      * System.out. Will fail if any errors occurred.
      * @throws BuildException an error occurred
      **/
     public void execute()
         throws BuildException
     {
         // Check for no arguments
         if ((mFileName == null) && (mFileSets.size() == 0)) {
             throw new BuildException("Must specify atleast one of 'file' " +
                                      "or nested 'fileset'.", location);
         }
 
         // Create the checker
         Checker c;
         try {
             c = new Checker(mConfig, System.out);
         }
         catch (RESyntaxException e){
             e.printStackTrace();
             throw new BuildException("Unable to create a Checker", location);
         }
 
         // Process the files
         int numErrs = 0;
         if (mFileName != null) {
             numErrs += c.process(mFileName);
         }
 
         final Iterator it = mFileSets.iterator();
         while (it.hasNext()) {
             final FileSet fs = (FileSet) it.next();
             final DirectoryScanner ds = fs.getDirectoryScanner(project);
             numErrs += process(fs.getDir(project).getAbsolutePath(),
                                ds.getIncludedFiles(),
                                c);
         }
 
+        c.destroy();
+
         if (numErrs > 0) {
             throw new BuildException("Got " + numErrs + " errors.", location);
         }
     }
 
     /**
      * Processes the list of files.
      * @return the number of errors found
      * @param aDir absolute path to directory containing files
      * @param aFiles the files to process
      * @param aChecker the checker to process the files with
      **/
     private int process(String aDir, String[] aFiles, Checker aChecker)
     {
         int retVal = 0;
         for (int i = 0; i < aFiles.length; i++) {
             retVal += aChecker.process(aDir + File.separator + aFiles[i]);
         }
         return retVal;
     }
 }
