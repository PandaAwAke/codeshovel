diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java
index b3410547e..51f7a0bab 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java
@@ -150,127 +150,127 @@ public final class Utils
      * regular expression and compile flags.
      * <p>
      * This method is not MT safe, but neither are the returned Pattern objects.
      * @return an Pattern object for the supplied pattern
      * @param aPattern the regular expression pattern
      * @param aCompileFlags the compilation flags
      * @throws PatternSyntaxException an invalid pattern was supplied
      **/
     public static Pattern getPattern(String aPattern, int aCompileFlags)
         throws PatternSyntaxException
     {
         final String key = aPattern + ":flags-" + aCompileFlags;
         Pattern retVal = (Pattern) CREATED_RES.get(key);
         if (retVal == null) {
             retVal = Pattern.compile(aPattern, aCompileFlags);
             CREATED_RES.put(key, retVal);
         }
         return retVal;
     }
     /**
      * Loads the contents of a file in a String array.
      * @return the lines in the file
      * @param aFileName the name of the file to load
      * @throws IOException error occurred
      **/
     public static String[] getLines(String aFileName)
         throws IOException
     {
         return getLines(
             aFileName,
             System.getProperty("file.encoding", "UTF-8"));
     }
 
     /**
      * Loads the contents of a file in a String array using
      * the named charset.
      * @return the lines in the file
      * @param aFileName the name of the file to load
      * @param aCharsetName the name of a supported charset
      * @throws IOException error occurred
      **/
     public static String[] getLines(String aFileName, String aCharsetName)
         throws IOException
     {
         final ArrayList lines = new ArrayList();
         final FileInputStream fr = new FileInputStream(aFileName);
         LineNumberReader lnr = null;
         try {
             lnr = new LineNumberReader(new InputStreamReader(fr, aCharsetName));
         }
-        catch (UnsupportedEncodingException ex) {
+        catch (final UnsupportedEncodingException ex) {
             final String message = "unsupported charset: " + ex.getMessage();
             throw new UnsupportedEncodingException(message);
         }
         try {
             while (true) {
                 final String l = lnr.readLine();
                 if (l == null) {
                     break;
                 }
                 lines.add(l);
             }
         }
         finally {
             try {
                 lnr.close();
             }
-            catch (IOException e) {
+            catch (final IOException e) {
                 ; // silently ignore
             }
         }
 
         return (String[]) lines.toArray(new String[0]);
     }
 
     /**
      * Helper method to create a regular expression.
      * @param aPattern the pattern to match
      * @return a created regexp object
      * @throws ConversionException if unable to create Pattern object.
      **/
     public static Pattern createPattern(String aPattern)
         throws ConversionException
     {
         Pattern retVal = null;
         try {
             retVal = getPattern(aPattern);
         }
-        catch (PatternSyntaxException e) {
+        catch (final PatternSyntaxException e) {
             throw new ConversionException(
                 "Failed to initialise regexp expression " + aPattern, e);
         }
         return retVal;
     }
 
     /**
      * @return the base class name from a fully qualified name
      * @param aType the fully qualified name. Cannot be null
      */
     public static String baseClassname(String aType)
     {
         final int i = aType.lastIndexOf(".");
         return (i == -1) ? aType : aType.substring(i + 1);
     }
 
     /**
      * Create a stripped down version of a filename.
      * @param aBasedir the prefix to strip off the original filename
      * @param aFileName the original filename
      * @return the filename where an initial prefix of basedir is stripped
      */
     public static String getStrippedFileName(
             final String aBasedir, final String aFileName)
     {
         final String stripped;
         if ((aBasedir == null) || !aFileName.startsWith(aBasedir)) {
             stripped = aFileName;
         }
         else {
             // making the assumption that there is text after basedir
             final int skipSep = aBasedir.endsWith(File.separator) ? 0 : 1;
             stripped = aFileName.substring(aBasedir.length() + skipSep);
         }
         return stripped;
     }
 
 }
