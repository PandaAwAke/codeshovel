diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
index bce8d5090..0a46785ef 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
@@ -146,287 +146,278 @@ public class SuppressionCommentFilter
         }
 
         /** @return the text of the tag. */
         public String getText()
         {
             return mText;
         }
 
         /** @return the line number of the tag in the source file. */
         public int getLine()
         {
             return mLine;
         }
 
         /**
          * Determines the column number of the tag in the source file.
          * Will be 0 for all lines of multiline comment, except the
          * first line.
          * @return the column number of the tag in the source file.
          */
         public int getColumn()
         {
             return mColumn;
         }
 
         /**
          * Determines whether the suppression turns checkstyle reporting on or
          * off.
          * @return <code>true</code>if the suppression turns reporting on.
          */
         public boolean isOn()
         {
             return mOn;
         }
 
         /**
          * Compares the position of this tag in the file
          * with the position of another tag.
          * @param aObject the tag to compare with this one.
          * @return a negative number if this tag is before the other tag,
          * 0 if they are at the same position, and a positive number if this
          * tag is after the other tag.
          * @see java.lang.Comparable#compareTo(java.lang.Object)
          */
         public int compareTo(Object aObject)
         {
             final Tag other = (Tag) aObject;
             if (mLine == other.mLine) {
                 return mColumn - other.mColumn;
             }
-            else {
-                return (mLine - other.mLine);
-            }
+            
+            return (mLine - other.mLine);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param aEvent the <code>AuditEvent</code> to check.
          * @return true if the source of aEvent matches the text of this tag.
          */
         public boolean isMatch(AuditEvent aEvent)
         {
             if (mTagCheckRegexp.match(aEvent.getSourceName())) {
                 return true;
             }
             if (mTagMessageRegexp != null) {
                 return mTagMessageRegexp.match(aEvent.getMessage());
             }
             return false;
         }
 
         /**
          * Expand based on a matching comment.
          * @param aComment the comment.
          * @param aString the string to expand.
          * @param aRegexp the parsed expander.
          * @return the expanded string
          */
         private String expandFromComment(
             String aComment,
             String aString,
             RE aRegexp)
         {
             // Match primarily for effect.
             if (!aRegexp.match(aComment)) {
                 ///CLOVER:OFF
                 return aString;
                 ///CLOVER:ON
             }
             String result = aString;
             for (int i = 1; i < aRegexp.getParenCount(); i++) {
                 // $n expands comment match like in RE.subst().
                 result = result.replaceAll("\\$" + i, aRegexp.getParen(i));
             }
             return result;
         }
     }
 
     /** Turns checkstyle reporting off. */
     private static final String DEFAULT_OFF_FORMAT = "CHECKSTYLE\\:OFF";
 
     /** Turns checkstyle reporting on. */
     private static final String DEFAULT_ON_FORMAT = "CHECKSTYLE\\:ON";
 
     /** Control all checks */
     private static final String DEFAULT_CHECK_FORMAT = ".*";
 
     /** Whether to look in comments of the C type. */
     private boolean mCheckC = true;
 
     /** Whether to look in comments of the C++ type. */
     private boolean mCheckCPP = true;
 
-    /** Turns checkstyle reporting off. */
-    private String mOffCommentFormat;
-
     /** Parsed comment regexp that turns checkstyle reporting off. */
     private RE mOffRegexp;
 
-    /** Turns checkstyle reporting on. */
-    private String mOnCommentFormat;
-
     /** Parsed comment regexp that turns checkstyle reporting on. */
     private RE mOnRegexp;
 
     /** The check format to suppress. */
     private String mCheckFormat;
 
     /** The parsed check regexp. */
     private RE mCheckRegexp;
 
     /** The message format to suppress. */
     private String mMessageFormat;
 
     //TODO: Investigate performance improvement with array
     /** Tagged comments */
     private List mTags = new ArrayList();
 
     /**
      * References the current FileContents for this filter.
      * Since this is a weak reference to the FileContents, the FileContents
      * can be reclaimed as soon as the strong references in TreeWalker
      * and FileContentsHolder are reassigned to the next FileContents,
      * at which time filtering for the current FileContents is finished.
      */
     private WeakReference mFileContentsReference = new WeakReference(null);
 
     /**
      * Constructs a SuppressionCommentFilter.
      * Initializes comment on, comment off, and check formats
      * to defaults.
      */
     public SuppressionCommentFilter()
     {
         setOnCommentFormat(DEFAULT_ON_FORMAT);
         setOffCommentFormat(DEFAULT_OFF_FORMAT);
         setCheckFormat(DEFAULT_CHECK_FORMAT);
     }
 
     /**
      * Set the format for a comment that turns off reporting.
      * @param aFormat a <code>String</code> value.
      * @throws ConversionException unable to parse aFormat.
      */
     public void setOffCommentFormat(String aFormat)
         throws ConversionException
     {
         try {
             mOffRegexp = Utils.getRE(aFormat);
-            mOffCommentFormat = aFormat;
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
 
     /**
      * Set the format for a comment that turns on reporting.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setOnCommentFormat(String aFormat)
         throws ConversionException
     {
         try {
             mOnRegexp = Utils.getRE(aFormat);
-            mOnCommentFormat = aFormat;
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
 
     /** @return the FileContents for this filter. */
     public FileContents getFileContents()
     {
         return (FileContents) mFileContentsReference.get();
     }
 
     /**
      * Set the FileContents for this filter.
      * @param aFileContents the FileContents for this filter.
      */
     public void setFileContents(FileContents aFileContents)
     {
         mFileContentsReference = new WeakReference(aFileContents);
     }
 
     /**
      * Set the format for a check.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setCheckFormat(String aFormat)
         throws ConversionException
     {
         try {
             mCheckRegexp = Utils.getRE(aFormat);
             mCheckFormat = aFormat;
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
 
     /**
      * Set the format for a message.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setMessageFormat(String aFormat)
         throws ConversionException
     {
         // check that aFormat parses
         try {
-            RE messageRegexp = Utils.getRE(aFormat);
+            Utils.getRE(aFormat);
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
         mMessageFormat = aFormat;
     }
 
 
     /**
      * Set whether to look in C++ comments.
      * @param aCheckCPP <code>true</code> if C++ comments are checked.
      */
     public void setCheckCPP(boolean aCheckCPP)
     {
         mCheckCPP = aCheckCPP;
     }
 
     /**
      * Set whether to look in C comments.
      * @param aCheckC <code>true</code> if C comments are checked.
      */
     public void setCheckC(boolean aCheckC)
     {
         mCheckC = aCheckC;
     }
 
     /** @see Filter */
     public boolean accept(AuditEvent aEvent)
     {
         if (aEvent.getLocalizedMessage() == null) {
             return true;        // A special event.
         }
 
         // Lazy update. If the first event for the current file, update file
         // contents and tag suppressions
         final FileContents currentContents = FileContentsHolder.getContents();
         if (getFileContents() != currentContents) {
             setFileContents(currentContents);
             tagSuppressions();
         }
         final Tag matchTag = findNearestMatch(aEvent);
         if ((matchTag != null) && !matchTag.isOn()) {
             return false;
         }
         return true;
     }
 
     /**
      * Finds the nearest comment text tag that matches an audit event.
      * The nearest tag is before the line and column of the event.
