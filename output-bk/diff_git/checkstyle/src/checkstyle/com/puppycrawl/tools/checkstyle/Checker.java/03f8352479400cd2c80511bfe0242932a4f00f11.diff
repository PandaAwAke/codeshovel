diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index bf75cf428..da4a6dece 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -177,153 +177,158 @@ public class Checker
         if ((basedir == null) || !aFileName.startsWith(basedir)) {
             stripped = aFileName;
         }
         else {
             // making the assumption that there is text after basedir
             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;
             stripped = aFileName.substring(basedir.length() + skipSep);
         }
 
         LocalizedMessage[] errors;
         try {
             fireFileStarted(stripped);
             final String[] lines = getLines(aFileName);
             try {
                 // try the 1.4 grammar first, this will succeed for
                 // all code that compiles without any warnings in JDK 1.4,
                 // that should cover most cases
                 VerifierSingleton.getInstance().reset();
                 VerifierSingleton.getInstance().setLines(lines);
                 final Reader sar = new StringArrayReader(lines);
                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJava14Recognizer jr =
                     new SilentJava14Recognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             catch (RecognitionException re) {
                 // Parsing might have failed because the checked
                 // file contains "assert" as an identifier. Retry with a
                 // grammar that treats "assert" as an identifier
                 // and not as a keyword
 
                 // Arghh - the pain - duplicate code!
                 VerifierSingleton.getInstance().reset();
                 VerifierSingleton.getInstance().setLines(lines);
                 final Reader sar = new StringArrayReader(lines);
                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJavaRecognizer jr =
                     new GeneratedJavaRecognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             errors = VerifierSingleton.getInstance().getMessages();
         }
         catch (FileNotFoundException fnfe) {
             errors = new LocalizedMessage[] {
-                new LocalizedMessage(0, "general.fileNotFound", null, null)};
+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
+                                     "general.fileNotFound", null)};
         }
         catch (IOException ioe) {
             errors = new LocalizedMessage[] {
-                new LocalizedMessage(0, "general.exception", null,
+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
+                                     "general.exception",
                                      new String[] {ioe.getMessage()})};
         }
         catch (RecognitionException re) {
             errors = new LocalizedMessage[] {
-                new LocalizedMessage(0, "general.exception", null,
+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
+                                     "general.exception",
                                      new String[] {re.getMessage()})};
         }
         catch (TokenStreamException te) {
             errors = new LocalizedMessage[] {
-                new LocalizedMessage(0, "general.exception", null,
+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
+                                     "general.exception",
                                      new String[] {te.getMessage()})};
         }
 
         if (errors.length == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(stripped, errors);
         }
 
         fireFileFinished(stripped);
         return errors.length;
     }
 
     /**
      * Checks for a package.html file for all java files in parameter list.
      * @param aFiles the filenames of the java files to check
      * @return the number of errors found
      */
     private int checkPackageHtml(String[] aFiles)
     {
         if (!mConfig.isRequirePackageHtml()) {
             return 0;
         }
 
         int packageHtmlErrors = 0;
         final HashSet checkedPackages = new HashSet();
         for (int i = 0; i < aFiles.length; i++) {
             final File file = new File(aFiles[i]);
             final File packageDir = file.getParentFile();
             if (!checkedPackages.contains(packageDir)) {
                 final File packageDoc =
                     new File(packageDir, "package.html");
                 final String docFile = packageDoc.toString();
                 fireFileStarted(docFile);
                 if (!packageDoc.exists()) {
                     final LocalizedMessage error =
-                        new LocalizedMessage(0, "javadoc.packageHtml", null, null);
+                        new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
+                                             "javadoc.packageHtml", null);
                     fireErrors(docFile, new LocalizedMessage[]{error});
                     packageHtmlErrors++;
                 }
                 fireFileFinished(docFile);
                 checkedPackages.add(packageDir);
             }
         }
         return packageHtmlErrors;
     }
 
 
     /**
      * Loads the contents of a file in a String array.
      * @return the lines in the file
      * @param aFileName the name of the file to load
      * @throws IOException error occurred
      **/
     private String[] getLines(String aFileName)
         throws IOException
     {
         final LineNumberReader lnr =
             new LineNumberReader(new FileReader(aFileName));
         final ArrayList lines = new ArrayList();
         while (true) {
             final String l = lnr.readLine();
             if (l == null) {
                 break;
             }
             lines.add(l);
         }
 
         return (String[]) lines.toArray(new String[0]);
     }
 
     /** notify all listeners about the audit start */
     protected void fireAuditStarted()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.auditStarted(evt);
         }
     }
 
     /** notify all listeners about the audit end */
     protected void fireAuditFinished()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
