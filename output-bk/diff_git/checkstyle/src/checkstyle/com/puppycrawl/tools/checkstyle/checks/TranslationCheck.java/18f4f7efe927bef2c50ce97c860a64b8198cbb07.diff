diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
index aa48c9fa6..fb85aa22c 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
@@ -89,175 +89,178 @@ public class TranslationCheck
      * work as keys each mapped to a set of files.
      * @param aPropFiles the set of property files
      * @return a Map object which holds the arranged property file sets
      */
     private static Map arrangePropertyFiles(File[] aPropFiles)
     {
         final Map propFileMap = new HashMap();
 
         for (int i = 0; i < aPropFiles.length; i++) {
             final File f = aPropFiles[i];
             final String identifier = extractPropertyIdentifier(f);
 
             Set fileSet = (Set) propFileMap.get(identifier);
             if (fileSet == null) {
                 fileSet = new HashSet();
                 propFileMap.put(identifier, fileSet);
             }
             fileSet.add(f);
         }
         return propFileMap;
     }
 
 
     /**
      * Loads the keys of the specified property file into a set.
      * @param aFile the property file
      * @return a Set object which holds the loaded keys
      */
     private Set loadKeys(File aFile)
     {
         final Set keys = new HashSet();
         InputStream inStream = null;
 
         try {
             // Load file and properties.
             inStream = new FileInputStream(aFile);
             final Properties props = new Properties();
             props.load(inStream);
 
             // Gather the keys and put them into a set
             final Enumeration e = props.propertyNames();
             while (e.hasMoreElements()) {
                 keys.add(e.nextElement());
             }
         }
         catch (IOException e) {
             logIOException(e, aFile);
         }
         finally {
             try {
-                inStream.close();
+                if (inStream != null) {
+                    inStream.close();
+                }
             }
             catch (IOException e) {
                 logIOException(e, aFile);
             }
         }
         return keys;
     }
 
     /**
      * helper method to log an io exception.
      * @param aEx the exception that occured
      * @param aFile the file that could not be processed
      */
     private void logIOException(IOException aEx, File aFile)
     {
         String[] args = null;
         String key = "general.fileNotFound";
         if (!(aEx instanceof FileNotFoundException)) {
             args = new String[] {aEx.getMessage()};
             key = "general.exception";
         }
         final LocalizedMessage message =
             new LocalizedMessage(
                 0,
                 Defn.CHECKSTYLE_BUNDLE,
                 key,
                 args,
                 this.getClass());
         final LocalizedMessage[] messages = new LocalizedMessage[] {message};
         getMessageDispatcher().fireErrors(aFile.getPath(), messages);
         Utils.getExceptionLogger().debug("IOException occured.", aEx);
     }
 
 
     /**
      * Compares the key sets of the given property files (arranged in a map)
      * with the specified key set. All missing keys are reported.
      * @param aKeys the set of keys to compare with
      * @param aFileMap a Map from property files to their key sets
      */
     private void compareKeySets(Set aKeys, Map aFileMap)
     {
-        final Set fls = aFileMap.keySet();
+        final Set fls = aFileMap.entrySet();
 
         for (Iterator iter = fls.iterator(); iter.hasNext();) {
-            final File currentFile = (File) iter.next();
+            final Map.Entry entry = (Map.Entry) iter.next();
+            final File currentFile = (File) entry.getKey();
             final MessageDispatcher dispatcher = getMessageDispatcher();
             final String path = currentFile.getPath();
             dispatcher.fireFileStarted(path);
-            final Set currentKeys = (Set) aFileMap.get(currentFile);
+            final Set currentKeys = (Set) entry.getValue();
 
             // Clone the keys so that they are not lost
             final Set keysClone = new HashSet(aKeys);
             keysClone.removeAll(currentKeys);
 
             // Remaining elements in the key set are missing in the current file
             if (!keysClone.isEmpty()) {
                 for (Iterator it = keysClone.iterator(); it.hasNext();) {
                     final Object key = it.next();
                     log(0, "translation.missingKey", key);
                 }
             }
             fireErrors(path);
             dispatcher.fireFileFinished(path);
         }
     }
 
 
     /**
      * Tests whether the given property files (arranged by their prefixes
      * in a Map) contain the proper keys.
      *
      * Each group of files must have the same keys. If this is not the case
      * an error message is posted giving information which key misses in
      * which file.
      *
      * @param aPropFiles the property files organized as Map
      */
     private void checkPropertyFileSets(Map aPropFiles)
     {
-        final Set keySet = aPropFiles.keySet();
+        final Set entrySet = aPropFiles.entrySet();
 
-        for (Iterator iterator = keySet.iterator(); iterator.hasNext();) {
-            final String baseName = (String) iterator.next();
-            final Set files = (Set) aPropFiles.get(baseName);
+        for (Iterator iterator = entrySet.iterator(); iterator.hasNext();) {
+            final Map.Entry entry = (Map.Entry) iterator.next();
+            final Set files = (Set) entry.getValue();
 
             if (files.size() >= 2) {
                 // build a map from files to the keys they contain
                 final Set keys = new HashSet();
                 final Map fileMap = new HashMap();
 
                 for (Iterator iter = files.iterator(); iter.hasNext();) {
                     final File file = (File) iter.next();
                     final Set fileKeys = loadKeys(file);
                     keys.addAll(fileKeys);
                     fileMap.put(file, fileKeys);
                 }
 
                 // check the map for consistency
                 compareKeySets(keys, fileMap);
             }
         }
     }
 
 
     /**
      * This method searches for property files in the specified file array
      * and checks whether the key usage is consistent.
      *
      * Two property files which have the same prefix should use the same
      * keys. If this is not the case the missing keys are reported.
      *
      * @see com.puppycrawl.tools.checkstyle.api.FileSetCheck
      */
     public void process(File[] aFiles)
     {
         final File[] propertyFiles = filter(aFiles);
         final Map propFilesMap = arrangePropertyFiles(propertyFiles);
         checkPropertyFileSets(propFilesMap);
     }
 
 
 
 }
