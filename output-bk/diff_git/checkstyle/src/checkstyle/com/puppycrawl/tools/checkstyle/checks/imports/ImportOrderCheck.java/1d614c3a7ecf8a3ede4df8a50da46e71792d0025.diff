diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index 86eb0a689..2c36a78be 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -247,123 +247,121 @@ public class ImportOrderCheck
             doVisitToken(ident, isStatic, true);
             break;
 
         case BOTTOM:
             if (isStatic && !mLastImportStatic) {
                 mLastGroup = Integer.MIN_VALUE;
                 mLastImport = "";
             }
             // no break;
 
         case UNDER:
             // previous static but current is non-static
             doVisitToken(ident, isStatic, (mLastImportStatic && !isStatic));
             break;
 
         default:
             break;
         }
 
         mLastImportLine = aAST.findFirstToken(TokenTypes.SEMI).getLineNo();
         mLastImportStatic = isStatic;
         mBeforeFirstImport = false;
     }
 
     /**
      * Shares processing...
      *
      * @param aIdent the import to process.
      * @param aIsStatic whether the token is static or not.
      * @param aPrevious previous non-static but current is static (above), or
      *                  previous static but current is non-static (under).
      */
     private void doVisitToken(FullIdent aIdent, boolean aIsStatic,
             boolean aPrevious)
     {
         if (aIdent != null) {
             final String name = aIdent.getText();
             final int groupIdx = getGroupNumber(name);
             final int line = aIdent.getLineNo();
 
             if (groupIdx > mLastGroup) {
                 if (!mBeforeFirstImport && mSeparated) {
                     // This check should be made more robust to handle
                     // comments and imports that span more than one line.
                     if ((line - mLastImportLine) < 2) {
                         log(line, "import.separation", name);
                     }
                 }
             }
             else if (groupIdx == mLastGroup) {
-                doVisitTokenInSameGroup(aIdent, aIsStatic, aPrevious, name,
-                        line);
+                doVisitTokenInSameGroup(aIsStatic, aPrevious, name, line);
             }
             else {
                 log(line, "import.ordering", name);
             }
 
             mLastGroup = groupIdx;
             mLastImport = name;
         }
     }
 
     /**
      * Shares processing...
      *
-     * @param aIdent the import to process.
      * @param aIsStatic whether the token is static or not.
      * @param aPrevious previous non-static but current is static (above), or
      *    previous static but current is non-static (under).
      * @param aName the name of the current import.
      * @param aLine the line of the current import.
      */
-    private void doVisitTokenInSameGroup(FullIdent aIdent, boolean aIsStatic,
+    private void doVisitTokenInSameGroup(boolean aIsStatic,
             boolean aPrevious, String aName, int aLine)
     {
         if (!mOrdered) {
             return;
         }
 
         if (getAbstractOption().equals(ImportOrderOption.INFLOW)) {
             // out of lexicographic order
             if (compare(mLastImport, aName, mCaseSensitive) > 0) {
                 log(aLine, "import.ordering", aName);
             }
         }
         else {
             final boolean shouldFireError =
                 // current and previous static or current and
                 // previous non-static
                 (!(mLastImportStatic ^ aIsStatic)
                 &&
                 // and out of lexicographic order
                 (compare(mLastImport, aName, mCaseSensitive) > 0))
                 ||
                 // previous non-static but current is static (above)
                 // or
                 // previous static but current is non-static (under)
                 aPrevious;
 
             if (shouldFireError) {
                 log(aLine, "import.ordering", aName);
             }
         }
     }
 
     /**
      * Finds out what group the specified import belongs to.
      *
      * @param aName the import name to find.
      * @return group number for given import name.
      */
     private int getGroupNumber(String aName)
     {
         int bestIndex = mGroups.length;
         int bestLength = -1;
         int bestPos = 0;
 
         // find out what group this belongs in
         // loop over mGroups and get index
         for (int i = 0; i < mGroups.length; i++) {
             final Matcher matcher = mGroups[i].matcher(aName);
             while (matcher.find()) {
                 final int length = matcher.end() - matcher.start();
