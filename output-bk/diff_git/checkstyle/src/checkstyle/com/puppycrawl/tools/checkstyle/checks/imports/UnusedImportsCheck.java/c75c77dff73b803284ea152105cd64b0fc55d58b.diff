diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
index ceea684a4..e9ab2bd7a 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
@@ -50,161 +50,160 @@ import java.util.regex.Pattern;
  * @author Oliver Burn
  */
 public class UnusedImportsCheck extends Check
 {
     /** flag to indicate when time to start collecting references */
     private boolean mCollect;
     /** flag whether to process Javadoc comments. */
     private boolean mProcessJavadoc;
 
     /** set of the imports */
     private final Set<FullIdent> mImports = Sets.newHashSet();
 
     /** set of references - possibly to imports or other things */
     private final Set<String> mReferenced = Sets.newHashSet();
 
     /** Default constructor. */
     public UnusedImportsCheck()
     {
     }
 
     public void setProcessJavadoc(boolean aValue)
     {
         mProcessJavadoc = aValue;
     }
 
     @Override
     public void beginTree(DetailAST aRootAST)
     {
         mCollect = false;
         mImports.clear();
         mReferenced.clear();
     }
 
     @Override
     public void finishTree(DetailAST aRootAST)
     {
         // loop over all the imports to see if referenced.
         for (final FullIdent imp : mImports) {
             if (!mReferenced.contains(Utils.baseClassname(imp.getText()))) {
                 log(imp.getLineNo(),
                     imp.getColumnNo(),
                     "import.unused", imp.getText());
             }
         }
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
+            TokenTypes.IDENT,
+            TokenTypes.IMPORT,
+            TokenTypes.STATIC_IMPORT,
+            // Definitions that may contain Javadoc...
             TokenTypes.PACKAGE_DEF,
             TokenTypes.ANNOTATION_DEF,
-            TokenTypes.CLASS_DEF,
+            TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_DEF,
-            TokenTypes.IDENT,
-            TokenTypes.IMPORT,
+            TokenTypes.ENUM_CONSTANT_DEF,
+            TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
-            TokenTypes.STATIC_IMPORT,
+            TokenTypes.METHOD_DEF,
+            TokenTypes.CTOR_DEF,
+            TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.IDENT) {
             if (mCollect) {
                 processIdent(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
             processImport(aAST);
         }
         else if (aAST.getType() == TokenTypes.STATIC_IMPORT) {
             processStaticImport(aAST);
         }
-        else if ((aAST.getType() == TokenTypes.CLASS_DEF)
-            || (aAST.getType() == TokenTypes.INTERFACE_DEF)
-            || (aAST.getType() == TokenTypes.ENUM_DEF)
-            || (aAST.getType() == TokenTypes.ANNOTATION_DEF)
-            || (aAST.getType() == TokenTypes.PACKAGE_DEF))
-        {
+        else {
             mCollect = true;
+            if (mProcessJavadoc) {
+                processJavadoc(aAST);
+            }
         }
     }
 
     /**
      * Collects references made by IDENT.
      * @param aAST the IDENT node to process
      */
     private void processIdent(DetailAST aAST)
     {
         final DetailAST parent = aAST.getParent();
         final int parentType = parent.getType();
         if (((parentType != TokenTypes.DOT)
             && (parentType != TokenTypes.METHOD_DEF))
             || ((parentType == TokenTypes.DOT)
                 && (aAST.getNextSibling() != null)))
         {
             mReferenced.add(aAST.getText());
         }
-        // TODO Need to filter how often this is run to improve speed, and
-        // also turn off by default.
-        if (mProcessJavadoc) {
-            processJavadoc(aAST);
-        }
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(aAST);
         if ((name != null) && !name.getText().endsWith(".*")) {
             mImports.add(name);
         }
     }
 
     /**
      * Collects the details of static imports.
      * @param aAST node containing the static import details
      */
     private void processStaticImport(DetailAST aAST)
     {
         final FullIdent name =
             FullIdent.createFullIdent(
                 aAST.getFirstChild().getNextSibling());
         if ((name != null) && !name.getText().endsWith(".*")) {
             mImports.add(name);
         }
     }
 
     /**
      * Collects references made in JavaDoc comments.
      * @param aAST node to inspect for JavaDoc
      */
     private void processJavadoc(DetailAST aAST)
     {
         final FileContents contents = getFileContents();
         final int lineNo = aAST.getLineNo();
         final TextBlock cmt = contents.getJavadocBefore(lineNo);
         if (cmt != null) {
             final JavadocTags tags = JavadocUtils.getJavadocTags(cmt,
                     JavadocUtils.JavadocTagType.ALL);
             for (final JavadocTag tag : tags.getValidTags()) {
                 if (tag.canReferenceImports()) {
                     String identifier = tag.getArg1();
                     // Trim off method or link text
                     final Pattern pattern =
                         Utils.getPattern("(.+?)(?:\\s+|#|\\$).*");
                     final Matcher matcher = pattern.matcher(identifier);
                     if (matcher.find()) {
                         identifier = matcher.group(1);
                     }
