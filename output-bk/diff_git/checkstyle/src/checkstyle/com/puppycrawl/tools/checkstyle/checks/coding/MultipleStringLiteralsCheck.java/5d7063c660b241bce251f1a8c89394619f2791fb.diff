diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
index ba3d2ed00..42b70131b 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
@@ -17,122 +17,129 @@
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Set;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Checks for multiple occurrences of the same string literal within a
  * single file.
  *
  * @author Daniel Grenner
  */
 public class MultipleStringLiteralsCheck extends Check
 {
     /**
      * The found strings and their positions.
      * <String, ArrayList>, with the ArrayList containing StringInfo objects.
      */
     private HashMap mStringMap = new HashMap();
     /**
      * The allowed number of string duplicates in a file before an error is
      * generated.
      */
     private int mAllowedDuplicates = 1;
 
     /**
      * Sets the maximum allowed duplicates of a string.
      * @param aAllowedDuplicates The maximum number of duplicates.
      */
     public void setAllowedDuplicates(int aAllowedDuplicates)
     {
         mAllowedDuplicates = aAllowedDuplicates;
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
-        String currentString = aAST.getText();
-        ArrayList i = (ArrayList) mStringMap.get(currentString);
-        if (i == null) {
-            i = new ArrayList();
-            mStringMap.put(currentString, i);
+        final String currentString = aAST.getText();
+        ArrayList hitList = (ArrayList) mStringMap.get(currentString);
+        if (hitList == null) {
+            hitList = new ArrayList();
+            mStringMap.put(currentString, hitList);
         }
         int line = aAST.getLineNo();
         int col = aAST.getColumnNo();
-        i.add(new StringInfo(line, col));
+        hitList.add(new StringInfo(line, col));
+    }
+
+    /** {@inheritDoc} */
+    public void beginTree(DetailAST aRootAST)
+    {
+        super.beginTree(aRootAST);
+        mStringMap.clear();
     }
 
     /** {@inheritDoc} */
     public void finishTree(DetailAST aRootAST)
     {
-        Set keys = mStringMap.keySet();
-        Iterator keyIterator = keys.iterator();
+        final Set keys = mStringMap.keySet();
+        final Iterator keyIterator = keys.iterator();
         while (keyIterator.hasNext()) {
-            String key = (String) keyIterator.next();
-            ArrayList hits = (ArrayList) mStringMap.get(key);
+            final String key = (String) keyIterator.next();
+            final ArrayList hits = (ArrayList) mStringMap.get(key);
             if (hits.size() > mAllowedDuplicates) {
-                StringInfo firstFinding = (StringInfo) hits.get(0);
-                int line = firstFinding.getLine();
+                final StringInfo firstFinding = (StringInfo) hits.get(0);
+                final int line = firstFinding.getLine();
                 int col = firstFinding.getCol();
                 Object[] args = new Object[]{key, new Integer(hits.size())};
                 log(line, col, "multiple.string.literal", args);
             }
         }
     }
 
     /**
      * This class contains information about where a string was found.
      */
     private static final class StringInfo
     {
         /**
          * Line of finding
          */
-        private int mLine;
+        private final int mLine;
         /**
          * Column of finding
          */
-        private int mCol;
+        private final int mCol;
         /**
          * Creates information about a string position.
          * @param aLine int
          * @param aCol int
          */
         private StringInfo(int aLine, int aCol)
         {
             mLine = aLine;
             mCol = aCol;
         }
 
         /**
          * The line where a string was found.
          * @return int Line of the string.
          */
         private int getLine()
         {
             return mLine;
         }
 
         /**
          * The columen where a string was found.
          * @return int Column of the string.
          */
         private int getCol()
         {
             return mCol;
         }
     }
 }
