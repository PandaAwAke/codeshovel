diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
index ab53656ce..c3684fe52 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
@@ -40,160 +40,148 @@ import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 
 /**
  * An implementation of a ANT task for calling checkstyle. See the documentation
  * of the task for usage.
  * @author Oliver Burn
  */
 public class CheckStyleTask
     extends Task
 {
     /** poor man's enum for an xml formatter */
     private static final String E_XML = "xml";
     /** poor man's enum for an plain formatter */
     private static final String E_PLAIN = "plain";
 
     /** class path to locate class files */
     private Path mClasspath;
 
     /** name of file to check */
     private String mFileName;
 
     /** config file containing configuration */
     private String mConfigLocation;
 
     /** contains package names */
     private File mPackageNamesFile = null;
 
     /** whether to fail build on violations */
     private boolean mFailOnViolation = true;
 
     /** property to set on violations */
     private String mFailureProperty = null;
 
     /** contains the filesets to process */
     private final List mFileSets = new ArrayList();
 
     /** contains the formatters to log to */
     private final List mFormatters = new ArrayList();
 
     /** contains the Properties to override */
     private final List mOverrideProps = new ArrayList();
 
     /** the name of the properties file */
     private File mPropertiesFile;
 
-    /** custom listeners to add to Checker */
-    private final List mCustomListeners = new ArrayList();
-
     ////////////////////////////////////////////////////////////////////////////
     // Setters for ANT specific attributes
     ////////////////////////////////////////////////////////////////////////////
 
     /**
      * Tells this task to set the named property to "true" when there
      * is a violation.
      * @param aPropertyName the name of the property to set
      *                      in the event of an failure.
      */
     public void setFailureProperty(String aPropertyName)
     {
         mFailureProperty = aPropertyName;
     }
 
     /** @param aFail whether to fail if a violation is found */
     public void setFailOnViolation(boolean aFail)
     {
         mFailOnViolation = aFail;
     }
 
     /**
      * Adds a set of files (nested fileset attribute).
      * @param aFS the file set to add
      */
     public void addFileset(FileSet aFS)
     {
         mFileSets.add(aFS);
     }
 
     /**
      * Add a formatter.
      * @param aFormatter the formatter to add for logging.
      */
     public void addFormatter(Formatter aFormatter)
     {
         mFormatters.add(aFormatter);
     }
 
     /**
      * Add an override property.
      * @param aProperty the property to add
      */
     public void addProperty(Property aProperty)
     {
         mOverrideProps.add(aProperty);
     }
 
-    /**
-     * Add a custom listener.
-     * @param aListener the listener to add
-     */
-    public void addListener(Listener aListener)
-    {
-        mCustomListeners.add(aListener);
-    }
-
     /**
      * Set the class path.
      * @param aClasspath the path to locate classes
      */
     public void setClasspath(Path aClasspath)
     {
         mClasspath = aClasspath;
     }
 
     /** @return a created path for locating classes */
     public Path createClasspath()
     {
         if (mClasspath == null) {
             mClasspath = new Path(getProject());
         }
         return mClasspath.createPath();
     }
 
     /** @param aFile the file to be checked */
     public void setFile(File aFile)
     {
         mFileName = aFile.getAbsolutePath();
     }
 
     /** @param aFile the configuration file to use */
     public void setConfig(File aFile)
     {
         setConfigLocation(aFile.getAbsolutePath());
     }
 
     /** @param aURL the URL of the configuration to use */
     public void setConfigURL(URL aURL)
     {
         setConfigLocation(aURL.toExternalForm());
     }
 
     /**
      * Sets the location of the configuration.
      * @param aLocation the location, which is either a
      */
     private void setConfigLocation(String aLocation)
     {
         if (mConfigLocation != null) {
             throw new BuildException(
                 "Attributes 'config' and 'configURL' "
                 + "must not be set at the same time");
         }
         mConfigLocation = aLocation;
     }
 
@@ -333,151 +321,118 @@ public class CheckStyleTask
             catch (IOException e) {
                 throw new BuildException(
                     "Error loading Properties file '" + mPropertiesFile + "'",
                     e, getLocation());
             }
             finally {
                 try {
                     if (inStream != null) {
                         inStream.close();
                     }
                 }
                 catch (IOException e) {
                     throw new BuildException(
                         "Error closing Properties file '"
                         + mPropertiesFile + "'",
                         e, getLocation());
                 }
             }
         }
 
         // override with Ant properties like ${basedir}
         Hashtable antProps = this.getProject().getProperties();
         for (Iterator it = antProps.keySet().iterator(); it.hasNext();) {
             final String key = (String) it.next();
             final String value = String.valueOf(antProps.get(key));
             retVal.put(key, value);
         }
 
         // override with properties specified in subelements
         for (Iterator it = mOverrideProps.iterator(); it.hasNext();) {
             final Property p = (Property) it.next();
             retVal.put(p.getKey(), p.getValue());
         }
 
         return retVal;
     }
 
     /**
      * Return the list of listeners set in this task.
      * @return the list of listeners.
      * @throws ClassNotFoundException if an error occurs
      * @throws InstantiationException if an error occurs
      * @throws IllegalAccessException if an error occurs
      * @throws IOException if an error occurs
      */
     protected AuditListener[] getListeners()
         throws ClassNotFoundException, InstantiationException,
         IllegalAccessException, IOException
     {
         final int formatterCount = Math.max(1, mFormatters.size());
-        final int listenerCount = mCustomListeners.size();
 
         final AuditListener[] listeners =
-            new AuditListener[formatterCount + listenerCount];
+            new AuditListener[formatterCount];
 
         // formatters
         if (mFormatters.size() == 0) {
             OutputStream debug = new LogOutputStream(this, Project.MSG_DEBUG);
             OutputStream err = new LogOutputStream(this, Project.MSG_ERR);
             listeners[0] = new DefaultLogger(debug, true, err, true);
         }
         else {
             for (int i = 0; i < formatterCount; i++) {
                 final Formatter f = (Formatter) mFormatters.get(i);
                 listeners[i] = f.createListener(this);
             }
         }
-        //custom listeners
-        for (int i = 0; i < listenerCount; i++) {
-            final Listener listener = (Listener) mCustomListeners.get(i);
-            listeners[formatterCount + i] = createCustomListener(listener);
-        }
         return listeners;
     }
-    /**
-     * Creates an audit listener for a custom listener.
-     * @param aListener custom listener
-     * @return an audit listener
-     */
-    private AuditListener createCustomListener(Listener aListener)
-    {
-        final String classname = aListener.getClassname();
-
-        // use the task classpath property
-        final ClassLoader loader =
-            new AntClassLoader(getClass().getClassLoader(), getProject(),
-                 mClasspath, true);
-
-        AuditListener listener = null;
-        try {
-            final Class listenerClass =
-                Class.forName(classname, true, loader);
-            listener =
-                (AuditListener) listenerClass.newInstance();
-        }
-        catch (Exception e) {
-            throw new BuildException("Unable to create listener '"
-                + classname + "': " + e);
-        }
-        return listener;
-    }
 
     /**
      * returns the list of files (full path name) to process.
      * @return the list of files included via the filesets.
      */
     protected File[] scanFileSets()
     {
         final ArrayList list = new ArrayList();
         if (mFileName != null) {
             // oops we've got an additional one to process, don't
             // forget it. No sweat, it's fully resolved via the setter.
             log("Adding standalone file for audit", Project.MSG_VERBOSE);
             list.add(new File(mFileName));
         }
         for (int i = 0; i < mFileSets.size(); i++) {
             final FileSet fs = (FileSet) mFileSets.get(i);
             final DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             ds.scan();
 
             final String[] names = ds.getIncludedFiles();
             log(i + ") Adding " + names.length + " files from directory "
                 + ds.getBasedir(),
                 Project.MSG_VERBOSE);
 
             for (int j = 0; j < names.length; j++) {
                 final String pathname =
                     ds.getBasedir() + File.separator + names[j];
                 list.add(new File(pathname));
             }
         }
 
         return (File[]) list.toArray(new File[0]);
     }
 
     /**
      * Poor mans enumeration for the formatter types.
      * @author Oliver Burn
      */
     public static class FormatterType
         extends EnumeratedAttribute
     {
         /** my possible values */
         private static final String[] VALUES = {E_XML, E_PLAIN};
 
         /** @see EnumeratedAttribute */
         public String[] getValues()
         {
             return VALUES;
         }
     }
