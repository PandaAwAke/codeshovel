diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
index adcc3d290..8899dab32 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
@@ -79,152 +79,212 @@ public class LeftCurlyCheck
     public LeftCurlyCheck()
     {
         super(LeftCurlyOption.EOL, LeftCurlyOption.class);
     }
 
     /**
      * Sets the maximum line length used in calculating the placement of the
      * left curly brace.
      * @param aMaxLineLength the max allowed line length
      */
     public void setMaxLineLength(int aMaxLineLength)
     {
         mMaxLineLength = aMaxLineLength;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             // TODO: need to handle....
             //TokenTypes.STATIC_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST startToken;
         final DetailAST brace;
 
         switch (aAST.getType()) {
         case TokenTypes.CTOR_DEF :
         case TokenTypes.METHOD_DEF :
-            startToken = aAST;
+            // Orig
+            //startToken = aAST;
+            // New
+            startToken = skipAnnotationOnlyLines(aAST);
+            // End
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.INTERFACE_DEF :
         case TokenTypes.CLASS_DEF :
         case TokenTypes.ANNOTATION_DEF :
         case TokenTypes.ENUM_DEF :
         case TokenTypes.ENUM_CONSTANT_DEF :
-            startToken = aAST.getFirstChild();
+            startToken = (DetailAST) skipAnnotationOnlyLines(aAST);
             final DetailAST objBlock = aAST.findFirstToken(TokenTypes.OBJBLOCK);
             brace = (objBlock == null)
                 ? null
-                : objBlock.getFirstChild();
+                : (DetailAST) objBlock.getFirstChild();
             break;
 
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_SYNCHRONIZED:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_FINALLY:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_IF :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.LITERAL_ELSE :
             startToken = aAST;
-            final DetailAST candidate = aAST.getFirstChild();
+            final DetailAST candidate = (DetailAST) aAST.getFirstChild();
             brace =
                 (candidate.getType() == TokenTypes.SLIST)
                 ? candidate
                 : null; // silently ignore
             break;
 
         case TokenTypes.LITERAL_SWITCH :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.LCURLY);
             break;
 
         default :
             startToken = null;
             brace = null;
         }
 
         if ((brace != null) && (startToken != null)) {
             verifyBrace(brace, startToken);
         }
     }
 
+    /**
+     * Skip lines that only contain <code>TokenTypes.ANNOTATION</code>s.
+     * If the received <code>DetailAST</code>
+     * has annotations within its modifiers then first token on the line
+     * of the first token afer all annotations is return. This might be
+     * an annotation.
+     * Otherwise, the received <code>DetailAST</code> is returned.
+     * @param aAST <code>DetailAST</code>.
+     * @return <code>DetailAST</code>.
+     */
+    private DetailAST skipAnnotationOnlyLines(DetailAST aAST)
+    {
+        final DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);
+        if (modifiers == null) {
+            return aAST;
+        }
+        DetailAST lastAnnot = findLastAnnotation(modifiers);
+        if (lastAnnot == null) {
+            // There are no annotations.
+            return aAST;
+        }
+        final DetailAST tokenAfterLast = lastAnnot.getNextSibling() != null
+                                       ? lastAnnot.getNextSibling()
+                                       : modifiers.getNextSibling();
+        if (tokenAfterLast.getLineNo() > lastAnnot.getLineNo()) {
+            return tokenAfterLast;
+        }
+        else {
+            final int lastAnnotLineNumber = lastAnnot.getLineNo();
+            while (lastAnnot.getPreviousSibling() != null
+                   && (lastAnnot.getPreviousSibling().getLineNo()
+                        == lastAnnotLineNumber))
+            {
+                lastAnnot = lastAnnot.getPreviousSibling();
+            }
+            return lastAnnot;
+        }
+    }
+
+    /**
+     * Find the last token of type <code>TokenTypes.ANNOTATION</code>
+     * under the given set of modifiers.
+     * @param aModifiers <code>DetailAST</code>.
+     * @return <code>DetailAST</code> or null if there are no annotations.
+     */
+    private DetailAST findLastAnnotation(DetailAST aModifiers)
+    {
+        DetailAST aAnnot = aModifiers.findFirstToken(TokenTypes.ANNOTATION);
+        while (aAnnot != null && aAnnot.getNextSibling() != null
+               && aAnnot.getNextSibling().getType() == TokenTypes.ANNOTATION)
+        {
+            aAnnot = aAnnot.getNextSibling();
+        }
+        return aAnnot;
+    }
+
     /**
      * Verifies that a specified left curly brace is placed correctly
      * according to policy.
      * @param aBrace token for left curly brace
      * @param aStartToken token for start of expression
      */
     private void verifyBrace(final DetailAST aBrace,
                              final DetailAST aStartToken)
     {
         final String braceLine = getLines()[aBrace.getLineNo() - 1];
 
         // calculate the previous line length without trailing whitespace. Need
         // to handle the case where there is no previous line, cause the line
         // being check is the first line in the file.
         final int prevLineLen = (aBrace.getLineNo() == 1)
             ? mMaxLineLength
             : Utils.lengthMinusTrailingWhitespace(
                 getLines()[aBrace.getLineNo() - 2]);
 
         // Check for being told to ignore, or have '{}' which is a special case
         if ((braceLine.length() > (aBrace.getColumnNo() + 1))
             && (braceLine.charAt(aBrace.getColumnNo() + 1) == '}'))
         {
             ; // ignore
         }
         else if (getAbstractOption() == LeftCurlyOption.NL) {
             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {
                 log(aBrace.getLineNo(), aBrace.getColumnNo(),
                     "line.new", "{");
             }
         }
         else if (getAbstractOption() == LeftCurlyOption.EOL) {
             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)
                 && ((prevLineLen + 2) <= mMaxLineLength))
             {
                 log(aBrace.getLineNo(), aBrace.getColumnNo(),
                     "line.previous", "{");
             }
         }
         else if (getAbstractOption() == LeftCurlyOption.NLOW) {
             if (aStartToken.getLineNo() == aBrace.getLineNo()) {
                 ; // all ok as on the same line
             }
             else if ((aStartToken.getLineNo() + 1) == aBrace.getLineNo()) {
                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {
                     log(aBrace.getLineNo(), aBrace.getColumnNo(),
                         "line.new", "{");
                 }
                 else if ((prevLineLen + 2) <= mMaxLineLength) {
                     log(aBrace.getLineNo(), aBrace.getColumnNo(),
