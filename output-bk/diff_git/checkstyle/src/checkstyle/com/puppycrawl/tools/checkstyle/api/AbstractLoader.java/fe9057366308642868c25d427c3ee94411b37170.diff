diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/api/AbstractLoader.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/api/AbstractLoader.java
index 3d462d6f0..608f1fd44 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/api/AbstractLoader.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/api/AbstractLoader.java
@@ -58,92 +58,92 @@ public abstract class AbstractLoader
      * @throws SAXException if an error occurs
      * @throws ParserConfigurationException if an error occurs
      */
     protected AbstractLoader(String aPublicId, String aDtdResourceName)
         throws SAXException, ParserConfigurationException
     {
         this(new HashMap<String, String>(1));
         mPublicIdToResourceNameMap.put(aPublicId, aDtdResourceName);
     }
 
     /**
      * Creates a new instance.
      * @param aPublicIdToResourceNameMap maps public IDs to DTD resource names
      * @throws SAXException if an error occurs
      * @throws ParserConfigurationException if an error occurs
      */
     protected AbstractLoader(Map<String, String> aPublicIdToResourceNameMap)
         throws SAXException, ParserConfigurationException
     {
         mPublicIdToResourceNameMap = new HashMap<String, String>(
                 aPublicIdToResourceNameMap);
         final SAXParserFactory factory = SAXParserFactory.newInstance();
         factory.setValidating(true);
         factory.setNamespaceAware(true);
         mParser = factory.newSAXParser().getXMLReader();
         mParser.setContentHandler(this);
         mParser.setEntityResolver(this);
         mParser.setErrorHandler(this);
     }
 
     /**
      * Parses the specified input source.
      * @param aInputSource the input source to parse.
      * @throws IOException if an error occurs
      * @throws SAXException in an error occurs
      */
     public void parseInputSource(InputSource aInputSource)
         throws IOException, SAXException
     {
         mParser.parse(aInputSource);
     }
 
     @Override
     public InputSource resolveEntity(String aPublicId, String aSystemId)
         throws SAXException
     {
         if (mPublicIdToResourceNameMap.keySet().contains(aPublicId)) {
             final String dtdResourceName =
                     mPublicIdToResourceNameMap.get(aPublicId);
             final ClassLoader loader =
-                Thread.currentThread().getContextClassLoader();
+                this.getClass().getClassLoader();
             final InputStream dtdIS =
                 loader.getResourceAsStream(dtdResourceName);
             if (dtdIS == null) {
                 throw new SAXException(
                     "Unable to load internal dtd " + dtdResourceName);
             }
             return new InputSource(dtdIS);
         }
         // This is a hack to workaround problem with SAX
         // DefaultHeader.resolveEntity():
         // sometimes it throws SAX- and IO- exceptions
         // sometime SAX only :(
         try {
             if (false) {
                 throw new IOException("");
             }
             return super.resolveEntity(aPublicId, aSystemId);
         }
         catch (final IOException e) {
             throw new SAXException("" + e, e);
         }
     }
 
     @Override
     public void warning(SAXParseException aEx) throws SAXException
     {
         throw aEx;
     }
 
     @Override
     public void error(SAXParseException aEx) throws SAXException
     {
         throw aEx;
     }
 
     @Override
     public void fatalError(SAXParseException aEx) throws SAXException
     {
         throw aEx;
     }
 }
