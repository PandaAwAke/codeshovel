diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
index d5de3efcd..3304a0b95 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
@@ -76,87 +76,87 @@ class PkgControl
     }
 
     /**
      * @return the full package name represented by the node.
      */
     String getFullPackage()
     {
         return mFullPackage;
     }
 
     /**
      * Search down the tree to locate the finest match for a supplied package.
      * @param aForPkg the package to search for.
      * @return the finest match, or null if no match at all.
      */
     PkgControl locateFinest(final String aForPkg)
     {
         // Check if we are a match.
         // This algormithm should be improved to check for a trailing "."
         // or nothing following.
         if (!aForPkg.startsWith(getFullPackage())) {
             return null;
         }
 
         // Check if any of the children match.
         final Iterator it = mChildren.iterator();
         while (it.hasNext()) {
             final PkgControl pc = (PkgControl) it.next();
             final PkgControl match = pc.locateFinest(aForPkg);
             if (match != null) {
                 return match;
             }
         }
 
         // No match so I am the best there is.
         return this;
     }
 
     /**
      * Returns whether a package is allowed to be used. The algorithm checks
      * with the current node for a result, and if none is found then calls
      * its parent looking for a match. This will recurse looking for match.
      * If there is no clear result then {@link AccessResult#UNKNOWN} is
      * returned.
      * @param aForImport the package to check on.
      * @param aInPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
     AccessResult checkAccess(final String aForImport, final String aInPkg)
     {
-        AccessResult retVal = localCheckAccess(aForImport, aInPkg);
+        final AccessResult retVal = localCheckAccess(aForImport, aInPkg);
         if (retVal != AccessResult.UNKNOWN) {
             return retVal;
         }
         else if (mParent == null) {
             // we are the top, so default to not allowed.
             return AccessResult.DISALLOWED;
         }
 
         return mParent.checkAccess(aForImport, aInPkg);
     }
 
     /**
      * Checks whether any of the guards for this node control access to
      * a specified package.
      * @param aForImport the package to check.
      * @param aInPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
     private AccessResult localCheckAccess(final String aForImport,
         final String aInPkg)
     {
         final Iterator it = mGuards.iterator();
         while (it.hasNext()) {
             final Guard g = (Guard) it.next();
             // Check if a Guard is only meant to be applied locally.
             if (g.isLocalOnly() && !mFullPackage.equals(aInPkg)) {
                 continue;
             }
             final AccessResult result = g.verifyImport(aForImport);
             if (result != AccessResult.UNKNOWN) {
                 return result;
             }
         }
         return AccessResult.UNKNOWN;
     }
 }
