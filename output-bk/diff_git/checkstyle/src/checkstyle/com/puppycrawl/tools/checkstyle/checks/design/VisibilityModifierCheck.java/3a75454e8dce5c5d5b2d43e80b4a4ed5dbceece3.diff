diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index acd6ce940..5a348a3be 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -84,102 +84,102 @@ public class VisibilityModifierCheck
         mProtectedAllowed = aProtectedAllowed;
     }
 
     /** @return whether package visible members are allowed */
     public boolean isPackageAllowed()
     {
         return mPackageAllowed;
     }
 
     /**
      * Set whether package visible members are allowed
      * @param aPackageAllowed whether package visible members are allowed
      */
     public void setPackageAllowed(boolean aPackageAllowed)
     {
         mPackageAllowed = aPackageAllowed;
     }
 
     /**
      * Set the pattern for public members to ignore.
      * @param aPattern pattern for public members to ignore.
      */
     public void setPublicMemberPattern(String aPattern)
     {
         try {
             mPublicMemberRE = Utils.getRE(aPattern);
             mPublicMemberPattern = aPattern;
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aPattern, e);
         }
     }
 
     /**
      * @return the regexp for public members to ignore.
      */
     private RE getPublicMemberRegexp()
     {
         return mPublicMemberRE;
     }
 
     /** @see Check */
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
     /** @see Check */
     public void visitToken(DetailAST aAST)
     {
-        if (aAST.getType() != TokenTypes.VARIABLE_DEF
-                || aAST.getParent().getType() != TokenTypes.OBJBLOCK)
+        if ((aAST.getType() != TokenTypes.VARIABLE_DEF)
+            || (aAST.getParent().getType() != TokenTypes.OBJBLOCK))
         {
             return;
         }
 
         final DetailAST varNameAST = getVarNameAST(aAST);
         String varName = varNameAST.getText();
         boolean inInterfaceBlock = inInterfaceBlock(aAST);
         final Set mods = getModifiers(aAST);
         final String declaredScope = getVisibilityScope(mods);
         final String variableScope =
              inInterfaceBlock ? "public" : declaredScope;
 
         if (!("private".equals(variableScope)
                 || inInterfaceBlock // implicitly static and final
                 || mods.contains("static") && mods.contains("final")
                 || "package".equals(variableScope) && isPackageAllowed()
                 || "protected".equals(variableScope) && isProtectedAllowed()
                 || "public".equals(variableScope)
                    && getPublicMemberRegexp().match(varName)))
         {
             log(varNameAST.getLineNo(), varNameAST.getColumnNo(),
                     "variable.notPrivate", varName);
         }
     }
 
     /**
      * Returns the variable name in a VARIABLE_DEF AST.
      * @param aVariableDefAST an AST where type == VARIABLE_DEF AST.
      * @return the variable name in aVariableDefAST
      */
     private DetailAST getVarNameAST(DetailAST aVariableDefAST)
     {
         AST ast = aVariableDefAST.getFirstChild();
         while (ast != null) {
             AST nextSibling = ast.getNextSibling();
             if (ast.getType() == TokenTypes.TYPE) {
                 return (DetailAST) nextSibling;
             }
             ast = nextSibling;
         }
         return null;
     }
 
     /**
      * Returns whether an AST is in an interface block.
      * @param aAST the AST to check for
      * @return true iff aAST is in an interface def with no class def in between
      */
     private boolean inInterfaceBlock(DetailAST aAST)
     {
