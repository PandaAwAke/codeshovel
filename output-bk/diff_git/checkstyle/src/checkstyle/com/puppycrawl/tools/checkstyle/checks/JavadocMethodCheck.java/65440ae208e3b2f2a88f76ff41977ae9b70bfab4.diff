diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index 9bf761143..eb670e8b3 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -33,126 +33,134 @@ import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
 import org.apache.regexp.RE;
 
 /**
  * <p>
  * Checks the Javadoc of a method or constructor.
  * By default, does not check for unused throws.
  * To allow documented <code>java.lang.RuntimeException</code>s
  * that are not declared, set property allowUndeclaredRTE to true.
  * The scope to verify is specified using the {@link Scope} class and
  * defaults to {@link Scope#PRIVATE}. To verify another scope,
  * set property scope to one of the {@link Scope} constants.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="JavadocMethod"/&gt;
  * </pre>
  * <p> An example of how to configure the check to check to allow
  * documentation of undeclared RuntimeExceptions
  * and for the {@link Scope#PUBLIC} scope is:
  *</p>
  * <pre>
  * &lt;module name="JavadocMethod"&gt;
  *    &lt;property name="scope" value="public"/&gt;
  *    &lt;property name="allowUndeclaredRTE" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @author Rick Giles
  * @version 1.0
  */
 public class JavadocMethodCheck
     extends AbstractImportCheck
 {
 
        // {{{ Data declarations
     /** the pattern to match Javadoc tags that take an argument **/
     private static final String MATCH_JAVADOC_ARG_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s+\\S";
     /** compiled regexp to match Javadoc tags that take an argument **/
     private static final RE MATCH_JAVADOC_ARG =
         Utils.createRE(MATCH_JAVADOC_ARG_PAT);
 
    /**
     * the pattern to match the first line of a multi-line Javadoc
-    * tag that takes an argument. Javadoc with no arguments isn't
-    * allowed to go over multiple lines.
+    * tag that takes an argument.
     **/
-    private static final String MATCH_JAVADOC_MULTILINE_START_PAT =
+    private static final String MATCH_JAVADOC_ARG_MULTILINE_START_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s*$";
     /** compiled regexp to match first part of multilineJavadoc tags **/
-    private static final RE MATCH_JAVADOC_MULTILINE_START =
-        Utils.createRE(MATCH_JAVADOC_MULTILINE_START_PAT);
+    private static final RE MATCH_JAVADOC_ARG_MULTILINE_START =
+        Utils.createRE(MATCH_JAVADOC_ARG_MULTILINE_START_PAT);
 
     /** the pattern that looks for a continuation of the comment **/
     private static final String MATCH_JAVADOC_MULTILINE_CONT_PAT =
         "(\\*/|@|[^\\s\\*])";
     /** compiled regexp to look for a continuation of the comment **/
     private static final RE MATCH_JAVADOC_MULTILINE_CONT =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_CONT_PAT);
     /** Multiline finished at end of comment **/
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc **/
     private static final String NEXT_TAG = "@";
 
     /** the pattern to match Javadoc tags with no argument **/
     private static final String MATCH_JAVADOC_NOARG_PAT =
-        "@(return|see|author)\\s+\\S";
+        "@(return|see)\\s+\\S";
     /** compiled regexp to match Javadoc tags with no argument **/
     private static final RE MATCH_JAVADOC_NOARG =
         Utils.createRE(MATCH_JAVADOC_NOARG_PAT);
+   /**
+    * the pattern to match the first line of a multi-line Javadoc
+    * tag that takes no argument.
+    **/
+    private static final String MATCH_JAVADOC_NOARG_MULTILINE_START_PAT =
+        "@(return|see)\\s*$";
+    /** compiled regexp to match first part of multilineJavadoc tags **/
+    private static final RE MATCH_JAVADOC_NOARG_MULTILINE_START =
+        Utils.createRE(MATCH_JAVADOC_NOARG_MULTILINE_START_PAT);
 
     /** the pattern to match Javadoc tags with no argument and {} **/
     private static final String MATCH_JAVADOC_NOARG_CURLY_PAT =
         "\\{\\s*@(inheritDoc)\\s*\\}";
     /** compiled regexp to match Javadoc tags with no argument and {} **/
     private static final RE MATCH_JAVADOC_NOARG_CURLY =
         Utils.createRE(MATCH_JAVADOC_NOARG_CURLY_PAT);
 
     /** full identifier for package of the method **/
     private FullIdent mPackageFullIdent = null;
 
     /** imports details **/
     private Set mImports = new HashSet();
 
     /** the visibility scope where Javadoc comments are checked **/
     private Scope mScope = Scope.PRIVATE;
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      **/
     private boolean mAllowUndeclaredRTE = false;
 
     /**
      * Set the scope.
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowUndeclaredRTE(boolean aFlag)
     {
         mAllowUndeclaredRTE = aFlag;
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
@@ -266,122 +274,143 @@ public class JavadocMethodCheck
     private void checkComment(DetailAST aAST, String[] aComment)
     {
         final List tags = getMethodTags(aComment, aAST.getLineNo() - 1);
         // Check for only one @see tag
         if ((tags.size() != 1)
             || !((JavadocTag) tags.get(0)).isSeeOrInheritDocTag())
         {
             checkParamTags(tags, getParameters(aAST));
             checkThrowsTags(tags, getThrows(aAST));
             if (isFunction(aAST)) {
                 checkReturnTag(tags, aAST.getLineNo());
             }
 
             // Dump out all unused tags
             final Iterator it = tags.iterator();
             while (it.hasNext()) {
                 final JavadocTag jt = (JavadocTag) it.next();
                 if (!jt.isSeeOrInheritDocTag()) {
                     log(jt.getLineNo(), "javadoc.unusedTagGeneral");
                 }
             }
         }
     }
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      * @return the tags found
      * @param aLines the Javadoc comment
      * @param aLastLineNo the line number of the last line in the Javadoc
      *                    comment
      **/
     private List getMethodTags(String[] aLines, int aLastLineNo)
     {
         final List tags = new ArrayList();
         int currentLine = aLastLineNo - aLines.length;
         for (int i = 0; i < aLines.length; i++) {
             currentLine++;
             if (MATCH_JAVADOC_ARG.match(aLines[i])) {
                 tags.add(new JavadocTag(currentLine,
                                         MATCH_JAVADOC_ARG.getParen(1),
                                         MATCH_JAVADOC_ARG.getParen(2)));
             }
             else if (MATCH_JAVADOC_NOARG.match(aLines[i])) {
                 tags.add(new JavadocTag(currentLine,
                                         MATCH_JAVADOC_NOARG.getParen(1)));
             }
             else if (MATCH_JAVADOC_NOARG_CURLY.match(aLines[i])) {
                 tags.add(new JavadocTag(currentLine,
                                         MATCH_JAVADOC_NOARG_CURLY.getParen(1)));
             }
-            else if (MATCH_JAVADOC_MULTILINE_START.match(aLines[i])) {
-                final String p1 = MATCH_JAVADOC_MULTILINE_START.getParen(1);
-                final String p2 = MATCH_JAVADOC_MULTILINE_START.getParen(2);
+            else if (MATCH_JAVADOC_ARG_MULTILINE_START.match(aLines[i])) {
+                final String p1 = MATCH_JAVADOC_ARG_MULTILINE_START.getParen(1);
+                final String p2 = MATCH_JAVADOC_ARG_MULTILINE_START.getParen(2);
 
                 // Look for the rest of the comment if all we saw was
                 // the tag and the name. Stop when we see '*/' (end of
                 // Javadoc, '@' (start of next tag), or anything that's
                 // not whitespace or '*' characters.
                 int remIndex = i + 1;
                 while (remIndex < aLines.length) {
                     if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {
                         remIndex = aLines.length;
                         String lFin = MATCH_JAVADOC_MULTILINE_CONT.getParen(1);
                         if (!lFin.equals(NEXT_TAG)
                             && !lFin.equals(END_JAVADOC))
                         {
                             tags.add(new JavadocTag(currentLine, p1, p2));
                         }
                     }
                     remIndex++;
                 }
             }
+            else if (MATCH_JAVADOC_NOARG_MULTILINE_START.match(aLines[i])) {
+                final String p1 = MATCH_JAVADOC_NOARG_MULTILINE_START.getParen(1);
+
+                // Look for the rest of the comment if all we saw was
+                // the tag and the name. Stop when we see '*/' (end of
+                // Javadoc, '@' (start of next tag), or anything that's
+                // not whitespace or '*' characters.
+                int remIndex = i + 1;
+                while (remIndex < aLines.length) {
+                    if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {
+                        remIndex = aLines.length;
+                        String lFin = MATCH_JAVADOC_MULTILINE_CONT.getParen(1);
+                        if (!lFin.equals(NEXT_TAG)
+                            && !lFin.equals(END_JAVADOC))
+                        {
+                            tags.add(new JavadocTag(currentLine, p1));
+                        }
+                    }
+                    remIndex++;
+                }
+            }
         }
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      * @param aAST the method node.
      * @return the list of parameter nodes for aAST.
      **/
     private List getParameters(DetailAST aAST)
     {
         final DetailAST params = aAST.findFirstToken(TokenTypes.PARAMETERS);
         final List retVal = new ArrayList();
 
         DetailAST child = (DetailAST) params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = (DetailAST) child.getNextSibling();
         }
         return retVal;
     }
 
      /**
      * Computes the exception nodes for a method.
      * @param aAST the method node.
      * @return the list of exception nodes for aAST.
      **/
     private List getThrows(DetailAST aAST)
     {
         final List retVal = new ArrayList();
         final DetailAST throwsAST =
             aAST.findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = (DetailAST) throwsAST.getFirstChild();
             while (child != null) {
                 if ((child.getType() == TokenTypes.IDENT)
                     || (child.getType() == TokenTypes.DOT))
                 {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     retVal.add(fi);
                 }
                 child = (DetailAST) child.getNextSibling();
             }
         }
         return retVal;
     }
 
