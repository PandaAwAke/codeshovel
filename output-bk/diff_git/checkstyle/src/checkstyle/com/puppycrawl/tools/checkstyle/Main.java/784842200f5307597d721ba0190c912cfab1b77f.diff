diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
index 09d7cef95..2659afe0c 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
@@ -45,222 +45,294 @@ import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
  * Wrapper command line program for the Checker.
  * @author Oliver Burn
  **/
 public final class Main
 {
     /** the options to the command line */
     private static final Options OPTS = new Options();
     static {
         OPTS.addOption("c", true, "The check configuration file to use.");
         OPTS.addOption("r", true, "Traverse the directory for source files");
         OPTS.addOption("o", true, "Sets the output file. Defaults to stdout");
         OPTS.addOption("p", true, "Loads the properties file");
         OPTS.addOption("n", true, "Loads the package names file");
         OPTS.addOption(
             "f",
             true,
             "Sets the output format. (plain|xml). Defaults to plain");
         OPTS.addOption("l", true, "Adds a list of listeners");
     }
 
     /**
      * Loops over the files specified checking them for errors. The exit code
      * is the number of errors found in all the files.
      * @param aArgs the command line arguments
      **/
     public static void main(String[] aArgs)
     {
         // parse the parameters
         final CommandLineParser clp = new PosixParser();
         CommandLine line = null;
         try {
             line = clp.parse(OPTS, aArgs);
         }
         catch (ParseException e) {
             e.printStackTrace();
             usage();
         }
 
         // setup the properties
         final Properties props =
             line.hasOption("p")
                 ? loadProperties(new File(line.getOptionValue("p")))
                 : System.getProperties();
 
         // ensure a config file is specified
         if (!line.hasOption("c")) {
             System.out.println("Must specify a config XML file.");
             usage();
         }
 
-        // Load the config file
-        Configuration config = null;
-        try {
-            config = ConfigurationLoader.loadConfiguration(
-                    line.getOptionValue("c"), new PropertiesExpander(props));
-        }
-        catch (CheckstyleException e) {
-            System.out.println("Error loading configuration file");
-            e.printStackTrace(System.out);
-            System.exit(1);
-        }
+        final Configuration config = loadConfig(line, props);
 
         //Load the set of package names
         ModuleFactory moduleFactory = null;
         if (line.hasOption("n")) {
-            try {
-                moduleFactory = PackageNamesLoader.loadModuleFactory(
-                    line.getOptionValue("n"));
-            }
-            catch (CheckstyleException e) {
-                System.out.println("Error loading package names file");
-                e.printStackTrace(System.out);
-                System.exit(1);
-            }
+            moduleFactory = loadPackages(line);
         }
 
         // setup the output stream
         OutputStream out = null;
         boolean closeOut = false;
         if (line.hasOption("o")) {
             final String fname = line.getOptionValue("o");
             try {
                 out = new FileOutputStream(fname);
                 closeOut = true;
             }
             catch (FileNotFoundException e) {
                 System.out.println("Could not find file: '" + fname + "'");
                 System.exit(1);
             }
         }
         else {
             out = System.out;
             closeOut = false;
         }
 
-        // create the appropriate listener
-        final String format =
-            line.hasOption("f") ? line.getOptionValue("f") : "plain";
+        final AuditListener listener = createListener(line, out, closeOut);
+        final List files = getFilesToProcess(line);
+        final Checker c = createChecker(config, moduleFactory, listener);
+        addCustomListeners(c, line);
 
-        AuditListener listener = null;
-        if ("xml".equals(format)) {
-            listener = new XMLLogger(out, closeOut);
+        final File[] processedFiles = new File[files.size()];
+        files.toArray(processedFiles);
+        final int numErrs = c.process(processedFiles);
+        c.destroy();
+        System.exit(numErrs);
+    }
+
+    /**
+     * Added the custom listeners to a checker.
+     *
+     * @param aChecker who to add the listeners to
+     * @param aLine contains the command line options for what listeners to add
+     */
+    private static void addCustomListeners(Checker aChecker, CommandLine aLine)
+    {
+        if (aLine.hasOption("l")) {
+            final String listeners = aLine.getOptionValue("l");
+            final StringTokenizer t = new StringTokenizer(listeners, ",");
+            while (t.hasMoreTokens()) {
+                final String className = t.nextToken();
+                AuditListener customListener = null;
+                try {
+                    customListener =
+                        (AuditListener) Class.forName(className).newInstance();
+                }
+                catch (Exception e) {
+                    System.out.println("Unable to create listener '"
+                        + className + "': " + e);
+                    e.printStackTrace(System.out);
+                    System.exit(1);
+                }
+                aChecker.addListener(customListener);
+            }
         }
-        else if ("plain".equals(format)) {
-            listener = new DefaultLogger(out, closeOut);
+    }
+
+    /**
+     * Creates the Checker object.
+     *
+     * @param aConfig the configuration to use
+     * @param aFactory the module factor to use
+     * @param aNosy the sticky beak to track what happens
+     * @return a nice new fresh Checker
+     */
+    private static Checker createChecker(Configuration aConfig,
+                                         ModuleFactory aFactory,
+                                         AuditListener aNosy)
+    {
+        Checker c = null;
+        try {
+            c = new Checker();
+            c.setModuleFactory(aFactory);
+            c.configure(aConfig);
+            c.addListener(aNosy);
         }
-        else {
-            System.out.println("Invalid format: (" + format
-                               + "). Must be 'plain' or 'xml'.");
-            usage();
+        catch (Exception e) {
+            System.out.println("Unable to create Checker: "
+                               + e.getMessage());
+            e.printStackTrace(System.out);
+            System.exit(1);
         }
+        return c;
+    }
 
-        // Get all the Java files
+    /**
+     * Determines the files to process.
+     *
+     * @param aLine the command line options specifying what files to process
+     * @return list of files to process
+     */
+    private static List getFilesToProcess(CommandLine aLine)
+    {
         final List files = new LinkedList();
-        if (line.hasOption("r")) {
-            final String[] values = line.getOptionValues("r");
+        if (aLine.hasOption("r")) {
+            final String[] values = aLine.getOptionValues("r");
             for (int i = 0; i < values.length; i++) {
                 traverse(new File(values[i]), files);
             }
         }
 
-        final String[] remainingArgs = line.getArgs();
+        final String[] remainingArgs = aLine.getArgs();
         for (int i = 0; i < remainingArgs.length; i++) {
             files.add(new File(remainingArgs[i]));
         }
 
         if (files.isEmpty()) {
             System.out.println("Must specify files to process");
             usage();
         }
+        return files;
+    }
 
-        // create the checker
-        Checker c = null;
+    /**
+     * Create the audit listener
+     *
+     * @param aLine command line options supplied
+     * @param aOut the stream to log to
+     * @param aCloseOut whether the stream should be closed
+     * @return a fresh new <code>AuditListener</code>
+     */
+    private static AuditListener createListener(CommandLine aLine,
+                                                OutputStream aOut,
+                                                boolean aCloseOut)
+    {
+        final String format =
+            aLine.hasOption("f") ? aLine.getOptionValue("f") : "plain";
+
+        AuditListener listener = null;
+        if ("xml".equals(format)) {
+            listener = new XMLLogger(aOut, aCloseOut);
+        }
+        else if ("plain".equals(format)) {
+            listener = new DefaultLogger(aOut, aCloseOut);
+        }
+        else {
+            System.out.println("Invalid format: (" + format
+                               + "). Must be 'plain' or 'xml'.");
+            usage();
+        }
+        return listener;
+    }
+
+    /**
+     * Loads the packages, or exists if unable to.
+     *
+     * @param aLine the supplied command line options
+     * @return a fresh new <code>ModuleFactory</code>
+     */
+    private static ModuleFactory loadPackages(CommandLine aLine)
+    {
         try {
-            c = new Checker();
-            c.setModuleFactory(moduleFactory);
-            c.configure(config);
-            c.addListener(listener);
+            return PackageNamesLoader.loadModuleFactory(
+                aLine.getOptionValue("n"));
         }
-        catch (Exception e) {
-            System.out.println("Unable to create Checker: "
-                               + e.getMessage());
+        catch (CheckstyleException e) {
+            System.out.println("Error loading package names file");
             e.printStackTrace(System.out);
             System.exit(1);
+            return null; // never get here
         }
+    }
 
-        // add custom listeners
-        if (line.hasOption("l")) {
-            final String listeners = line.getOptionValue("l");
-            final StringTokenizer t = new StringTokenizer(listeners, ",");
-            while (t.hasMoreTokens()) {
-                final String className = t.nextToken();
-                AuditListener customListener = null;
-                try {
-                    customListener =
-                        (AuditListener) Class.forName(className).newInstance();
-                }
-                catch (Exception e) {
-                    System.out.println("Unable to create listener '"
-                        + className + "': " + e);
-                    e.printStackTrace(System.out);
-                    System.exit(1);
-                }
-                c.addListener(customListener);
-            }
+    /**
+     * Loads the configuration file. Will exit if unable to load.
+     *
+     * @param aLine specifies the location of the configuration
+     * @param aProps the properties to resolve with the configuration
+     * @return a fresh new configuration
+     */
+    private static Configuration loadConfig(CommandLine aLine,
+                                            Properties aProps)
+    {
+        try {
+            return ConfigurationLoader.loadConfiguration(
+                    aLine.getOptionValue("c"), new PropertiesExpander(aProps));
+        }
+        catch (CheckstyleException e) {
+            System.out.println("Error loading configuration file");
+            e.printStackTrace(System.out);
+            System.exit(1);
+            return null; // can never get here
         }
-
-        final File[] processedFiles = new File[files.size()];
-        files.toArray(processedFiles);
-        final int numErrs = c.process(processedFiles);
-        c.destroy();
-        System.exit(numErrs);
     }
 
     /** Prints the usage information. **/
     private static void usage()
     {
         HelpFormatter hf = new HelpFormatter();
         hf.printHelp(
             "java "
                 + Main.class.getName()
                 + " [options] -c <config.xml> file...",
             OPTS);
         System.exit(1);
     }
 
     /**
      * Traverses a specified node looking for files to check. Found
      * files are added to a specified list. Subdirectories are also
      * traversed.
      *
      * @param aNode the node to process
      * @param aFiles list to add found files to
      */
     private static void traverse(File aNode, List aFiles)
     {
         if (aNode.canRead()) {
             if (aNode.isDirectory()) {
                 final File[] nodes = aNode.listFiles();
                 for (int i = 0; i < nodes.length; i++) {
                     traverse(nodes[i], aFiles);
                 }
             }
             else if (aNode.isFile()) {
                 aFiles.add(aNode);
             }
         }
     }
 
     /**
      * Loads properties from a File.
      * @param aFile the properties file
      * @return the properties in aFile
      */
     private static Properties loadProperties(File aFile)
     {
         Properties properties = new Properties();
         try {
             FileInputStream fis = null;
             fis = new FileInputStream(aFile);
             properties.load(fis);
             fis.close();
