diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index a0d0108b5..fb54c195d 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -132,101 +132,101 @@ public class JavadocMethodCheck
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree()
     {
         mPackageFullIdent = new FullIdent();
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.PACKAGE_DEF) {
             if (mCheckUnusedThrows) {
                 processPackage(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
             if (mCheckUnusedThrows) {
                 processImport(aAST);
             }
         }
         else {
             //TokenTypes.METHOD_DEF or TokenTypes.CTOR_DEF
             processMethod(aAST);
         }
     }
 
 
 
     /**
      * Collects the details of a package.
      * @param aAST node containing the package details
      */
     private void processPackage(DetailAST aAST)
     {
         final DetailAST nameAST = (DetailAST) aAST.getFirstChild();
         mPackageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = getImportText(aAST);
         if (name != null) {
-            mImports.add(name);
+            mImports.add(name.getText());
         }
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     private void processMethod(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope targetScope =
             ScopeUtils.inInterfaceBlock(aAST)
                 ? Scope.PUBLIC
                 : declaredScope;
 
         if (targetScope.isIn(mScope)) {
             final Scope surroundingScope =
                 ScopeUtils.getSurroundingScope(aAST);
 
             if (surroundingScope.isIn(mScope)) {
                 final FileContents contents = getFileContents();
                 final String[] cmt =
                     contents.getJavadocBefore(aAST.getLineNo());
 
                 if (cmt == null) {
                     log(aAST.getLineNo(),
                         aAST.getColumnNo(),
                         "javadoc.missing");
                 }
                 else {
                     checkComment(aAST, cmt);
                 }
             }
         }
     }
 
     /**
      * Checks the Javadoc for a method.
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
      */
     private void checkComment(DetailAST aAST, String[] aComment)
     {
         final List tags = getMethodTags(aComment, aAST.getLineNo() - 1);
         // Check for only one @see tag
         if ((tags.size() != 1)
             || !((JavadocTag) tags.get(0)).isSeeTag())
         {
             checkParamTags(tags, getParameters(aAST));
@@ -426,80 +426,83 @@ public class JavadocMethodCheck
                     log(jt.getLineNo(), "javadoc.return.duplicate");
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags
         if (!found) {
             log(aLineNo, "javadoc.return.expected");
         }
     }
 
 
     /**
      * Checks a set of tags for matching throws.
      * @param aTags the tags to check
      * @param aThrows the throws to check
      **/
     private void checkThrowsTags(List aTags, List aThrows)
     {
         // Loop over the tags, checking to see they exist in the throws.
         final Set foundThrows = new HashSet();
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             boolean found = foundThrows.contains(documentedEx);
             final ListIterator throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final FullIdent fi = (FullIdent) throwIt.next();
                 if (fi.getText().equals(documentedEx)) {
                     found = true;
                     throwIt.remove();
                     foundThrows.add(documentedEx);
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (mCheckUnusedThrows) {
-                    final ClassResolver cr = new ClassResolver(
-                        Thread.currentThread().getContextClassLoader(),
-                        mPackageFullIdent.getText(), mImports);
+                    final ClassResolver cr =
+                        new ClassResolver(
+                            getClassLoader(),
+                            mPackageFullIdent.getText(),
+                            mImports);
                     try {
                         final Class clazz = cr.resolve(tag.getArg1());
-                        reqd = !RuntimeException.class.isAssignableFrom(clazz)
-                            && !Error.class.isAssignableFrom(clazz);
+                        reqd =
+                            !RuntimeException.class.isAssignableFrom(clazz)
+                                && !Error.class.isAssignableFrom(clazz);
                     }
                     catch (ClassNotFoundException e) {
                         log(tag.getLineNo(), "javadoc.classInfo",
                                       "@throws", tag.getArg1());
                     }
                 }
 
                 if (reqd) {
                     log(tag.getLineNo(), "javadoc.unusedTag",
                                   "@throws", tag.getArg1());
                 }
             }
         }
 
         // Now dump out all throws without tags
         final ListIterator throwIt = aThrows.listIterator();
         while (throwIt.hasNext()) {
             final FullIdent fi = (FullIdent) throwIt.next();
             log(fi.getLineNo(), fi.getColumnNo(),
                 "javadoc.expectedTag", "@throws", fi.getText());
         }
     }
 }
