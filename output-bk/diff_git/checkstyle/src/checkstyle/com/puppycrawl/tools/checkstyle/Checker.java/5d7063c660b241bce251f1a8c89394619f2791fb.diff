diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index 961866b60..5c4dc9b83 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -186,251 +186,252 @@ public class Checker extends AutomaticBean
     {
         mFilters.addFilter(aFilter);
     }
 
     /**
      * Removes filter.
      * @param aFilter filter to remove.
      */
     public void removeFilter(Filter aFilter)
     {
         mFilters.removeFilter(aFilter);
     }
 
     /** Cleans up the object. **/
     public void destroy()
     {
         mListeners.clear();
         mFilters.clear();
     }
 
     /**
      * Add the listener that will be used to receive events from the audit.
      * @param aListener the nosy thing
      */
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Removes a given listener.
      * @param aListener a listener to remove
      */
     public void removeListener(AuditListener aListener)
     {
         mListeners.remove(aListener);
     }
 
     /**
      * Processes a set of files with all FileSetChecks.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(File[] aFiles)
     {
         fireAuditStarted();
         for (int i = 0; i < mFileSetChecks.size(); i++) {
-            FileSetCheck fileSetCheck = (FileSetCheck) mFileSetChecks.get(i);
+            final FileSetCheck fileSetCheck =
+                (FileSetCheck) mFileSetChecks.get(i);
             fileSetCheck.process(aFiles);
             fileSetCheck.destroy();
         }
-        int errorCount = mCounter.getCount();
+        final int errorCount = mCounter.getCount();
         fireAuditFinished();
         return errorCount;
     }
 
 
     /**
      * Create a stripped down version of a filename.
      * @param aFileName the original filename
      * @return the filename where an initial prefix of basedir is stripped
      */
     private String getStrippedFileName(final String aFileName)
     {
         return Utils.getStrippedFileName(mBasedir, aFileName);
     }
 
     /** @param aBasedir the base directory to strip off in filenames */
     public void setBasedir(String aBasedir)
     {
         // we use getAbsolutePath() instead of getCanonicalPath()
         // because normalize() removes all . and .. so path
         // will be canonical by default.
         mBasedir = normalize(aBasedir);
     }
 
     /**
      * &quot;normalize&quot; the given absolute path.
      *
      * <p>This includes:
      * <ul>
      *   <li>Uppercase the drive letter if there is one.</li>
      *   <li>Remove redundant slashes after the drive spec.</li>
      *   <li>resolve all ./, .\, ../ and ..\ sequences.</li>
      *   <li>DOS style paths that start with a drive letter will have
      *     \ as the separator.</li>
      * </ul>
      *
      * @param aPath a path for &quot;normalizing&quot;
      * @return &quot;normalized&quot; file name
      * @throws java.lang.NullPointerException if the file path is
      * equal to null.
      */
     public String normalize(String aPath)
     {
         final String osName =
             System.getProperty("os.name").toLowerCase(Locale.US);
         final boolean onNetWare = (osName.indexOf("netware") > -1);
 
-        String orig = aPath;
+        final String orig = aPath;
 
         aPath = aPath.replace('/', File.separatorChar)
             .replace('\\', File.separatorChar);
 
         // make sure we are dealing with an absolute path
-        int colon = aPath.indexOf(":");
+        final int colon = aPath.indexOf(":");
 
         if (!onNetWare) {
             if (!aPath.startsWith(File.separator)
                 && !(aPath.length() >= 2
                      && Character.isLetter(aPath.charAt(0))
                      && colon == 1))
             {
-                String msg = aPath + " is not an absolute path";
+                final String msg = aPath + " is not an absolute path";
                 throw new IllegalArgumentException(msg);
             }
         }
         else {
             if (!aPath.startsWith(File.separator)
                 && (colon == -1))
             {
-                String msg = aPath + " is not an absolute path";
+                final String msg = aPath + " is not an absolute path";
                 throw new IllegalArgumentException(msg);
             }
         }
 
         boolean dosWithDrive = false;
         String root = null;
         // Eliminate consecutive slashes after the drive spec
         if ((!onNetWare
              && aPath.length() >= 2
              && Character.isLetter(aPath.charAt(0))
              && aPath.charAt(1) == ':')
             || (onNetWare && colon > -1))
         {
 
             dosWithDrive = true;
 
-            char[] ca = aPath.replace('/', '\\').toCharArray();
-            StringBuffer sbRoot = new StringBuffer();
+            final char[] ca = aPath.replace('/', '\\').toCharArray();
+            final StringBuffer sbRoot = new StringBuffer();
             for (int i = 0; i < colon; i++) {
                 sbRoot.append(Character.toUpperCase(ca[i]));
             }
             sbRoot.append(':');
             if (colon + 1 < aPath.length()) {
                 sbRoot.append(File.separatorChar);
             }
             root = sbRoot.toString();
 
             // Eliminate consecutive slashes after the drive spec
-            StringBuffer sbPath = new StringBuffer();
+            final StringBuffer sbPath = new StringBuffer();
             for (int i = colon + 1; i < ca.length; i++) {
                 if ((ca[i] != '\\')
                     || (ca[i] == '\\' && ca[i - 1] != '\\'))
                 {
                     sbPath.append(ca[i]);
                 }
             }
             aPath = sbPath.toString().replace('\\', File.separatorChar);
 
         }
         else {
             if (aPath.length() == 1) {
                 root = File.separator;
                 aPath = "";
             }
             else if (aPath.charAt(1) == File.separatorChar) {
                 // UNC drive
                 root = File.separator + File.separator;
                 aPath = aPath.substring(2);
             }
             else {
                 root = File.separator;
                 aPath = aPath.substring(1);
             }
         }
 
-        Stack s = new Stack();
+        final Stack s = new Stack();
         s.push(root);
-        StringTokenizer tok = new StringTokenizer(aPath, File.separator);
+        final StringTokenizer tok = new StringTokenizer(aPath, File.separator);
         while (tok.hasMoreTokens()) {
-            String thisToken = tok.nextToken();
+            final String thisToken = tok.nextToken();
             if (".".equals(thisToken)) {
                 continue;
             }
             else if ("..".equals(thisToken)) {
                 if (s.size() < 2) {
                     throw new IllegalArgumentException("Cannot resolve path "
                                                        + orig);
                 }
                 s.pop();
             }
             else { // plain component
                 s.push(thisToken);
             }
         }
 
-        StringBuffer sb = new StringBuffer();
+        final StringBuffer sb = new StringBuffer();
         for (int i = 0; i < s.size(); i++) {
             if (i > 1) {
                 // not before the filesystem root and not after it, since root
                 // already contains one
                 sb.append(File.separatorChar);
             }
             sb.append(s.elementAt(i));
         }
 
 
         aPath = sb.toString();
         if (dosWithDrive) {
             aPath = aPath.replace('/', '\\');
         }
         return aPath;
     }
 
     /** @return the base directory property used in unit-test. */
     String getBasedir()
     {
         return mBasedir;
     }
 
     /** notify all listeners about the audit start */
     protected void fireAuditStarted()
     {
         final AuditEvent evt = new AuditEvent(this);
         if (mFilters.accept(evt)) {
             final Iterator it = mListeners.iterator();
             while (it.hasNext()) {
                 final AuditListener listener = (AuditListener) it.next();
                 listener.auditStarted(evt);
             }
         }
     }
 
     /** notify all listeners about the audit end */
     protected void fireAuditFinished()
     {
         final AuditEvent evt = new AuditEvent(this);
         if (mFilters.accept(evt)) {
             final Iterator it = mListeners.iterator();
             while (it.hasNext()) {
                 final AuditListener listener = (AuditListener) it.next();
                 listener.auditFinished(evt);
             }
         }
     }
 
     /**
