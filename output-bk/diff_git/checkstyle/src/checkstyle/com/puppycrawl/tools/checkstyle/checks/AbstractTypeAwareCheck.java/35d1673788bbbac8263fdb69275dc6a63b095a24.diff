diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index 4499e06d2..28a228d99 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -195,259 +195,261 @@ public abstract class AbstractTypeAwareCheck extends Check
      * @param aException <code>Class</code> of exception to check
      * @return true  if exception is unchecked
      *         false if exception is checked
      */
     protected boolean isUnchecked(Class aException)
     {
         return isSubclass(aException, RuntimeException.class)
             || isSubclass(aException, Error.class);
     }
 
     /**
      * Checks if one class is subclass of another
      *
      * @param aChild <code>Class</code> of class
      *               which should be child
      * @param aParent <code>Class</code> of class
      *                which should be parent
      * @return true  if aChild is subclass of aParent
      *         false otherwise
      */
     protected boolean isSubclass(Class aChild, Class aParent)
     {
         return (aParent != null) && (aChild != null)
             &&  aParent.isAssignableFrom(aChild);
     }
 
     /** @return <code>ClassResolver</code> for current tree. */
     private ClassResolver getClassResolver()
     {
         if (mClassResolver == null) {
             mClassResolver =
                 new ClassResolver(getClassLoader(),
                                   mPackageFullIdent.getText(),
                                   mImports);
         }
         return mClassResolver;
     }
 
     /**
      * Attempts to resolve the Class for a specified name.
      * @param aClassName name of the class to resolve
      * @param aCurrentClass name of surrounding class.
      * @return the resolved class or <code>null</code>
      *          if unable to resolve the class.
      */
     protected final Class resolveClass(String aClassName, String aCurrentClass)
     {
         try {
             return getClassResolver().resolve(aClassName, aCurrentClass);
         }
-        catch (ClassNotFoundException e) {
+        catch (final ClassNotFoundException e) {
             return null;
         }
     }
 
     /**
      * Tries to load class. Logs error if unable.
      * @param aIdent name of class which we try to load.
      * @param aCurrentClass name of surrounding class.
      * @return <code>Class</code> for a ident.
      */
     protected final Class tryLoadClass(Token aIdent, String aCurrentClass)
     {
         final Class clazz = resolveClass(aIdent.getText(), aCurrentClass);
         if (clazz == null) {
             logLoadError(aIdent);
         }
         return clazz;
     }
 
     /**
      * Logs error if unable to load class information.
      * Abstract, should be overrided in subclasses.
      * @param aIdent class name for which we can no load class.
      */
     protected abstract void logLoadError(Token aIdent);
 
     /**
      * Common implementation for logLoadError() method.
      * @param aLineNo line number of the problem.
      * @param aColumnNo column number of the problem.
      * @param aMsgKey message key to use.
      * @param aValues values to fill the message out.
      */
     protected final void logLoadErrorImpl(int aLineNo, int aColumnNo,
                                           String aMsgKey, Object[] aValues)
     {
         if (!mLogLoadErrors) {
-            LocalizedMessage msg = new LocalizedMessage(aLineNo,
+            final LocalizedMessage msg = new LocalizedMessage(aLineNo,
                                                     aColumnNo,
                                                     getMessageBundle(),
                                                     aMsgKey,
                                                     aValues,
                                                     getSeverityLevel(),
                                                     getId(),
                                                     this.getClass());
             throw new RuntimeException(msg.getMessage());
         }
 
         if (!mSuppressLoadErrors) {
             log(aLineNo, aColumnNo, aMsgKey, aValues);
         }
     }
 
     /**
      * Collects the details of a package.
      * @param aAST node containing the package details
      */
     private void processPackage(DetailAST aAST)
     {
         final DetailAST nameAST = aAST.getLastChild().getPreviousSibling();
         mPackageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(aAST);
         if (name != null) {
             mImports.add(name.getText());
         }
     }
 
     /**
      * Process type params (if any) for given class, enum or method.
      * @param aAST class, enum or method to process.
      */
     private void processTypeParams(DetailAST aAST)
     {
         final DetailAST typeParams =
             aAST.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
-        Map paramsMap = new HashMap();
+        final Map paramsMap = new HashMap();
         mTypeParams.add(paramsMap);
 
         if (typeParams == null) {
             return;
         }
 
         for (DetailAST child = (DetailAST) typeParams.getFirstChild();
              child != null;
              child = (DetailAST) child.getNextSibling())
         {
             if (child.getType() == TokenTypes.TYPE_PARAMETER) {
-                DetailAST param = child;
-                String alias = param.findFirstToken(TokenTypes.IDENT).getText();
-                DetailAST bounds =
+                final DetailAST param = child;
+                final String alias =
+                    param.findFirstToken(TokenTypes.IDENT).getText();
+                final DetailAST bounds =
                     param.findFirstToken(TokenTypes.TYPE_UPPER_BOUNDS);
                 if (bounds != null) {
-                    FullIdent name = FullIdent.createFullIdentBelow(bounds);
-                    ClassInfo ci =
+                    final FullIdent name =
+                        FullIdent.createFullIdentBelow(bounds);
+                    final ClassInfo ci =
                         createClassInfo(new Token(name), getCurrentClassName());
                     paramsMap.put(alias, ci);
                 }
             }
         }
     }
 
     /**
      * Processes class definition.
      * @param aAST class definition to process.
      */
     private void processClass(DetailAST aAST)
     {
         final DetailAST ident = aAST.findFirstToken(TokenTypes.IDENT);
         mCurrentClass += ("".equals(mCurrentClass) ? "" : "$")
             + ident.getText();
 
         processTypeParams(aAST);
     }
 
     /**
      * Returns current class.
      * @return name of current class.
      */
     protected final String getCurrentClassName()
     {
         return mCurrentClass;
     }
 
     /**
      * Creates class info for given name.
      * @param aName name of type.
      * @param aSurroundingClass name of surrounding class.
      * @return class infor for given name.
      */
     protected final ClassInfo createClassInfo(final Token aName,
                                               final String aSurroundingClass)
     {
-        ClassInfo ci = findClassAlias(aName.getText());
+        final ClassInfo ci = findClassAlias(aName.getText());
         if (ci != null) {
             return new ClassAlias(aName, ci);
         }
         return new RegularClass(aName, aSurroundingClass, this);
     }
 
     /**
      * Looking if a given name is alias.
      * @param aName given name
      * @return ClassInfo for alias if it exists, null otherwise
      */
     protected final ClassInfo findClassAlias(final String aName)
     {
         ClassInfo ci = null;
         for (int i = mTypeParams.size() - 1; i >= 0; i--) {
-            Map paramMap = (Map) mTypeParams.get(i);
+            final Map paramMap = (Map) mTypeParams.get(i);
             ci = (ClassInfo) paramMap.get(aName);
             if (ci != null) {
                 break;
             }
         }
         return ci;
     }
 
     /**
      * Contains class's <code>Token</code>.
      */
     protected abstract static class ClassInfo
     {
         /** <code>FullIdent</code> associated with this class. */
         private final Token mName;
 
         /** @return class name */
         public final Token getName()
         {
             return mName;
         }
 
         /** @return <code>Class</code> associated with an object. */
         public abstract Class getClazz();
 
         /**
          * Creates new instance of class inforamtion object.
          * @param aName token which represents class name.
          */
         protected ClassInfo(final Token aName)
         {
             if (aName == null) {
                 throw new NullPointerException(
                     "ClassInfo's name should be non-null");
             }
             mName = aName;
         }
     }
 
     /** Represents regular classes/enumes. */
     private static final class RegularClass extends ClassInfo
     {
         /** name of surrounding class. */
         private String mSurroundingClass;
         /** is class loadable. */
         private boolean mIsLoadable = true;
         /** <code>Class</code> object of this class if it's loadable. */
         private Class mClass;
         /** the check we use to resolve classes. */
         private final AbstractTypeAwareCheck mCheck;
