diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index fb1eac0a1..65cc4f9a5 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -198,111 +198,111 @@ public class Checker extends AutomaticBean implements MessageDispatcher
         mFilters.addFilter(aFilter);
     }
 
     /**
      * Removes filter.
      * @param aFilter filter to remove.
      */
     public void removeFilter(Filter aFilter)
     {
         mFilters.removeFilter(aFilter);
     }
 
     /** Cleans up the object. **/
     public void destroy()
     {
         mListeners.clear();
         mFilters.clear();
     }
 
     /**
      * Add the listener that will be used to receive events from the audit.
      * @param aListener the nosy thing
      */
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Removes a given listener.
      * @param aListener a listener to remove
      */
     public void removeListener(AuditListener aListener)
     {
         mListeners.remove(aListener);
     }
 
     /**
      * Processes a set of files with all FileSetChecks.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(List<File> aFiles)
     {
         // Prepare to start
         fireAuditStarted();
         for (FileSetCheck fsc : mFileSetChecks) {
-            fsc.beginProcessing(getCharset());
+            fsc.beginProcessing(mCharset);
         }
 
         // Process each file
         for (File f : aFiles) {
             final String fileName = f.getAbsolutePath();
             fireFileStarted(fileName);
             final TreeSet<LocalizedMessage> fileMessages = Sets.newTreeSet();
             try {
                 final String[] lines = Utils.getLines(f.getAbsolutePath(),
-                        getCharset());
+                        mCharset);
                 final List<String> theLines = Lists.newArrayList(lines);
                 for (FileSetCheck fsc : mFileSetChecks) {
                     fileMessages.addAll(fsc.process(f, theLines));
                 }
             }
             catch (final FileNotFoundException fnfe) {
                 Utils.getExceptionLogger().debug(
                         "FileNotFoundException occured.", fnfe);
                 fileMessages.add(new LocalizedMessage(0,
                         Defn.CHECKSTYLE_BUNDLE, "general.fileNotFound", null,
                         null, this.getClass(), null));
             }
             catch (final IOException ioe) {
                 Utils.getExceptionLogger().debug("IOException occured.", ioe);
                 fileMessages.add(new LocalizedMessage(0,
                         Defn.CHECKSTYLE_BUNDLE, "general.exception",
                         new String[] {ioe.getMessage()}, null, this.getClass(),
                         null));
             }
             fireErrors(fileName, fileMessages);
             fireFileFinished(fileName);
         }
 
         // Finish up
         for (FileSetCheck fsc : mFileSetChecks) {
             // They may also log!!!
             fsc.finishProcessing();
             fsc.destroy();
         }
 
         final int errorCount = mCounter.getCount();
         fireAuditFinished();
         return errorCount;
     }
 
     /**
      * Create a stripped down version of a filename.
      * @param aFileName the original filename
      * @return the filename where an initial prefix of basedir is stripped
      */
     private String getStrippedFileName(final String aFileName)
     {
         return Utils.getStrippedFileName(mBasedir, aFileName);
     }
 
     /** @param aBasedir the base directory to strip off in filenames */
     public void setBasedir(String aBasedir)
     {
         // we use getAbsolutePath() instead of getCanonicalPath()
         // because normalize() removes all . and .. so path
@@ -526,71 +526,65 @@ public class Checker extends AutomaticBean implements MessageDispatcher
     }
 
     /** @param aLocaleCountry the country to report messages  **/
     public void setLocaleCountry(String aLocaleCountry)
     {
         mLocaleCountry = aLocaleCountry;
     }
 
     /** @param aLocaleLanguage the language to report messages  **/
     public void setLocaleLanguage(String aLocaleLanguage)
     {
         mLocaleLanguage = aLocaleLanguage;
     }
 
     /**
      * Sets the severity level.  The string should be one of the names
      * defined in the <code>SeverityLevel</code> class.
      *
      * @param aSeverity  The new severity level
      * @see SeverityLevel
      */
     public final void setSeverity(String aSeverity)
     {
         mSeverityLevel = SeverityLevel.getInstance(aSeverity);
     }
 
     /**
      * Sets the classloader that is used to contextualize filesetchecks.
      * Some Check implementations will use that classloader to improve the
      * quality of their reports, e.g. to load a class and then analyze it via
      * reflection.
      * @param aLoader the new classloader
      */
     public final void setClassloader(ClassLoader aLoader)
     {
         mLoader = aLoader;
     }
 
     /**
      * Sets the classloader used to load Checkstyle core and custom module
      * classes when the module tree is being built up.
      * If no custom ModuleFactory is being set for the Checker module then
      * this module classloader must be specified.
      * @param aModuleClassLoader the classloader used to load module classes
      */
     public final void setModuleClassLoader(ClassLoader aModuleClassLoader)
     {
         mModuleClassLoader = aModuleClassLoader;
     }
 
-    /** @return the name of the charset */
-    public String getCharset()
-    {
-        return mCharset;
-    }
-
     /**
      * Sets a named charset.
      * @param aCharset the name of a charset
      * @throws UnsupportedEncodingException if aCharset is unsupported.
      */
     public void setCharset(String aCharset)
         throws UnsupportedEncodingException
     {
         if (!Charset.isSupported(aCharset)) {
             final String message = "unsupported charset: '" + aCharset + "'";
             throw new UnsupportedEncodingException(message);
         }
         mCharset = aCharset;
     }
 }
