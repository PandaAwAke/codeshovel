diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
index 70fdd71aa..8c0679432 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
@@ -1174,101 +1174,122 @@ class Verifier
     }
 
     /**
      * checks if the order of modifiers follows the suggestions
      * in the JLS and logs an error message accordingly.
      *
      * @param aModSet the set of modifiers
      */
     private void checkModOrder(MyModifierSet aModSet)
     {
         final String error = aModSet.checkOrderSuggestedByJLS();
         if (error != null) {
             log(aModSet.getFirstLineNo(), error);
         }
     }
 
     /**
      * @return the class name from a fully qualified name
      * @param aType the fully qualified name
      */
     private String basename(String aType)
     {
         final int i = aType.lastIndexOf(".");
         return (i == -1) ? aType : aType.substring(i + 1);
     }
 
     /** Check the imports that are unused or unrequired. **/
     private void checkImports()
     {
         if (mConfig.isIgnoreImports()) {
             return;
         }
 
         // Loop checking imports
         final Iterator it = mImports.iterator();
         while (it.hasNext()) {
             final LineText imp = (LineText) it.next();
 
             if (fromPackage(imp.getText(), "java.lang")) {
                 log(imp.getLineNo(),
                     "Redundant import from the java.lang package.");
             }
             else if (fromPackage(imp.getText(), mPkgName)) {
                 log(imp.getLineNo(), "Redundant import from the same package.");
             }
             else if (!imp.getText().endsWith(".*") &&
                      !mReferenced.contains(basename(imp.getText())))
             {
                 log(imp.getLineNo(), "Unused import - " + imp.getText());
             }
+            else if (isIllegalImport(imp.getText())) {
+                log(imp.getLineNo(),
+                    "Import from illegal package - " + imp.getText());
+            }
+        }
+    }
+
+    /**
+     * Checks if an import is from a package that must not be used.
+     * @param aImportText the argument of the import keyword
+     * @return if <code>aImportText</code> contains an illegal package prefix
+     */
+    private boolean isIllegalImport(String aImportText)
+    {
+        final Iterator it = mConfig.getIllegalImports().iterator();
+        while (it.hasNext()) {
+            final String illegalPkgName = (String) it.next();
+            if (aImportText.startsWith(illegalPkgName + ".")) {
+                return true;
+            }
         }
+        return false;
     }
 
     /** @return whether currently in an interface block **/
     private boolean inInterfaceBlock()
     {
         return (!mInInterface.empty() &&
                 Boolean.TRUE.equals(mInInterface.peek()));
     }
 
     /** @return whether currently in a method block **/
     private boolean inMethodBlock()
     {
         return (mMethodBlockLevel > 0);
     }
 
     /**
      * Determines in an import statement is for types from a specified package.
      * @param aImport the import name
      * @param aPkg the package name
      * @return whether from the package
      */
     private static boolean fromPackage(String aImport, String aPkg)
     {
         boolean retVal = false;
         if (aPkg == null) {
             // If not package, then check for no package in the import.
             retVal = (aImport.indexOf('.') == -1);
         }
         else {
             final int index = aImport.lastIndexOf('.');
             if (index != -1) {
                 final String front = aImport.substring(0, index);
                 retVal = front.equals(aPkg);
             }
         }
         return retVal;
     }
 
     /**
      * Verify the correct placement of the left curly brace.
      * @param aStartLine line the construct starts on
      * @param aBrace location of the brace
      * @param aOption specifies where the brace should be
      */
     private void checkLCurly(int aStartLine,
                              MyCommonAST aBrace,
                              LeftCurlyOption aOption)
     {
         final String braceLine = mLines[aBrace.getLineNo() - 1];
 
