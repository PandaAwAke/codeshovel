diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index 5f31f90d9..1b36de706 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -1,158 +1,162 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle;
 
+
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.Reader;
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Locale;
 import org.apache.regexp.RESyntaxException;
 
 /**
  * This class provides the functionality to check a set of files.
  * @author <a href="mailto:oliver@puppycrawl.com">Oliver Burn</a>
  * @author <a href="mailto:stephane.bailliez@wanadoo.fr">Stephane Bailliez</a>
  */
 public class Checker
     implements Defn
 {
 
     /**
      * Overrides ANTLR error reporting so we completely control
      * checkstyle's output during parsing. This is important because
      * we try parsing with several grammers (with/without support for
      * <code>assert</code>). We must not write any error messages when
      * parsing fails because with the next grammar it might succeed
      * and the user will be confused.
      */
     private class SilentJava14Recognizer extends GeneratedJava14Recognizer
     {
         /**
          * Creates a new <code>SilentJava14Recognizer</code> instance.
          *
          * @param aLexer the tokenstream the recognizer operates on.
          */
         private SilentJava14Recognizer(GeneratedJava14Lexer aLexer)
         {
             super(aLexer);
         }
 
         /**
          * Parser error-reporting function, does nothing.
          * @param aRex the exception to be reported
          */
         public void reportError(RecognitionException aRex)
         {
         }
 
         /**
          * Parser error-reporting function, does nothing.
          * @param aMsg the error message
          */
         public void reportError(String aMsg)
         {
         }
 
         /**
          * Parser warning-reporting function, does nothing.
          * @param aMsg the error message
          */
         public void reportWarning(String aMsg)
         {
         }
     }
 
     /** configuration */
     private final Configuration mConfig;
 
     /** cache file **/
     private final PropertyCacheFile mCache;
 
     /** vector of listeners */
     private final ArrayList mListeners = new ArrayList();
 
     /**
      * Constructs the object.
      * @param aConfig contains the configuration to check with
      * @throws RESyntaxException unable to create a regexp object
      **/
     public Checker(Configuration aConfig)
         throws RESyntaxException
     {
         mConfig = aConfig;
         mCache = new PropertyCacheFile(aConfig);
         final Verifier v = new Verifier(aConfig);
         VerifierSingleton.setInstance(v);
+        LocalizedMessage.init(new Locale(mConfig.getLocaleLanguage()),
+                              mConfig.getClassLoader());
     }
 
     /** Cleans up the object **/
     public void destroy()
     {
         mCache.destroy();
         mListeners.clear();
     }
 
     /**
      * Add the listener that will be used to receive events from the audit
      * @param aListener the nosy thing
      */
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Processes a set of files.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(String[] aFiles)
     {
         int total = 0;
         fireAuditStarted();
 
         // If you move checkPackageHtml() around beware of the caching
         // functionality of checkstyle. Make sure that package.html
         // checks are not skipped because of caching. Otherwise you
         // might e.g. have a package.html file, check all java files
         // without errors, delete package.html and then recheck without
         // errors because the html file is not covered by the cache.
         total += checkPackageHtml(aFiles);
 
         for (int i = 0; i < aFiles.length; i++) {
             total += process(aFiles[i]);
         }
         fireAuditFinished();
         return total;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
      * @param aFileName the name of the file to process
@@ -318,62 +322,59 @@ public class Checker
     }
 
     /** notify all listeners about the audit end */
     protected void fireAuditFinished()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.auditFinished(evt);
         }
     }
 
     /**
      * notify all listeners about the beginning of a file audit
      * @param aFileName the file to be audited
      */
     protected void fireFileStarted(String aFileName)
     {
         final AuditEvent evt = new AuditEvent(this, aFileName);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.fileStarted(evt);
         }
     }
 
     /**
      * notify all listeners about the end of a file audit
      * @param aFileName the audited file
      */
     protected void fireFileFinished(String aFileName)
     {
         final AuditEvent evt = new AuditEvent(this, aFileName);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.fileFinished(evt);
         }
     }
 
     /**
      * notify all listeners about the errors in a file.
      * @param aFileName the audited file
      * @param aErrors the audit errors from the file
      */
     protected void fireErrors(String aFileName, LocalizedMessage[] aErrors)
     {
         for (int i = 0; i < aErrors.length; i++) {
             final AuditEvent evt =
-                new AuditEvent(this, aFileName,
-                               aErrors[i].getLineNo(),
-                               aErrors[i].getColumnNo(),
-                               aErrors[i].getMessage());
+                new AuditEvent(this, aFileName, aErrors[i]);
             final Iterator it = mListeners.iterator();
             while (it.hasNext()) {
                 final AuditListener listener = (AuditListener) it.next();
                 listener.addError(evt);
             }
         }
     }
 }
