diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
index b3a9aec48..f99c2a889 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
@@ -13,101 +13,107 @@
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Restricts the number of statements per line to one.
  * @author Alexander Jesse
  */
 public final class OneStatementPerLineCheck extends Check
 {
     /** hold the line-number where the last statement ended. */
     private int mLastStatementEnd = -1;
     /** tracks the depth of EXPR tokens. */
     private int mExprDepth;
 
     /**
      * The for-header usually has 3 statements on one line, but THIS IS OK.
      */
     private boolean mInForHeader;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.EXPR, TokenTypes.SEMI, TokenTypes.FOR_INIT,
             TokenTypes.FOR_ITERATOR,
         };
     }
 
     @Override
     public void beginTree(DetailAST aRootAST)
     {
         mExprDepth = 0;
         mInForHeader = false;
         mLastStatementEnd = -1;
     }
 
     @Override
     public void visitToken(DetailAST aAst)
     {
         switch (aAst.getType()) {
         case TokenTypes.EXPR:
-            startStatement(aAst);
+            visitExpr(aAst);
             break;
         case TokenTypes.SEMI:
-            startSemi(aAst);
+            visitSemi(aAst);
             break;
         case TokenTypes.FOR_INIT:
             mInForHeader = true;
             break;
         default:
             break;
         }
     }
 
     @Override
     public void leaveToken(DetailAST aAst)
     {
-        if (TokenTypes.FOR_ITERATOR == aAst.getType()) {
+        switch (aAst.getType()) {
+        case TokenTypes.FOR_ITERATOR:
             mInForHeader = false;
+            break;
+        case TokenTypes.EXPR:
+            mExprDepth--;
+            break;
+        default:
+            break;
         }
     }
 
     /**
      * Mark the state-change for the statement (entering) and remember the
      * first line of the last statement. If the first line of the new
      * statement is the same as the last line of the last statement and we are
      * not within a for-statement, then the rule is violated.
      * @param aAst token for the {@link TokenTypes#EXPR}.
      */
-    private void startStatement(DetailAST aAst)
+    private void visitExpr(DetailAST aAst)
     {
         mExprDepth++;
         if (mExprDepth == 1) {
             if (!mInForHeader && (mLastStatementEnd == aAst.getLineNo())) {
                 log(aAst, "multiple.statements.line");
             }
         }
     }
 
     /**
      * Mark the state-change for the statement (leaving) and remember the last
      * line of the last statement.
      * @param aAst for the {@link TokenTypes#SEMI}.
      */
-    private void startSemi(DetailAST aAst)
+    private void visitSemi(DetailAST aAst)
     {
-        mExprDepth--;
         if (mExprDepth == 0) {
             mLastStatementEnd = aAst.getLineNo();
         }
     }
-}
\ No newline at end of file
+}
