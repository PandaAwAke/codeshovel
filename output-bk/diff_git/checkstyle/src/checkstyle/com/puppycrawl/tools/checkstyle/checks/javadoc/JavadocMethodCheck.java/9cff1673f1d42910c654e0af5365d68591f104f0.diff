diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 27227a7ea..ff10c1996 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -319,103 +319,105 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
         final List<JavadocTag> tags = getMethodTags(aComment);
 
         if (hasShortCircuitTag(aAST, tags, aScope)) {
             return;
         }
 
         Iterator<JavadocTag> it = tags.iterator();
         if (aAST.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
                 hasInheritDocTag |= (it.next()).isInheritDocTag();
             }
 
             checkParamTags(tags, aAST, !hasInheritDocTag);
             checkThrowsTags(tags, getThrows(aAST), !hasInheritDocTag);
             if (isFunction(aAST)) {
                 checkReturnTag(tags, aAST.getLineNo(), !hasInheritDocTag);
             }
         }
 
         // Dump out all unused tags
         it = tags.iterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (!jt.isSeeOrInheritDocTag()) {
                 log(jt.getLineNo(), "javadoc.unusedTagGeneral");
             }
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param aAST the construct being checked
      * @param aTags the list of Javadoc tags associated with the construct
      * @param aScope the scope of the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST aAST,
             final List<JavadocTag> aTags, final Scope aScope)
     {
         // Check if it contains {@inheritDoc} tag
         if ((aTags.size() != 1)
                 || !(aTags.get(0)).isInheritDocTag())
         {
             return false;
         }
 
-        // Invalid if private or a constructor
+        // Invalid if private, a constructor, or a static method
         if ((aAST.getType() == TokenTypes.CTOR_DEF)
-                || (aScope == Scope.PRIVATE))
+                || (aScope == Scope.PRIVATE)
+                || (aAST.getType() == TokenTypes.METHOD_DEF
+                && aAST.branchContains(TokenTypes.LITERAL_STATIC)))
         {
             log(aAST, "javadoc.invalidInheritDoc");
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param aAST the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private Scope calculateScope(final DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         return ScopeUtils.inInterfaceOrAnnotationBlock(aAST) ? Scope.PUBLIC
                 : declaredScope;
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      *
      * @return the tags found
      * @param aComment the Javadoc comment
      */
     private List<JavadocTag> getMethodTags(TextBlock aComment)
     {
         final String[] lines = aComment.getText();
         final List<JavadocTag> tags = Lists.newArrayList();
         int currentLine = aComment.getStartLineNo() - 1;
 
         for (int i = 0; i < lines.length; i++) {
             currentLine++;
             final Matcher javadocArgMatcher =
                 MATCH_JAVADOC_ARG.matcher(lines[i]);
             final Matcher javadocNoargMatcher =
                 MATCH_JAVADOC_NOARG.matcher(lines[i]);
             final Matcher noargCurlyMatcher =
                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);
             final Matcher argMultilineStart =
                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);
             final Matcher noargMultilineStart =
                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);
 
             if (javadocArgMatcher.find()) {
