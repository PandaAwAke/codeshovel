diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
index f2b391865..5e8710f21 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -78,128 +78,131 @@ class TreeWalker
             Arrays.sort(acceptableTokens);
             final Iterator it = aConfig.getTokens().iterator();
             while (it.hasNext()) {
                 String token = (String) it.next();
                 int tokenId = TokenTypes.getTokenId(token);
                 if (Arrays.binarySearch(acceptableTokens, tokenId) >= 0) {
                     registerCheck(token, aCheck);
                 }
                 // TODO: else error message?
             }
         }
         else {
             final int[] tokens = aCheck.getDefaultTokens();
             for (int i = 0; i < tokens.length; i++) {
                 registerCheck(tokens[i], aCheck);
             }
         }
         mAllChecks.add(aCheck);
     }
 
     /**
      * Register a check for a specified token id.
      * @param aTokenID the id of the token
      * @param aCheck the check to register
      */
     private void registerCheck(int aTokenID, Check aCheck)
     {
         registerCheck(TokenTypes.getTokenName(aTokenID), aCheck);
     }
 
     /**
      * Register a check for a specified token name
      * @param aToken the name of the token
      * @param aCheck the check to register
      */
     private void registerCheck(String aToken, Check aCheck)
     {
         ArrayList visitors = (ArrayList) mTokenToChecks.get(aToken);
         if (visitors == null) {
             visitors = new ArrayList();
             mTokenToChecks.put(aToken, visitors);
         }
 
         visitors.add(aCheck);
     }
 
     /**
      * Initiates the walk of an AST.
      * @param aAST the root AST
      * @param aContents the contents of the file the AST was generated from
+     * @param aLoader the class loader for resolving classes
      */
-    void walk(DetailAST aAST, FileContents aContents)
+    void walk(DetailAST aAST, FileContents aContents, ClassLoader aLoader)
     {
         mMessages.reset();
-        notifyBegin(aContents);
+        notifyBegin(aContents, aLoader);
 
          // empty files are not flagged by javac, will yield aAST == null
         if (aAST != null) {
             aAST.setParent(null);
             process(aAST);
         }
 
         notifyEnd();
     }
 
     /**
      * Notify interested checks that about to begin walking a tree.
      * @param aContents the contents of the file the AST was generated from
+     * @param aLoader the class loader for resolving classes
      */
-    private void notifyBegin(FileContents aContents)
+    private void notifyBegin(FileContents aContents, ClassLoader aLoader)
     {
         // TODO: do not track Context properly for token
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             final HashMap treeContext = new HashMap();
             check.setTreeContext(treeContext);
             check.setFileContents(aContents);
+            check.setClassLoader(aLoader);
             check.beginTree();
         }
     }
 
     /**
      * Notify checks that finished walking a tree.
      */
     private void notifyEnd()
     {
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             check.finishTree();
         }
     }
 
     /**
      * Recursively processes a node calling interested checks at each node.
      * @param aAST the node to start from
      */
     private void process(DetailAST aAST)
     {
         if (aAST == null) {
             return;
         }
 
         notifyVisit(aAST);
 
         final DetailAST child = (DetailAST) aAST.getFirstChild();
         if (child != null) {
             child.setParent(aAST);
             process(child);
         }
 
         notifyLeave(aAST);
 
         final DetailAST sibling = (DetailAST) aAST.getNextSibling();
         if (sibling != null) {
             sibling.setParent(aAST.getParent());
             process(sibling);
         }
 
     }
 
     /**
      * Notify interested checks that visiting a node.
      * @param aAST the node to notify for
      */
     private void notifyVisit(DetailAST aAST)
     {
