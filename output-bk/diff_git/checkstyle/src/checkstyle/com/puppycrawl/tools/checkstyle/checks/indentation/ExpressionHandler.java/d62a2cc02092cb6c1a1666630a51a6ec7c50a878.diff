diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
index 447c9dd44..9bb8ea905 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
@@ -138,111 +138,111 @@ public abstract class ExpressionHandler
     /**
      * Log child indentation error.
      *
      * @param aLine           the expression that caused the error
      * @param aActualLevel   the actual indent level of the expression
      * @param aExpectedLevel the expected indent level of the expression
      */
     private void logChildError(int aLine,
                                int aActualLevel,
                                IndentLevel aExpectedLevel)
     {
         mIndentCheck.indentationLog(aLine, "indentation.child.error",
                 mTypeName, aActualLevel, aExpectedLevel);
     }
 
     /**
      * Determines if the given expression is at the start of a line.
      *
      * @param aAst   the expression to check
      *
      * @return true if it is, false otherwise
      */
     protected final boolean startsLine(DetailAST aAst)
     {
         return getLineStart(aAst) == expandedTabsColumnNo(aAst);
     }
 
     /**
      * Determines if two expressions are on the same line.
      *
      * @param aAst1   the first expression
      * @param aAst2   the second expression
      *
      * @return true if they are, false otherwise
      */
     static boolean areOnSameLine(DetailAST aAst1, DetailAST aAst2)
     {
         return (aAst1 != null) && (aAst2 != null)
             && (aAst1.getLineNo() == aAst2.getLineNo());
     }
 
     /**
      * Searchs in given sub-tree (including given node) for the token
      * which represents first symbol for this sub-tree in file.
      * @param aAST a root of sub-tree in which the search shoul be performed.
      * @return a token which occurs first in the file.
      */
     static DetailAST getFirstToken(DetailAST aAST)
     {
         DetailAST first = aAST;
-        DetailAST child = (DetailAST) aAST.getFirstChild();
+        DetailAST child = aAST.getFirstChild();
 
         while (child != null) {
             final DetailAST toTest = getFirstToken(child);
             if ((toTest.getLineNo() < first.getLineNo())
                 || ((toTest.getLineNo() == first.getLineNo())
                     && (toTest.getColumnNo() < first.getColumnNo())))
             {
                 first = toTest;
             }
-            child = (DetailAST) child.getNextSibling();
+            child = child.getNextSibling();
         }
 
         return first;
     }
 
     /**
      * Get the start of the line for the given expression.
      *
      * @param aAst   the expression to find the start of the line for
      *
      * @return the start of the line for the given expression
      */
     protected final int getLineStart(DetailAST aAst)
     {
         final String line = mIndentCheck.getLines()[aAst.getLineNo() - 1];
         return getLineStart(line);
     }
 
     // TODO: this whole checking of consecuitive/expression line indents is
     // smelling pretty bad... and is in serious need of pruning.  But, I
     // want to finish the invalid tests before I start messing around with
     // it.
 
     /**
      * Check the indentation of consecutive lines for the expression we are
      * handling.
      *
      * @param aStartLine     the first line to check
      * @param aEndLine       the last line to check
      * @param aIndentLevel   the required indent level
      */
     protected final void checkLinesIndent(int aStartLine, int aEndLine,
                                           IndentLevel aIndentLevel)
     {
         // check first line
         checkSingleLine(aStartLine, aIndentLevel);
 
         // check following lines
         aIndentLevel = new IndentLevel(aIndentLevel, getBasicOffset());
         for (int i = aStartLine + 1; i <= aEndLine; i++) {
             checkSingleLine(i, aIndentLevel);
         }
     }
 
     /**
      * @return true if indentation should be increased after
      *              fisrt line in checkLinesIndent()
      *         false otherwise
      */
     protected boolean shouldIncreaseIndent()
@@ -342,238 +342,238 @@ public abstract class ExpressionHandler
         // error if this statement starts the line and it is less than
         // the correct indentation level
         if (aMustMatch ? !aIndentLevel.accept(start)
             : (aColNum == start) && aIndentLevel.gt(start))
         {
             logChildError(aLineNum, start, aIndentLevel);
         }
     }
 
     /**
      * Get the start of the specified line.
      *
      * @param aLine   the specified line number
      *
      * @return the start of the specified line
      */
     protected final int getLineStart(String aLine)
     {
         for (int start = 0; start < aLine.length(); start++) {
             final char c = aLine.charAt(start);
 
             if (!Character.isWhitespace(c)) {
                 return Utils.lengthExpandedTabs(
                     aLine, start, mIndentCheck.getIndentationTabWidth());
             }
         }
         return 0;
     }
 
     // TODO: allowNesting either shouldn't be allowed with
     //  firstLineMatches, or I should change the firstLineMatches logic
     //  so it doesn't match if the first line is nested
 
     /**
      * Check the indent level of the children of the specified parent
      * expression.
      *
      * @param aParent             the parent whose children we are checking
      * @param aTokenTypes         the token types to check
      * @param aStartLevel         the starting indent level
      * @param aFirstLineMatches   whether or not the first line needs to match
      * @param aAllowNesting       whether or not nested children are allowed
      */
     protected final void checkChildren(DetailAST aParent,
                                        int[] aTokenTypes,
                                        IndentLevel aStartLevel,
                                        boolean aFirstLineMatches,
                                        boolean aAllowNesting)
     {
         Arrays.sort(aTokenTypes);
-        for (DetailAST child = (DetailAST) aParent.getFirstChild();
+        for (DetailAST child = aParent.getFirstChild();
                 child != null;
-                child = (DetailAST) child.getNextSibling())
+                child = child.getNextSibling())
         {
             if (Arrays.binarySearch(aTokenTypes, child.getType()) >= 0) {
                 checkExpressionSubtree(child, aStartLevel,
                     aFirstLineMatches, aAllowNesting);
             }
         }
     }
 
     /**
      * Check the indentation level for an expression subtree.
      *
      * @param aTree               the expression subtree to check
      * @param aLevel              the indentation level
      * @param aFirstLineMatches   whether or not the first line has to match
      * @param aAllowNesting       whether or not subtree nesting is allowed
      */
     protected final void checkExpressionSubtree(
         DetailAST aTree,
         IndentLevel aLevel,
         boolean aFirstLineMatches,
         boolean aAllowNesting
     )
     {
         final LineSet subtreeLines = new LineSet();
         final int firstLine = getFirstLine(Integer.MAX_VALUE, aTree);
         if (aFirstLineMatches && !aAllowNesting) {
             subtreeLines.addLineAndCol(firstLine,
                 getLineStart(mIndentCheck.getLines()[firstLine - 1]));
         }
         findSubtreeLines(subtreeLines, aTree, aAllowNesting);
 
         checkLinesIndent(subtreeLines, aLevel, aFirstLineMatches, firstLine);
     }
 
     /**
      * Get the first line for a given expression.
      *
      * @param aStartLine   the line we are starting from
      * @param aTree        the expression to find the first line for
      *
      * @return the first line of the expression
      */
     protected final int getFirstLine(int aStartLine, DetailAST aTree)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
         // the interface methods... I should ask about this
 
         final int currLine = aTree.getLineNo();
         if (currLine < aStartLine) {
             aStartLine = currLine;
         }
 
         // check children
-        for (DetailAST node = (DetailAST) aTree.getFirstChild();
+        for (DetailAST node = aTree.getFirstChild();
             node != null;
-            node = (DetailAST) node.getNextSibling())
+            node = node.getNextSibling())
         {
             aStartLine = getFirstLine(aStartLine, node);
         }
 
         return aStartLine;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param aAST   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     protected final int expandedTabsColumnNo(DetailAST aAST)
     {
         final String line =
             mIndentCheck.getLines()[aAST.getLineNo() - 1];
 
         return Utils.lengthExpandedTabs(line, aAST.getColumnNo(),
             mIndentCheck.getIndentationTabWidth());
     }
 
     /**
      * Find the set of lines for a given subtree.
      *
      * @param aLines          the set of lines to add to
      * @param aTree           the subtree to examine
      * @param aAllowNesting   whether or not to allow nested subtrees
      */
     protected final void findSubtreeLines(LineSet aLines, DetailAST aTree,
         boolean aAllowNesting)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
         // the interface methods... I should ask about this
 
         if (getIndentCheck().getHandlerFactory().isHandledType(aTree.getType())
             || (aTree.getLineNo() < 0))
         {
             return;
         }
 
         // TODO: the problem with this is that not all tree tokens actually
         // have the right column number -- I should get a list of these
         // and verify that checking nesting this way won't cause problems
 //          if (aAllowNesting && aTree.getColumnNo() != getLineStart(aTree)) {
 //              return;
 //          }
 
         final int lineNum = aTree.getLineNo();
         final Integer colNum = aLines.getStartColumn(lineNum);
 
         final int thisLineColumn = expandedTabsColumnNo(aTree);
         if ((colNum == null) || (thisLineColumn < colNum.intValue())) {
             aLines.addLineAndCol(lineNum, thisLineColumn);
         }
 
         // check children
-        for (DetailAST node = (DetailAST) aTree.getFirstChild();
+        for (DetailAST node = aTree.getFirstChild();
             node != null;
-            node = (DetailAST) node.getNextSibling())
+            node = node.getNextSibling())
         {
             findSubtreeLines(aLines, node, aAllowNesting);
         }
     }
 
     /**
      * Check the indentation level of modifiers.
      */
     protected final void checkModifiers()
     {
         final DetailAST modifiers =
             mMainAst.findFirstToken(TokenTypes.MODIFIERS);
-        for (DetailAST modifier = (DetailAST) modifiers.getFirstChild();
+        for (DetailAST modifier = modifiers.getFirstChild();
              modifier != null;
-             modifier = (DetailAST) modifier.getNextSibling())
+             modifier = modifier.getNextSibling())
         {
             /*
             if (!areOnSameLine(modifier, prevExpr)) {
                 continue;
             }
             */
             if (startsLine(modifier)
                 && !getLevel().accept(expandedTabsColumnNo(modifier)))
             {
                 logError(modifier, "modifier",
                     expandedTabsColumnNo(modifier));
             }
         }
     }
 
     /**
      * Check the indentation of the expression we are handling.
      */
     public abstract void checkIndentation();
 
     /**
      * Accessor for the IndentCheck attribute.
      *
      * @return the IndentCheck attribute
      */
     protected final IndentationCheck getIndentCheck()
     {
         return mIndentCheck;
     }
 
     /**
      * Accessor for the MainAst attribute.
      *
      * @return the MainAst attribute
      */
     protected final DetailAST getMainAst()
     {
         return mMainAst;
     }
 
     /**
      * Accessor for the Parent attribute.
      *
      * @return the Parent attribute
      */
     protected final ExpressionHandler getParent()
     {
         return mParent;
     }
 
