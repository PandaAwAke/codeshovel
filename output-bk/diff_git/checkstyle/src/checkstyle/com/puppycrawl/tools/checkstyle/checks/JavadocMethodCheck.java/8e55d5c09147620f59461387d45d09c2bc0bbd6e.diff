diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index 66c1d9fd9..4879263f6 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -61,100 +61,107 @@ import org.apache.regexp.RE;
  *    &lt;property name="scope" value="public"/&gt;
  *    &lt;property name="checkUnusedThrows" value="true"/&gt;
  * &lt;/check&gt;
  * </pre>
  *
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @author Rick Giles
  * @version 1.0
  */
 public class JavadocMethodCheck
     extends AbstractImportCheck
 {
 
        // {{{ Data declarations
     /** the pattern to match Javadoc tags that take an argument **/
     private static final String MATCH_JAVADOC_ARG_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s+\\S";
     /** compiled regexp to match Javadoc tags that take an argument **/
     private static final RE MATCH_JAVADOC_ARG =
         Utils.createRE(MATCH_JAVADOC_ARG_PAT);
 
    /**
     * the pattern to match the first line of a multi-line Javadoc
     * tag that takes an argument. Javadoc with no arguments isn't
     * allowed to go over multiple lines.
     **/
     private static final String MATCH_JAVADOC_MULTILINE_START_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s*$";
     /** compiled regexp to match first part of multilineJavadoc tags **/
     private static final RE MATCH_JAVADOC_MULTILINE_START =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_START_PAT);
 
     /** the pattern that looks for a continuation of the comment **/
     private static final String MATCH_JAVADOC_MULTILINE_CONT_PAT =
         "(\\*/|@|[^\\s\\*])";
     /** compiled regexp to look for a continuation of the comment **/
     private static final RE MATCH_JAVADOC_MULTILINE_CONT =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_CONT_PAT);
     /** Multiline finished at end of comment **/
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc **/
     private static final String NEXT_TAG = "@";
 
     /** the pattern to match Javadoc tags with no argument **/
     private static final String MATCH_JAVADOC_NOARG_PAT =
         "@(return|see|author)\\s+\\S";
     /** compiled regexp to match Javadoc tags with no argument **/
     private static final RE MATCH_JAVADOC_NOARG =
         Utils.createRE(MATCH_JAVADOC_NOARG_PAT);
 
+    /** the pattern to match Javadoc tags with no argument and {} **/
+    private static final String MATCH_JAVADOC_NOARG_CURLY_PAT =
+        "\\{\\s*@(inheritDoc)\\s*\\}";
+    /** compiled regexp to match Javadoc tags with no argument and {} **/
+    private static final RE MATCH_JAVADOC_NOARG_CURLY =
+        Utils.createRE(MATCH_JAVADOC_NOARG_CURLY_PAT);
+
     /** full identifier for package of the method **/
     private FullIdent mPackageFullIdent = null;
 
     /** imports details **/
     private Set mImports = new HashSet();
 
     /** the visibility scope where Javadoc comments are checked **/
     private Scope mScope = Scope.PRIVATE;
 
     /** check for unused throws **/
     private boolean mCheckUnusedThrows = false;
 
     /**
      * Set the scope.
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set whether to check for unused throws.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setCheckUnusedThrows(boolean aFlag)
     {
         mCheckUnusedThrows = aFlag;
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree()
     {
         mPackageFullIdent = FullIdent.createFullIdent(null);
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
@@ -195,141 +202,145 @@ public class JavadocMethodCheck
         final FullIdent name = getImportText(aAST);
         if (name != null) {
             mImports.add(name.getText());
         }
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     private void processMethod(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope targetScope =
             ScopeUtils.inInterfaceBlock(aAST)
                 ? Scope.PUBLIC
                 : declaredScope;
 
         if (targetScope.isIn(mScope)) {
             final Scope surroundingScope =
                 ScopeUtils.getSurroundingScope(aAST);
 
             if (surroundingScope.isIn(mScope)) {
                 final FileContents contents = getFileContents();
                 final String[] cmt =
                     contents.getJavadocBefore(aAST.getLineNo());
 
                 if (cmt == null) {
                     log(aAST.getLineNo(),
                         aAST.getColumnNo(),
                         "javadoc.missing");
                 }
                 else {
                     checkComment(aAST, cmt);
                 }
             }
         }
     }
 
     /**
      * Checks the Javadoc for a method.
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
      */
     private void checkComment(DetailAST aAST, String[] aComment)
     {
         final List tags = getMethodTags(aComment, aAST.getLineNo() - 1);
         // Check for only one @see tag
         if ((tags.size() != 1)
-            || !((JavadocTag) tags.get(0)).isSeeTag())
+            || !((JavadocTag) tags.get(0)).isSeeOrInheritDocTag())
         {
             checkParamTags(tags, getParameters(aAST));
             checkThrowsTags(tags, getThrows(aAST));
             if (isFunction(aAST)) {
                 checkReturnTag(tags, aAST.getLineNo());
             }
 
             // Dump out all unused tags
             final Iterator it = tags.iterator();
             while (it.hasNext()) {
                 final JavadocTag jt = (JavadocTag) it.next();
-                if (!jt.isSeeTag()) {
+                if (!jt.isSeeOrInheritDocTag()) {
                     log(jt.getLineNo(), "javadoc.unusedTagGeneral");
                 }
             }
         }
     }
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      * @return the tags found
      * @param aLines the Javadoc comment
      * @param aLastLineNo the line number of the last line in the Javadoc
      *                    comment
      **/
     private List getMethodTags(String[] aLines, int aLastLineNo)
     {
         final List tags = new ArrayList();
         int currentLine = aLastLineNo - aLines.length;
         for (int i = 0; i < aLines.length; i++) {
             currentLine++;
             if (MATCH_JAVADOC_ARG.match(aLines[i])) {
                 tags.add(new JavadocTag(currentLine,
                                         MATCH_JAVADOC_ARG.getParen(1),
                                         MATCH_JAVADOC_ARG.getParen(2)));
             }
             else if (MATCH_JAVADOC_NOARG.match(aLines[i])) {
                 tags.add(new JavadocTag(currentLine,
                                         MATCH_JAVADOC_NOARG.getParen(1)));
             }
+            else if (MATCH_JAVADOC_NOARG_CURLY.match(aLines[i])) {
+                tags.add(new JavadocTag(currentLine,
+                                        MATCH_JAVADOC_NOARG_CURLY.getParen(1)));
+            }
             else if (MATCH_JAVADOC_MULTILINE_START.match(aLines[i])) {
                 final String p1 = MATCH_JAVADOC_MULTILINE_START.getParen(1);
                 final String p2 = MATCH_JAVADOC_MULTILINE_START.getParen(2);
 
                 // Look for the rest of the comment if all we saw was
                 // the tag and the name. Stop when we see '*/' (end of
                 // Javadoc, '@' (start of next tag), or anything that's
                 // not whitespace or '*' characters.
                 int remIndex = i + 1;
                 while (remIndex < aLines.length) {
                     if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {
                         remIndex = aLines.length;
                         String lFin = MATCH_JAVADOC_MULTILINE_CONT.getParen(1);
                         if (!lFin.equals(NEXT_TAG)
                             && !lFin.equals(END_JAVADOC))
                         {
                             tags.add(new JavadocTag(currentLine, p1, p2));
                         }
                     }
                     remIndex++;
                 }
             }
         }
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      * @param aAST the method node.
      * @return the list of parameter nodes for aAST.
      **/
     private List getParameters(DetailAST aAST)
     {
         final DetailAST params = aAST.findFirstToken(TokenTypes.PARAMETERS);
         final List retVal = new ArrayList();
 
         DetailAST child = (DetailAST) params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = (DetailAST) child.getNextSibling();
         }
         return retVal;
     }
 
      /**
      * Computes the exception nodes for a method.
      * @param aAST the method node.
