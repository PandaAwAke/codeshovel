diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index da5a493c4..3d398190f 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -673,101 +673,116 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), jt.getColumnNo(),
                         "javadoc.duplicateTag",
                         JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !mAllowMissingReturnTag && aReportExpectedTags) {
             log(aLineNo, "javadoc.return.expected");
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param aTags the tags to check
      * @param aThrows the throws to check
      * @param aReportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> aTags,
             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)
     {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
         final ListIterator<JavadocTag> tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag
                     .getColumnNo());
             final ClassInfo documentedCI = createClassInfo(token,
                     getCurrentClassName());
             boolean found = foundThrows.contains(documentedEx);
 
-            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();
+            // First look for matches on the exception name
+            ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();
+            while (!found && throwIt.hasNext()) {
+                final ExceptionInfo ei = throwIt.next();
+
+                if (ei.getName().getText().equals(
+                        documentedCI.getName().getText()))
+                {
+                    found = true;
+                    ei.setFound();
+                    foundThrows.add(documentedEx);
+                }
+            }
+
+            // Now match on the exception type
+            throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final ExceptionInfo ei = throwIt.next();
 
                 if (documentedCI.getClazz() == ei.getClazz()) {
                     found = true;
                     ei.setFound();
                     foundThrows.add(documentedEx);
                 }
                 else if (mAllowThrowsTagsForSubclasses) {
                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (mAllowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedCI.getClazz());
                 }
 
                 if (reqd) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         "javadoc.unusedTag",
                         JavadocTagInfo.THROWS.getText(), tag.getArg1());
 
                 }
             }
         }
 
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!mAllowMissingThrowsTags && aReportExpectedTags) {
             for (ExceptionInfo ei : aThrows) {
                 if (!ei.isFound()) {
                     final Token fi = ei.getName();
                     log(fi.getLineNo(), fi.getColumnNo(),
                         "javadoc.expectedTag",
                         JavadocTagInfo.THROWS.getText(), fi.getText());
                 }
             }
         }
     }
 
     /**
      * Returns whether an AST represents a setter method.
      * @param aAST the AST to check with
      * @return whether the AST represents a setter method
      */
     private boolean isSetterMethod(final DetailAST aAST)
     {
