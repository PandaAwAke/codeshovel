diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
index 3cb6eef4f..7d94201c0 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
@@ -73,139 +73,146 @@ public abstract class ExpressionHandler
     }
 
     /**
      * Get the indentation amount for this handler. For performance reasons,
      * this value is cached. The first time this method is called, the
      * indentation amount is computed and stored. On further calls, the stored
      * value is returned.
      *
      * @return the expected indentation amount
      */
     public int getLevel()
     {
         if (mLevel == UNINITIALIZED) {
             mLevel = getLevelImpl();
         }
         return mLevel;
     }
 
     /**
      * Compute the indentation amount for this handler.
      *
      * @return the expected indentation amount
      */
     protected int getLevelImpl()
     {
         return mParent.suggestedChildLevel(this);
     }
 
     /**
      * Indentation level suggested for a child element. Children don't have
      * to respect this, but most do.
      *
      * @param aChild  child AST (so suggestion level can differ based on child
      *                  type)
      *
      * @return suggested indentation for child
      */
     public int suggestedChildLevel(ExpressionHandler aChild)
     {
         return getLevel() + mIndentCheck.getBasicOffset();
     }
 
     /**
      * Log an indentation error.
      *
      * @param aAst           the expression that caused the error
      * @param aSubtypeName   the type of the expression
      * @param aActualLevel    the actual indent level of the expression
      */
     protected void logError(DetailAST aAst, String aSubtypeName,
-        int aActualLevel)
+                            int aActualLevel)
     {
-        // TODO: i18n
-        String typeStr = (aSubtypeName == "" ? "" : (" " + aSubtypeName));
-        mIndentCheck.indentationLog(aAst.getLineNo(), mTypeName + typeStr
-            + " at indentation level "
-            + aActualLevel + " not at correct indentation, " + getLevel());
+        logError(aAst, aSubtypeName, aActualLevel, getLevel());
     }
 
     /**
      * Log an indentation error.
      *
      * @param aAst           the expression that caused the error
      * @param aSubtypeName   the type of the expression
      * @param aActualLevel   the actual indent level of the expression
      * @param aExpectedLevel the expected indent level of the expression
      */
     protected void logError(DetailAST aAst, String aSubtypeName,
-        int aActualLevel, int aExpectedLevel)
+                            int aActualLevel, int aExpectedLevel)
     {
-        // TODO: i18n
         String typeStr = (aSubtypeName == "" ? "" : (" " + aSubtypeName));
-        mIndentCheck.indentationLog(aAst.getLineNo(), mTypeName + typeStr
-            + " at indentation level " + aActualLevel
-            + " not at correct indentation, " + aExpectedLevel);
+        Object[] args = new Object[] {
+            mTypeName + typeStr,
+            new Integer(aActualLevel),
+            new Integer(aExpectedLevel),
+        };
+        mIndentCheck.indentationLog(aAst.getLineNo(),
+                                    "indentation.error",
+                                    args);
     }
 
     /**
-     * Log an indentation error.
+     * Log child indentation error.
      *
-     * @param aAst           the expression that caused the error
-     * @param aSubtypeName   the type of the expression
+     * @param aLine           the expression that caused the error
+     * @param aActualLevel   the actual indent level of the expression
+     * @param aExpectedLevel the expected indent level of the expression
      */
-    protected void logError(DetailAST aAst, String aSubtypeName)
+    protected void logChildError(int aLine,
+                                 int aActualLevel,
+                                 int aExpectedLevel)
     {
-        String typeStr = (aSubtypeName == "" ? "" : (" " + aSubtypeName));
-        mIndentCheck.indentationLog(aAst.getLineNo(), mTypeName + typeStr
-            + " at indentation level not at correct indentation, "
-            + getLevel());
+        Object[] args = new Object[] {
+            mTypeName,
+            new Integer(aActualLevel),
+            new Integer(aExpectedLevel),
+        };
+        mIndentCheck.indentationLog(aLine,
+                                    "indentation.child.error",
+                                    args);
     }
 
     /**
      * Determines if the given expression is at the start of a line.
      *
      * @param aAst   the expression to check
      *
      * @return true if it is, false otherwise
      */
     protected boolean startsLine(DetailAST aAst)
     {
         return getLineStart(aAst) == expandedTabsColumnNo(aAst);
     }
 
     /**
      * Determines if two expressions are on the same line.
      *
      * @param aAst1   the first expression
      * @param aAst2   the second expression
      *
      * @return true if they are, false otherwise
      */
     protected boolean areOnSameLine(DetailAST aAst1, DetailAST aAst2)
     {
         return aAst1 != null && aAst2 != null
             && aAst1.getLineNo() == aAst2.getLineNo();
     }
 
     /**
      * Determines if the gieven parent expression is equal to or greater than
      * the correct indentation level.
      *
      * @param aParent   the parent expression
      *
      * @return true if it is, false otherwise
      */
     protected boolean atLevelOrGreater(DetailAST aParent)
     {
         if (expandedTabsColumnNo(aParent) < getLevel()) {
             return false;
         }
 
         for (DetailAST child = aParent.getLastChild(); child != null;
             child = child.getPreviousSibling())
         {
             if (!atLevelOrGreater(child)) {
                 return false;
             }
         }
         return true;
@@ -216,103 +223,101 @@ public abstract class ExpressionHandler
      *
      * @param aAst   the expression to find the start of the line for
      *
      * @return the start of the line for the given expression
      */
     protected int getLineStart(DetailAST aAst)
     {
         // TODO: this breaks indentation -- add to tests
         String line = mIndentCheck.getLines()[
             aAst.getLineNo() - 1];
         return getLineStart(line);
     }
 
     // TODO: this whole checking of consecuitive/expression line indents is
     // smelling pretty bad... and is in serious need of pruning.  But, I
     // want to finish the invalid tests before I start messing around with
     // it.
 
     /**
      * Check the indentation of consecutive lines for the expression we are
      * handling.
      *
      * @param aStartLine     the first line to check
      * @param aEndLine       the last line to check
      * @param aIndentLevel   the required indent level
      */
     protected void checkLinesIndent(int aStartLine, int aEndLine,
         int aIndentLevel)
     {
         // check first line
         checkSingleLine(aStartLine, aIndentLevel);
 
         // check following lines
         aIndentLevel += mIndentCheck.getBasicOffset();
         for (int i = aStartLine + 1; i <= aEndLine; i++) {
             checkSingleLine(i, aIndentLevel);
         }
     }
 
     /**
      * Check the indent level for a single line.
      *
      * @param aLineNum       the line number to check
      * @param aIndentLevel   the required indent level
      */
     private void checkSingleLine(int aLineNum, int aIndentLevel)
     {
         String line = mIndentCheck.getLines()[aLineNum - 1];
         int start = getLineStart(line);
         if (start < aIndentLevel) {
-            mIndentCheck.indentationLog(aLineNum,
-                mTypeName + " child at indentation level "
-                + start + " not at correct indentation, " + aIndentLevel);
+            logChildError(aLineNum, start, aIndentLevel);
         }
     }
 
     /**
      * Get the start of the specified line.
      *
      * @param aLine   the specified line number
      *
      * @return the start of the specified line
      */
     protected int getLineStart(String aLine)
     {
         for (int start = 0; start < aLine.length(); start++) {
             char c = aLine.charAt(start);
 
             if (!Character.isWhitespace(c)) {
                 return Utils.lengthExpandedTabs(
                     aLine, start, mIndentCheck.getIndentationTabWidth());
             }
         }
         return 0;
     }
 
     // TODO: allowNesting either shouldn't be allowed with
     //  firstLineMatches, or I should change the firstLineMatches logic
     //  so it doesn't match if the first line is nested
 
     /**
      * Check the indent level of the children of the specified parent
      * expression.
      *
      * @param aParent             the parent whose children we are checking
      * @param aTokenTypes         the token types to check
      * @param aStartLevel         the starting indent level
      * @param aFirstLineMatches   whether or not the first line needs to match
      * @param aAllowNesting       whether or not nested children are allowed
      */
     protected void checkChildren(DetailAST aParent, int[] aTokenTypes,
         int aStartLevel,
         boolean aFirstLineMatches, boolean aAllowNesting)
     {
         Arrays.sort(aTokenTypes);
         for (DetailAST child = (DetailAST) aParent.getFirstChild();
                 child != null;
                 child = (DetailAST) child.getNextSibling())
         {
             if (Arrays.binarySearch(aTokenTypes, child.getType()) >= 0) {
                 checkExpressionSubtree(child, aStartLevel,
                     aFirstLineMatches, aAllowNesting);
             }
@@ -397,104 +402,101 @@ public abstract class ExpressionHandler
         }
 
         // check following lines
         for (int i = startLine + 1; i <= endLine; i++) {
             Integer col = aLines.getStartColumn(new Integer(i));
             // startCol could be null if this line didn't have an
             // expression that was required to be checked (it could be
             // checked by a child expression)
 
             // TODO: not sure if this does anything, look at taking it out
 
             // TODO: we can check here if this line starts or the previous
             // line ends in a dot.  If so, we should increase the indent.
 
             // TODO: check if -2 is possible here?  but unlikely to be a
             // problem...
             String thisLine = mIndentCheck.getLines()[i - 1];
             String prevLine = mIndentCheck.getLines()[i - 2];
             if (thisLine.matches("^\\s*\\.")
                 || prevLine.matches("\\.\\s*$"))
             {
                 aIndentLevel += mIndentCheck.getBasicOffset();
             }
 
             if (col != null) {
                 checkSingleLine(i, col.intValue(), aIndentLevel, false);
             }
         }
     }
 
     /**
      * Check the indentation for a single line.
      *
      * @param aLineNum       the number of the line to check
      * @param aColNum        the column number we are starting at
      * @param aIndentLevel   the indentation level
      * @param aMustMatch     whether or not the indentation level must match
      */
     private void checkSingleLine(int aLineNum, int aColNum,
         int aIndentLevel, boolean aMustMatch)
     {
         String line = mIndentCheck.getLines()[aLineNum - 1];
         int start = getLineStart(line);
         // if must match is set, it is an error if the line start is not
         // at the correct indention level; otherwise, it is an only an
         // error if this statement starts the line and it is less than
         // the correct indentation level
         if (aMustMatch ? start != aIndentLevel
             : aColNum == start && start < aIndentLevel)
         {
-            // TODO: i18n or use logError
-            mIndentCheck.indentationLog(aLineNum, mTypeName
-                + " child at indentation level " + start
-                + " not at correct indentation, " + aIndentLevel);
+            logChildError(aLineNum, start, aIndentLevel);
         }
     }
 
     /**
      * Get the first line for a given expression.
      *
      * @param aStartLine   the line we are starting from
      * @param aTree        the expression to find the first line for
      *
      * @return the first line of the expression
      */
     private int getFirstLine(int aStartLine, DetailAST aTree)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
         // the interface methods... I should ask about this
 
         int currLine = aTree.getLineNo();
         if (currLine < aStartLine) {
             aStartLine = currLine;
         }
 
         // check children
         for (DetailAST node = (DetailAST) aTree.getFirstChild();
             node != null;
             node = (DetailAST) node.getNextSibling())
         {
             aStartLine = getFirstLine(aStartLine, node);
         }
 
         return aStartLine;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param aAst   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     protected int expandedTabsColumnNo(DetailAST aAst)
     {
         String line =
             mIndentCheck.getLines()[aAst.getLineNo() - 1];
 
         return Utils.lengthExpandedTabs(line, aAst.getColumnNo(),
             mIndentCheck.getIndentationTabWidth());
     }
 
