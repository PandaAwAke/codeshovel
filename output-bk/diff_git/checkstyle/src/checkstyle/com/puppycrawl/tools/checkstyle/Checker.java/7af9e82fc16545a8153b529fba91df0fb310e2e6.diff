diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index 7925c43ed..c591acc58 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -1,76 +1,77 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle;
 
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessages;
 import com.puppycrawl.tools.checkstyle.api.Utils;
+import com.puppycrawl.tools.checkstyle.api.FileContents;
 import org.apache.regexp.RESyntaxException;
 import org.xml.sax.SAXException;
 
 import javax.xml.parsers.ParserConfigurationException;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.Reader;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Locale;
 
 /**
  * This class provides the functionality to check a set of files.
  * @author <a href="mailto:oliver@puppycrawl.com">Oliver Burn</a>
  * @author <a href="mailto:stephane.bailliez@wanadoo.fr">Stephane Bailliez</a>
  */
 public class Checker
     implements Defn
 {
     /**
      * Overrides ANTLR error reporting so we completely control
      * checkstyle's output during parsing. This is important because
      * we try parsing with several grammers (with/without support for
      * <code>assert</code>). We must not write any error messages when
      * parsing fails because with the next grammar it might succeed
      * and the user will be confused.
      */
     private class SilentJava14Recognizer extends GeneratedJava14Recognizer
     {
         // TODO: remove
         /**
          * Creates a new <code>SilentJava14Recognizer</code> instance.
          *
          * @param aLexer the tokenstream the recognizer operates on.
          */
         private SilentJava14Recognizer(GeneratedJava14Lexer aLexer)
         {
             super(aLexer);
         }
 
         /**
          * Parser error-reporting function, does nothing.
          * @param aRex the exception to be reported
          */
         public void reportError(RecognitionException aRex)
         {
         }
@@ -367,181 +368,177 @@ public class Checker
         catch (TokenStreamException te) {
             errors = new LocalizedMessage[] {
                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                      "general.exception",
                                      new String[] {te.getMessage()})};
         }
 
         if (errors.length == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(stripped, errors);
         }
 
         fireFileFinished(stripped);
         return errors.length;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
      * @param aFileName the name of the file to process
      **/
     private int processNEW(String aFileName)
     {
         // TODO: blow away the old process and rename this one
 
         // check if already checked and passed the file
         final File f = new File(aFileName);
         final long timestamp = f.lastModified();
         if (mCache.alreadyChecked(aFileName, timestamp)) {
             return 0;
         }
 
         // Create a stripped down version
         final String stripped;
         final String basedir = mConfig.getBasedir();
         if ((basedir == null) || !aFileName.startsWith(basedir)) {
             stripped = aFileName;
         }
         else {
             // making the assumption that there is text after basedir
             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;
             stripped = aFileName.substring(basedir.length() + skipSep);
         }
 
         mMessages.reset();
         try {
             fireFileStarted(stripped);
             final String[] lines = Utils.getLines(aFileName);
-            final CommentManager cmgr = new CommentManager(lines);
-            DetailAST rootAST = parse(lines, aFileName, cmgr);
-            // ParseTreeInfoPanel.show(rootAST);
-            mWalker.walk(rootAST, lines, aFileName);
+            final FileContents contents = new FileContents(aFileName, lines);
+            final DetailAST rootAST = parse(contents);
+            mWalker.walk(rootAST, contents);
         }
         catch (FileNotFoundException fnfe) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.fileNotFound", null));
         }
         catch (IOException ioe) {
             mMessages.add(new LocalizedMessage(
                               0, Defn.CHECKSTYLE_BUNDLE,
                               "general.exception",
                               new String[] {ioe.getMessage()}));
         }
         catch (RecognitionException re) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {re.getMessage()}));
         }
         catch (TokenStreamException te) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {te.getMessage()}));
         }
 
         if (mMessages.size() == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(stripped, mMessages.getMessages());
         }
 
         fireFileFinished(stripped);
         return mMessages.size();
     }
 
     /**
      *
-     * @param aLines the individual lines of the java file
-     * @param aFileName the filename of the file (used for error messages?)
-     * @param aCmgr the comment manager is informed of comments during parsing
+     * @param aContents contains the contents of the file
      * @return the root of the AST
      * @throws TokenStreamException if lexing failed
      * @throws RecognitionException if parsing failed
      */
-    public static DetailAST parse(
-            final String[] aLines, String aFileName, final CommentManager aCmgr)
-            throws TokenStreamException, RecognitionException
+    public static DetailAST parse(FileContents aContents)
+        throws TokenStreamException, RecognitionException
     {
         DetailAST rootAST;
         try {
             // try the 1.4 grammar first, this will succeed for
             // all code that compiles without any warnings in JDK 1.4,
             // that should cover most cases
-            final Reader sar = new StringArrayReader(aLines);
+            final Reader sar = new StringArrayReader(aContents.getLines());
             final Java14Lexer jl = new Java14Lexer(sar);
-            jl.setFilename(aFileName);
-            jl.setCommentManager(aCmgr);
+            jl.setFilename(aContents.getFilename());
+            jl.setFileContents(aContents);
 
             final Java14Recognizer jr =
                 new NEWSilentJava14Recognizer(jl);
-            jr.setFilename(aFileName);
+            jr.setFilename(aContents.getFilename());
             jr.setASTNodeClass(DetailAST.class.getName());
             jr.compilationUnit();
             rootAST = (DetailAST) jr.getAST();
         }
         catch (RecognitionException re) {
             // Parsing might have failed because the checked
             // file contains "assert" as an identifier. Retry with a
             // grammar that treats "assert" as an identifier
             // and not as a keyword
 
             // Arghh - the pain - duplicate code!
-            final Reader sar = new StringArrayReader(aLines);
+            final Reader sar = new StringArrayReader(aContents.getLines());
             final JavaLexer jl = new JavaLexer(sar);
-            jl.setFilename(aFileName);
-            jl.setCommentManager(aCmgr);
+            jl.setFilename(aContents.getFilename());
+            jl.setFileContents(aContents);
 
             final JavaRecognizer jr = new JavaRecognizer(jl);
-            jr.setFilename(aFileName);
+            jr.setFilename(aContents.getFilename());
             jr.setASTNodeClass(DetailAST.class.getName());
             jr.compilationUnit();
             rootAST = (DetailAST) jr.getAST();
         }
         return rootAST;
     }
 
     /**
      * Checks for a package.html file for all java files in parameter list.
      * @param aFiles the filenames of the java files to check
      * @return the number of errors found
      */
     private int checkPackageHtml(String[] aFiles)
     {
         if (!mConfig.isRequirePackageHtml()) {
             return 0;
         }
 
         int packageHtmlErrors = 0;
         final HashSet checkedPackages = new HashSet();
         for (int i = 0; i < aFiles.length; i++) {
             final File file = new File(aFiles[i]);
             final File packageDir = file.getParentFile();
             if (!checkedPackages.contains(packageDir)) {
                 final File packageDoc =
                     new File(packageDir, "package.html");
                 final String docFile = packageDoc.toString();
                 fireFileStarted(docFile);
                 if (!packageDoc.exists()) {
                     final LocalizedMessage error =
                         new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                              "javadoc.packageHtml", null);
                     fireErrors(docFile, new LocalizedMessage[]{error});
                     packageHtmlErrors++;
                 }
                 fireFileFinished(docFile);
                 checkedPackages.add(packageDir);
             }
         }
         return packageHtmlErrors;
     }
 
 
     /** notify all listeners about the audit start */
     protected void fireAuditStarted()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
