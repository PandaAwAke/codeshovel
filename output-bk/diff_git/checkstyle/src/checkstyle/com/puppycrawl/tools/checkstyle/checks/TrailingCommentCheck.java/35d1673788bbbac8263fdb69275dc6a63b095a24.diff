diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
index 0dd7826f2..50b5120ef 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
@@ -72,101 +72,101 @@ import org.apache.commons.beanutils.ConversionException;
  * maintain aren't maintained....&quot;
  * </li>
  * <li>
  * &quot;Endline comments also tend to be cryptic. The right side of
  * the line doesn't offer much room and the desire to keep the
  * comment on one line means the comment must be short.
  * Work then goes into making the line as short as possible
  * instead of as clear as possible. The comment usually ends
  * up as cryptic as possible....&quot;
  * </li>
  * <li>
  * &quot;A systemic problem with endline comments is that it's hard
  * to write a meaningful comment for one line of code. Most
  * endline comments just repeat the line of code, which hurts
  * more than it helps.&quot;
  * </li>
  * </ul>
  * His comments on being hard to maintain when the size of
  * the line changes are even more important in the age of
  * automated refactorings.
  * </p>
  * <p>
  * To configure the check so it enforces only comment on a line:
  * <pre>
  * &lt;module name=&quot;TrailingComment&quot;&gt;
  *    &lt;property name=&quot;format&quot; value=&quot;^\\s*$&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  * </p>
  * @author o_sukhodolsky
  */
 public class TrailingCommentCheck extends AbstractFormatCheck
 {
     /** default format for allowed blank line. */
     private static final String DEFAULT_FORMAT = "^[\\s\\}\\);]*$";
 
     /** pattern for legal trailing comment. */
     private Pattern mLegalComment;
 
     /**
      * Sets patter for legal trailing comments.
      * @param aFormat format to set.
      * @throws ConversionException unable to parse a given format.
      */
     public void setLegalComment(final String aFormat)
         throws ConversionException
     {
         try {
             mLegalComment = Utils.getPattern(aFormat);
         }
-        catch (PatternSyntaxException e) {
+        catch (final PatternSyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
     /**
      * Creates new instance of the check.
      * @throws ConversionException unable to parse DEFAULT_FORMAT.
      */
     public TrailingCommentCheck() throws ConversionException
     {
         super(DEFAULT_FORMAT);
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
         throw new IllegalStateException("visitToken() shouldn't be called.");
     }
 
     /** {@inheritDoc} */
     public void beginTree(DetailAST aRootAST)
     {
         final Pattern blankLinePattern = getRegexp();
         final Map cppComments = getFileContents().getCppComments();
         final Map cComments = getFileContents().getCComments();
         final Set lines = new HashSet();
         lines.addAll(cppComments.keySet());
         lines.addAll(cComments.keySet());
 
         final Iterator linesIter = lines.iterator();
         while (linesIter.hasNext()) {
             final Integer lineNo = (Integer) linesIter.next();
 
             final String line = getLines()[lineNo.intValue() - 1];
             String lineBefore = "";
             TextBlock comment = null;
             if (cppComments.containsKey(lineNo)) {
                 comment = (TextBlock) cppComments.get(lineNo);
                 lineBefore = line.substring(0, comment.getStartColNo());
             }
             else if (cComments.containsKey(lineNo)) {
                 final List commentList = (List) cComments.get(lineNo);
                 comment = (TextBlock) commentList.get(commentList.size() - 1);
                 lineBefore = line.substring(0, comment.getStartColNo());
                 if (comment.getText().length == 1) {
