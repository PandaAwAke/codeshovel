diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
index 06b9a0351..196a40629 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
@@ -150,101 +150,101 @@ public class RegexpCheck extends AbstractFormatCheck
 
     /**
      * Sets the maximum number of instances of required pattern allowed.
      * @param aDuplicateLimit negative values mean no duplicate checking,
      * any positive value is used as the limit.
      */
     public void setDuplicateLimit(int aDuplicateLimit)
     {
         mDuplicateLimit = aDuplicateLimit;
         mCheckForDuplicates = (mDuplicateLimit > DEFAULT_DUPLICATE_LIMIT);
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     /** {@inheritDoc} */
     public void beginTree(DetailAST aRootAST)
     {
         mCharacters.clear();
         final Pattern pattern = getRegexp();
         final String[] lines = getLines();
         final StringBuffer sb = new StringBuffer();
         for (int i = 0; i < lines.length; i++) {
             sb.append(lines[i]);
             sb.append('\n');
             for (int j = 0; j < (lines[i].length() + 1); j++) {
                 mCharacters.add(new Integer[] {
                     new Integer(i + 1), new Integer(j), });
             }
         }
         mMatcher = pattern.matcher(sb.toString());
         mMatchCount = 0;
         mErrorCount = 0;
         findMatch();
     }
 
     /** recursive method that finds the matches. */
     private void findMatch()
     {
         int startLine;
         int startColumn;
         int endLine;
         int endColumn;
         boolean foundMatch;
         boolean ignore = false;
 
         foundMatch = mMatcher.find();
-        if (!foundMatch && !mIllegalPattern && mMatchCount == 0) {
+        if (!foundMatch && !mIllegalPattern && (mMatchCount == 0)) {
             logMessage(0);
         }
         else if (foundMatch) {
             startLine = ((Integer[]) mCharacters.get(mMatcher.start()))[0].
                     intValue();
             startColumn = ((Integer[]) mCharacters.get(mMatcher.start()))[1].
                     intValue();
             endLine = ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].
                     intValue();
             endColumn = ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].
                     intValue();
             if (mIgnoreComments) {
                 final FileContents theFileContents = getFileContents();
                 ignore = theFileContents.hasIntersectionWithComment(startLine,
                     startColumn, endLine, endColumn);
             }
             if (!ignore) {
                 mMatchCount++;
                 if (mIllegalPattern || (mCheckForDuplicates
                         && ((mMatchCount - 1) > mDuplicateLimit)))
                 {
                     mErrorCount++;
                     logMessage(startLine);
                 }
             }
             if ((mErrorCount < mErrorLimit)
                     && (ignore || mIllegalPattern || mCheckForDuplicates))
             {
                 findMatch();
             }
         }
     }
 
     /**
      * Displays the right message.
      * @param aLineNumber the line number the message relates to.
      */
     private void logMessage(int aLineNumber)
     {
         String message = "".equals(getMessage()) ? getFormat() : mMessage;
         if (mErrorCount >= mErrorLimit) {
             message = ERROR_LIMIT_EXCEEDED_MESSAGE + message;
         }
         if (mIllegalPattern) {
             log(aLineNumber, "illegal.regexp", message);
         }
         else {
             if (aLineNumber > 0) {
                 log(aLineNumber, "duplicate.regexp", message);
             }
