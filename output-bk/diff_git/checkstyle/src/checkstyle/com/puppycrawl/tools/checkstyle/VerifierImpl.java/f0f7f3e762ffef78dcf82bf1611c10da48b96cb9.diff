diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/VerifierImpl.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/VerifierImpl.java
index c96677d8b..339c46f58 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/VerifierImpl.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/VerifierImpl.java
@@ -21,156 +21,156 @@ package com.puppycrawl.tools.checkstyle;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Set;
 import java.util.Stack;
 import org.apache.regexp.RE;
 import org.apache.regexp.RESyntaxException;
 
 /**
  * Simple implementation of the Verifier interface. Should really get details
  * of the rules from a configuration file, rather than being hard coded.
  * @author <a href="mailto:oliver@puppycrawl.com">Oliver Burn</a>
  **/
 class VerifierImpl
     implements Verifier
 {
     /** the pattern to match Javadoc tags that take an argument **/
     private static final String MATCH_JAVADOC_ARG_PAT
         = "@(throws|exception|param)\\s+(\\S+)\\s+\\S";
     /** compiled regexp to match Javadoc tags that take an argument **/
     private static final RE MATCH_JAVADOC_ARG = createRE(MATCH_JAVADOC_ARG_PAT);
 
     /** the pattern to match Javadoc tags with no argument **/
     private static final String MATCH_JAVADOC_NOARG_PAT
         = "@(return|see|author)\\s+\\S";
     /** compiled regexp to match Javadoc tags with no argument **/
     private static final RE MATCH_JAVADOC_NOARG
         = createRE(MATCH_JAVADOC_NOARG_PAT);
 
     /** the pattern to match author tag **/
     private static final String MATCH_JAVADOC_AUTHOR_PAT = "@author\\s+\\S";
     /** compiled regexp to match author tag **/
     private static final RE MATCH_JAVADOC_AUTHOR
         = createRE(MATCH_JAVADOC_AUTHOR_PAT);
 
 
     ////////////////////////////////////////////////////////////////////////////
     // Member variables
     ////////////////////////////////////////////////////////////////////////////
 
     /** stack tracking the type of block currently in **/
     private final Stack mInInterface = new Stack();
 
     /** tracks the level of block definitions for methods **/
     private int mMethodBlockLevel = 0;
-    
+
     /** the messages being logged **/
     private final List mMessages = new ArrayList();
 
     /** the lines of the file being checked **/
     private String[] mLines;
 
     /** map of the Javadoc comments indexed on the last line of the comment.
      * The hack is it assumes that there is only one Javadoc comment per line.
      **/
     private final Map mComments = new HashMap();
 
     /** the set of imports (no line number) **/
     private final Set mImports = new HashSet();
 
     /** the identifiers used **/
     private final Set mReferenced = new HashSet();
 
     /** pattern to match parameters **/
     private final String mParamPat;
     /** regexp to match parameters **/
     private final RE mParamRegexp;
 
     /** pattern to match static variables **/
     private final String mStaticPat;
     /** regexp to match static variables **/
     private final RE mStaticRegexp;
 
     /** pattern to match static final variables **/
     private final String mStaticFinalPat;
     /** regexp to match static final variables **/
     private final RE mStaticFinalRegexp;
 
     /** pattern to match member variables **/
     private final String mMemberPat;
     /** regexp to match member variables **/
     private final RE mMemberRegexp;
 
     /** pattern to match type names **/
     private final String mTypePat;
     /** regexp to match type names **/
     private final RE mTypeRegexp;
 
     /** the maximum line length **/
     private final int mMaxLineLength;
     /** whether to allow tabs **/
     private final boolean mAllowTabs;
     /** whether to allow protected data **/
     private final boolean mAllowProtected;
     /** whether to allow having no author tag **/
     private final boolean mAllowNoAuthor;
     /** whether to relax javadoc checking **/
     private final boolean mRelaxJavadoc;
     /** whether to process imports **/
     private final boolean mCheckImports;
-    
+
     /** the header lines to check for **/
     private final String[] mHeaderLines;
     /** line number to ignore in header **/
     private final int mHeaderIgnoreLineNo;
 
     ////////////////////////////////////////////////////////////////////////////
     // Constructor methods
     ////////////////////////////////////////////////////////////////////////////
 
     /**
      * Constructs the object.
      * @param aParamPat pattern to match against parameters
      * @param aStaticPat pattern to match against static variables
      * @param aStaticFinalPat pattern to match against static final variables
      * @param aMemberPat pattern to match against member variables
      * @param aTypePat pattern to match against type names
      * @param aMaxLineLength max line length allowed
      * @param aAllowTabs specifies if tabs are allowed
      * @param aAllowProtected specifies if protected data is allowed
      * @param aAllowNoAuthor specifies if allowed to have no author tag
      * @param aRelaxJavadoc specifies if to relax Javadoc checking
      * @param aCheckImports specifies whether to check import statements
      * @param aHeaderLines the header lines to check for
      * @param aHeaderIgnoreLineNo the line to ignore in the header
      * @throws RESyntaxException error creating a regexp object
      **/
     VerifierImpl(String aParamPat,
                  String aStaticPat,
                  String aStaticFinalPat,
                  String aMemberPat,
                  String aTypePat,
                  int aMaxLineLength,
                  boolean aAllowTabs,
                  boolean aAllowProtected,
                  boolean aAllowNoAuthor,
                  boolean aRelaxJavadoc,
                  boolean aCheckImports,
                  String[] aHeaderLines,
                  int aHeaderIgnoreLineNo)
         throws RESyntaxException
     {
         mParamPat = aParamPat;
         mParamRegexp = new RE(aParamPat);
         mStaticPat = aStaticPat;
         mStaticRegexp = new RE(aStaticPat);
         mStaticFinalPat = aStaticFinalPat;
         mStaticFinalRegexp = new RE(aStaticFinalPat);
         mMemberPat = aMemberPat;
         mMemberRegexp = new RE(aMemberPat);
         mTypePat = aTypePat;
@@ -412,172 +412,179 @@ class VerifierImpl
                 "' is not proceeded with whitespace.");
         }
     }
 
     /** @see Verifier **/
     public void verifyNoWSAfter(MyCommonAST aAST)
     {
         final String line = mLines[aAST.getLineNo() - 1];
         final int after = aAST.getColumnNo() + aAST.getText().length();
         if ((after >= line.length()) ||
             Character.isWhitespace(line.charAt(after))) {
             log(aAST.getLineNo(),
                 "'" + aAST.getText() + "' is proceeded with whitespace.");
         }
     }
 
     /** @see Verifier **/
     public void verifyNoWSBefore(MyCommonAST aAST)
     {
         final String line = mLines[aAST.getLineNo() - 1];
         final int before = aAST.getColumnNo() - 1;
         if ((before < 0) || Character.isWhitespace(line.charAt(before))) {
             log(aAST.getLineNo(),
                 "'" + aAST.getText() + "' is preceeded with whitespace.");
         }
     }
 
     /** @see Verifier **/
     public void reportCppComment(int aLineNo, int aColNo)
     {
         // nop
     }
 
     /** @see Verifier **/
     public void reportCComment(int aStartLineNo, int aStartColNo,
                                int aEndLineNo, int aEndColNo)
     {
         if (mLines[aStartLineNo - 1].indexOf("/**", aStartColNo) != -1) {
             final String[] cc =
                 extractCComment(aStartLineNo, aStartColNo,
                                 aEndLineNo, aEndColNo);
             mComments.put(new Integer(aEndLineNo - 1), cc);
         }
     }
 
     /** @see Verifier **/
     public void reportReference(String aType)
     {
         mReferenced.add(aType);
     }
-    
+
     /** @see Verifier **/
     public void reportImport(int aLineNo, String aType)
     {
         if (mCheckImports) {
             // Check for a duplicate import
             final Iterator it = mImports.iterator();
             while (it.hasNext()) {
                 final LineText lt = (LineText) it.next();
                 if (aType.equals(lt.getText())) {
                     log(aLineNo,
                         "Duplicate import to line " + lt.getLineNo() + ".");
                 }
             }
-        }
 
-        mImports.add(new LineText(aLineNo, aType));
+            // Check for import from java.lang package.
+            if (aType.startsWith("java.lang.")) {
+                log(aLineNo, "Redundant import from the java.lang package.");
+            }
+            else {
+                // Add to list to check for duplicates and usage
+                mImports.add(new LineText(aLineNo, aType));
+            }
+        }
     }
-    
+
     /** @see Verifier **/
     public void reportStarImport(int aLineNo, String aPkg)
     {
         if (mCheckImports) {
             log(aLineNo, "Avoid using the '.*' form of import.");
         }
     }
-    
+
     /** @see Verifier **/
     public void reportStartTypeBlock(boolean aIsInterface)
     {
         mInInterface.push(new Boolean(aIsInterface));
     }
-    
+
     /** @see Verifier **/
     public void reportEndTypeBlock()
     {
         mInInterface.pop();
     }
-    
+
     /** @see Verifier **/
     public void reportStartMethodBlock()
     {
         mMethodBlockLevel++;
     }
-    
+
     /** @see Verifier **/
     public void reportEndMethodBlock()
     {
         mMethodBlockLevel--;
     }
-    
+
 
     ////////////////////////////////////////////////////////////////////////////
     // Private methods
     ////////////////////////////////////////////////////////////////////////////
 
     /**
      * Helper method to create a regular expression. Will exit if unable to
      * create the object.
      * @param aPattern the pattern to match
      * @return a created regexp object
      **/
     private static RE createRE(String aPattern)
     {
         RE retVal = null;
         try {
             retVal = new RE(aPattern);
         }
         catch (RESyntaxException e) {
-            System.err.println("Failed to initialise regexp expression " +
+            System.out.println("Failed to initialise regexp expression " +
                                aPattern);
-            e.printStackTrace(System.err);
+            e.printStackTrace(System.out);
             System.exit(1);
         }
         return retVal;
     }
 
     /**
      * Logs a message to be reported.
      * @param aLineNo the line number associated with the message
      * @param aMsg the message to log
      **/
     private void log(int aLineNo, String aMsg)
     {
         mMessages.add(new LineText(aLineNo, aMsg));
     }
 
 
     /**
      * Checks that a variable confirms to a specified regular expression. Logs
      * a message if it does not.
      * @param aVar the variable to check
      * @param aRegexp the regexp to match against
      * @param aPattern text representation of regexp
      **/
     private void checkVariable(MyVariable aVar, RE aRegexp, String aPattern)
     {
         if (!aRegexp.match(aVar.getText())) {
             log(aVar.getLineNo(),
                 "variable '" + aVar.getText() +
                 "' must match pattern '" + aPattern + "'.");
         }
     }
 
     /**
      * Returns the specified C comment as a String array.
      * @return C comment as a array
      * @param aStartLineNo the starting line number
      * @param aStartColNo the starting column number
      * @param aEndLineNo the ending line number
      * @param aEndColNo the ending column number
      **/
     private String[] extractCComment(int aStartLineNo, int aStartColNo,
                                      int aEndLineNo, int aEndColNo)
     {
         String[] retVal;
         if (aStartLineNo == aEndLineNo) {
             retVal = new String[1];
             retVal[0] = mLines[aStartLineNo - 1].substring(aStartColNo,
                                                            aEndColNo + 1);
         }
         else {
@@ -736,78 +743,79 @@ class VerifierImpl
                 }
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(),
                     "Unused @throws tag for '" + tag.getArg1() + "'.");
             }
         }
 
         // Now dump out all throws without tags
         final ListIterator throwIt = aThrows.listIterator();
         while (throwIt.hasNext()) {
             final LineText t = (LineText) throwIt.next();
             log(t.getLineNo(),
                 "Expected @throws tag for '" + t.getText() + "'.");
         }
     }
 
 
     /** checks that a file contains a valid header **/
     private void checkHeader()
     {
         if (mHeaderLines.length > mLines.length) {
             log(1, "Missing a header - not enough lines in file.");
         }
         else {
             for (int i = 0; i < mHeaderLines.length; i++) {
                 if ((i != (mHeaderIgnoreLineNo - 1)) &&
                     !mHeaderLines[i].equals(mLines[i]))
                 {
                     log(i + 1,
                         "Line does not match expected header line of '" +
                         mHeaderLines[i] + "'.");
                     break; // stop checking
                 }
             }
         }
     }
 
     /**
      * @return the class name from a fully qualified name
      * @param aType the fully qualified name
      */
     private String basename(String aType)
     {
         final int i = aType.lastIndexOf(".");
         return (i == -1) ? aType : aType.substring(i + 1);
     }
 
-    /** Check for imports that are unused. **/
+    /** Check the imports that are unused or unrequired. **/
     private void checkImports()
     {
         if (!mCheckImports) {
             return;
         }
 
+        // Loop checking for unused imports
         final Iterator it = mImports.iterator();
         while (it.hasNext()) {
             final LineText imp = (LineText) it.next();
             if (!mReferenced.contains(basename(imp.getText()))) {
                 log(imp.getLineNo(), "Unused import - " + imp.getText());
             }
         }
     }
 
     /** @return whether currently in an interface block **/
     private boolean inInterfaceBlock()
     {
         return ((Boolean) mInInterface.peek()).booleanValue();
     }
 
     /** @return whether currently in a method block **/
     private boolean inMethodBlock()
     {
         return (mMethodBlockLevel > 0);
     }
 }
