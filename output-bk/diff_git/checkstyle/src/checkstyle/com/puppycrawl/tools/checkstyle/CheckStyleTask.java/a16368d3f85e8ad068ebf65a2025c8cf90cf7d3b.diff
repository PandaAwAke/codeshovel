diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
index 0bcfdc84d..fccbd5280 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/CheckStyleTask.java
@@ -229,113 +229,128 @@ public class CheckStyleTask
                         mPackageNamesFile.getAbsolutePath());
                     c.setModuleFactory(moduleFactory);
                 }
                 c.contextualize(context);
                 c.configure(config);
 
                 // setup the listeners
                 AuditListener[] listeners = getListeners();
                 for (int i = 0; i < listeners.length; i++) {
                     c.addListener(listeners[i]);
                 }
             }
             catch (Exception e) {
                 throw new BuildException(
                     "Unable to create a Checker: " + e.getMessage(), e);
             }
 
             // Process the files
             final File[] files = scanFileSets();
             final int numErrs = c.process(files);
 
             // Handle the return status
             if ((numErrs > 0) && mFailureProperty != null) {
                 getProject().setProperty(mFailureProperty, "true");
             }
 
             if ((numErrs > 0) && mFailOnViolation) {
                 throw new BuildException("Got " + numErrs + " errors.",
                                          getLocation());
             }
         }
         finally {
             if (c != null) {
                 c.destroy();
             }
         }
     }
 
     /**
      * Create the Properties object based on the arguments specified
      * to the ANT task.
      * @return Properties object
      * @throws BuildException if an error occurs
      */
     private Properties createOverridingProperties()
     {
         final Properties retVal = new Properties();
 
         // Load the properties file if specified
         if (mPropertiesFile != null) {
+            FileInputStream inStream = null;
             try {
-                retVal.load(new FileInputStream(mPropertiesFile));
+                inStream = new FileInputStream(mPropertiesFile);
+                retVal.load(inStream);
             }
             catch (FileNotFoundException e) {
                 throw new BuildException(
                     "Could not find Properties file '" + mPropertiesFile + "'",
                     e, getLocation());
             }
             catch (IOException e) {
                 throw new BuildException(
                     "Error loading Properties file '" + mPropertiesFile + "'",
                     e, getLocation());
             }
+            finally {
+                try {
+                    if (inStream != null) {
+                        inStream.close();
+                    }
+                }
+                catch (IOException e) {
+                    throw new BuildException(
+                        "Error closing Properties file '"
+                        + mPropertiesFile + "'",
+                        e, getLocation());
+                }
+            }
         }
 
         // Now override the properties specified
         for (Iterator it = mOverrideProps.iterator(); it.hasNext();) {
             final Property p = (Property) it.next();
             retVal.put(p.getKey(), p.getValue());
         }
 
         return retVal;
     }
 
     /**
      * Return the list of listeners set in this task.
      * @return the list of listeners.
      * @throws ClassNotFoundException if an error occurs
      * @throws InstantiationException if an error occurs
      * @throws IllegalAccessException if an error occurs
      * @throws IOException if an error occurs
      */
     protected AuditListener[] getListeners()
         throws ClassNotFoundException, InstantiationException,
         IllegalAccessException, IOException
     {
         final int listenerCount = Math.max(1, mFormatters.size());
 
         final AuditListener[] listeners = new AuditListener[listenerCount];
 
         if (mFormatters.size() == 0) {
             OutputStream debug = new LogOutputStream(this, Project.MSG_DEBUG);
             OutputStream err = new LogOutputStream(this, Project.MSG_ERR);
             listeners[0] = new DefaultLogger(debug, true, err, true);
             return listeners;
         }
 
         for (int i = 0; i < listeners.length; i++) {
             final Formatter f = (Formatter) mFormatters.get(i);
             listeners[i] = f.createListener(this);
         }
         return listeners;
     }
 
     /**
      * returns the list of files (full path name) to process.
      * @return the list of files included via the filesets.
      */
     protected File[] scanFileSets()
     {
         final ArrayList list = new ArrayList();
         if (mFileName != null) {
             // oops we've got an additional one to process, don't
