diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index 8845fee5f..3b39e1588 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -48,183 +48,289 @@ import com.puppycrawl.tools.checkstyle.api.DetailAST;
  *  {@link TokenTypes#LE LE},
  *  {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH},
  *  {@link TokenTypes#LITERAL_DO LITERAL_DO},
  *  {@link TokenTypes#LITERAL_ELSE LITERAL_ELSE},
  *  {@link TokenTypes#LITERAL_FINALLY LITERAL_FINALLY},
  *  {@link TokenTypes#LITERAL_FOR LITERAL_FOR},
  *  {@link TokenTypes#LITERAL_IF LITERAL_IF},
  *  {@link TokenTypes#LITERAL_RETURN LITERAL_RETURN},
  *  {@link TokenTypes#LITERAL_SYNCHRONIZED LITERAL_SYNCHRONIZED},
  *  {@link TokenTypes#LITERAL_TRY LITERAL_TRY},
  *  {@link TokenTypes#LITERAL_WHILE LITERAL_WHILE},
  *  {@link TokenTypes#LOR LOR},
  *  {@link TokenTypes#LT LT},
  *  {@link TokenTypes#MINUS MINUS},
  *  {@link TokenTypes#MINUS_ASSIGN MINUS_ASSIGN},
  *  {@link TokenTypes#MOD MOD},
  *  {@link TokenTypes#MOD_ASSIGN MOD_ASSIGN},
  *  {@link TokenTypes#NOT_EQUAL NOT_EQUAL},
  *  {@link TokenTypes#PLUS PLUS},
  *  {@link TokenTypes#PLUS_ASSIGN PLUS_ASSIGN},
  *  {@link TokenTypes#QUESTION QUESTION},
  *  {@link TokenTypes#RCURLY RCURLY},
  *  {@link TokenTypes#SL SL},
  *  {@link TokenTypes#SLIST SLIST},
  *  {@link TokenTypes#SL_ASSIGN SL_ASSIGN},
  *  {@link TokenTypes#SR SR},
  *  {@link TokenTypes#SR_ASSIGN SR_ASSIGN},
  *  {@link TokenTypes#STAR STAR},
  *  {@link TokenTypes#STAR_ASSIGN STAR_ASSIGN}.
  *  {@link TokenTypes#LITERAL_ASSERT LITERAL_ASSERT}.
  *  {@link TokenTypes#GENERIC_START GENERIC_START}.
  *  {@link TokenTypes#GENERIC_END GENERIC_END}.
  *  {@link TokenTypes#TYPE_EXTENSION_AND TYPE_EXTENSION_AND}.
  *  {@link TokenTypes#WILDCARD_TYPE WILDCARD_TYPE}.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="WhitespaceAround"/&gt;
  * </pre>
  * <p> An example of how to configure the check for whitespace only around
  * assignment operators is:
  * </p>
  * <pre>
  * &lt;module name="WhitespaceAround"&gt;
  *     &lt;property name="tokens"
  *               value="ASSIGN,DIV_ASSIGN,PLUS_ASSIGN,MINUS_ASSIGN,STAR_ASSIGN,MOD_ASSIGN,SR_ASSIGN,BSR_ASSIGN,SL_ASSIGN,BXOR_ASSIGN,BOR_ASSIGN,BAND_ASSIGN"/&gt;
  * &lt;/module&gt;
  * </pre>
+ * <p>
+ * In addition, this check can be configured to allow empty method and/or
+ * constructor bodies.  For example, a method with an empty body might look
+ * like:
+ * </p>
+ * <p>
+ * <pre>    public void doSomething(int val) {}</pre>
+ * </p>
+ * <p>
+ * To configure the check to allow empty method blocks use
+ * </p>
+ * <p>
+ * <pre>   &lt;property name="allowEmptyMethods" value="true" /&gt;</pre>
+ * </p>
+ * <p>
+ * To configure the check to allow empty constructor blocks use
+ * </p>
+ * <p>
+ * <pre>   &lt;property name="allowEmptyConstructors" value="true" /&gt;</pre>
+ * </p>
  *
  * @author Oliver Burn
  * @version 1.0
  */
-public class WhitespaceAroundCheck
-    extends Check
+public class WhitespaceAroundCheck extends Check
 {
+    /** Whether or not empty constructor bodies are allowed. */
+    private boolean mAllowEmptyCtors;
+    /** Whether or not empty method bodies are allowed. */
+    private boolean mAllowEmptyMethods;
+
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.ASSIGN,
             TokenTypes.BAND,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.COLON,
             TokenTypes.DIV,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.EQUAL,
             TokenTypes.GE,
             TokenTypes.GT,
             TokenTypes.LAND,
             TokenTypes.LCURLY,
             TokenTypes.LE,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LOR,
             TokenTypes.LT,
             TokenTypes.MINUS,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.NOT_EQUAL,
             TokenTypes.PLUS,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.QUESTION,
             TokenTypes.RCURLY,
             TokenTypes.SL,
             TokenTypes.SLIST,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.LITERAL_ASSERT,
             TokenTypes.GENERIC_START,
             TokenTypes.GENERIC_END,
             TokenTypes.TYPE_EXTENSION_AND,
             TokenTypes.WILDCARD_TYPE,
         };
     }
 
+    /**
+     * Sets whether or now empty method bodies are allowed.
+     * @param aAllow <code>true</code> to allow empty method bodies.
+     */
+    public void setAllowEmptyMethods(boolean aAllow)
+    {
+        mAllowEmptyMethods = aAllow;
+    }
+
+    /**
+     * Sets whether or now empty constructor bodies are allowed.
+     * @param aAllow <code>true</code> to allow empty constructor bodies.
+     */
+    public void setAllowEmptyConstructors(boolean aAllow)
+    {
+        mAllowEmptyCtors = aAllow;
+    }
+
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
         final int type = aAST.getType();
         final int parentType = aAST.getParent().getType();
 
         // Check for CURLY in array initializer
         if ((type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
             && (parentType == TokenTypes.ARRAY_INIT))
         {
             return;
         }
 
         // Check for import pkg.name.*;
         if ((type == TokenTypes.STAR)
             && (parentType == TokenTypes.DOT))
         {
             return;
         }
 
         // Check for an SLIST that has a parent CASE_GROUP. It is not a '{'.
         if ((type == TokenTypes.SLIST)
             && (parentType == TokenTypes.CASE_GROUP))
         {
             return;
         }
 
         //we do not want to check colon for cases and defaults
         if (type == TokenTypes.COLON
             && (parentType == TokenTypes.LITERAL_DEFAULT
                 || parentType == TokenTypes.LITERAL_CASE))
         {
             return;
         }
 
+        // Check for allowed empty method or ctor blocks.
+        if (emptyMethodBlockCheck(aAST, parentType)
+            || emptyCtorBlockCheck(aAST, parentType))
+        {
+            return;
+        }
+
         final String[] lines = getLines();
         final String line = lines[aAST.getLineNo() - 1];
         final int before = aAST.getColumnNo() - 1;
         final int after = aAST.getColumnNo() + aAST.getText().length();
 
         if ((before >= 0) && !Character.isWhitespace(line.charAt(before))) {
             log(aAST.getLineNo(), aAST.getColumnNo(),
                     "ws.notPreceded", new Object[]{aAST.getText()});
         }
 
         if (after >= line.length()) {
             return;
         }
 
         final char nextChar = line.charAt(after);
         if (!Character.isWhitespace(nextChar)
             // Check for "return;"
             && !((type == TokenTypes.LITERAL_RETURN)
                 && (aAST.getFirstChild().getType() == TokenTypes.SEMI))
             // Check for "})" or "};" or "},". Happens with anon-inners
             && !((type == TokenTypes.RCURLY)
                 && ((nextChar == ')')
                     || (nextChar == ';')
                     || (nextChar == ','))))
         {
             log(
                 aAST.getLineNo(),
                 aAST.getColumnNo() + aAST.getText().length(),
                 "ws.notFollowed",
                 new Object[] {aAST.getText()});
         }
     }
+
+    /**
+     * Test if the given <code>DetailAST</code> is part of an allowed empty
+     * method block.
+     * @param aAST the <code>DetailAST</code> to test.
+     * @param aParentType the token type of <code>aAST</code>'s parent.
+     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     *         allowed empty method block.
+     */
+    private boolean emptyMethodBlockCheck(DetailAST aAST, int aParentType)
+    {
+        return mAllowEmptyMethods
+            && emptyBlockCheck(aAST, aParentType, TokenTypes.METHOD_DEF);
+    }
+
+    /**
+     * Test if the given <code>DetailAST</code> is part of an allowed empty
+     * constructor (ctor) block.
+     * @param aAST the <code>DetailAST</code> to test.
+     * @param aParentType the token type of <code>aAST</code>'s parent.
+     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     *         allowed empty constructor block.
+     */
+    private boolean emptyCtorBlockCheck(DetailAST aAST, int aParentType)
+    {
+        return mAllowEmptyCtors
+            && emptyBlockCheck(aAST, aParentType, TokenTypes.CTOR_DEF);
+    }
+
+    /**
+     * Test if the given <code>DetailAST</code> is part of an empty block.
+     * An example empty block might look like the following
+     * <p>
+     * <pre>   public void myMethod(int val) {}</pre>
+     * <p>
+     * In the above, the method body is an empty block ("{}").
+     *
+     * @param aAST the <code>DetailAST</code> to test.
+     * @param aParentType the token type of <code>aAST</code>'s parent.
+     * @param aMatch the parent token type we're looking to match.
+     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     *         empty block contained under a <code>aMatch</code> token type
+     *         node.
+     */
+    private boolean emptyBlockCheck(DetailAST aAST, int aParentType, int aMatch)
+    {
+        final int type = aAST.getType();
+        if (type == TokenTypes.RCURLY) {
+            DetailAST grandParent = aAST.getParent().getParent();
+            return aParentType == TokenTypes.SLIST
+                && grandParent.getType() == aMatch;
+        }
+
+        return type == TokenTypes.SLIST
+            && aParentType == aMatch
+            && aAST.getFirstChild().getType() == TokenTypes.RCURLY;
+    }
 }
