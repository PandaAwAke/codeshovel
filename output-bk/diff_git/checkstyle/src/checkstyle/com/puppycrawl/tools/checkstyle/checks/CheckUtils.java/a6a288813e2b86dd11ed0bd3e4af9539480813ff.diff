diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
index 7839f1236..16bdb9c11 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
@@ -147,51 +147,75 @@ public final class CheckUtils
     /** octal radix */
     private static final int BASE_8 = 8;
 
     /** decimal radix */
     private static final int BASE_10 = 10;
 
     /** hex radix */
     private static final int BASE_16 = 16;
 
     /**
      * Returns the value represented by the specified string of the specified
      * type. Returns 0 for types other than float, double, int, and long.
      * @param aText the string to be parsed.
      * @param aType the token type of the text. Should be a constant of
      * {@link com.puppycrawl.tools.checkstyle.api.TokenTypes}.
      * @return the float value represented by the string argument.
      */
     public static float parseFloat(String aText, int aType)
     {
         float result = 0;
         switch (aType) {
         case TokenTypes.NUM_FLOAT:
         case TokenTypes.NUM_DOUBLE:
             result = (float) Double.parseDouble(aText);
             break;
         case TokenTypes.NUM_INT:
         case TokenTypes.NUM_LONG:
             int radix = BASE_10;
             if (aText.startsWith("0x") || aText.startsWith("0X")) {
                 radix = BASE_16;
                 aText = aText.substring(2);
             }
             else if (aText.charAt(0) == '0') {
                 radix = BASE_8;
                 aText = aText.substring(1);
             }
             // Long.parseLong requires that the text ends with neither 'L'
             // nor 'l'.
             if ((aText.endsWith("L")) || (aText.endsWith("l"))) {
                 aText = aText.substring(0, aText.length() - 1);
             }
             if (aText.length() > 0) {
                 result = (float) Long.parseLong(aText, radix);
             }
             break;
         default:
             break;
         }
         return result;
     }
+
+
+    /**
+     * Finds sub-node for given node minimal (line, column) pair.
+     * @param aNode the root of tree for search.
+     * @return sub-node with minimal (line, column) pair.
+     */
+    public static DetailAST getFirstNode(final DetailAST aNode)
+    {
+        DetailAST currentNode = aNode;
+        DetailAST child = (DetailAST) aNode.getFirstChild();
+        while (child != null) {
+            final DetailAST newNode = getFirstNode(child);
+            if (newNode.getLineNo() < currentNode.getLineNo()
+                || (newNode.getLineNo() == currentNode.getLineNo()
+                    && newNode.getColumnNo() < currentNode.getColumnNo()))
+            {
+                currentNode = newNode;
+            }
+            child = (DetailAST) child.getNextSibling();
+        }
+
+        return currentNode;
+    }
 }
