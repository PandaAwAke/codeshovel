diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
index 1e3f1a1b4..faf763d6e 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
@@ -67,84 +67,84 @@ public class ClassDefHandler extends BlockParentHandler
     @Override
     protected DetailAST getRCurly()
     {
         return getMainAst().findFirstToken(TokenTypes.OBJBLOCK)
             .findFirstToken(TokenTypes.RCURLY);
     }
 
     /**
      * There is no top level expression for this handler.
      *
      * @return null
      */
     @Override
     protected DetailAST getToplevelAST()
     {
         return null;
         // note: ident checked by hand in check indentation;
     }
 
     /**
      * Get the child element representing the list of statements.
      *
      * @return the statement list child
      */
     @Override
     protected DetailAST getListChild()
     {
         return getMainAst().findFirstToken(TokenTypes.OBJBLOCK);
     }
 
     /**
      * Check the indentation of the expression we are handling.
      */
     @Override
     public void checkIndentation()
     {
         // TODO: still need to better deal with the modifiers and "class"
         checkModifiers();
 
         final LineSet lines = new LineSet();
 
         // checks that line with class name starts at correct indentation,
         //  and following lines (in implements and extends clauses) are
         //  indented at least one level
         final DetailAST ident = getMainAst().findFirstToken(TokenTypes.IDENT);
         final int lineStart = getLineStart(ident);
         if (!getLevel().accept(lineStart)) {
             logError(ident, "ident", lineStart);
         }
 
-        lines.addLineAndCol(new Integer(ident.getLineNo()), lineStart);
+        lines.addLineAndCol(ident.getLineNo(), lineStart);
 
         final DetailAST impl = getMainAst().findFirstToken(
             TokenTypes.IMPLEMENTS_CLAUSE);
         if ((impl != null) && (impl.getFirstChild() != null)) {
             findSubtreeLines(lines, impl, false);
         }
 
         final DetailAST ext =
             getMainAst().findFirstToken(TokenTypes.EXTENDS_CLAUSE);
         if ((ext != null) && (ext.getFirstChild() != null)) {
             findSubtreeLines(lines, ext, false);
         }
 
         checkLinesIndent(ident.getLineNo(), lines.lastLine(), getLevel());
 
         super.checkIndentation();
     }
 
     /** {@inheritDoc} */
     @Override
     protected int[] getCheckedChildren()
     {
         return new int[] {
             TokenTypes.EXPR,
             TokenTypes.OBJBLOCK,
             TokenTypes.LITERAL_BREAK,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_THROW,
             TokenTypes.LITERAL_CONTINUE,
         };
     }
 
 }
