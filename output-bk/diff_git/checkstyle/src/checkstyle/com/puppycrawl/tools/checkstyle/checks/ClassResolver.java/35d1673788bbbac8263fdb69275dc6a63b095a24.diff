diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
index b94cf146c..3a061be29 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
@@ -90,101 +90,101 @@ public class ClassResolver
 
             }
         }
 
         // See if in the package
         if (!"".equals(mPkg)) {
             clazz = resolveQualifiedName(mPkg + "." + aName);
             if (clazz != null) {
                 return clazz;
             }
         }
 
         //inner class of this class???
         if (!"".equals(aCurrentClass)) {
             final String innerClass = (!"".equals(mPkg) ? (mPkg + ".") : "")
                 + aCurrentClass + "$" + aName;
             if (isLoadable(innerClass)) {
                 return safeLoad(innerClass);
             }
         }
 
         // try star imports
         it = mImports.iterator();
         while (it.hasNext()) {
             final String imp = (String) it.next();
             if (imp.endsWith(".*")) {
                 final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1)
                     + aName;
                 clazz = resolveQualifiedName(fqn);
                 if (clazz != null) {
                     return clazz;
                 }
             }
         }
 
         // Giving up, the type is unknown, so load the class to generate an
         // exception
         return safeLoad(aName);
     }
 
     /**
      * @return whether a specified class is loadable with safeLoad().
      * @param aName name of the class to check
      */
     public boolean isLoadable(String aName)
     {
         try {
             safeLoad(aName);
             return true;
         }
-        catch (ClassNotFoundException e) {
+        catch (final ClassNotFoundException e) {
             return false;
         }
     }
 
     /**
      * Will load a specified class is such a way that it will NOT be
      * initialised.
      * @param aName name of the class to load
      * @return the <code>Class</code> for the specified class
      * @throws ClassNotFoundException if an error occurs
      */
     public Class safeLoad(String aName)
         throws ClassNotFoundException
     {
         // The next line will load the class using the specified class
         // loader. The magic is having the "false" parameter. This means the
         // class will not be initialised. Very, very important.
         return Class.forName(aName, false, mLoader);
     }
 
     /**
      * Tries to resolve a class for fully-specified name.
      * @param aName a given name of class.
      * @return Class object for the given name or null.
      */
     private Class resolveQualifiedName(final String aName)
     {
         try {
             if (isLoadable(aName)) {
                 return safeLoad(aName);
             }
             //Perhaps it's fully-qualified inner class
             final int dot = aName.lastIndexOf(".");
             if (dot != -1) {
                 final String innerName =
                     aName.substring(0, dot) + "$" + aName.substring(dot + 1);
                 if (isLoadable(innerName)) {
                     return safeLoad(innerName);
                 }
             }
         }
-        catch (ClassNotFoundException ex) {
+        catch (final ClassNotFoundException ex) {
             // we shouldn't get this exception here,
             // so this is unexpected runtime exception
             throw new RuntimeException(ex);
         }
 
         return null;
     }
 }
