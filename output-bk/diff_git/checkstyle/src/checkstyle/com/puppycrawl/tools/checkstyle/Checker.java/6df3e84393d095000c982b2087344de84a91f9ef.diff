diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index ffd63fdab..99dc32350 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -64,187 +64,182 @@ public class Checker
     }
 
     /** Cleans up the object **/
     public void destroy()
     {
         mCache.destroy();
 
         // close all streamable listeners
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final Object obj = it.next();
             if (obj instanceof Streamable) {
                 final Streamable str = (Streamable) obj;
                 final OutputStream os = str.getOutputStream();
                 // close only those that can be closed...
                 if ((os != System.out) && (os != System.err) && (os != null)) {
                     try  {
                         os.flush();
                         os.close();
                     }
                     catch (IOException ignored) {
                     }
                 }
             }
             it.remove();
         }
     }
 
     /**
      * Add the listener that will be used to receive events from the audit
      * @param aListener the nosy thing
      */
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Processes a set of files.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(String[] aFiles)
     {
         int total = 0;
         fireAuditStarted();
 
-        /*
-
-          If you move checkPackageHtml() around beware of the caching
-          functionality of checkstyle. Make sure that package.html
-          checks are not skipped because of caching. Otherwise you
-          might e.g. have a package.html file, check all java files
-          without errors, delete package.html and then recheck without
-          errors because the html file is not covered by the cache.
-
-        */
-
+        // If you move checkPackageHtml() around beware of the caching
+        // functionality of checkstyle. Make sure that package.html
+        // checks are not skipped because of caching. Otherwise you
+        // might e.g. have a package.html file, check all java files
+        // without errors, delete package.html and then recheck without
+        // errors because the html file is not covered by the cache.
         total += checkPackageHtml(aFiles);
-        
+
         for (int i = 0; i < aFiles.length; i++)
         {
             total += process(aFiles[i]);
         }
         fireAuditFinished();
         return total;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
      * @param aFileName the name of the file to process
      **/
     private int process(String aFileName)
     {
         final File f = new File(aFileName);
         final long timestamp = f.lastModified();
         if (mCache.alreadyChecked(aFileName, timestamp)) {
             return 0;
         }
 
         LineText[] errors;
         try {
             fireFileStarted(aFileName);
             final String[] lines = getLines(aFileName);
             VerifierSingleton.getInstance().clearMessages();
             VerifierSingleton.getInstance().setLines(lines);
             final Reader sar = new StringArrayReader(lines);
             final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
             jl.setFilename(aFileName);
             final GeneratedJavaRecognizer jr = new GeneratedJavaRecognizer(jl);
             jr.setFilename(aFileName);
             jr.setASTNodeClass(MyCommonAST.class.getName());
             jr.compilationUnit();
             errors = VerifierSingleton.getInstance().getMessages();
         }
         catch (FileNotFoundException fnfe) {
             errors = new LineText[] {new LineText(0, "File not found!")};
         }
         catch (IOException ioe) {
             errors = new LineText[] {
                 new LineText(0, "Got an IOException -" + ioe.getMessage())};
         }
         catch (RecognitionException re) {
             errors = new LineText[] {
                 new LineText(0,
                              "Got a RecognitionException -" + re.getMessage())};
         }
         catch (TokenStreamException te) {
             errors = new LineText[] {
                 new LineText(0,
                              "Got a TokenStreamException -" + te.getMessage())};
         }
 
         if (errors.length == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(aFileName, errors);
         }
 
         fireFileFinished(aFileName);
         return errors.length;
     }
 
     /**
      * Checks for a package.html file for all java files in parameter list.
      * @param aFiles the filenames of the java files to check
      * @return the number of errors found
      */
     private int checkPackageHtml(String[] aFiles)
     {
         int packageHtmlErrors = 0;
-        
+
         if (aFiles != null && mConfig.isRequirePackageHtml())
         {
             final HashSet checkedPackages = new HashSet();
             for (int i = 0; i < aFiles.length; i++)
             {
                 final File file = new File(aFiles[i]);
                 final File packageDir = file.getParentFile();
                 if (!checkedPackages.contains(packageDir))
                 {
                     final File packageDoc =
                         new File(packageDir, "package.html");
                     final String docFile = packageDoc.toString();
                     fireFileStarted(docFile);
                     if (!packageDoc.exists())
                     {
                         final LineText error = new LineText(0,
                             "missing package documentation file.");
                         fireErrors(docFile, new LineText[]{error} );
                         packageHtmlErrors++;
                     }
                     fireFileFinished(docFile);
                     checkedPackages.add(packageDir);
                 }
             }
         }
         return packageHtmlErrors;
     }
 
 
     /**
      * Loads the contents of a file in a String array.
      * @return the lines in the file
      * @param aFileName the name of the file to load
      * @throws IOException error occurred
      **/
     private String[] getLines(String aFileName)
         throws IOException
     {
         final LineNumberReader lnr =
             new LineNumberReader(new FileReader(aFileName));
         final ArrayList lines = new ArrayList();
         while (true) {
             final String l = lnr.readLine();
             if (l == null) {
                 break;
             }
             lines.add(l);
         }
 
         return (String[]) lines.toArray(new String[0]);
