diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java
index ba5026a0a..de9f9c27f 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java
@@ -231,155 +231,109 @@ public class BlockParentHandler extends ExpressionHandler
         return (DetailAST) getMainAst().findFirstToken(
             TokenTypes.RPAREN).getNextSibling();
     }
 
     /**
      * Check the indentation level of a child that is not a list of statements.
      */
     private void checkNonlistChild()
     {
         // TODO: look for SEMI and check for it here?
         DetailAST nonlist = getNonlistChild();
         if (nonlist == null) {
             return;
         }
 
         IndentLevel expected = new IndentLevel(getLevel(), getBasicOffset());
 
         checkExpressionSubtree(nonlist, expected, false, false);
     }
 
     /**
      * Get the child element representing the list of statements.
      *
      * @return the statement list child
      */
     protected DetailAST getListChild()
     {
         return getMainAst().findFirstToken(TokenTypes.SLIST);
     }
 
     /**
      * Get the right parenthesis portion of the expression we are handling.
      *
      * @return the right parenthis expression
      */
     protected DetailAST getRParen()
     {
         return getMainAst().findFirstToken(TokenTypes.RPAREN);
     }
 
     /**
      * Get the left parenthesis portion of the expression we are handling.
      *
      * @return the left parenthis expression
      */
     protected DetailAST getLParen()
     {
         return getMainAst().findFirstToken(TokenTypes.LPAREN);
     }
 
-    /**
-     * Check the indentation of the right parenthesis.
-     */
-    protected void checkRParen()
-    {
-        final DetailAST rparen = getRParen();
-
-        // no paren - no check :)
-        if (rparen == null) {
-            return;
-        }
-
-        // the rcurly can either be at the correct indentation,
-        // or not first on the line ...
-        final int rparenLevel = expandedTabsColumnNo(rparen);
-        if (getLevel().accept(rparenLevel) || !startsLine(rparen)) {
-            return;
-        }
-
-        // or has <lparen level> + 1 indentation
-        final DetailAST lparen = getLParen();
-        final int lparenLevel = expandedTabsColumnNo(lparen);
-        if (rparenLevel == (lparenLevel + 1)) {
-            return;
-        }
-
-        logError(rparen, "rparen", expandedTabsColumnNo(rparen));
-    }
-
-    /**
-     * Check the indentation of the left parenthesis.
-     */
-    protected void checkLParen()
-    {
-        // the rcurly can either be at the correct indentation, or on the
-        // same line as the lcurly
-        DetailAST lparen = getLParen();
-        if (lparen == null
-            || getLevel().accept(expandedTabsColumnNo(lparen))
-            || !startsLine(lparen))
-        {
-            return;
-        }
-        logError(lparen, "lparen", expandedTabsColumnNo(lparen));
-    }
-
     /**
      * Check the indentation of the expression we are handling.
      */
     public void checkIndentation()
     {
         checkToplevelToken();
         // seperate to allow for eventual configuration
-        checkLParen();
-        checkRParen();
+        checkLParen(getLParen());
+        checkRParen(getLParen(), getRParen());
         if (hasCurlys()) {
             checkLCurly();
             checkRCurly();
         }
         DetailAST listChild = getListChild();
         if (listChild != null) {
             // NOTE: switch statements usually don't have curlys
             if (!hasCurlys() || !areOnSameLine(getLCurly(), getRCurly())) {
                 checkChildren(listChild,
                               getCheckedChildren(),
                               getChildrenExpectedLevel(),
                               true,
                               childrenMayNest());
             }
         }
         else {
             checkNonlistChild();
         }
     }
 
     /**
      * @return indentation level expected for children
      */
     protected IndentLevel getChildrenExpectedLevel()
     {
         // if we have multileveled expected level then we should
         // try to suggest single level to children using curlies'
         // levels.
         if (getLevel().isMultiLevel() && hasCurlys()
             && !areOnSameLine(getLCurly(), getRCurly()))
         {
             if (startsLine(getLCurly())) {
                 return new IndentLevel(expandedTabsColumnNo(getLCurly())
                                        + getBasicOffset());
             }
             else if (startsLine(getRCurly())) {
                 return new IndentLevel(expandedTabsColumnNo(getRCurly())
                                        + getBasicOffset());
             }
         }
         return new IndentLevel(getLevel(), getBasicOffset());
     }
 
     /** {@inheritDoc} */
     public IndentLevel suggestedChildLevel(ExpressionHandler aChild)
     {
         return getChildrenExpectedLevel();
     }
 
 }
