diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 2149729d3..e06859ddd 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -129,217 +129,234 @@ public class JavadocMethodCheck
         Utils.createRE(MATCH_JAVADOC_NOARG_MULTILINE_START_PAT);
 
     /** the pattern to match Javadoc tags with no argument and {} **/
     private static final String MATCH_JAVADOC_NOARG_CURLY_PAT =
         "\\{\\s*@(inheritDoc)\\s*\\}";
     /** compiled regexp to match Javadoc tags with no argument and {} **/
     private static final RE MATCH_JAVADOC_NOARG_CURLY =
         Utils.createRE(MATCH_JAVADOC_NOARG_CURLY_PAT);
 
     /** the visibility scope where Javadoc comments are checked **/
     private Scope mScope = Scope.PRIVATE;
 
     /** the visibility scope where Javadoc comments shouldn't be checked **/
     private Scope mExcludeScope;
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      **/
     private boolean mAllowUndeclaredRTE;
 
     /**
      * controls whether to allow documented exceptions that
      * are subclass of one of declared exception.
      * Defaults to false (backward compatibility).
      **/
     private boolean mAllowThrowsTagsForSubclasses;
 
     /**
      * controls whether to ignore errors when a method has parameters
      * but does not have matching param tags in the javadoc.
      * Defaults to false.
      **/
     private boolean mAllowMissingParamTags;
 
     /**
      * controls whether to ignore errors when a method declares that
      * it throws exceptions but does not have matching throws tags
      * in the javadoc. Defaults to false.
      **/
     private boolean mAllowMissingThrowsTags;
 
     /**
      * controls whether to ignore errors when a method returns
      * non-void type but does not have a return tag in the javadoc.
      * Defaults to false.
      **/
     private boolean mAllowMissingReturnTag;
 
+    /**
+     * Controls whether to ignoreerrors when there is no javadoc.
+     * Defaults to false.
+     */
+    private boolean mAllowMissingJavadoc;
+
     /**
      * Set the scope.
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set the excludeScope.
      * @param aScope a <code>String</code> value
      */
     public void setExcludeScope(String aScope)
     {
         mExcludeScope = Scope.getInstance(aScope);
     }
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowUndeclaredRTE(boolean aFlag)
     {
         mAllowUndeclaredRTE = aFlag;
     }
 
     /**
      * controls whether to allow documented exception that
      * are subclass of one of declared exceptions.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowThrowsTagsForSubclasses(boolean aFlag)
     {
         mAllowThrowsTagsForSubclasses = aFlag;
     }
 
     /**
      * controls whether to allow a method which has parameters
      * to omit matching param tags in the javadoc.
      * Defaults to false.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowMissingParamTags(boolean aFlag)
     {
         mAllowMissingParamTags = aFlag;
     }
 
     /**
      * controls whether to allow a method which declares that
      * it throws exceptions to omit matching throws tags
      * in the javadoc. Defaults to false.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowMissingThrowsTags(boolean aFlag)
     {
         mAllowMissingThrowsTags = aFlag;
     }
 
     /**
      * controls whether to allow a method which returns
      * non-void type to omit the return tag in the javadoc.
      * Defaults to false.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowMissingReturnTag(boolean aFlag)
     {
         mAllowMissingReturnTag = aFlag;
     }
 
+    /**
+     * Controls whether to ignoreerrors when there is no javadoc.
+     * Defaults to false.
+     */
+    public void setAllowMissingJavadoc(boolean aFlag)
+    {
+        mAllowMissingJavadoc = aFlag;
+    }
+
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
         };
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     protected final void processAST(DetailAST aAST)
     {
         if (shouldCheck(aAST)) {
             final FileContents contents = getFileContents();
             final TextBlock cmt = contents.getJavadocBefore(aAST.getLineNo());
 
             if (cmt == null) {
-                log(aAST, "javadoc.missing");
+                if (!mAllowMissingJavadoc) {
+                    log(aAST, "javadoc.missing");
+                }
             }
             else {
                 checkComment(aAST, cmt);
             }
         }
     }
 
     /**
      * Whether we should check this node.
      * @param aAST a given node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope scope = ScopeUtils.inInterfaceOrAnnotationBlock(aAST)
                 ? Scope.PUBLIC : declaredScope;
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
 
         return scope.isIn(mScope) && surroundingScope.isIn(mScope)
             && ((mExcludeScope == null)
                 || !scope.isIn(mExcludeScope)
                 || !surroundingScope.isIn(mExcludeScope));
     }
 
     /**
      * Checks the Javadoc for a method.
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
      */
     private void checkComment(DetailAST aAST, TextBlock aComment)
     {
         final List tags = getMethodTags(aComment);
 
         // Check for only one @see or inheritDoc tag
         if ((tags.size() == 1)
             && ((JavadocTag) tags.get(0)).isSeeOrInheritDocTag())
         {
             return;
         }
 
         Iterator it = tags.iterator();
         if (aAST.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
                 hasInheritDocTag |=
                     ((JavadocTag) it.next()).isInheritDocTag();
             }
