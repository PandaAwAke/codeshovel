diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 58c84e46c..add0531cf 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -39,152 +39,196 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  *      the protected, then package level (no access modifier), and then
  *      the private. </li>
  * <li> Instance variables. First the public class variables, then
  *      the protected, then package level (no access modifier), and then
  *      the private. </li>
  * <li> Constructors </li>
  * <li> Methods </li>
  * </ol>
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="DeclarationOrder"/&gt;
  * </pre>
  *
  * @author r_auckenthaler
  */
 public class DeclarationOrderCheck extends Check
 {
     /** State for the VARIABLE_DEF */
     private static final int STATE_STATIC_VARIABLE_DEF = 1;
 
     /** State for the VARIABLE_DEF */
     private static final int STATE_INSTANCE_VARIABLE_DEF = 2;
 
     /** State for the CTOR_DEF */
     private static final int STATE_CTOR_DEF = 3;
 
     /** State for the METHOD_DEF */
     private static final int STATE_METHOD_DEF = 4;
 
     /**
      * List of Declaration States. This is necessary due to
      * inner classes that have their own state
      */
     private final FastStack<ScopeState> mScopeStates = FastStack.newInstance();
 
     /**
      * private class to encapsulate the state
      */
     private static class ScopeState
     {
         /** The state the check is in */
         private int mScopeState = STATE_STATIC_VARIABLE_DEF;
 
         /** The sub-state the check is in */
         private Scope mDeclarationAccess = Scope.PUBLIC;
     }
 
+    /** If true, ignores the check to constructors. */
+    private boolean mIgnoreConstructors;
+    /** If true, ignore the check to methods. */
+    private boolean mIgnoreMethods;
+    /** If true, ignore the check to modifiers (fields, ...). */
+    private boolean mIgnoreModifiers;
+
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final int parentType = aAST.getParent().getType();
         ScopeState state;
 
         switch(aAST.getType()) {
         case TokenTypes.OBJBLOCK:
             mScopeStates.push(new ScopeState());
             break;
 
         case TokenTypes.CTOR_DEF:
             if (parentType != TokenTypes.OBJBLOCK) {
                 return;
             }
 
             state = mScopeStates.peek();
             if (state.mScopeState > STATE_CTOR_DEF) {
-                log(aAST, "declaration.order.constructor");
+                if (!mIgnoreConstructors) {
+                    log(aAST, "declaration.order.constructor");
+                }
             }
             else {
                 state.mScopeState = STATE_CTOR_DEF;
             }
             break;
 
         case TokenTypes.METHOD_DEF:
             state = mScopeStates.peek();
             if (parentType != TokenTypes.OBJBLOCK) {
                 return;
             }
 
             if (state.mScopeState > STATE_METHOD_DEF) {
-                log(aAST, "declaration.order.method");
+                if (!mIgnoreMethods) {
+                    log(aAST, "declaration.order.method");
+                }
             }
             else {
                 state.mScopeState = STATE_METHOD_DEF;
             }
             break;
 
         case TokenTypes.MODIFIERS:
             if ((parentType != TokenTypes.VARIABLE_DEF)
                 || (aAST.getParent().getParent().getType()
                     != TokenTypes.OBJBLOCK))
             {
                 return;
             }
 
             state = mScopeStates.peek();
             if (aAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
                 if (state.mScopeState > STATE_STATIC_VARIABLE_DEF) {
-                    log(aAST, "declaration.order.static");
+                    if (!mIgnoreModifiers) {
+                        log(aAST, "declaration.order.static");
+                    }
                 }
                 else {
                     state.mScopeState = STATE_STATIC_VARIABLE_DEF;
                 }
             }
             else {
                 if (state.mScopeState > STATE_INSTANCE_VARIABLE_DEF) {
-                    log(aAST, "declaration.order.instance");
+                    if (!mIgnoreModifiers) {
+                        log(aAST, "declaration.order.instance");
+                    }
                 }
                 else if (state.mScopeState == STATE_STATIC_VARIABLE_DEF) {
                     state.mDeclarationAccess = Scope.PUBLIC;
                     state.mScopeState = STATE_INSTANCE_VARIABLE_DEF;
                 }
             }
 
             final Scope access = ScopeUtils.getScopeFromMods(aAST);
             if (state.mDeclarationAccess.compareTo(access) > 0) {
-                log(aAST, "declaration.order.access");
+                if (!mIgnoreModifiers) {
+                    log(aAST, "declaration.order.access");
+                }
             }
             else {
                 state.mDeclarationAccess = access;
             }
             break;
 
         default:
         }
     }
 
     @Override
     public void leaveToken(DetailAST aAST)
     {
         switch(aAST.getType()) {
         case TokenTypes.OBJBLOCK:
             mScopeStates.pop();
             break;
 
         default:
         }
     }
+
+    /**
+     * Sets whether to ignore constructors.
+     * @param aIgnoreConstructors whether to ignore constructors.
+     */
+    public void setIgnoreConstructors(boolean aIgnoreConstructors)
+    {
+        mIgnoreConstructors = aIgnoreConstructors;
+    }
+
+    /**
+     * Sets whether to ignore methods.
+     * @param aIgnoreMethods whether to ignore methods.
+     */
+    public void setIgnoreMethods(boolean aIgnoreMethods)
+    {
+        mIgnoreMethods = aIgnoreMethods;
+    }
+
+    /**
+     * Sets whether to ignore modifiers.
+     * @param aIgnoreModifiers whether to ignore modifiers.
+     */
+    public void setIgnoreModifiers(boolean aIgnoreModifiers)
+    {
+        mIgnoreModifiers = aIgnoreModifiers;
+    }
 }
