diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index 63bbc37c5..8079e5782 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -118,168 +118,168 @@ public class Checker
     /**
      * Creates a new <code>Checker</code> instance.
      *
      * @param aConfig the configuration to use
      * @param aConfigs the configuation of the checks to use
      * @throws CheckstyleException if an error occurs
      */
     public Checker(GlobalProperties aConfig, CheckConfiguration[] aConfigs)
         throws CheckstyleException
     {
         mConfig = aConfig;
         mCache = new PropertyCacheFile(aConfig);
         LocalizedMessage.setLocale(new Locale(mConfig.getLocaleLanguage(),
                                               mConfig.getLocaleCountry()));
         mWalker = new TreeWalker(mMessages, mConfig.getTabWidth());
         // TODO: improve the error handing
         for (int i = 0; i < aConfigs.length; i++) {
             final CheckConfiguration config = aConfigs[i];
             // IMPORTANT! Need to use the same class loader that created this
             // class. Otherwise can get ClassCastException problems.
             mWalker.registerCheck(
                 config.createInstance(this.getClass().getClassLoader()),
                 config);
         }
     }
 
     /** Cleans up the object **/
     public void destroy()
     {
         mCache.destroy();
         mListeners.clear();
     }
 
     /**
      * Add the listener that will be used to receive events from the audit
      * @param aListener the nosy thing
      */
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Processes a set of files.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
-    public int process(String[] aFiles)
+    public int process(File[] aFiles)
     {
         int total = 0;
         fireAuditStarted();
         for (int i = 0; i < aFiles.length; i++) {
             total += process(aFiles[i]);
         }
         fireAuditFinished();
         return total;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
-     * @param aFileName the name of the file to process
+     * @param aFile the file to process
      **/
-    private int process(String aFileName)
+    private int process(File aFile)
     {
         // check if already checked and passed the file
-        final File f = new File(aFileName);
-        final long timestamp = f.lastModified();
-        if (mCache.alreadyChecked(aFileName, timestamp)) {
+        final String fileName = aFile.getPath();
+        final long timestamp = aFile.lastModified();
+        if (mCache.alreadyChecked(fileName, timestamp)) {
             return 0;
         }
 
         // Create a stripped down version
         final String stripped;
         final String basedir = mConfig.getBasedir();
-        if ((basedir == null) || !aFileName.startsWith(basedir)) {
-            stripped = aFileName;
+        if ((basedir == null) || !fileName.startsWith(basedir)) {
+            stripped = fileName;
         }
         else {
             // making the assumption that there is text after basedir
             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;
-            stripped = aFileName.substring(basedir.length() + skipSep);
+            stripped = fileName.substring(basedir.length() + skipSep);
         }
 
         mMessages.reset();
         try {
             fireFileStarted(stripped);
-            final String[] lines = Utils.getLines(aFileName);
-            final FileContents contents = new FileContents(aFileName, lines);
+            final String[] lines = Utils.getLines(fileName);
+            final FileContents contents = new FileContents(fileName, lines);
             final DetailAST rootAST = parse(contents);
             mWalker.walk(rootAST, contents, mConfig.getClassLoader());
         }
         catch (FileNotFoundException fnfe) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.fileNotFound", null));
         }
         catch (IOException ioe) {
             mMessages.add(new LocalizedMessage(
                               0, Defn.CHECKSTYLE_BUNDLE,
                               "general.exception",
                               new String[] {ioe.getMessage()}));
         }
         catch (RecognitionException re) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {re.getMessage()}));
         }
         catch (TokenStreamException te) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {te.getMessage()}));
         }
 
         if (mMessages.size() == 0) {
-            mCache.checkedOk(aFileName, timestamp);
+            mCache.checkedOk(fileName, timestamp);
         }
         else {
             fireErrors(stripped, mMessages.getMessages());
         }
 
         fireFileFinished(stripped);
         return mMessages.size();
     }
 
     /**
      *
      * @param aContents contains the contents of the file
      * @return the root of the AST
      * @throws TokenStreamException if lexing failed
      * @throws RecognitionException if parsing failed
      */
     public static DetailAST parse(FileContents aContents)
         throws TokenStreamException, RecognitionException
     {
         DetailAST rootAST;
         try {
             // try the 1.4 grammar first, this will succeed for
             // all code that compiles without any warnings in JDK 1.4,
             // that should cover most cases
             final Reader sar = new StringArrayReader(aContents.getLines());
             final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);
             jl.setFilename(aContents.getFilename());
             jl.setFileContents(aContents);
 
             final GeneratedJava14Recognizer jr =
                 new SilentJava14Recognizer(jl);
             jr.setFilename(aContents.getFilename());
             jr.setASTNodeClass(DetailAST.class.getName());
             jr.compilationUnit();
             rootAST = (DetailAST) jr.getAST();
         }
         catch (RecognitionException re) {
             // Parsing might have failed because the checked
             // file contains "assert" as an identifier. Retry with a
             // grammar that treats "assert" as an identifier
             // and not as a keyword
 
             // Arghh - the pain - duplicate code!
             final Reader sar = new StringArrayReader(aContents.getLines());
             final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
             jl.setFilename(aContents.getFilename());
             jl.setFileContents(aContents);
 
             final GeneratedJavaRecognizer jr = new GeneratedJavaRecognizer(jl);
             jr.setFilename(aContents.getFilename());
