diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index d23a239b2..d90cbb8df 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -213,199 +213,197 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowMissingJavadoc(boolean aFlag)
     {
         mAllowMissingJavadoc = aFlag;
     }
 
     /**
      * Controls whether to ignore errors when there is no javadoc for a
      * property accessor (setter/getter methods). Defaults to false.
      *
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowMissingPropertyJavadoc(final boolean aFlag)
     {
         mAllowMissingPropertyJavadoc = aFlag;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.PACKAGE_DEF, TokenTypes.IMPORT,
                           TokenTypes.CLASS_DEF, TokenTypes.ENUM_DEF,
                           TokenTypes.METHOD_DEF, TokenTypes.CTOR_DEF,
                           TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {TokenTypes.METHOD_DEF, TokenTypes.CTOR_DEF,
                           TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     protected final void processAST(DetailAST aAST)
     {
         final Scope theScope = calculateScope(aAST);
         if (shouldCheck(aAST, theScope)) {
             final FileContents contents = getFileContents();
             final TextBlock cmt = contents.getJavadocBefore(aAST.getLineNo());
 
             if (cmt == null) {
                 if (!isMissingJavadocAllowed(aAST)) {
                     log(aAST, "javadoc.missing");
                 }
             }
             else {
-                checkComment(aAST, cmt, theScope);
+                checkComment(aAST, cmt);
             }
         }
     }
 
     @Override
     protected final void logLoadError(Token aIdent)
     {
         logLoadErrorImpl(aIdent.getLineNo(), aIdent.getColumnNo(),
             "javadoc.classInfo",
             JavadocTagInfo.THROWS.getText(), aIdent.getText());
     }
 
     /**
      * The JavadocMethodCheck is about to report a missing Javadoc.
      * This hook can be used by derived classes to allow a missing javadoc
      * in some situations.  The default implementation checks
      * <code>allowMissingJavadoc</code> and
      * <code>allowMissingPropertyJavadoc</code> properties, do not forget
      * to call <code>super.isMissingJavadocAllowed(aAST)</code> in case
      * you want to keep this logic.
      * @param aAST the tree node for the method or constructor.
      * @return True if this method or constructor doesn't need Javadoc.
      */
     protected boolean isMissingJavadocAllowed(final DetailAST aAST)
     {
         return mAllowMissingJavadoc || isOverrideMethod(aAST)
             || (mAllowMissingPropertyJavadoc
                 && (isSetterMethod(aAST) || isGetterMethod(aAST)));
     }
 
     /**
      * Whether we should check this node.
      *
      * @param aAST a given node.
      * @param aScope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST aAST, final Scope aScope)
     {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
 
         return aScope.isIn(mScope)
                 && surroundingScope.isIn(mScope)
                 && ((mExcludeScope == null) || !aScope.isIn(mExcludeScope)
                     || !surroundingScope.isIn(mExcludeScope));
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
-     * @param aScope the scope of the method.
      */
-    private void checkComment(DetailAST aAST, TextBlock aComment, Scope aScope)
+    private void checkComment(DetailAST aAST, TextBlock aComment)
     {
         final List<JavadocTag> tags = getMethodTags(aComment);
 
-        if (hasShortCircuitTag(aAST, tags, aScope)) {
+        if (hasShortCircuitTag(aAST, tags)) {
             return;
         }
 
         Iterator<JavadocTag> it = tags.iterator();
         if (aAST.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
                 hasInheritDocTag |= (it.next()).isInheritDocTag();
             }
 
             checkParamTags(tags, aAST, !hasInheritDocTag);
             checkThrowsTags(tags, getThrows(aAST), !hasInheritDocTag);
             if (isFunction(aAST)) {
                 checkReturnTag(tags, aAST.getLineNo(), !hasInheritDocTag);
             }
         }
 
         // Dump out all unused tags
         it = tags.iterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (!jt.isSeeOrInheritDocTag()) {
                 log(jt.getLineNo(), "javadoc.unusedTagGeneral");
             }
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param aAST the construct being checked
      * @param aTags the list of Javadoc tags associated with the construct
-     * @param aScope the scope of the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST aAST,
-            final List<JavadocTag> aTags, final Scope aScope)
+            final List<JavadocTag> aTags)
     {
         // Check if it contains {@inheritDoc} tag
         if ((aTags.size() != 1)
                 || !(aTags.get(0)).isInheritDocTag())
         {
             return false;
         }
 
         // Invalid if private, a constructor, or a static method
         if (!JavadocTagInfo.INHERIT_DOC.isValidOn(aAST)) {
             log(aAST, "javadoc.invalidInheritDoc");
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param aAST the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private Scope calculateScope(final DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         return ScopeUtils.inInterfaceOrAnnotationBlock(aAST) ? Scope.PUBLIC
                 : declaredScope;
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      *
      * @return the tags found
      * @param aComment the Javadoc comment
      */
     private List<JavadocTag> getMethodTags(TextBlock aComment)
     {
         final String[] lines = aComment.getText();
         final List<JavadocTag> tags = Lists.newArrayList();
         int currentLine = aComment.getStartLineNo() - 1;
 
         for (int i = 0; i < lines.length; i++) {
             currentLine++;
             final Matcher javadocArgMatcher =
                 MATCH_JAVADOC_ARG.matcher(lines[i]);
             final Matcher javadocNoargMatcher =
