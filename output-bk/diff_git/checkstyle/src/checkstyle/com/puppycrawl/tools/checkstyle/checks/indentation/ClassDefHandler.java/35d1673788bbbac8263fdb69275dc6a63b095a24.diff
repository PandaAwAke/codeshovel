diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
index c46fd4463..be20c3e99 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java
@@ -51,93 +51,94 @@ public class ClassDefHandler extends BlockParentHandler
      * Get the left curly brace portion of the expression we are handling.
      *
      * @return the left curly brace expression
      */
     protected DetailAST getLCurly()
     {
         return getMainAst().findFirstToken(TokenTypes.OBJBLOCK)
             .findFirstToken(TokenTypes.LCURLY);
     }
 
     /**
      * Get the right curly brace portion of the expression we are handling.
      *
      * @return the right curly brace expression
      */
     protected DetailAST getRCurly()
     {
         return getMainAst().findFirstToken(TokenTypes.OBJBLOCK)
             .findFirstToken(TokenTypes.RCURLY);
     }
 
     /**
      * There is no top level expression for this handler.
      *
      * @return null
      */
     protected DetailAST getToplevelAST()
     {
         return null;
         // note: ident checked by hand in check indentation;
     }
 
     /**
      * Get the child element representing the list of statements.
      *
      * @return the statement list child
      */
     protected DetailAST getListChild()
     {
         return getMainAst().findFirstToken(TokenTypes.OBJBLOCK);
     }
 
     /**
      * Check the indentation of the expression we are handling.
      */
     public void checkIndentation()
     {
         // TODO: still need to better deal with the modifiers and "class"
         checkModifiers();
 
-        LineSet lines = new LineSet();
+        final LineSet lines = new LineSet();
 
         // checks that line with class name starts at correct indentation,
         //  and following lines (in implements and extends clauses) are
         //  indented at least one level
-        DetailAST ident = getMainAst().findFirstToken(TokenTypes.IDENT);
-        int lineStart = getLineStart(ident);
+        final DetailAST ident = getMainAst().findFirstToken(TokenTypes.IDENT);
+        final int lineStart = getLineStart(ident);
         if (!getLevel().accept(lineStart)) {
             logError(ident, "ident", lineStart);
         }
 
         lines.addLineAndCol(new Integer(ident.getLineNo()), lineStart);
 
-        DetailAST impl = getMainAst().findFirstToken(
+        final DetailAST impl = getMainAst().findFirstToken(
             TokenTypes.IMPLEMENTS_CLAUSE);
         if ((impl != null) && (impl.getFirstChild() != null)) {
             findSubtreeLines(lines, impl, false);
         }
 
-        DetailAST ext = getMainAst().findFirstToken(TokenTypes.EXTENDS_CLAUSE);
+        final DetailAST ext =
+            getMainAst().findFirstToken(TokenTypes.EXTENDS_CLAUSE);
         if ((ext != null) && (ext.getFirstChild() != null)) {
             findSubtreeLines(lines, ext, false);
         }
 
         checkLinesIndent(ident.getLineNo(), lines.lastLine(), getLevel());
 
         super.checkIndentation();
     }
 
     /** {@inheritDoc} */
     protected int[] getCheckedChildren()
     {
         return new int[] {
             TokenTypes.EXPR,
             TokenTypes.OBJBLOCK,
             TokenTypes.LITERAL_BREAK,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_THROW,
             TokenTypes.LITERAL_CONTINUE,
         };
     }
 
 }
