diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
index 63ef9d68d..49bc12383 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java
@@ -118,108 +118,108 @@ public final class Main
         final AuditListener listener = createListener(line, out, closeOut);
         final List<File> files = getFilesToProcess(line);
         final Checker c = createChecker(config, moduleFactory, listener);
 
         final File[] processedFiles = new File[files.size()];
         files.toArray(processedFiles);
         final int numErrs = c.process(processedFiles);
         c.destroy();
         System.exit(numErrs);
     }
 
     /**
      * Creates the Checker object.
      *
      * @param aConfig the configuration to use
      * @param aFactory the module factor to use
      * @param aNosy the sticky beak to track what happens
      * @return a nice new fresh Checker
      */
     private static Checker createChecker(Configuration aConfig,
                                          ModuleFactory aFactory,
                                          AuditListener aNosy)
     {
         Checker c = null;
         try {
             c = new Checker();
             c.setModuleFactory(aFactory);
             c.configure(aConfig);
             c.addListener(aNosy);
         }
         catch (final Exception e) {
             System.out.println("Unable to create Checker: "
                                + e.getMessage());
             e.printStackTrace(System.out);
             System.exit(1);
         }
         return c;
     }
 
     /**
      * Determines the files to process.
      *
      * @param aLine the command line options specifying what files to process
      * @return list of files to process
      */
     private static List<File> getFilesToProcess(CommandLine aLine)
     {
         final List<File> files = new LinkedList<File>();
         if (aLine.hasOption("r")) {
             final String[] values = aLine.getOptionValues("r");
-            for (int i = 0; i < values.length; i++) {
-                traverse(new File(values[i]), files);
+            for (String element : values) {
+                traverse(new File(element), files);
             }
         }
 
         final String[] remainingArgs = aLine.getArgs();
-        for (int i = 0; i < remainingArgs.length; i++) {
-            files.add(new File(remainingArgs[i]));
+        for (String element : remainingArgs) {
+            files.add(new File(element));
         }
 
         if (files.isEmpty()) {
             System.out.println("Must specify files to process");
             usage();
         }
         return files;
     }
 
     /**
      * Create the audit listener
      *
      * @param aLine command line options supplied
      * @param aOut the stream to log to
      * @param aCloseOut whether the stream should be closed
      * @return a fresh new <code>AuditListener</code>
      */
     private static AuditListener createListener(CommandLine aLine,
                                                 OutputStream aOut,
                                                 boolean aCloseOut)
     {
         final String format =
             aLine.hasOption("f") ? aLine.getOptionValue("f") : "plain";
 
         AuditListener listener = null;
         if ("xml".equals(format)) {
             listener = new XMLLogger(aOut, aCloseOut);
         }
         else if ("plain".equals(format)) {
             listener = new DefaultLogger(aOut, aCloseOut);
         }
         else {
             System.out.println("Invalid format: (" + format
                                + "). Must be 'plain' or 'xml'.");
             usage();
         }
         return listener;
     }
 
     /**
      * Loads the packages, or exists if unable to.
      *
      * @param aLine the supplied command line options
      * @return a fresh new <code>ModuleFactory</code>
      */
     private static ModuleFactory loadPackages(CommandLine aLine)
     {
         try {
             return PackageNamesLoader.loadModuleFactory(
                 aLine.getOptionValue("n"));
@@ -232,83 +232,83 @@ public final class Main
         }
     }
 
     /**
      * Loads the configuration file. Will exit if unable to load.
      *
      * @param aLine specifies the location of the configuration
      * @param aProps the properties to resolve with the configuration
      * @return a fresh new configuration
      */
     private static Configuration loadConfig(CommandLine aLine,
                                             Properties aProps)
     {
         try {
             return ConfigurationLoader.loadConfiguration(
                     aLine.getOptionValue("c"), new PropertiesExpander(aProps));
         }
         catch (final CheckstyleException e) {
             System.out.println("Error loading configuration file");
             e.printStackTrace(System.out);
             System.exit(1);
             return null; // can never get here
         }
     }
 
     /** Prints the usage information. **/
     private static void usage()
     {
         final HelpFormatter hf = new HelpFormatter();
         hf.printHelp(
             "java "
                 + Main.class.getName()
                 + " [options] -c <config.xml> file...",
             OPTS);
         System.exit(1);
     }
 
     /**
      * Traverses a specified node looking for files to check. Found
      * files are added to a specified list. Subdirectories are also
      * traversed.
      *
      * @param aNode the node to process
      * @param aFiles list to add found files to
      */
     private static void traverse(File aNode, List<File> aFiles)
     {
         if (aNode.canRead()) {
             if (aNode.isDirectory()) {
                 final File[] nodes = aNode.listFiles();
-                for (int i = 0; i < nodes.length; i++) {
-                    traverse(nodes[i], aFiles);
+                for (File element : nodes) {
+                    traverse(element, aFiles);
                 }
             }
             else if (aNode.isFile()) {
                 aFiles.add(aNode);
             }
         }
     }
 
     /**
      * Loads properties from a File.
      * @param aFile the properties file
      * @return the properties in aFile
      */
     private static Properties loadProperties(File aFile)
     {
         final Properties properties = new Properties();
         try {
             FileInputStream fis = null;
             fis = new FileInputStream(aFile);
             properties.load(fis);
             fis.close();
         }
         catch (final IOException ex) {
             System.out.println("Unable to load properties from file: "
                                + aFile.getAbsolutePath());
             ex.printStackTrace(System.out);
             System.exit(1);
         }
         return properties;
     }
 }
