diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index 91e69a2c5..9bf761143 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -145,103 +145,101 @@ public class JavadocMethodCheck
      * java.lang.RuntimeException.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowUndeclaredRTE(boolean aFlag)
     {
         mAllowUndeclaredRTE = aFlag;
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree()
     {
         mPackageFullIdent = FullIdent.createFullIdent(null);
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.PACKAGE_DEF) {
             if (mAllowUndeclaredRTE) {
                 processPackage(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
-            if (mAllowUndeclaredRTE) {
-                processImport(aAST);
-            }
+            processImport(aAST);
         }
         else {
             //TokenTypes.METHOD_DEF or TokenTypes.CTOR_DEF
             processMethod(aAST);
         }
     }
 
 
 
     /**
      * Collects the details of a package.
      * @param aAST node containing the package details
      */
     private void processPackage(DetailAST aAST)
     {
         final DetailAST nameAST = (DetailAST) aAST.getFirstChild();
         mPackageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = getImportText(aAST);
         if (name != null) {
             mImports.add(name.getText());
         }
     }
 
     /**
      * Checks Javadoc comments for a method or constructor.
      * @param aAST the tree node for the method or constructor.
      */
     private void processMethod(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope targetScope =
             ScopeUtils.inInterfaceBlock(aAST)
                 ? Scope.PUBLIC
                 : declaredScope;
 
         if (targetScope.isIn(mScope)) {
             final Scope surroundingScope =
                 ScopeUtils.getSurroundingScope(aAST);
 
             if (surroundingScope.isIn(mScope)) {
                 final FileContents contents = getFileContents();
@@ -387,168 +385,232 @@ public class JavadocMethodCheck
         return retVal;
     }
 
 
     /**
      * Checks a set of tags for matching parameters.
      * @param aTags the tags to check
      * @param aParams the list of parameters to check
      **/
     private void checkParamTags(List aTags, List aParams)
     {
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching param
             boolean found = false;
             final Iterator paramIt = aParams.iterator();
             while (paramIt.hasNext()) {
                 final DetailAST param = (DetailAST) paramIt.next();
                 if (param.getText().equals(tag.getArg1())) {
                     found = true;
                     paramIt.remove();
                     break;
                 }
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), "javadoc.unusedTag",
                               "@param", tag.getArg1());
             }
         }
 
         // Now dump out all parameters without tags
         final Iterator paramIt = aParams.iterator();
         while (paramIt.hasNext()) {
             final DetailAST param = (DetailAST) paramIt.next();
             log(param.getLineNo(), param.getColumnNo(),
                 "javadoc.expectedTag", "@param", param.getText());
         }
     }
 
+    /**
+     * Return if two Strings represent the same type, inspecting the
+     * import statements if necessary
+     *
+     * @param aDeclared type declared in throws clause
+     * @param aDocumented type declared in javadoc throws tag
+     * @return true iff type names represent the same type
+     */
+    private boolean isSameType(String aDeclared, String aDocumented)
+    {
+        return aDeclared.equals(aDocumented)
+                || isShortName(aDeclared, aDocumented)
+                || isShortName(aDocumented, aDeclared);
+    }
+
+    /**
+     * Calculate if one type name is a shortname for another type name.
+     * @param aShortName a shorthand, such as <code>IOException</code>
+     * @param aFullName a full name, such as <code>java.io.IOException</code>
+     * @return true iff aShortName represents the same type as aFullName
+     */
+    private boolean isShortName(String aShortName, String aFullName)
+    {
+        if (aShortName.length() >= aFullName.length()) {
+            return false;
+        }
+
+        final String base = basename(aFullName);
+        if (aShortName.length() >= aFullName.length()
+                || !base.equals(aShortName))
+        {
+            return false;
+        }
+
+        // check fully qualified import
+        if (mImports.contains(aFullName)) {
+            return true;
+        }
+
+        // check .* import
+        final int endIndex = aFullName.length() - base.length() - 1;
+        final String packageName = aFullName.substring(0, endIndex);
+        final String starImport = packageName + ".*";
+        if (mImports.contains(starImport)) {
+            return true;
+        }
+
+        // check fully qualified class from same package
+        return packageName.equals(mPackageFullIdent.getText());
+    }
+
     /**
      * Checks whether a method is a function.
      * @param aAST the method node.
      * @return whether the method is a function.
      **/
     private boolean isFunction(DetailAST aAST)
     {
         boolean retVal = false;
         if (aAST.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = aAST.findFirstToken(TokenTypes.TYPE);
             if ((typeAST != null)
                 && (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null))
             {
                 retVal = true;
             }
         }
         return retVal;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      * @param aTags the tags to check
      * @param aLineNo the line number of the expected tag
      **/
     private void checkReturnTag(List aTags, int aLineNo)
     {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator it = aTags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = (JavadocTag) it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), "javadoc.return.duplicate");
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags
         if (!found) {
             log(aLineNo, "javadoc.return.expected");
         }
     }
 
 
     /**
      * Checks a set of tags for matching throws.
      * @param aTags the tags to check
      * @param aThrows the throws to check
      **/
     private void checkThrowsTags(List aTags, List aThrows)
     {
         // Loop over the tags, checking to see they exist in the throws.
         final Set foundThrows = new HashSet();
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             boolean found = foundThrows.contains(documentedEx);
             final ListIterator throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final FullIdent fi = (FullIdent) throwIt.next();
-                if (fi.getText().equals(documentedEx)) {
+                final String declaredEx = fi.getText();
+                if (isSameType(declaredEx, documentedEx)) {
                     found = true;
                     throwIt.remove();
                     foundThrows.add(documentedEx);
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (mAllowUndeclaredRTE) {
                     final ClassResolver cr =
                         new ClassResolver(
                             getClassLoader(),
                             mPackageFullIdent.getText(),
                             mImports);
                     try {
                         final Class clazz = cr.resolve(tag.getArg1());
                         reqd =
                             !RuntimeException.class.isAssignableFrom(clazz)
                                 && !Error.class.isAssignableFrom(clazz);
                     }
                     catch (ClassNotFoundException e) {
                         log(tag.getLineNo(), "javadoc.classInfo",
                                       "@throws", tag.getArg1());
                     }
                 }
 
                 if (reqd) {
                     log(tag.getLineNo(), "javadoc.unusedTag",
                                   "@throws", tag.getArg1());
                 }
             }
         }
 
         // Now dump out all throws without tags
         final ListIterator throwIt = aThrows.listIterator();
         while (throwIt.hasNext()) {
             final FullIdent fi = (FullIdent) throwIt.next();
             log(fi.getLineNo(), fi.getColumnNo(),
                 "javadoc.expectedTag", "@throws", fi.getText());
         }
     }
+
+    // TODO: clean up duplicate code in UnusedImports and IllegalInstantiation
+    /**
+     * @return the class name from a fully qualified name
+     * @param aType the fully qualified name
+     */
+    private String basename(String aType)
+    {
+        final int i = aType.lastIndexOf(".");
+        return (i == -1) ? aType : aType.substring(i + 1);
+    }
+
 }
