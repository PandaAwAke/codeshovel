diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
index 3cca43da1..580466634 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
@@ -105,135 +105,141 @@ public class JavadocTypeCheck
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set the excludeScope.
      * @param aScope a <code>String</code> value
      */
     public void setExcludeScope(String aScope)
     {
         mExcludeScope = Scope.getInstance(aScope);
     }
 
     /**
      * Set the author tag pattern.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setAuthorFormat(String aFormat)
         throws ConversionException
     {
         try {
             mAuthorFormat = aFormat;
             mAuthorFormatRE = Utils.getRE(aFormat);
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
 
     /**
      * Set the version format pattern.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setVersionFormat(String aFormat)
         throws ConversionException
     {
         try {
             mVersionFormat = aFormat;
             mVersionFormatRE = Utils.getRE(aFormat);
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
 
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
-        return new int[] {TokenTypes.INTERFACE_DEF, TokenTypes.CLASS_DEF};
+        return new int[] {
+            TokenTypes.INTERFACE_DEF,
+            TokenTypes.CLASS_DEF,
+            TokenTypes.ENUM_DEF,
+            TokenTypes.ANNOTATION_DEF,
+        };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (shouldCheck(aAST)) {
             final FileContents contents = getFileContents();
             final int lineNo = aAST.getLineNo();
             final TextBlock cmt = contents.getJavadocBefore(lineNo);
             if (cmt == null) {
                 log(lineNo, "javadoc.missing");
             }
             else if (ScopeUtils.isOuterMostType(aAST)) {
                 // don't check author/version for inner classes
                 Vector tags = getJavadocTags(cmt);
                 checkTag(lineNo, tags, "author",
                          mAuthorFormatRE, mAuthorFormat);
                 checkTag(lineNo, tags, "version",
                          mVersionFormatRE, mVersionFormat);
             }
         }
     }
 
     /**
      * Whether we should check this node.
      * @param aAST a given node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope scope =
-            ScopeUtils.inInterfaceBlock(aAST) ? Scope.PUBLIC : declaredScope;
+            ScopeUtils.inInterfaceOrAnnotationBlock(aAST)
+                ? Scope.PUBLIC : declaredScope;
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
 
         return scope.isIn(mScope)
             && ((surroundingScope == null) || surroundingScope.isIn(mScope))
             && ((mExcludeScope == null)
                 || !scope.isIn(mExcludeScope)
                 || (surroundingScope != null)
                 && !surroundingScope.isIn(mExcludeScope));
     }
 
     /**
      * Gets all standalone tags from a given javadoc.
      * @param aCmt teh Javadoc comment to process.
      * @return all standalone tags from the given javadoc.
      */
     private Vector getJavadocTags(TextBlock aCmt)
     {
         final String[] text = aCmt.getText();
         Vector tags = new Vector();
         RE tagRE = Utils.getRE("/\\*{2,}\\s*@([:alpha:]+)\\s");
         for (int i = 0; i < text.length; i++) {
             final String s = text[i];
             if (tagRE.match(s)) {
                 final String tagName = tagRE.getParen(1);
                 String content = s.substring(tagRE.getParenEnd(0));
                 if (content.endsWith("*/")) {
                     content = content.substring(0, content.length() - 2);
                 }
                 tags.add(new JavadocTag(aCmt.getStartLineNo() + i,
                                         tagName,
                                         content.trim()));
             }
             tagRE = Utils.getRE("^\\s*\\**\\s*@([:alpha:]+)\\s");
         }
         return tags;
     }
 
     /**
      * Verifies that a type definition has a required tag.
      * @param aLineNo the line number for the type definition.
      * @param aTags tags from the Javadoc comment for the type definition.
      * @param aTag the required tag name.
      * @param aFormatRE regexp for the tag value.
      * @param aFormat pattern for the tag value.
      */
     private void checkTag(int aLineNo, Vector aTags, String aTag,
                           RE aFormatRE, String aFormat)
     {
         if (aFormatRE == null) {
             return;
