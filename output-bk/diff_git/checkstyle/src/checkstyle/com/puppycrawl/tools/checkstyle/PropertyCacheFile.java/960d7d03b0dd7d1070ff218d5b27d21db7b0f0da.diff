diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index d3001e31c..cc15a5056 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -18,137 +18,165 @@
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.Properties;
 import java.security.MessageDigest;
 
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 
 /**
  * This class maintains a persistent store of the files that have
  * checked ok and their associated timestamp. It uses a property file
  * for storage.  A hashcode of the Configuration is stored in the
  * cache file to ensure the cache is invalidated when the
  * configuration has changed.
  *
  * @author <a href="mailto:oliver-work@puppycrawl.com">Oliver Burn</a>
  */
 class PropertyCacheFile
 {
     /**
      * The property key to use for storing the hashcode of the
      * configuration. To avoid nameclashes with the files that are
      * checked the key is chosen in such a way that it cannot be a
      * valid file name.
      */
     private static final String CONFIG_HASH_KEY = "configuration*?";
 
     /** name of file to store details **/
     private final String mDetailsFile;
     /** the details on files **/
     private final Properties mDetails = new Properties();
 
     /**
      * Creates a new <code>PropertyCacheFile</code> instance.
      *
      * @param aCurrentConfig the current configuration, not null
      * @param aFileName the cache file
      */
     PropertyCacheFile(Configuration aCurrentConfig, String aFileName)
     {
         boolean setInActive = true;
         final String fileName = aFileName;
         if (fileName != null) {
+            FileInputStream inStream = null;
             try {
-                mDetails.load(new FileInputStream(fileName));
+                inStream = new FileInputStream(fileName);
+                mDetails.load(inStream);
                 String cachedConfigHash = mDetails.getProperty(CONFIG_HASH_KEY);
                 String currentConfigHash = getConfigHashCode(aCurrentConfig);
                 setInActive = false;
                 if ((cachedConfigHash == null)
                     || !cachedConfigHash.equals(currentConfigHash))
                 {
                     // Detected configuration change - clear cache
                     mDetails.clear();
                     mDetails.put(CONFIG_HASH_KEY, currentConfigHash);
                 }
             }
             catch (FileNotFoundException e) {
                 // Ignore, the cache does not exist
                 setInActive = false;
             }
             catch (IOException e) {
                 // TODO: use logger
                 System.out.println("Unable to open cache file, ignoring.");
                 e.printStackTrace(System.out);
             }
+            finally {
+                if (inStream != null) {
+                    try {
+                        inStream.close();
+                    }
+                    catch (IOException ex) {
+                        // TODO: use logger
+                        System.out.println("Unable to close cache file.");
+                        ex.printStackTrace(System.out);
+                    }
+                }
+            }
         }
         mDetailsFile = (setInActive) ? null : fileName;
     }
 
     /** Cleans up the object and updates the cache file. **/
     void destroy()
     {
         if (mDetailsFile != null) {
+            FileOutputStream out = null;
             try {
-                mDetails.store(new FileOutputStream(mDetailsFile), null);
+                out = new FileOutputStream(mDetailsFile);
+                mDetails.store(out, null);
             }
             catch (IOException e) {
                 System.out.println("Unable to save cache file");
                 e.printStackTrace(System.out);
             }
+            finally {
+                if (out != null) {
+                    try {
+                        out.flush();
+                        out.close();
+                    }
+                    catch (IOException ex) {
+                        System.out.println("Unable to close cache file");
+                        ex.printStackTrace(System.out);
+                    }
+                }
+            }
         }
     }
 
     /**
      * @return whether the specified file has already been checked ok
      * @param aFileName the file to check
      * @param aTimestamp the timestamp of the file to check
      */
     boolean alreadyChecked(String aFileName, long aTimestamp)
     {
         final String lastChecked = mDetails.getProperty(aFileName);
         return (lastChecked != null)
             && (lastChecked.equals(Long.toString(aTimestamp)));
     }
 
     /**
      * Records that a file checked ok.
      * @param aFileName name of the file that checked ok
      * @param aTimestamp the timestamp of the file
      */
     void checkedOk(String aFileName, long aTimestamp)
     {
         mDetails.put(aFileName, Long.toString(aTimestamp));
     }
 
     /**
      * Calculates the hashcode for a GlobalProperties.
      *
      * @param aConfiguration the GlobalProperties
      * @return the hashcode for <code>aConfiguration</code>
      */
     private String getConfigHashCode(Serializable aConfiguration)
     {
         try {
             // im-memory serialization of Configuration
 
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos);
             oos.writeObject(aConfiguration);
             oos.flush();
             oos.close();
 
             // Instead of hexEncoding baos.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             MessageDigest md = MessageDigest.getInstance("SHA");
             md.update(baos.toByteArray());
 
             return hexEncode(md.digest());
