diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index 929bcf207..ec87c6cca 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -176,101 +176,101 @@ public class UnnecessaryParenthesesCheck extends Check
         if ((type == TokenTypes.ASSIGN)
             && (parent.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR))
         {
             // shouldn't process assign in annotation pairs
             return;
         }
 
         // An expression is surrounded by parentheses.
         if (type == TokenTypes.EXPR) {
 
             // If 'mParentToSkip' == 'aAST', then we've already logged a
             // warning about an immediate child node in visitToken, so we don't
             // need to log another one here.
 
             if ((mParentToSkip != aAST) && exprSurrounded(aAST)) {
                 if (mAssignDepth >= 1) {
                     log(aAST, "unnecessary.paren.assign");
                 }
                 else if (aAST.getParent().getType()
                     == TokenTypes.LITERAL_RETURN)
                 {
                     log(aAST, "unnecessary.paren.return");
                 }
                 else {
                     log(aAST, "unnecessary.paren.expr");
                 }
             }
 
             mParentToSkip = null;
         }
         else if (inTokenList(type, ASSIGNMENTS)) {
             mAssignDepth--;
         }
 
         super.leaveToken(aAST);
     }
 
     /**
      * Tests if the given <code>DetailAST</code> is surrounded by parentheses.
      * In short, does <code>aAST</code> have a previous sibling whose type is
      * <code>TokenTypes.LPAREN</code> and a next sibling whose type is <code>
      * TokenTypes.RPAREN</code>.
      * @param aAST the <code>DetailAST</code> to check if it is surrounded by
      *        parentheses.
      * @return <code>true</code> if <code>aAST</code> is surrounded by
      *         parentheses.
      */
     private boolean isSurrounded(DetailAST aAST)
     {
         final DetailAST prev = aAST.getPreviousSibling();
-        final DetailAST next = (DetailAST) aAST.getNextSibling();
+        final DetailAST next = aAST.getNextSibling();
 
         return (prev != null) && (prev.getType() == TokenTypes.LPAREN)
             && (next != null) && (next.getType() == TokenTypes.RPAREN);
     }
 
     /**
      * Tests if the given expression node is surrounded by parentheses.
      * @param aAST a <code>DetailAST</code> whose type is
      *        <code>TokenTypes.EXPR</code>.
      * @return <code>true</code> if the expression is surrounded by
      *         parentheses.
      * @throws IllegalArgumentException if <code>aAST.getType()</code> is not
      *         equal to <code>TokenTypes.EXPR</code>.
      */
     private boolean exprSurrounded(DetailAST aAST)
     {
         if (aAST.getType() != TokenTypes.EXPR) {
             throw new IllegalArgumentException("Not an expression node.");
         }
         boolean surrounded = false;
         if (aAST.getChildCount() >= MIN_CHILDREN_FOR_MATCH) {
             final AST n1 = aAST.getFirstChild();
             final AST nn = aAST.getLastChild();
 
             surrounded = (n1.getType() == TokenTypes.LPAREN)
                 && (nn.getType() == TokenTypes.RPAREN);
         }
         return surrounded;
     }
 
     /**
      * Check if the given token type can be found in an array of token types.
      * @param aType the token type.
      * @param aTokens an array of token types to search.
      * @return <code>true</code> if <code>aType</code> was found in <code>
      *         aTokens</code>.
      */
     private boolean inTokenList(int aType, int [] aTokens)
     {
         // NOTE: Given the small size of the two arrays searched, I'm not sure
         //       it's worth bothering with doing a binary search or using a
         //       HashMap to do the searches.
 
         boolean found = false;
         for (int i = 0; (i < aTokens.length) && !found; i++) {
             found = aTokens[i] == aType;
         }
         return found;
     }
 
