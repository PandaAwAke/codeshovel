diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
index 8379f6475..265f67e5c 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
@@ -1,153 +1,174 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 /*
  * @(#)JTreeTable.java	1.2 98/10/27
  *
  * Copyright 1997, 1998 by Sun Microsystems, Inc.,
  * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
  * All rights reserved.
  *
  * This software is the confidential and proprietary information
  * of Sun Microsystems, Inc. ("Confidential Information").  You
  * shall not disclose such Confidential Information and shall use
  * it only in accordance with the terms of the license agreement
  * you entered into with Sun.
  */
 
 package com.puppycrawl.tools.checkstyle.gui;
 
 import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.Graphics;
+import java.awt.event.ActionEvent;
 import java.awt.event.MouseEvent;
 import java.util.EventObject;
+import javax.swing.Action;
+import javax.swing.AbstractAction;
 import javax.swing.JTable;
 import javax.swing.JTree;
+import javax.swing.KeyStroke;
 import javax.swing.ListSelectionModel;
 import javax.swing.LookAndFeel;
 import javax.swing.UIManager;
 import javax.swing.event.ListSelectionEvent;
 import javax.swing.event.ListSelectionListener;
 import javax.swing.table.TableCellEditor;
 import javax.swing.table.TableCellRenderer;
 import javax.swing.tree.DefaultTreeCellRenderer;
 import javax.swing.tree.DefaultTreeSelectionModel;
 import javax.swing.tree.TreeCellRenderer;
 import javax.swing.tree.TreeModel;
 import javax.swing.tree.TreePath;
 
 /**
  * This example shows how to create a simple JTreeTable component,
  * by using a JTree as a renderer (and editor) for the cells in a
  * particular column in the JTable.
  *
  * @version 1.2 10/27/98
  *
  * @author Philip Milne
  * @author Scott Violet
  * @author Lars Kï¿½hne
  */
 public class JTreeTable extends JTable
 {
     /** A subclass of JTree. */
     protected TreeTableCellRenderer tree;
 
     public JTreeTable(TreeTableModel treeTableModel)
     {
         super();
 
         // Create the tree. It will be used as a renderer and editor.
         tree = new TreeTableCellRenderer(treeTableModel);
 
         // Install a tableModel representing the visible rows in the tree.
         super.setModel(new TreeTableModelAdapter(treeTableModel, tree));
 
         // Force the JTable and JTree to share their row selection models.
         ListToTreeSelectionModelWrapper selectionWrapper = new
                 ListToTreeSelectionModelWrapper();
         tree.setSelectionModel(selectionWrapper);
         setSelectionModel(selectionWrapper.getListSelectionModel());
 
         // Install the tree editor renderer and editor.
         setDefaultRenderer(TreeTableModel.class, tree);
         setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
 
         // No grid.
         setShowGrid(false);
 
         // No intercell spacing
         setIntercellSpacing(new Dimension(0, 0));
 
         // And update the height of the trees row to match that of
         // the table.
         if (tree.getRowHeight() < 1) {
             // Metal looks better like this.
             setRowHeight(getRowHeight());
         }
+
+        Action expand = new AbstractAction() {
+                public void actionPerformed(ActionEvent e) {
+                    TreePath selected = tree.getSelectionPath();
+                    if (tree.isExpanded(selected)) {
+                        tree.collapsePath(selected);
+                    }
+                    else {
+                        tree.expandPath(selected);
+                    }
+                    tree.setSelectionPath(selected);
+                }
+            };
+        KeyStroke stroke = KeyStroke.getKeyStroke("ENTER");
+        String command = "expand/collapse";
+        getInputMap().put(stroke, command);
+        getActionMap().put(command, expand);
     }
 
     /**
      * Overridden to message super and forward the method to the tree.
      * Since the tree is not actually in the component hierarchy it will
      * never receive this unless we forward it in this manner.
      */
     public void updateUI()
     {
         super.updateUI();
         if (tree != null) {
             tree.updateUI();
         }
         // Use the tree's default foreground and background colors in the
         // table.
         LookAndFeel.installColorsAndFont(this, "Tree.background",
                 "Tree.foreground", "Tree.font");
     }
 
     /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to
      * paint the editor. The UI currently uses different techniques to
      * paint the renderers and editors and overriding setBounds() below
      * is not the right thing to do for an editor. Returning -1 for the
      * editing row in this case, ensures the editor is never painted.
      */
     public int getEditingRow()
     {
         final Class editingClass = getColumnClass(editingColumn);
         return (editingClass == TreeTableModel.class) ? -1 : editingRow;
     }
 
     /**
      * Overridden to pass the new rowHeight to the tree.
      */
     public void setRowHeight(int rowHeight)
     {
         super.setRowHeight(rowHeight);
         if (tree != null && tree.getRowHeight() != rowHeight) {
             tree.setRowHeight(getRowHeight());
         }
     }
 
     /**
      * @return the tree that is being shared between the model.
      */
     public JTree getTree()
     {
         return tree;
     }
 
@@ -249,100 +270,101 @@ public class JTreeTable extends JTable
      * JTree.
      */
     public class TreeTableCellEditor extends AbstractCellEditor implements
             TableCellEditor
     {
         public Component getTableCellEditorComponent(JTable table,
                 Object value,
                 boolean isSelected,
                 int r, int c)
         {
             return tree;
         }
 
         /**
          * Overridden to return false, and if the event is a mouse event
          * it is forwarded to the tree.<p>
          * The behavior for this is debatable, and should really be offered
          * as a property. By returning false, all keyboard actions are
          * implemented in terms of the table. By returning true, the
          * tree would get a chance to do something with the keyboard
          * events. For the most part this is ok. But for certain keys,
          * such as left/right, the tree will expand/collapse where as
          * the table focus should really move to a different column. Page
          * up/down should also be implemented in terms of the table.
          * By returning false this also has the added benefit that clicking
          * outside of the bounds of the tree node, but still in the tree
          * column will select the row, whereas if this returned true
          * that wouldn't be the case.
          * <p>By returning false we are also enforcing the policy that
          * the tree will never be editable (at least by a key sequence).
          *
          * @see TableCellEditor
          */
         public boolean isCellEditable(EventObject e)
         {
             if (e instanceof MouseEvent) {
                 for (int counter = getColumnCount() - 1; counter >= 0;
                      counter--) {
                     if (getColumnClass(counter) == TreeTableModel.class) {
                         MouseEvent me = (MouseEvent) e;
                         MouseEvent newME = new MouseEvent(tree, me.getID(),
                                 me.getWhen(), me.getModifiers(),
                                 me.getX() - getCellRect(0, counter, true).x,
                                 me.getY(), me.getClickCount(),
                                 me.isPopupTrigger());
                         tree.dispatchEvent(newME);
                         break;
                     }
                 }
             }
+
             return false;
         }
     }
 
 
     /**
      * ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel
      * to listen for changes in the ListSelectionModel it maintains. Once
      * a change in the ListSelectionModel happens, the paths are updated
      * in the DefaultTreeSelectionModel.
      */
     class ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel
     {
         /** Set to true when we are updating the ListSelectionModel. */
         protected boolean updatingListSelectionModel;
 
         public ListToTreeSelectionModelWrapper()
         {
             super();
             getListSelectionModel().addListSelectionListener
                     (createListSelectionListener());
         }
 
         /**
          * Returns the list selection model. ListToTreeSelectionModelWrapper
          * listens for changes to this model and updates the selected paths
          * accordingly.
          *
          * @return the list selection model
          */
         ListSelectionModel getListSelectionModel()
         {
             return listSelectionModel;
         }
 
         /**
          * This is overridden to set <code>updatingListSelectionModel</code>
          * and message super. This is the only place DefaultTreeSelectionModel
          * alters the ListSelectionModel.
          */
         public void resetRowSelection()
         {
             if (!updatingListSelectionModel) {
                 updatingListSelectionModel = true;
                 try {
                     super.resetRowSelection();
                 } finally {
                     updatingListSelectionModel = false;
                 }
             }
