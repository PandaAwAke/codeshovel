diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
index ef5a393d7..75dd74630 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
@@ -21,101 +21,101 @@ package com.puppycrawl.tools.checkstyle.checks;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
 import org.apache.commons.beanutils.ConversionException;
 
 /**
  * Detects uncommented main methods. Basically detects
  * any main method, since if it is detectable
  * that means it is uncommented.
  *
  * <pre class="body">
  * &lt;module name=&quot;UncommentedMain&quot;/&gt;
  * </pre>
  *
  * @author Michael Yui
  * @author o_sukhodolsky
  */
 public class UncommentedMainCheck
     extends Check
 {
     /** the pattern to exclude classes from the check */
     private String mExcludedClasses = "^$";
     /** compiled regexp to exclude classes from check */
     private Pattern mExcludedClassesPattern =
         Utils.createPattern(mExcludedClasses);
     /** current class name */
     private String mCurrentClass;
     /** current package */
     private FullIdent mPackage;
     /** class definition depth */
     private int mClassDepth;
 
     /**
      * Set the excluded classes pattern.
      * @param aExcludedClasses a <code>String</code> value
      * @throws ConversionException unable to parse aExcludedClasses
      */
     public void setExcludedClasses(String aExcludedClasses)
         throws ConversionException
     {
         try {
             mExcludedClasses = aExcludedClasses;
             mExcludedClassesPattern = Utils.getPattern(mExcludedClasses);
         }
-        catch (PatternSyntaxException e) {
+        catch (final PatternSyntaxException e) {
             throw new ConversionException("unable to parse "
                                           + mExcludedClasses,
                                           e);
         }
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     /** {@inheritDoc} */
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     /** {@inheritDoc} */
     public void beginTree(DetailAST aRootAST)
     {
         mPackage = FullIdent.createFullIdent(null);
         mCurrentClass = null;
         mClassDepth = 0;
     }
 
     /** {@inheritDoc} */
     public void leaveToken(DetailAST aAst)
     {
         if (aAst.getType() == TokenTypes.CLASS_DEF) {
             if (mClassDepth == 1) {
                 mCurrentClass = null;
             }
             mClassDepth--;
         }
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAst)
     {
         switch (aAst.getType()) {
         case TokenTypes.PACKAGE_DEF:
             visitPackageDef(aAst);
             break;
         case TokenTypes.CLASS_DEF:
             visitClassDef(aAst);
