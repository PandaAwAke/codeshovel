diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 96a4fe446..1aa5e87a0 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -1,229 +1,232 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessages;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
+import com.puppycrawl.tools.checkstyle.api.Context;
 
 /**
  * Responsible for walking an abstract syntax tree and notifying interested
  * checks at each each node.
  *
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @version 1.0
  */
 public final class TreeWalker
     extends AbstractFileSetCheck
 {
     /**
      * Overrides ANTLR error reporting so we completely control
      * checkstyle's output during parsing. This is important because
      * we try parsing with several grammers (with/without support for
      * <code>assert</code>). We must not write any error messages when
      * parsing fails because with the next grammar it might succeed
      * and the user will be confused.
      */
     private static class SilentJava14Recognizer
         extends GeneratedJava14Recognizer
     {
         /**
          * Creates a new <code>SilentJava14Recognizer</code> instance.
          *
          * @param aLexer the tokenstream the recognizer operates on.
          */
         private SilentJava14Recognizer(GeneratedJava14Lexer aLexer)
         {
             super(aLexer);
         }
 
         /**
          * Parser error-reporting function, does nothing.
          * @param aRex the exception to be reported
          */
         public void reportError(RecognitionException aRex)
         {
         }
 
         /**
          * Parser error-reporting function, does nothing.
          * @param aMsg the error message
          */
         public void reportError(String aMsg)
         {
         }
 
         /**
          * Parser warning-reporting function, does nothing.
          * @param aMsg the error message
          */
         public void reportWarning(String aMsg)
         {
         }
     }
     // TODO: really need to optimise the performance of this class.
 
     /** maps from token name to checks */
     private final Map mTokenToChecks = new HashMap();
     /** all the registered checks */
     private final Set mAllChecks = new HashSet();
     /** collects the error messages */
     private final LocalizedMessages mMessages;
     /** the distance between tab stops */
     private int mTabWidth = 8;
     /** cache file **/
     private PropertyCacheFile mCache = new PropertyCacheFile(null, null);
 
-    /**
-     * the global configuration.
-     * TODO: should only know the treewalker part of the config
-     */
-    private Configuration mConfig;
-
     /** class loader to resolve classes with. **/
     private ClassLoader mClassLoader;
 
+    /** context of child components */
+    private Context mChildContext;
+
     /**
      * Creates a new <code>TreeWalker</code> instance.
      */
     public TreeWalker()
     {
         mMessages = new LocalizedMessages();
     }
 
     /** @param aTabWidth the distance between tab stops */
     public void setTabWidth(int aTabWidth)
     {
         mTabWidth = aTabWidth;
     }
 
     /** @param aFileName the cache file */
     public void setCacheFile(String aFileName)
     {
-        mCache = new PropertyCacheFile(mConfig, aFileName);
+        final Configuration configuration = getConfiguration();
+        mCache = new PropertyCacheFile(configuration, aFileName);
     }
 
     // TODO: Call from contextualize
     /** @param aClassLoader class loader to resolve classes with. */
     public void setClassLoader(ClassLoader aClassLoader)
     {
         mClassLoader = aClassLoader;
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Configurable */
-    public void configure(Configuration aConfiguration)
-            throws CheckstyleException
+    public void finishLocalSetup()
     {
-        super.configure(aConfiguration);
-        mConfig = aConfiguration;
-
         DefaultContext checkContext = new DefaultContext();
         checkContext.add("classLoader", mClassLoader);
         checkContext.add("messages", mMessages);
         // TODO: hmmm.. this looks less than elegant
         checkContext.add("tabWidth", String.valueOf(mTabWidth));
 
+        mChildContext = checkContext;
+    }
+
+    /**
+     * Instantiates, configures and registers a Check that is specified
+     * in the provided configuration.
+     * @see com.puppycrawl.tools.checkstyle.api.AutomaticBean
+     */
+    public void setupChild(Configuration aChildConf)
+            throws CheckstyleException
+    {
         // TODO: improve the error handing
-        Configuration[] checkConfigs = aConfiguration.getChildren();
-        for (int i = 0; i < checkConfigs.length; i++) {
-            final Configuration config = checkConfigs[i];
-            // IMPORTANT! Need to use the same class loader that created this
-            // class. Otherwise can get ClassCastException problems.
-            final String name = config.getName();
-            final String[] packageNames = getPackageNames();
-            final Check check =
-                    (Check) PackageObjectFactory.makeObject(
+
+        // IMPORTANT! Need to use the same class loader that created this
+        // class. Otherwise can get ClassCastException problems.
+        final String name = aChildConf.getName();
+        final String[] packageNames = getPackageNames();
+        final Check check =
+                (Check) PackageObjectFactory.makeObject(
                         packageNames, this.getClass().getClassLoader(), name);
 
-            check.contextualize(checkContext);
-            check.configure(config);
+        check.contextualize(mChildContext);
+        check.configure(aChildConf);
 
-            registerCheck(check);
-        }
+        registerCheck(check);
     }
 
     /**
      * Processes a specified file and reports all errors found.
      * @param aFile the file to process
      **/
     private void process(File aFile)
     {
         // check if already checked and passed the file
         final String fileName = aFile.getPath();
         final long timestamp = aFile.lastModified();
         if (mCache.alreadyChecked(fileName, timestamp)) {
             return;
         }
 
         mMessages.reset();
         try {
             getMessageDispatcher().fireFileStarted(fileName);
             final String[] lines = Utils.getLines(fileName);
             final FileContents contents = new FileContents(fileName, lines);
             final DetailAST rootAST = TreeWalker.parse(contents);
             walk(rootAST, contents);
         }
         catch (FileNotFoundException fnfe) {
             // TODO: this dependency on the checkstyle package is not good. It
             // introduces a circular dependency between packages.
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.fileNotFound", null));
         }
         catch (IOException ioe) {
             mMessages.add(new LocalizedMessage(
                               0, Defn.CHECKSTYLE_BUNDLE,
                               "general.exception",
                               new String[] {ioe.getMessage()}));
         }
         catch (RecognitionException re) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {re.getMessage()}));
         }
         catch (TokenStreamException te) {
             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,
                                                "general.exception",
                                                new String[] {te.getMessage()}));
         }
 
         if (mMessages.size() == 0) {
             mCache.checkedOk(fileName, timestamp);
         }
         else {
