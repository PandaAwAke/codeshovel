diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 400ad3170..8a95fe056 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -74,127 +74,127 @@ class TreeWalker
                 System.exit(1);
             }
         }
 
     }
 
     /**
      * Creates a new <code>TreeWalker</code> instance.
      *
      * @param aMessages used to collect messages
      */
     public TreeWalker(LocalizedMessages aMessages)
     {
         mMessages = aMessages;
     }
 
     /**
      * Returns the name of a token for a given ID.
      * @param aID the ID of the token name to get
      * @return a token name
      */
     static String getTokenName(int aID)
     {
         final String name = (String) TOKEN_VALUE_TO_NAME.get(new Integer(aID));
         if (name == null) {
             throw new IllegalArgumentException("given id " + aID);
         }
         return name;
     }
 
     /**
      * Register a check for a given configuration.
      * @param aCheck the check to register
      * @param aConfig the configuration to use
      */
     void registerCheck(Check aCheck, CheckConfiguration aConfig)
     {
         aCheck.setMessages(mMessages);
         if (!aConfig.getTokens().isEmpty()) {
             final Iterator it = aConfig.getTokens().iterator();
             while (it.hasNext()) {
                 registerCheck((String) it.next(), aCheck);
             }
         }
         else {
             final int[] tokens = aCheck.getDefaultTokens();
             for (int i = 0; i < tokens.length; i++) {
                 registerCheck(tokens[i], aCheck);
             }
         }
+        mAllChecks.add(aCheck);
     }
 
     /**
      * Register a check for a specified token id.
      * @param aTokenID the id of the token
      * @param aCheck the check to register
      */
     private void registerCheck(int aTokenID, Check aCheck)
     {
         registerCheck(getTokenName(aTokenID), aCheck);
     }
 
     /**
      * Register a check for a specified token name
      * @param aToken the name of the token
      * @param aCheck the check to register
      */
     private void registerCheck(String aToken, Check aCheck)
     {
         ArrayList visitors = (ArrayList) mTokenToChecks.get(aToken);
         if (visitors == null) {
             visitors = new ArrayList();
             mTokenToChecks.put(aToken, visitors);
         }
 
         visitors.add(aCheck);
-        mAllChecks.add(aCheck);
     }
 
     /**
      * Initiates the walk of an AST.
      * @param aAST the root AST
      * @param aLines the lines of the file the AST was generated from
      * @param aFilename the file name of the file the AST was generated from
      */
     void walk(DetailAST aAST, String[] aLines, String aFilename)
     {
         mMessages.reset();
         notifyBegin(aLines, aFilename);
         aAST.setParent(null);
         process(aAST);
         notifyEnd();
     }
 
     /**
      * Notify interested checks that about to begin walking a tree.
      * @param aLines the lines of the file the AST was generated from
      * @param aFilename the file name of the file the AST was generated from
      */
     private void notifyBegin(String[] aLines, String aFilename)
     {
         // TODO: do not track Context properly for token
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             final HashMap treeContext = new HashMap();
             check.setTreeContext(treeContext);
             check.setFilename(aFilename);
             check.setLines(aLines);
             check.beginTree();
         }
     }
 
     /**
      * Notify checks that finished walking a tree.
      */
     private void notifyEnd()
     {
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             check.finishTree();
         }
     }
 
     /**
      * Recursively processes a node calling interested checks at each node.
