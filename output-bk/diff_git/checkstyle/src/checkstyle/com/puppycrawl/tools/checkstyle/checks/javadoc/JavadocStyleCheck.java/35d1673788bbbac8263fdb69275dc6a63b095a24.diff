diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
index 782e05202..99f5eec1e 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
@@ -163,101 +163,101 @@ public class JavadocStyleCheck
 
         if (mCheckEmptyJavadoc) {
             checkEmptyJavadoc(aComment);
         }
     }
 
     /**
      * Checks that the first sentence ends with proper puctuation.  This method
      * uses a regular expression that checks for the presence of a period,
      * question mark, or exclaimation mark followed either by whitespace, an
      * HTML element, or the end of string. This method ignores {_AT_inheritDoc}
      * comments.
      *
      * @param aComment the source lines that make up the Javadoc comment.
      */
     private void checkFirstSentence(TextBlock aComment)
     {
         final String commentText = getCommentText(aComment.getText());
 
         if ((commentText.length() != 0)
             && !getEndOfSentencePattern().matcher(commentText).find()
             && !"{@inheritDoc}".equals(commentText))
         {
             log(aComment.getStartLineNo(), "javadoc.noperiod");
         }
     }
 
     /**
      * Checks that the Javadoc is not empty.
      *
      * @param aComment the source lines that make up the Javadoc comment.
      */
     private void checkEmptyJavadoc(TextBlock aComment)
     {
         final String commentText = getCommentText(aComment.getText());
 
         if (commentText.length() == 0) {
             log(aComment.getStartLineNo(), "javadoc.empty");
         }
     }
 
     /**
      * Returns the comment text from the Javadoc.
      * @param aComments the lines of Javadoc.
      * @return a comment text String.
      */
     private String getCommentText(String[] aComments)
     {
         final StringBuffer buffer = new StringBuffer();
         for (int i = 0; i < aComments.length; i++) {
-            String line = aComments[i];
+            final String line = aComments[i];
             final int textStart = findTextStart(line);
 
             if (textStart != -1) {
                 if (line.charAt(textStart) == '@') {
                     //we have found the tag section
                     break;
                 }
                 buffer.append(line.substring(textStart));
                 trimTail(buffer);
                 buffer.append('\n');
             }
         }
 
         return buffer.toString().trim();
     }
 
     /**
      * Finds the index of the first non-whitespace character ignoring the
      * Javadoc comment start and end strings (&#47** and *&#47) as well as any
      * leading asterisk.
      * @param aLine the Javadoc comment line of text to scan.
      * @return the int index relative to 0 for the start of text
      *         or -1 if not found.
      */
     private int findTextStart(String aLine)
     {
         int textStart = -1;
         for (int i = 0; i < aLine.length(); i++) {
             if (!Character.isWhitespace(aLine.charAt(i))) {
                 if (aLine.regionMatches(i, "/**", 0, "/**".length())) {
                     i += 2;
                 }
                 else if (aLine.regionMatches(i, "*/", 0, 2)) {
                     i++;
                 }
                 else if (aLine.charAt(i) != '*') {
                     textStart = i;
                     break;
                 }
             }
         }
         return textStart;
     }
 
     /**
      * Trims any trailing whitespace or the end of Javadoc comment string.
      * @param aBuffer the StringBuffer to trim.
      */
     private void trimTail(StringBuffer aBuffer)
     {
@@ -380,126 +380,126 @@ public class JavadocStyleCheck
             lastOpenTag = (HtmlTag) unclosedTags.get(i);
             if (lastOpenTag.getId().equals(lastFound)) {
                 continue;
             }
             lastFound = lastOpenTag.getId();
             log(lastOpenTag.getLineno(),
                 lastOpenTag.getPosition(),
                 UNCLOSED_HTML,
                 lastOpenTag);
         }
     }
 
     /**
      * Determines if the HtmlTag is one which does not require a close tag.
      *
      * @param aTag the HtmlTag to check.
      * @return <code>true</code> if the HtmlTag is a single tag.
      */
     private boolean isSingleTag(HtmlTag aTag)
     {
         boolean isSingleTag = false;
         for (int i = 0; i < SINGLE_TAG.length; i++) {
             // If its a singleton tag (<p>, <br>, etc.), ignore it
             // Can't simply not put them on the stack, since singletons
             // like <dt> and <dd> (unhappily) may either be terminated
             // or not terminated. Both options are legal.
             if (aTag.getId().equalsIgnoreCase(SINGLE_TAG[i])) {
                 isSingleTag = true;
             }
         }
         return isSingleTag;
     }
 
     /**
      * Determines if the given token is an extra HTML tag. This indicates that
      * a close tag was found that does not have a corresponding open tag.
      *
      * @param aToken an HTML tag id for which a close was found.
      * @param aHtmlStack a Stack of previous open HTML tags.
      * @return <code>false</code> if a previous open tag was found
      *         for the token.
      */
     private boolean isExtraHtml(String aToken, Stack aHtmlStack)
     {
         boolean isExtra = true;
         for (int i = 0; i < aHtmlStack.size(); i++) {
             // Loop, looking for tags that are closed.
             // The loop is needed in case there are unclosed
             // tags on the stack. In that case, the stack would
             // not be empty, but this tag would still be extra.
-            HtmlTag td = (HtmlTag) aHtmlStack.elementAt(i);
+            final HtmlTag td = (HtmlTag) aHtmlStack.elementAt(i);
             if (aToken.equalsIgnoreCase(td.getId())) {
                 isExtra = false;
                 break;
             }
         }
 
         return isExtra;
     }
 
     /**
      * Sets the scope to check.
      * @param aFrom string to get the scope from
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set the excludeScope.
      * @param aScope a <code>String</code> value
      */
     public void setExcludeScope(String aScope)
     {
         mExcludeScope = Scope.getInstance(aScope);
     }
 
     /**
      * Returns a regular expression for matching the end of a sentence.
      *
      * @return a regular expression for matching the end of a sentence.
      */
     private Pattern getEndOfSentencePattern()
     {
         if (mEndOfSentencePattern == null) {
             try {
                 mEndOfSentencePattern =
                     Pattern.compile("([.?!][ \t\n\r\f<])|([.?!]$)");
             }
-            catch (PatternSyntaxException e) {
+            catch (final PatternSyntaxException e) {
                 // This should never occur.
                 e.printStackTrace();
             }
         }
         return mEndOfSentencePattern;
     }
 
     /**
      * Sets the flag that determines if the first sentence is checked for
      * proper end of sentence punctuation.
      * @param aFlag <code>true</code> if the first sentence is to be checked
      */
     public void setCheckFirstSentence(boolean aFlag)
     {
         mCheckFirstSentence = aFlag;
     }
 
     /**
      * Sets the flag that determines if HTML checking is to be performed.
      * @param aFlag <code>true</code> if HTML checking is to be performed.
      */
     public void setCheckHtml(boolean aFlag)
     {
         mCheckHtml = aFlag;
     }
 
     /**
      * Sets the flag that determines if empty JavaDoc checking should be done.
      * @param aFlag <code>true</code> if empty JavaDoc checking should be done.
      */
     public void setCheckEmptyJavadoc(boolean aFlag)
     {
         mCheckEmptyJavadoc = aFlag;
     }
 }
