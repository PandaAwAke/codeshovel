diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
index c71f8dd0e..e91fb3d9e 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
@@ -88,180 +88,178 @@ public class LeftCurlyCheck
      */
     public void setMaxLineLength(int aMaxLineLength)
     {
         mMaxLineLength = aMaxLineLength;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             // TODO: need to handle....
             //TokenTypes.STATIC_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST startToken;
         final DetailAST brace;
 
         switch (aAST.getType()) {
         case TokenTypes.CTOR_DEF :
         case TokenTypes.METHOD_DEF :
             startToken = skipAnnotationOnlyLines(aAST);
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.INTERFACE_DEF :
         case TokenTypes.CLASS_DEF :
         case TokenTypes.ANNOTATION_DEF :
         case TokenTypes.ENUM_DEF :
         case TokenTypes.ENUM_CONSTANT_DEF :
-            startToken = (DetailAST) skipAnnotationOnlyLines(aAST);
+            startToken = skipAnnotationOnlyLines(aAST);
             final DetailAST objBlock = aAST.findFirstToken(TokenTypes.OBJBLOCK);
             brace = (objBlock == null)
                 ? null
                 : (DetailAST) objBlock.getFirstChild();
             break;
 
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_SYNCHRONIZED:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_FINALLY:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_IF :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.LITERAL_ELSE :
             startToken = aAST;
-            final DetailAST candidate = (DetailAST) aAST.getFirstChild();
+            final DetailAST candidate = aAST.getFirstChild();
             brace =
                 (candidate.getType() == TokenTypes.SLIST)
                 ? candidate
                 : null; // silently ignore
             break;
 
         case TokenTypes.LITERAL_SWITCH :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.LCURLY);
             break;
 
         default :
             startToken = null;
             brace = null;
         }
 
         if ((brace != null) && (startToken != null)) {
             verifyBrace(brace, startToken);
         }
     }
 
     /**
      * Skip lines that only contain <code>TokenTypes.ANNOTATION</code>s.
      * If the received <code>DetailAST</code>
      * has annotations within its modifiers then first token on the line
      * of the first token afer all annotations is return. This might be
      * an annotation.
      * Otherwise, the received <code>DetailAST</code> is returned.
      * @param aAST <code>DetailAST</code>.
      * @return <code>DetailAST</code>.
      */
     private DetailAST skipAnnotationOnlyLines(DetailAST aAST)
     {
         final DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);
         if (modifiers == null) {
             return aAST;
         }
         DetailAST lastAnnot = findLastAnnotation(modifiers);
         if (lastAnnot == null) {
             // There are no annotations.
             return aAST;
         }
         final DetailAST tokenAfterLast = lastAnnot.getNextSibling() != null
                                        ? lastAnnot.getNextSibling()
                                        : modifiers.getNextSibling();
         if (tokenAfterLast.getLineNo() > lastAnnot.getLineNo()) {
             return tokenAfterLast;
         }
-        else {
-            final int lastAnnotLineNumber = lastAnnot.getLineNo();
-            while (lastAnnot.getPreviousSibling() != null
-                   && (lastAnnot.getPreviousSibling().getLineNo()
-                        == lastAnnotLineNumber))
-            {
-                lastAnnot = lastAnnot.getPreviousSibling();
-            }
-            return lastAnnot;
+        final int lastAnnotLineNumber = lastAnnot.getLineNo();
+        while (lastAnnot.getPreviousSibling() != null
+               && (lastAnnot.getPreviousSibling().getLineNo()
+                    == lastAnnotLineNumber))
+        {
+            lastAnnot = lastAnnot.getPreviousSibling();
         }
+        return lastAnnot;
     }
 
     /**
      * Find the last token of type <code>TokenTypes.ANNOTATION</code>
      * under the given set of modifiers.
      * @param aModifiers <code>DetailAST</code>.
      * @return <code>DetailAST</code> or null if there are no annotations.
      */
     private DetailAST findLastAnnotation(DetailAST aModifiers)
     {
         DetailAST aAnnot = aModifiers.findFirstToken(TokenTypes.ANNOTATION);
         while (aAnnot != null && aAnnot.getNextSibling() != null
                && aAnnot.getNextSibling().getType() == TokenTypes.ANNOTATION)
         {
             aAnnot = aAnnot.getNextSibling();
         }
         return aAnnot;
     }
 
     /**
      * Verifies that a specified left curly brace is placed correctly
      * according to policy.
      * @param aBrace token for left curly brace
      * @param aStartToken token for start of expression
      */
     private void verifyBrace(final DetailAST aBrace,
                              final DetailAST aStartToken)
     {
         final String braceLine = getLines()[aBrace.getLineNo() - 1];
 
         // calculate the previous line length without trailing whitespace. Need
         // to handle the case where there is no previous line, cause the line
         // being check is the first line in the file.
         final int prevLineLen = (aBrace.getLineNo() == 1)
             ? mMaxLineLength
             : Utils.lengthMinusTrailingWhitespace(
                 getLines()[aBrace.getLineNo() - 2]);
 
         // Check for being told to ignore, or have '{}' which is a special case
         if ((braceLine.length() > (aBrace.getColumnNo() + 1))
             && (braceLine.charAt(aBrace.getColumnNo() + 1) == '}'))
         {
             ; // ignore
         }
         else if (getAbstractOption() == LeftCurlyOption.NL) {
             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {
                 log(aBrace.getLineNo(), aBrace.getColumnNo(),
                     "line.new", "{");
             }
         }
