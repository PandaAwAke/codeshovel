diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 31cab7779..058802b60 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -57,171 +57,171 @@ class TreeWalker
     static {
         // Wow, pretty cool idea to use reflection here...
         final Field[] fields = JavaTokenTypes.class.getDeclaredFields();
         for (int i = 0; i < fields.length; i++) {
             final Field f = fields[i];
             final String name = f.getName();
             try {
                 // this should NEVER fail (famous last words)
                 final Integer value = new Integer(f.getInt(name));
                 TOKEN_NAME_TO_VALUE.put(name, value);
                 TOKEN_VALUE_TO_NAME.put(value, name);
             }
             catch (IllegalArgumentException e) {
                 e.printStackTrace();
                 System.exit(1);
             }
             catch (IllegalAccessException e) {
                 e.printStackTrace();
                 System.exit(1);
             }
         }
 
     }
 
     public TreeWalker(LocalizedMessages aMessages)
     {
         mMessages = aMessages;
     }
 
     /**
      * Returns the name of a token for a given ID.
      * @param aID the ID of the token name to get
      * @return a token name
      */
     static String getTokenName(int aID)
     {
         final String name = (String) TOKEN_VALUE_TO_NAME.get(new Integer(aID));
         if (name == null) {
             throw new IllegalArgumentException("given id " + aID);
         }
         return name;
     }
 
     /**
      * Register a check for a given configuration.
      * @param aCheck the check to register
      * @param aConfig the configuration to use
      */
     void registerCheck(Check aCheck, CheckConfiguration aConfig)
     {
+        aCheck.setMessages(mMessages);
         if (!aConfig.getTokens().isEmpty()) {
             final Iterator it = aConfig.getTokens().iterator();
             while (it.hasNext()) {
                 registerCheck((String) it.next(), aCheck);
             }
         }
         else {
             final int[] tokens = aCheck.getDefaultTokens();
             for (int i = 0; i < tokens.length; i++) {
                 registerCheck(tokens[i], aCheck);
             }
         }
     }
 
     /**
      * Register a check for a specified token id.
      * @param aTokenID the id of the token
      * @param aCheck the check to register
      */
     private void registerCheck(int aTokenID, Check aCheck)
     {
         registerCheck(getTokenName(aTokenID), aCheck);
     }
 
     /**
      * Register a check for a specified token name
      * @param aToken the name of the token
      * @param aCheck the check to register
      */
     private void registerCheck(String aToken, Check aCheck)
     {
         ArrayList visitors = (ArrayList) mTokenToChecks.get(aToken);
         if (visitors == null) {
             visitors = new ArrayList();
             mTokenToChecks.put(aToken, visitors);
         }
 
         visitors.add(aCheck);
         mAllChecks.add(aCheck);
     }
 
     /**
      * Initiates the walk of an AST.
      * @param aAST the root AST
      * @param aLines the lines of the file the AST was generated from
      * @param aFilename the file name of the file the AST was generated from
      */
-    LocalizedMessages walk(DetailAST aAST, String[] aLines, String aFilename)
+    void walk(DetailAST aAST, String[] aLines, String aFilename)
     {
         mMessages.reset();
         notifyBegin(aLines, aFilename);
         aAST.setParent(null);
         process(aAST);
         notifyEnd();
-        return mMessages;
     }
 
     /**
      * Notify interested checks that about to begin walking a tree.
      * @param aLines the lines of the file the AST was generated from
      * @param aFilename the file name of the file the AST was generated from
      */
     private void notifyBegin(String[] aLines, String aFilename)
     {
         // TODO: do not track Context properly for token
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             final HashMap treeContext = new HashMap();
-            check.setFilename(aFilename);
             check.setTreeContext(treeContext);
+            check.setFilename(aFilename);
             check.setLines(aLines);
             check.beginTree();
         }
     }
 
     /**
      * Notify checks that finished walking a tree.
      */
     private void notifyEnd()
     {
         final Iterator it = mAllChecks.iterator();
         while (it.hasNext()) {
             final Check check = (Check) it.next();
             check.finishTree();
         }
     }
 
     /**
      * Recursively processes a node calling interested checks at each node.
      * @param aAST the node to start from
      */
     private void process(DetailAST aAST)
     {
         if (aAST == null) {
             return;
         }
 
         notifyVisit(aAST);
 
         final DetailAST child = (DetailAST) aAST.getFirstChild();
         if (child != null) {
             child.setParent(aAST);
             process(child);
         }
 
         notifyLeave(aAST);
 
         final DetailAST sibling = (DetailAST) aAST.getNextSibling();
         if (sibling != null) {
             sibling.setParent(aAST.getParent());
             process(sibling);
         }
 
     }
 
     /**
      * Notify interested checks that visiting a node.
      * @param aAST the node to notify for
      */
     private void notifyVisit(DetailAST aAST)
