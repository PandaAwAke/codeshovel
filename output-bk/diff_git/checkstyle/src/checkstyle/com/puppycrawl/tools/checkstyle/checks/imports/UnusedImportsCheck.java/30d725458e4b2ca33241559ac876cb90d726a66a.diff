diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
index f1a14a6a3..68e43e165 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
@@ -42,139 +42,141 @@ import java.util.Set;
  * Compatible with Java 1.5 source.
  *
  * @author Oliver Burn
  * @version 1.1
  */
 public class UnusedImportsCheck extends DeclarationCollector
 {
     /** flag to indicate when time to start collecting references */
     private boolean mCollect;
 
     /** set of the imports */
     private final Set mImports = new HashSet();
 
     /** set of references - possibly to imports or other things */
     private final Set mReferenced = new HashSet();
 
     /** Default constructor. */
     public UnusedImportsCheck()
     {
     }
 
     /** {@inheritDoc} */
     public void beginTree(DetailAST aRootAST)
     {
         super.beginTree(aRootAST);
         mCollect = false;
         mImports.clear();
         mReferenced.clear();
     }
 
     /** {@inheritDoc} */
     public void finishTree(DetailAST aRootAST)
     {
         // loop over all the imports to see if referenced.
         final Iterator it = mImports.iterator();
         while (it.hasNext()) {
             final FullIdent imp = (FullIdent) it.next();
 
             if (!mReferenced.contains(Utils.baseClassname(imp.getText()))) {
                 log(imp.getLineNo(),
                     imp.getColumnNo(),
                     "import.unused", imp.getText());
             }
         }
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[] {
+            TokenTypes.PACKAGE_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.IDENT,
             TokenTypes.IMPORT,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.SLIST,
             TokenTypes.STATIC_IMPORT,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     /** {@inheritDoc} */
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
         super.visitToken(aAST);
         if (aAST.getType() == TokenTypes.IDENT) {
             if (mCollect) {
                 processIdent(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
             processImport(aAST);
         }
         else if (aAST.getType() == TokenTypes.STATIC_IMPORT) {
             processStaticImport(aAST);
         }
         else if ((aAST.getType() == TokenTypes.CLASS_DEF)
             || (aAST.getType() == TokenTypes.INTERFACE_DEF)
             || (aAST.getType() == TokenTypes.ENUM_DEF)
-            || (aAST.getType() == TokenTypes.ANNOTATION_DEF))
+            || (aAST.getType() == TokenTypes.ANNOTATION_DEF)
+            || (aAST.getType() == TokenTypes.PACKAGE_DEF))
         {
             mCollect = true;
         }
     }
 
     /**
      * Collects references made by IDENT.
      * @param aAST the IDENT node to process
      */
     private void processIdent(DetailAST aAST)
     {
         final DetailAST parent = aAST.getParent();
         final int parentType = parent.getType();
         if (parentType != TokenTypes.DOT
             && parentType != TokenTypes.METHOD_DEF
             || parentType == TokenTypes.DOT && aAST.getNextSibling() != null)
         {
             if (!isDeclared(aAST.getText())) {
                 mReferenced.add(aAST.getText());
             }
         }
     }
 
     /**
      * Collects the details of imports.
      * @param aAST node containing the import details
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(aAST);
         if ((name != null) && !name.getText().endsWith(".*")) {
             mImports.add(name);
         }
     }
 
     /**
      * Collects the details of static imports.
      * @param aAST node containing the static import details
      */
     private void processStaticImport(DetailAST aAST)
     {
         final FullIdent name =
             FullIdent.createFullIdent(
                 (DetailAST) aAST.getFirstChild().getNextSibling());
         if ((name != null) && !name.getText().endsWith(".*")) {
             mImports.add(name);
         }
     }
 }
