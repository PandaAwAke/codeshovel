diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
index fa526e65c..7fdac66ab 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
@@ -212,136 +212,151 @@ public abstract class ExpressionHandler
             child = child.getPreviousSibling())
         {
             if (!atLevelOrGreater(child)) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Get the start of the line for the given expression.
      *
      * @param aAst   the expression to find the start of the line for
      *
      * @return the start of the line for the given expression
      */
     protected final int getLineStart(DetailAST aAst)
     {
         // TODO: this breaks indentation -- add to tests
         String line = mIndentCheck.getLines()[
           aAst.getLineNo() - 1];
         return getLineStart(line);
     }
 
     // TODO: this whole checking of consecuitive/expression line indents is
     // smelling pretty bad... and is in serious need of pruning.  But, I
     // want to finish the invalid tests before I start messing around with
     // it.
 
     /**
      * Check the indentation of consecutive lines for the expression we are
      * handling.
      *
      * @param aStartLine     the first line to check
      * @param aEndLine       the last line to check
      * @param aIndentLevel   the required indent level
      */
     protected final void checkLinesIndent(int aStartLine, int aEndLine,
         int aIndentLevel)
     {
         // check first line
         checkSingleLine(aStartLine, aIndentLevel);
 
         // check following lines
         aIndentLevel += mIndentCheck.getBasicOffset();
         for (int i = aStartLine + 1; i <= aEndLine; i++) {
             checkSingleLine(i, aIndentLevel);
         }
     }
 
+    /**
+     * @return true if indentation should be increased after
+     *              fisrt line in checkLinesIndent()
+     *         false otherwise
+     */
+    protected boolean shouldIncraeseIndent()
+    {
+        return true;
+    }
+
     /**
      * Check the indentation for a set of lines.
      *
      * @param aLines              the set of lines to check
      * @param aIndentLevel        the indentation level
      * @param aFirstLineMatches   whether or not the first line has to match
      * @param aFirstLine          firstline of whole expression
      */
-    protected final void checkLinesIndent(LineSet aLines,
-                                          int aIndentLevel,
-                                          boolean aFirstLineMatches,
-                                          int aFirstLine)
+    private void checkLinesIndent(LineSet aLines,
+                                  int aIndentLevel,
+                                  boolean aFirstLineMatches,
+                                  int aFirstLine)
     {
         if (aLines.isEmpty()) {
             return;
         }
 
         // check first line
         int startLine = aLines.firstLine();
         int endLine = aLines.lastLine();
         int startCol = aLines.firstLineCol();
 
         int realStartCol = getLineStart(mIndentCheck.getLines()[startLine - 1]);
 
         if (realStartCol == startCol) {
             checkSingleLine(startLine, startCol, aIndentLevel,
                 aFirstLineMatches);
         }
 
         // if first line starts the line, following lines are indented
         // one level; but if the first line of this expression is
         // nested with the previous expression (which is assumed if it
         // doesn't start the line) then don't indent more, the first
         // indentation is absorbed by the nesting
 
-        if (aFirstLineMatches || aFirstLine > mMainAst.getLineNo()) {
+        // TODO: shouldIncreseIndent() is a hack, should be removed
+        //       after complete rewriting of checkExpressionSubtree()
+
+        if (aFirstLineMatches
+            || (aFirstLine > mMainAst.getLineNo() && shouldIncraeseIndent()))
+        {
             aIndentLevel += mIndentCheck.getBasicOffset();
         }
 
         // check following lines
         for (int i = startLine + 1; i <= endLine; i++) {
             Integer col = aLines.getStartColumn(new Integer(i));
             // startCol could be null if this line didn't have an
             // expression that was required to be checked (it could be
             // checked by a child expression)
 
             // TODO: not sure if this does anything, look at taking it out
 
             // TODO: we can check here if this line starts or the previous
             // line ends in a dot.  If so, we should increase the indent.
 
             // TODO: check if -2 is possible here?  but unlikely to be a
             // problem...
             String thisLine = mIndentCheck.getLines()[i - 1];
             String prevLine = mIndentCheck.getLines()[i - 2];
             if (thisLine.matches("^\\s*\\.")
                 || prevLine.matches("\\.\\s*$"))
             {
                 aIndentLevel += mIndentCheck.getBasicOffset();
             }
 
             if (col != null) {
                 checkSingleLine(i, col.intValue(), aIndentLevel, false);
             }
         }
     }
 
     /**
      * Check the indent level for a single line.
      *
      * @param aLineNum       the line number to check
      * @param aIndentLevel   the required indent level
      */
     private void checkSingleLine(int aLineNum, int aIndentLevel)
     {
         String line = mIndentCheck.getLines()[aLineNum - 1];
         int start = getLineStart(line);
         if (start < aIndentLevel) {
             logChildError(aLineNum, start, aIndentLevel);
         }
     }
 
     /**
      * Check the indentation for a single line.
      *
      * @param aLineNum       the number of the line to check
@@ -369,111 +384,100 @@ public abstract class ExpressionHandler
     /**
      * Get the start of the specified line.
      *
      * @param aLine   the specified line number
      *
      * @return the start of the specified line
      */
     protected final int getLineStart(String aLine)
     {
         for (int start = 0; start < aLine.length(); start++) {
             char c = aLine.charAt(start);
 
             if (!Character.isWhitespace(c)) {
                 return Utils.lengthExpandedTabs(
                     aLine, start, mIndentCheck.getIndentationTabWidth());
             }
         }
         return 0;
     }
 
     // TODO: allowNesting either shouldn't be allowed with
     //  firstLineMatches, or I should change the firstLineMatches logic
     //  so it doesn't match if the first line is nested
 
     /**
      * Check the indent level of the children of the specified parent
      * expression.
      *
      * @param aParent             the parent whose children we are checking
      * @param aTokenTypes         the token types to check
      * @param aStartLevel         the starting indent level
      * @param aFirstLineMatches   whether or not the first line needs to match
      * @param aAllowNesting       whether or not nested children are allowed
      */
     protected final void checkChildren(DetailAST aParent, int[] aTokenTypes,
         int aStartLevel,
         boolean aFirstLineMatches, boolean aAllowNesting)
     {
         Arrays.sort(aTokenTypes);
         for (DetailAST child = (DetailAST) aParent.getFirstChild();
                 child != null;
                 child = (DetailAST) child.getNextSibling())
         {
             if (Arrays.binarySearch(aTokenTypes, child.getType()) >= 0) {
                 checkExpressionSubtree(child, aStartLevel,
                     aFirstLineMatches, aAllowNesting);
             }
         }
     }
 
-    /**
-     * Check the indentation level for an expression subtree.
-     *
-     * @param aTree    the expression subtree to check
-     * @param aLevel   the indentation level
-     */
-    protected final void checkExpressionSubtree(DetailAST aTree, int aLevel)
-    {
-        checkExpressionSubtree(aTree, aLevel, false, false);
-    }
-
     /**
      * Check the indentation level for an expression subtree.
      *
      * @param aTree               the expression subtree to check
      * @param aLevel              the indentation level
      * @param aFirstLineMatches   whether or not the first line has to match
      * @param aAllowNesting       whether or not subtree nesting is allowed
      */
     protected final void checkExpressionSubtree(
         DetailAST aTree,
         int aLevel,
         boolean aFirstLineMatches,
         boolean aAllowNesting
     )
     {
         LineSet subtreeLines = new LineSet();
         int firstLine = getFirstLine(Integer.MAX_VALUE, aTree);
         if (aFirstLineMatches && !aAllowNesting) {
             subtreeLines.addLineAndCol(new Integer(firstLine),
                 getLineStart(
                     mIndentCheck.getLines()[firstLine - 1]));
         }
         findSubtreeLines(subtreeLines, aTree, aAllowNesting);
 
         checkLinesIndent(subtreeLines, aLevel, aFirstLineMatches,
                          firstLine);
     }
 
     /**
      * Get the first line for a given expression.
      *
      * @param aStartLine   the line we are starting from
      * @param aTree        the expression to find the first line for
      *
      * @return the first line of the expression
      */
     private int getFirstLine(int aStartLine, DetailAST aTree)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
         // the interface methods... I should ask about this
 
         int currLine = aTree.getLineNo();
         if (currLine < aStartLine) {
             aStartLine = currLine;
         }
 
         // check children
         for (DetailAST node = (DetailAST) aTree.getFirstChild();
             node != null;
