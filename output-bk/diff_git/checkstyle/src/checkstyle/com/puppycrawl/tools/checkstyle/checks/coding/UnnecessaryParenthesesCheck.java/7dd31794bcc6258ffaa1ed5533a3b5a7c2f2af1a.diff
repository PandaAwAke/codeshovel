diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index 280f746d8..197eb0655 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -81,135 +81,151 @@ public class UnnecessaryParenthesesCheck extends Check
         TokenTypes.MINUS_ASSIGN,
         TokenTypes.MOD_ASSIGN,
         TokenTypes.PLUS_ASSIGN,
         TokenTypes.SL_ASSIGN,
         TokenTypes.SR_ASSIGN,
         TokenTypes.STAR_ASSIGN,
     };
 
     /**
      * Used to test if logging a warning in a parent node may be skipped
      * because a warning was already logged on an immediate child node.
      */
     private DetailAST mParentToSkip;
     /** Depth of nested assignments.  Normally this will be 0 or 1. */
     private int mAssignDepth;
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int [] {
             TokenTypes.EXPR,
             TokenTypes.IDENT,
             TokenTypes.NUM_DOUBLE,
             TokenTypes.NUM_FLOAT,
             TokenTypes.NUM_INT,
             TokenTypes.NUM_LONG,
             TokenTypes.STRING_LITERAL,
             TokenTypes.LITERAL_NULL,
             TokenTypes.LITERAL_FALSE,
             TokenTypes.LITERAL_TRUE,
             TokenTypes.ASSIGN,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR_ASSIGN,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         final int type = aAST.getType();
         final boolean surrounded = isSurrounded(aAST);
+        final DetailAST parent = aAST.getParent();
+
+        if (type == TokenTypes.ASSIGN
+            && parent.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
+        {
+            // shouldn't process assign in annotation pairs
+            return;
+        }
 
         // An identifier surrounded by parentheses.
         if (surrounded && type == TokenTypes.IDENT) {
             mParentToSkip = aAST.getParent();
             log(aAST, "unnecessary.paren.ident", aAST.getText());
             return;
         }
 
         // A literal (numeric or string) surrounded by parentheses.
         if (surrounded && inTokenList(type, LITERALS)) {
             mParentToSkip = aAST.getParent();
             if (type == TokenTypes.STRING_LITERAL) {
                 log(aAST, "unnecessary.paren.string",
                     chopString(aAST.getText()));
             }
             else {
                 log(aAST, "unnecessary.paren.literal", aAST.getText());
             }
             return;
         }
 
         // The rhs of an assignment surrounded by parentheses.
         if (inTokenList(type, ASSIGNMENTS)) {
             mAssignDepth++;
             final DetailAST last = aAST.getLastChild();
             if (last.getType() == TokenTypes.RPAREN) {
                 log(aAST, "unnecessary.paren.assign");
             }
         }
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void leaveToken(DetailAST aAST)
     {
         final int type = aAST.getType();
+        final DetailAST parent = aAST.getParent();
+
+        if (type == TokenTypes.ASSIGN
+            && parent.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
+        {
+            // shouldn't process assign in annotation pairs
+            return;
+        }
 
         // An expression is surrounded by parentheses.
         if (type == TokenTypes.EXPR) {
 
             // If 'mParentToSkip' == 'aAST', then we've already logged a
             // warning about an immediate child node in visitToken, so we don't
             // need to log another one here.
 
             if (mParentToSkip != aAST && exprSurrounded(aAST)) {
                 if (mAssignDepth >= 1) {
                     log(aAST, "unnecessary.paren.assign");
                 }
                 else if (aAST.getParent().getType()
                     == TokenTypes.LITERAL_RETURN)
                 {
                     log(aAST, "unnecessary.paren.return");
                 }
                 else {
                     log(aAST, "unnecessary.paren.expr");
                 }
             }
 
             mParentToSkip = null;
         }
         else if (inTokenList(type, ASSIGNMENTS)) {
             mAssignDepth--;
         }
 
         super.leaveToken(aAST);
     }
 
     /**
      * Tests if the given <code>DetailAST</code> is surrounded by parentheses.
      * In short, does <code>aAST</code> have a previous sibling whose type is
      * <code>TokenTypes.LPAREN</code> and a next sibling whose type is <code>
      * TokenTypes.RPAREN</code>.
      * @param aAST the <code>DetailAST</code> to check if it is surrounded by
      *        parentheses.
      * @return <code>true</code> if <code>aAST</code> is surrounded by
      *         parentheses.
      */
     private boolean isSurrounded(DetailAST aAST)
     {
         final DetailAST prev = aAST.getPreviousSibling();
         final DetailAST next = (DetailAST) aAST.getNextSibling();
 
         return prev != null && prev.getType() == TokenTypes.LPAREN
             && next != null && next.getType() == TokenTypes.RPAREN;
     }
 
