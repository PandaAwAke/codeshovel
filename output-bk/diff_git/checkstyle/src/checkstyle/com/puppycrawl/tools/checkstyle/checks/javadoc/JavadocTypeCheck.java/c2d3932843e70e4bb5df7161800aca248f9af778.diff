diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
index 39a2d527a..98d78a238 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
@@ -144,180 +144,180 @@ public class JavadocTypeCheck
     {
         if (shouldCheck(aAST)) {
             final FileContents contents = getFileContents();
             final int lineNo = aAST.getLineNo();
             final TextBlock cmt = contents.getJavadocBefore(lineNo);
             if (cmt == null) {
                 log(lineNo, "javadoc.missing");
             }
             else if (ScopeUtils.isOuterMostType(aAST)) {
                 // don't check author/version for inner classes
                 Vector tags = getJavadocTags(cmt);
                 checkTag(lineNo, tags, "author",
                          mAuthorFormatPattern, mAuthorFormat);
                 checkTag(lineNo, tags, "version",
                          mVersionFormatPattern, mVersionFormat);
 
                 List typeParamNames = CheckUtils.getTypeParameterNames(aAST);
                 if (!mAllowMissingParamTags) {
                     //Check type parameters that should exist, do
                     for (Iterator typeParamNameIt = typeParamNames.iterator();
                          typeParamNameIt.hasNext();)
                     {
                         checkTypeParamTag(
                             lineNo, tags, (String) typeParamNameIt.next());
                     }
                 }
 
                 checkUnusedTypeParamTags(tags, typeParamNames);
             }
         }
     }
 
     /**
      * Whether we should check this node.
      * @param aAST a given node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope scope =
             ScopeUtils.inInterfaceOrAnnotationBlock(aAST)
                 ? Scope.PUBLIC : declaredScope;
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
 
         return scope.isIn(mScope)
             && ((surroundingScope == null) || surroundingScope.isIn(mScope))
             && ((mExcludeScope == null)
                 || !scope.isIn(mExcludeScope)
-                || (surroundingScope != null)
-                && !surroundingScope.isIn(mExcludeScope));
+                || ((surroundingScope != null)
+                && !surroundingScope.isIn(mExcludeScope)));
     }
 
     /**
      * Gets all standalone tags from a given javadoc.
      * @param aCmt teh Javadoc comment to process.
      * @return all standalone tags from the given javadoc.
      */
     private Vector getJavadocTags(TextBlock aCmt)
     {
         final String[] text = aCmt.getText();
         Vector tags = new Vector();
         Pattern tagPattern = Utils.getPattern("/\\*{2,}\\s*@(\\p{Alpha}+)\\s");
         for (int i = 0; i < text.length; i++) {
             final String s = text[i];
             Matcher tagMatcher = tagPattern.matcher(s);
             if (tagMatcher.find()) {
                 final String tagName = tagMatcher.group(1);
                 String content = s.substring(tagMatcher.end(1));
                 if (content.endsWith("*/")) {
                     content = content.substring(0, content.length() - 2);
                 }
                 int col = tagMatcher.start(1) - 1;
                 if (i == 0) {
                     col += aCmt.getStartColNo();
                 }
                 tags.add(new JavadocTag(aCmt.getStartLineNo() + i, col,
                                         tagName, content.trim()));
             }
             tagPattern = Utils.getPattern("^\\s*\\**\\s*@(\\p{Alpha}+)\\s");
         }
         return tags;
     }
 
     /**
      * Verifies that a type definition has a required tag.
      * @param aLineNo the line number for the type definition.
      * @param aTags tags from the Javadoc comment for the type definition.
      * @param aTag the required tag name.
      * @param aFormatPattern regexp for the tag value.
      * @param aFormat pattern for the tag value.
      */
     private void checkTag(int aLineNo, Vector aTags, String aTag,
                           Pattern aFormatPattern, String aFormat)
     {
         if (aFormatPattern == null) {
             return;
         }
 
         int tagCount = 0;
         for (int i = aTags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = (JavadocTag) aTags.get(i);
             if (tag.getTag().equals(aTag)) {
                 tagCount++;
                 if (!aFormatPattern.matcher(tag.getArg1()).find()) {
                     log(aLineNo, "type.tagFormat", "@" + aTag, aFormat);
                 }
             }
         }
         if (tagCount == 0) {
             log(aLineNo, "type.missingTag", "@" + aTag);
         }
     }
 
     /**
      * Verifies that a type definition has the specified param tag for
      * the specified type parameter name.
      * @param aLineNo the line number for the type definition.
      * @param aTags tags from the Javadoc comment for the type definition.
      * @param aTypeParamName the name of the type parameter
      */
     private void checkTypeParamTag(
         final int aLineNo, final Vector aTags, final String aTypeParamName)
     {
         boolean found = false;
         for (int i = aTags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = (JavadocTag) aTags.get(i);
             if (tag.getTag().equals("param")
-                && tag.getArg1() != null
-                && tag.getArg1().indexOf("<" + aTypeParamName + ">") == 0)
+                && (tag.getArg1() != null)
+                && (tag.getArg1().indexOf("<" + aTypeParamName + ">") == 0))
             {
                 found = true;
             }
         }
         if (!found) {
             log(aLineNo, "type.missingTag", "@param <" + aTypeParamName + ">");
         }
     }
 
     /**
      * Checks for unused param tags for type parameters.
      * @param aTags tags from the Javadoc comment for the type definition.
      * @param aTypeParamNames names of type parameters
      */
     private void checkUnusedTypeParamTags(
         final Vector aTags,
         final List aTypeParamNames)
     {
         Pattern pattern = Utils.getPattern("\\s*<([^>]+)>.*");
         for (int i = aTags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = (JavadocTag) aTags.get(i);
             if (tag.getTag().equals("param")) {
 
                 if (tag.getArg1() != null) {
 
                     Matcher matcher = pattern.matcher(tag.getArg1());
                     String typeParamName = null;
 
                     if (matcher.matches()) {
                         typeParamName = matcher.group(1).trim();
                         if (!aTypeParamNames.contains(typeParamName)) {
                             log(tag.getLineNo(), tag.getColumnNo(),
                                 "javadoc.unusedTag",
                                 "@param", "<" + typeParamName + ">");
                         }
                     }
                     else {
                         log(tag.getLineNo(), tag.getColumnNo(),
                             "javadoc.unusedTagGeneral");
                     }
                 }
                 else {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         "javadoc.unusedTagGeneral");
                 }
             }
         }
     }
 }
