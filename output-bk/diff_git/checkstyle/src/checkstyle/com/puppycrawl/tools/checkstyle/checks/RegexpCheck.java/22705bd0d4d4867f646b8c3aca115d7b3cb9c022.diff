diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
index ae804f3ce..4bd7876a7 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java
@@ -131,102 +131,101 @@ public class RegexpCheck extends AbstractFormatCheck
     }
 
     /**
      * Sets if pattern is illegal, otherwise pattern is required.
      * @param aIllegalPattern True if pattern is not allowed.
      */
     public void setIllegalPattern(boolean aIllegalPattern)
     {
         mIllegalPattern = aIllegalPattern;
     }
 
     /**
      * Sets the limit on the number of errors to report.
      * @param aErrorLimit the number of errors to report.
      */
     public void setErrorLimit(int aErrorLimit)
     {
         mErrorLimit = aErrorLimit;
     }
 
     /**
      * Sets the maximum number of instances of required pattern allowed.
      * @param aDuplicateLimit negative values mean no duplicate checking,
      * any positive value is used as the limit.
      */
     public void setDuplicateLimit(int aDuplicateLimit)
     {
         mDuplicateLimit = aDuplicateLimit;
         mCheckForDuplicates = (mDuplicateLimit > DEFAULT_DUPLICATE_LIMIT);
     }
 
     /** {@inheritDoc} */
     @Override
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     /** {@inheritDoc} */
     @Override
     public void beginTree(DetailAST aRootAST)
     {
         mCharacters.clear();
         final Pattern pattern = getRegexp();
         final String[] lines = getLines();
         final StringBuffer sb = new StringBuffer();
         for (int i = 0; i < lines.length; i++) {
             sb.append(lines[i]);
             sb.append('\n');
             for (int j = 0; j < (lines[i].length() + 1); j++) {
-                mCharacters.add(new Integer[] {
-                    new Integer(i + 1), new Integer(j), });
+                mCharacters.add(new Integer[] {i + 1, j});
             }
         }
         mMatcher = pattern.matcher(sb.toString());
         mMatchCount = 0;
         mErrorCount = 0;
         findMatch();
     }
 
     /** recursive method that finds the matches. */
     private void findMatch()
     {
         int startLine;
         int startColumn;
         int endLine;
         int endColumn;
         boolean foundMatch;
         boolean ignore = false;
 
         foundMatch = mMatcher.find();
         if (!foundMatch && !mIllegalPattern && (mMatchCount == 0)) {
             logMessage(0);
         }
         else if (foundMatch) {
             startLine = (mCharacters.get(mMatcher.start()))[0].
                     intValue();
             startColumn = (mCharacters.get(mMatcher.start()))[1].
                     intValue();
             endLine = (mCharacters.get(mMatcher.end() - 1))[0].
                     intValue();
             endColumn = (mCharacters.get(mMatcher.end() - 1))[1].
                     intValue();
             if (mIgnoreComments) {
                 final FileContents theFileContents = getFileContents();
                 ignore = theFileContents.hasIntersectionWithComment(startLine,
                     startColumn, endLine, endColumn);
             }
             if (!ignore) {
                 mMatchCount++;
                 if (mIllegalPattern || (mCheckForDuplicates
                         && ((mMatchCount - 1) > mDuplicateLimit)))
                 {
                     mErrorCount++;
                     logMessage(startLine);
                 }
             }
             if ((mErrorCount < mErrorLimit)
                     && (ignore || mIllegalPattern || mCheckForDuplicates))
             {
                 findMatch();
             }
