diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
index 03ccc3874..99902b900 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java
@@ -1,210 +1,277 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2002  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks;
 
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.Scope;
 import com.puppycrawl.tools.checkstyle.api.ScopeUtils;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 
 import org.apache.regexp.RE;
 
 /**
  * <p>
  * Checks the Javadoc of a method or constructor.
  * By default, does not check for unused throws.
  * To allow documented <code>java.lang.RuntimeException</code>s
  * that are not declared, set property allowUndeclaredRTE to true.
  * The scope to verify is specified using the {@link Scope} class and
  * defaults to {@link Scope#PRIVATE}. To verify another scope,
  * set property scope to one of the {@link Scope} constants.
  * </p>
  * <p>
+ * Error messages about parameters for which no param tags are
+ * present can be suppressed by defining property
+ * <code>allowMissingParamTags</code>. 
+ * Error messages about exceptions which are declared to be thrown, 
+ * but for which no throws tag is present can be suppressed by 
+ * defining property <code>allowMissingThrowsTags</code>. 
+ * Error messages about methods which return non-void but for 
+ * which no return tag is present can be suppressed by defining 
+ * property <code>allowMissingReturnTag</code>.
+ * </p>
+ * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="JavadocMethod"/&gt;
  * </pre>
  * <p> An example of how to configure the check to check to allow
  * documentation of undeclared RuntimeExceptions
- * and for the {@link Scope#PUBLIC} scope is:
+ * and for the {@link Scope#PUBLIC} scope, while ignoring any missing
+ * param tags is:
  *</p>
  * <pre>
  * &lt;module name="JavadocMethod"&gt;
  *    &lt;property name="scope" value="public"/&gt;
  *    &lt;property name="allowUndeclaredRTE" value="true"/&gt;
+ *    &lt;property name="allowMissingParamTags" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @author Rick Giles
  * @version 1.0
  */
 public class JavadocMethodCheck
     extends AbstractImportCheck
 {
 
        // {{{ Data declarations
     /** the pattern to match Javadoc tags that take an argument **/
     private static final String MATCH_JAVADOC_ARG_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s+\\S";
     /** compiled regexp to match Javadoc tags that take an argument **/
     private static final RE MATCH_JAVADOC_ARG =
         Utils.createRE(MATCH_JAVADOC_ARG_PAT);
 
    /**
     * the pattern to match the first line of a multi-line Javadoc
     * tag that takes an argument.
     **/
     private static final String MATCH_JAVADOC_ARG_MULTILINE_START_PAT =
         "@(throws|exception|param)\\s+(\\S+)\\s*$";
     /** compiled regexp to match first part of multilineJavadoc tags **/
     private static final RE MATCH_JAVADOC_ARG_MULTILINE_START =
         Utils.createRE(MATCH_JAVADOC_ARG_MULTILINE_START_PAT);
 
     /** the pattern that looks for a continuation of the comment **/
     private static final String MATCH_JAVADOC_MULTILINE_CONT_PAT =
         "(\\*/|@|[^\\s\\*])";
     /** compiled regexp to look for a continuation of the comment **/
     private static final RE MATCH_JAVADOC_MULTILINE_CONT =
         Utils.createRE(MATCH_JAVADOC_MULTILINE_CONT_PAT);
     /** Multiline finished at end of comment **/
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc **/
     private static final String NEXT_TAG = "@";
 
     /** the pattern to match Javadoc tags with no argument **/
     private static final String MATCH_JAVADOC_NOARG_PAT =
         "@(return|see)\\s+\\S";
     /** compiled regexp to match Javadoc tags with no argument **/
     private static final RE MATCH_JAVADOC_NOARG =
         Utils.createRE(MATCH_JAVADOC_NOARG_PAT);
    /**
     * the pattern to match the first line of a multi-line Javadoc
     * tag that takes no argument.
     **/
     private static final String MATCH_JAVADOC_NOARG_MULTILINE_START_PAT =
         "@(return|see)\\s*$";
     /** compiled regexp to match first part of multilineJavadoc tags **/
     private static final RE MATCH_JAVADOC_NOARG_MULTILINE_START =
         Utils.createRE(MATCH_JAVADOC_NOARG_MULTILINE_START_PAT);
 
     /** the pattern to match Javadoc tags with no argument and {} **/
     private static final String MATCH_JAVADOC_NOARG_CURLY_PAT =
         "\\{\\s*@(inheritDoc)\\s*\\}";
     /** compiled regexp to match Javadoc tags with no argument and {} **/
     private static final RE MATCH_JAVADOC_NOARG_CURLY =
         Utils.createRE(MATCH_JAVADOC_NOARG_CURLY_PAT);
 
     /** full identifier for package of the method **/
     private FullIdent mPackageFullIdent = null;
 
     /** imports details **/
     private Set mImports = new HashSet();
 
     /** the visibility scope where Javadoc comments are checked **/
     private Scope mScope = Scope.PRIVATE;
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      **/
     private boolean mAllowUndeclaredRTE = false;
 
+    /**
+     * controls whether to ignore errors when a method has parameters
+     * but does not have matching param tags in the javadoc.
+     * Defaults to false.
+     **/
+    private boolean mAllowMissingParamTags = false;
+
+    /**
+     * controls whether to ignore errors when a method declares that
+     * it throws exceptions but does not have matching throws tags 
+     * in the javadoc. Defaults to false.
+     **/
+    private boolean mAllowMissingThrowsTags = false;
+
+    /**
+     * controls whether to ignore errors when a method returns
+     * non-void type but does not have a return tag in the javadoc.
+     * Defaults to false.
+     **/
+    private boolean mAllowMissingReturnTag = false;
+
     /**
      * Set the scope.
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * controls whether to allow documented exceptions that
      * are not declared if they are a subclass of
      * java.lang.RuntimeException.
      * @param aFlag a <code>Boolean</code> value
      */
     public void setAllowUndeclaredRTE(boolean aFlag)
     {
         mAllowUndeclaredRTE = aFlag;
     }
 
+    /**
+     * controls whether to allow a method which has parameters
+     * to omit matching param tags in the javadoc.
+     * Defaults to false.
+     * @param aFlag a <code>Boolean</code> value
+     */
+    public void setAllowMissingParamTags(boolean aFlag)
+    {
+        mAllowMissingParamTags = aFlag;
+    }
+
+    /**
+     * controls whether to allow a method which declares that
+     * it throws exceptions to omit matching throws tags 
+     * in the javadoc. Defaults to false.
+     * @param aFlag a <code>Boolean</code> value
+     */
+    public void setAllowMissingThrowsTags(boolean aFlag)
+    {
+        mAllowMissingThrowsTags = aFlag;
+    }
+
+    /**
+     * controls whether to allow a method which returns
+     * non-void type to omit the return tag in the javadoc.
+     * Defaults to false.
+     * @param aFlag a <code>Boolean</code> value
+     */
+    public void setAllowMissingReturnTag(boolean aFlag)
+    {
+        mAllowMissingReturnTag = aFlag;
+    }
+
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF};
     }
     
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void beginTree(DetailAST aRootAST)
     {
         mPackageFullIdent = FullIdent.createFullIdent(null);
         mImports.clear();
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.PACKAGE_DEF) {
             if (mAllowUndeclaredRTE) {
                 processPackage(aAST);
             }
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
             processImport(aAST);
         }
         else {
             //TokenTypes.METHOD_DEF or TokenTypes.CTOR_DEF
             processMethod(aAST);
         }
     }
 
@@ -406,241 +473,248 @@ public class JavadocMethodCheck
                 if ((child.getType() == TokenTypes.IDENT)
                     || (child.getType() == TokenTypes.DOT))
                 {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     retVal.add(fi);
                 }
                 child = (DetailAST) child.getNextSibling();
             }
         }
         return retVal;
     }
 
 
     /**
      * Checks a set of tags for matching parameters.
      * @param aTags the tags to check
      * @param aParams the list of parameters to check
      **/
     private void checkParamTags(List aTags, List aParams)
     {
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching param
             boolean found = false;
             final Iterator paramIt = aParams.iterator();
             while (paramIt.hasNext()) {
                 final DetailAST param = (DetailAST) paramIt.next();
                 if (param.getText().equals(tag.getArg1())) {
                     found = true;
                     paramIt.remove();
                     break;
                 }
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), "javadoc.unusedTag",
                               "@param", tag.getArg1());
             }
         }
 
-        // Now dump out all parameters without tags
-        final Iterator paramIt = aParams.iterator();
-        while (paramIt.hasNext()) {
-            final DetailAST param = (DetailAST) paramIt.next();
-            log(param.getLineNo(), param.getColumnNo(),
-                "javadoc.expectedTag", "@param", param.getText());
+        // Now dump out all parameters without tags :- unless
+        // the user has chosen to suppress these problems
+        if (!mAllowMissingParamTags) {
+            final Iterator paramIt = aParams.iterator();
+            while (paramIt.hasNext()) {
+                final DetailAST param = (DetailAST) paramIt.next();
+                log(param.getLineNo(), param.getColumnNo(),
+                    "javadoc.expectedTag", "@param", param.getText());
+            }
         }
     }
 
     /**
      * Return if two Strings represent the same type, inspecting the
      * import statements if necessary
      *
      * @param aDeclared type declared in throws clause
      * @param aDocumented type declared in javadoc throws tag
      * @return true iff type names represent the same type
      */
     private boolean isSameType(String aDeclared, String aDocumented)
     {
         return aDeclared.equals(aDocumented)
                 || isShortName(aDeclared, aDocumented)
                 || isShortName(aDocumented, aDeclared);
     }
 
     /**
      * Calculate if one type name is a shortname for another type name.
      * @param aShortName a shorthand, such as <code>IOException</code>
      * @param aFullName a full name, such as <code>java.io.IOException</code>
      * @return true iff aShortName represents the same type as aFullName
      */
     private boolean isShortName(String aShortName, String aFullName)
     {
         if (aShortName.length() >= aFullName.length()) {
             return false;
         }
 
         final String base = basename(aFullName);
         if (aShortName.length() >= aFullName.length()
                 || !base.equals(aShortName))
         {
             return false;
         }
 
         // check fully qualified import
         if (mImports.contains(aFullName)) {
             return true;
         }
 
         // check .* import
         final int endIndex = aFullName.length() - base.length() - 1;
         final String packageName = aFullName.substring(0, endIndex);
         final String starImport = packageName + ".*";
         if (mImports.contains(starImport)) {
             return true;
         }
 
         // check fully qualified class from same package
         return packageName.equals(mPackageFullIdent.getText());
     }
 
     /**
      * Checks whether a method is a function.
      * @param aAST the method node.
      * @return whether the method is a function.
      **/
     private boolean isFunction(DetailAST aAST)
     {
         boolean retVal = false;
         if (aAST.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = aAST.findFirstToken(TokenTypes.TYPE);
             if ((typeAST != null)
                 && (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null))
             {
                 retVal = true;
             }
         }
         return retVal;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      * @param aTags the tags to check
      * @param aLineNo the line number of the expected tag
      **/
     private void checkReturnTag(List aTags, int aLineNo)
     {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator it = aTags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = (JavadocTag) it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), "javadoc.return.duplicate");
                 }
                 found = true;
                 it.remove();
             }
         }
 
-        // Handle there being no @return tags
-        if (!found) {
+        // Handle there being no @return tags :- unless
+        // the user has chosen to suppress these problems
+        if (!found && !mAllowMissingReturnTag) {
             log(aLineNo, "javadoc.return.expected");
         }
     }
 
 
     /**
      * Checks a set of tags for matching throws.
      * @param aTags the tags to check
      * @param aThrows the throws to check
      **/
     private void checkThrowsTags(List aTags, List aThrows)
     {
         // Loop over the tags, checking to see they exist in the throws.
         final Set foundThrows = new HashSet();
         final ListIterator tagIt = aTags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = (JavadocTag) tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             boolean found = foundThrows.contains(documentedEx);
             final ListIterator throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final FullIdent fi = (FullIdent) throwIt.next();
                 final String declaredEx = fi.getText();
                 if (isSameType(declaredEx, documentedEx)) {
                     found = true;
                     throwIt.remove();
                     foundThrows.add(documentedEx);
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (mAllowUndeclaredRTE) {
                     final ClassResolver cr =
                         new ClassResolver(
                             getClassLoader(),
                             mPackageFullIdent.getText(),
                             mImports);
                     try {
                         final Class clazz = cr.resolve(tag.getArg1());
                         reqd =
                             !RuntimeException.class.isAssignableFrom(clazz)
                                 && !Error.class.isAssignableFrom(clazz);
                     }
                     catch (ClassNotFoundException e) {
                         log(tag.getLineNo(), "javadoc.classInfo",
                                       "@throws", tag.getArg1());
                     }
                 }
 
                 if (reqd) {
                     log(tag.getLineNo(), "javadoc.unusedTag",
                                   "@throws", tag.getArg1());
                 }
             }
         }
 
-        // Now dump out all throws without tags
-        final ListIterator throwIt = aThrows.listIterator();
-        while (throwIt.hasNext()) {
-            final FullIdent fi = (FullIdent) throwIt.next();
-            log(fi.getLineNo(), fi.getColumnNo(),
-                "javadoc.expectedTag", "@throws", fi.getText());
+        // Now dump out all throws without tags :- unless
+        // the user has chosen to suppress these problems
+        if (!mAllowMissingThrowsTags) {
+            final ListIterator throwIt = aThrows.listIterator();
+            while (throwIt.hasNext()) {
+                final FullIdent fi = (FullIdent) throwIt.next();
+                log(fi.getLineNo(), fi.getColumnNo(),
+                    "javadoc.expectedTag", "@throws", fi.getText());
+            }
         }
     }
 
     // TODO: clean up duplicate code in UnusedImports and IllegalInstantiation
     /**
      * @return the class name from a fully qualified name
      * @param aType the fully qualified name
      */
     private String basename(String aType)
     {
         final int i = aType.lastIndexOf(".");
         return (i == -1) ? aType : aType.substring(i + 1);
     }
 
 }
