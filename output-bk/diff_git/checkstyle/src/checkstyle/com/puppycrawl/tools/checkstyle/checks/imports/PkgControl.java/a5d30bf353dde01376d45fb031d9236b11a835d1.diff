diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
index 48b475ed2..82aa6f175 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/PkgControl.java
@@ -70,86 +70,93 @@ class PkgControl
      * Adds a guard to the node.
      * @param aThug the guard to be added.
      */
     void addGuard(final Guard aThug)
     {
         mGuards.addFirst(aThug);
     }
 
     /**
      * @return the full package name represented by the node.
      */
     String getFullPackage()
     {
         return mFullPackage;
     }
 
     /**
      * Search down the tree to locate the finest match for a supplied package.
      * @param aForPkg the package to search for.
      * @return the finest match, or null if no match at all.
      */
     PkgControl locateFinest(final String aForPkg)
     {
         // Check if we are a match.
         // This algormithm should be improved to check for a trailing "."
         // or nothing following.
         if (!aForPkg.startsWith(getFullPackage())) {
             return null;
         }
 
         // Check if any of the children match.
         final Iterator it = mChildren.iterator();
         while (it.hasNext()) {
             final PkgControl pc = (PkgControl) it.next();
             final PkgControl match = pc.locateFinest(aForPkg);
             if (match != null) {
                 return match;
             }
         }
 
         // No match so I am the best there is.
         return this;
     }
 
     /**
      * Returns whether a package is allowed to be used. The algorithm checks
      * with the current node for a result, and if none is found then calls
      * its parent looking for a match. This will recurse looking for match.
      * If there is no clear result then {@link AccessResult#UNKNOWN} is
      * returned.
-     * @param aForPkg the package to check on.
+     * @param aForImport the package to check on.
+     * @param aInPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
-    AccessResult checkAccess(final String aForPkg)
+    AccessResult checkAccess(final String aForImport, final String aInPkg)
     {
-        AccessResult retVal = localCheckAccess(aForPkg);
+        AccessResult retVal = localCheckAccess(aForImport, aInPkg);
         if (retVal != AccessResult.UNKNOWN) {
             return retVal;
         }
         else if (mParent == null) {
             // we are the top, so default to not allowed.
             return AccessResult.DISALLOWED;
         }
 
-        return mParent.checkAccess(aForPkg);
+        return mParent.checkAccess(aForImport, aInPkg);
     }
 
     /**
      * Checks whether any of the guards for this node control access to
      * a specified package.
-     * @param aForPkg the package to check.
+     * @param aForImport the package to check.
+     * @param aInPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
-    private AccessResult localCheckAccess(final String aForPkg)
+    private AccessResult localCheckAccess(final String aForImport,
+        final String aInPkg)
     {
         final Iterator it = mGuards.iterator();
         while (it.hasNext()) {
             final Guard g = (Guard) it.next();
-            final AccessResult result = g.verify(aForPkg);
+            // Check if a Guard is only meant to be applied locally.
+            if (g.isLocalOnly() && !mFullPackage.equals(aInPkg)) {
+                continue;
+            }
+            final AccessResult result = g.verifyImport(aForImport, aInPkg);
             if (result != AccessResult.UNKNOWN) {
                 return result;
             }
         }
         return AccessResult.UNKNOWN;
     }
 }
