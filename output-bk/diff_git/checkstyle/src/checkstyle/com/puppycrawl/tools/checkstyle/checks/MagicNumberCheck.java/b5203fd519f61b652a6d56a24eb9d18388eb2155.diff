diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/MagicNumberCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/MagicNumberCheck.java
index f6e6848c4..0ad2c288f 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/MagicNumberCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/MagicNumberCheck.java
@@ -41,141 +41,134 @@ import java.util.Arrays;
 public class MagicNumberCheck extends Check
 {
     /** the numbers to ignore in the check, sorted */
     private float[] mIgnoreNumbers = {-1, 0, 1, 2};
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.NUM_DOUBLE,
             TokenTypes.NUM_FLOAT,
             TokenTypes.NUM_INT,
             TokenTypes.NUM_LONG,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (!inIgnoreList(aAST) && !isConstantDefinition(aAST)) {
             log(aAST.getLineNo(),
                 aAST.getColumnNo(),
                 "magic.number",
                 aAST.getText());
         }
     }
 
     /**
      * Decides whether the number of an AST is in the ignore list of this
      * check.
      * @param aAST the AST to check
      * @return true if the number of aAST is in the ignore list of this
      * check.
      */
     private boolean inIgnoreList(DetailAST aAST)
     {
         final float value = parseFloat(aAST.getText(), aAST.getType());
         return (Arrays.binarySearch(mIgnoreNumbers, value) >= 0);
     }
 
     /**
      * Returns the value represented by the specified string of the specified
      * type. Returns 0 for types other than float, double, int, and long.
      * @param aText the string to be parsed.
      * @param aType the token type of the text. Should be a constant of
      * {@link com.puppycrawl.tools.checkstyle.api.TokenTypes}.
      * @return the float value represented by the string argument.
      */
     private float parseFloat(String aText, int aType)
     {
+        float result = 0;
         if (aType == TokenTypes.NUM_FLOAT) {
-            return Float.parseFloat(aText);
+            result = Float.parseFloat(aText);
         }
         if (aType == TokenTypes.NUM_DOUBLE) {
-            return (float) Double.parseDouble(aText);
+            result = (float) Double.parseDouble(aText);
         }
         else {
             int radix = 10;
             if (aText.startsWith("0x") || aText.startsWith("0X")) {
                 radix = 16;
                 aText = aText.substring(2);
             }
             else if (aText.charAt(0) == '0') {
                 radix = 8;
                 aText = aText.substring(1);
             }
             if (aType == TokenTypes.NUM_INT) {
                 if (aText.length() > 0) {
-                    return (float) Integer.parseInt(aText, radix);
-                }
-                else {
-                    return 0;
+                    result = (float) Integer.parseInt(aText, radix);
                 }
             }
             else if (aType == TokenTypes.NUM_LONG) {
                 // Long.parseLong requires that the text ends with neither 'L'
                 // nor 'l'.
                 if ((aText.endsWith("L")) || (aText.endsWith("l"))) {
                     aText = aText.substring(0, aText.length() - 1);
                 }
                 if (aText.length() > 0) {
-                    return (float) Long.parseLong(aText, radix);
+                    result = (float) Long.parseLong(aText, radix);
                 }
-                else {
-                    return 0;
-                } 
-            }
-            else {
-                return 0;
             }
         }
+        return result;
     }
 
     /**
      * Decides whether the number of an AST is the RHS of a constant
      * definition.
      * @param aAST the AST to check.
      * @return true if the number of aAST is the RHS of a constant definition.
      */
     private boolean isConstantDefinition(DetailAST aAST)
     {
         DetailAST parent = aAST.getParent();
 
         //expression?
         if ((parent == null) || (parent.getType() != TokenTypes.EXPR)) {
             return false;
         }
 
         //assignment?
         parent = parent.getParent();
         if ((parent == null) || (parent.getType() != TokenTypes.ASSIGN)) {
             return false;
         }
 
         //variable definition?
         parent = parent.getParent();
         if ((parent == null) || (parent.getType() != TokenTypes.VARIABLE_DEF)) {
             return false;
         }
 
         //final?
         final DetailAST modifiersAST =
             parent.findFirstToken(TokenTypes.MODIFIERS);
         return modifiersAST.branchContains(TokenTypes.FINAL);
     }
 
     /**
      * Sets the numbers to ignore in the check.
      * BeanUtils converts numeric token list to float array automatically.
      * @param aList list of numbers to ignore.
      */    
     public void setIgnoreNumbers(float[] aList)
     {
         if ((aList == null) || (aList.length == 0)) {
             mIgnoreNumbers = new float[0];
         }
         else {
             mIgnoreNumbers = new float[aList.length];
             System.arraycopy(aList, 0, mIgnoreNumbers, 0, aList.length);
             Arrays.sort(mIgnoreNumbers);
         }
