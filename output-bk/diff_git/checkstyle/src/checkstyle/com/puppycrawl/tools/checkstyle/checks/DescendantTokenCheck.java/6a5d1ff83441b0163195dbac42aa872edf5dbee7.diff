diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
index 7d0cd3a81..23e8173a2 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
@@ -119,157 +119,183 @@ import java.util.Set;
  * &lt;/module&gt;
  *
  * &lt;!-- Too many fields within an interface --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="INTERFACE_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="VARIABLE_DEF"/&gt;
  *     &lt;property name="maximumDepth" value="2"/&gt;
  *     &lt;property name="maximumNumber" value="0"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Limit the number of exceptions a method can throw --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="LITERAL_THROWS"/&gt;
  *     &lt;property name="limitedTokens" value="IDENT"/&gt;
  *     &lt;property name="maximumNumber" value="1"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Limit the number of expressions in a method --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="METHOD_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="EXPR"/&gt;
  *     &lt;property name="maximumNumber" value="200"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Disallow empty statements --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="EMPTY_STAT"/&gt;
  *     &lt;property name="limitedTokens" value="EMPTY_STAT"/&gt;
  *     &lt;property name="maximumNumber" value="0"/&gt;
  *     &lt;property name="maximumDepth" value="0"/&gt;
  *     &lt;property name="maximumMessage"
  *         value="Empty statement is not allowed."/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Too many fields within a class --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="CLASS_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="VARIABLE_DEF"/&gt;
  *     &lt;property name="maximumDepth" value="2"/&gt;
  *     &lt;property name="maximumNumber" value="10"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author Tim Tyler &lt;tim@tt1.org&gt;
  * @author Rick Giles
  */
 public class DescendantTokenCheck extends Check
 {
      /** minimum  depth */
     private int mMinimumDepth;
-
     /** maximum depth */
     private int mMaximumDepth = Integer.MAX_VALUE;
-
     /** minimum number */
     private int mMinimumNumber;
-
     /** maximum number */
     private int mMaximumNumber = Integer.MAX_VALUE;
-
+    /** Whether to sum the number of tokens found. */
+    private boolean mSumTokenCounts;
     /** limited tokens */
     private int[] mLimitedTokens = new int[0];
-
     /** error message when minimum count not reached */
-    private String mMinimumMessage = "descendant.token.min";
-
+    private String mMinimumMessage;
     /** error message when maximum count exceeded */
-    private String mMaximumMessage = "descendant.token.max";
+    private String mMaximumMessage;
 
     /**
      * Counts of descendant tokens.
      * Indexed by (token ID - 1) for performance.
      */
     private int[] mCounts = new int[0];
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         //reset counts
         Arrays.fill(mCounts, 0);
-
         countTokens(aAST, 0);
 
         // name of this token
         final String name = TokenTypes.getTokenName(aAST.getType());
 
-        for (int element : mLimitedTokens) {
-            final int tokenCount = mCounts[element - 1];
-            if (tokenCount < mMinimumNumber) {
-                final String descendantName =
-                    TokenTypes.getTokenName(element);
-                log(aAST.getLineNo(), aAST.getColumnNo(), mMinimumMessage,
-                    "" + tokenCount, "" + mMinimumNumber,
-                    name, descendantName);
+        if (mSumTokenCounts) {
+            int total = 0;
+            for (int element : mLimitedTokens) {
+                total += mCounts[element - 1];
             }
-            if (tokenCount > mMaximumNumber) {
-                final String descendantName =
-                    TokenTypes.getTokenName(element);
-                log(aAST.getLineNo(), aAST.getColumnNo(), mMaximumMessage,
-                    "" + tokenCount, "" + mMaximumNumber,
-                    name, descendantName);
+            if (total < mMinimumNumber) {
+                log(aAST.getLineNo(), aAST.getColumnNo(),
+                        (null == mMinimumMessage) ? "descendant.token.sum.min"
+                                : mMinimumMessage,
+                        String.valueOf(total),
+                        String.valueOf(mMinimumNumber), name);
+            }
+            if (total > mMaximumNumber) {
+                log(aAST.getLineNo(), aAST.getColumnNo(),
+                        (null == mMaximumMessage) ? "descendant.token.sum.max"
+                                : mMaximumMessage,
+                        String.valueOf(total),
+                        String.valueOf(mMaximumNumber),
+                        name);
+            }
+        }
+        else {
+            for (int element : mLimitedTokens) {
+                final int tokenCount = mCounts[element - 1];
+                if (tokenCount < mMinimumNumber) {
+                    final String descendantName = TokenTypes
+                            .getTokenName(element);
+                    log(aAST.getLineNo(), aAST.getColumnNo(),
+                            (null == mMinimumMessage) ? "descendant.token.min"
+                                    : mMinimumMessage,
+                            String.valueOf(tokenCount),
+                            String.valueOf(mMinimumNumber),
+                            name,
+                            descendantName);
+                }
+                if (tokenCount > mMaximumNumber) {
+                    final String descendantName = TokenTypes
+                            .getTokenName(element);
+                    log(aAST.getLineNo(), aAST.getColumnNo(),
+                            (null == mMaximumMessage) ? "descendant.token.max"
+                                    : mMaximumMessage,
+                            String.valueOf(tokenCount),
+                            String.valueOf(mMaximumNumber),
+                            name,
+                            descendantName);
+                }
             }
         }
     }
 
     /**
      * Counts the number of occurrences of descendant tokens.
      * @param aAST the root token for descendants.
      * @param aDepth the maximum depth of the counted descendants.
      */
     private void countTokens(AST aAST, int aDepth)
     {
         if (aDepth <= mMaximumDepth) {
             //update count
             if (aDepth >= mMinimumDepth) {
                 final int type = aAST.getType();
                 if (type <= mCounts.length) {
                     mCounts[type - 1]++;
                 }
             }
             AST child = aAST.getFirstChild();
             final int nextDepth = aDepth + 1;
             while (child != null) {
                 countTokens(child, nextDepth);
                 child = child.getNextSibling();
             }
         }
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         // Any tokens set by property 'tokens' are acceptable
         final Set<String> tokenNames = getTokenNames();
         final int[] result = new int[tokenNames.size()];
         int i = 0;
         for (String name : tokenNames) {
             result[i++] = TokenTypes.getTokenId(name);
         }
         return result;
     }
 
     /**
      * Sets the tokens which occurance as descendant is limited.
      * @param aLimitedTokens - list of tokens to ignore.
      */
     public void setLimitedTokens(String[] aLimitedTokens)
     {
         mLimitedTokens = new int[aLimitedTokens.length];
 
         int maxToken = 0;
@@ -303,51 +329,61 @@ public class DescendantTokenCheck extends Check
    /**
     * Sets a minimum count for descendants.
     * @param aMinimumNumber the minimum count for descendants.
     */
     public void setMinimumNumber(int aMinimumNumber)
     {
         mMinimumNumber = aMinimumNumber;
     }
 
     /**
       * Sets a maximum count for descendants.
       * @param aMaximumNumber the maximum count for descendants.
       */
     public void setMaximumNumber(int aMaximumNumber)
     {
         mMaximumNumber = aMaximumNumber;
     }
 
     /**
      * Sets the error message for minimum count not reached.
      * @param aMessage the error message for minimum count not reached.
      * Used as a <code>MessageFormat</code> pattern with arguments
      * <ul>
      * <li>{0} - token count</li>
      * <li>{1} - minimum number</li>
      * <li>{2} - name of token</li>
      * <li>{3} - name of limited token</li>
      * </ul>
      */
     public void setMinimumMessage(String aMessage)
     {
         mMinimumMessage = aMessage;
     }
 
     /**
      * Sets the error message for maximum count exceeded.
      * @param aMessage the error message for maximum count exceeded.
      * Used as a <code>MessageFormat</code> pattern with arguments
      * <ul>
      * <li>{0} - token count</li>
      * <li>{1} - maximum number</li>
      * <li>{2} - name of token</li>
      * <li>{3} - name of limited token</li>
      * </ul>
      */
 
     public void setMaximumMessage(String aMessage)
     {
         mMaximumMessage = aMessage;
     }
+
+    /**
+     * Sets whether to use the sum of the tokens found, rather than the
+     * individual counts.
+     * @param aSum whether to use the sum.
+     */
+    public void setSumTokenCounts(boolean aSum)
+    {
+        mSumTokenCounts = aSum;
+    }
 }
