diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocTypeCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocTypeCheck.java
index a4ce93ecd..ac30288a5 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocTypeCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocTypeCheck.java
@@ -36,141 +36,172 @@ import com.puppycrawl.tools.checkstyle.api.Utils;
  * By default, does not check for author or version tags.
  * The scope to verify is specified using the {@link Scope} class and
  * defaults to {@link Scope#PRIVATE}. To verify another scope,
  * set property scope to one of the {@link Scope} constants.
  * To define the format for an author tag or a version tag,
  * set property authorFormat or versionFormat respectively to a 
  * <a href="http://jakarta.apache.org/regexp/apidocs/org/apache/regexp/RE.html">
  * regular expression</a>. 
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="JavadocType"/&gt;
  * </pre>
  * <p> An example of how to configure the check for the 
  * {@link Scope#PUBLIC} scope is:
  *</p>
  * <pre>
  * &lt;module name="JavadocType"&gt;
  *    &lt;property name="scope" value="public"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p> An example of how to configure the check for an author tag
  *  and a version tag is:
  *</p>
  * <pre>
  * &lt;module name="JavadocType"&gt;
  *    &lt;property name="authorFormat" value="\S"/&gt;
  *    &lt;property name="versionFormat" value="\S"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p> An example of how to configure the check for a
  * CVS revision version tag is:
  *</p>
  * <pre>
  * &lt;module name="JavadocType"&gt;
  *    &lt;property name="versionFormat" value="\$Revision.*\$"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
 
  * @author <a href="mailto:checkstyle@puppycrawl.com">Oliver Burn</a>
  * @version 1.0
  */
 public class JavadocTypeCheck
     extends Check
 {
     /** the scope to check for */
     private Scope mScope = Scope.PRIVATE;
-    /** compiled regexp to match author tag **/ 
-    private RE mAuthorRE = null;
+    /** compiled regexp to match author tag **/
+    private RE mAuthorTagRE = null;
+    /** compiled regexp to match author tag content **/
+    private RE mAuthorFormatRE = null;
     /** compiled regexp to match version tag **/
-    private RE mVersionRE = null;
-    
+    private RE mVersionTagRE = null;
+    /** compiled regexp to match version tag content **/
+    private RE mVersionFormatRE = null;
+    /** regexp to match author tag content */
+    private String mAuthorFormat;
+    /** regexp to match version tag content */
+    private String mVersionFormat;
+
     /**
      * Sets the scope to check.
      * @param aFrom string to set scope from
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set the author tag pattern.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setAuthorFormat(String aFormat)
         throws ConversionException
     {      
         try {
-            mAuthorRE = Utils.getRE("@author\\s+" + aFormat);
+            mAuthorTagRE = Utils.getRE("@author\\s+(.*$)");
+            mAuthorFormat = aFormat;
+            mAuthorFormatRE = Utils.getRE(aFormat);
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
     }
     
     /**
-     * Set the ignore pattern.
+     * Set the version format pattern.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setVersionFormat(String aFormat)
         throws ConversionException
     {
         try {
-            mVersionRE = Utils.getRE("@version\\s+" + aFormat);
+            mVersionTagRE = Utils.getRE("@version\\s+(.*$)");
+            mVersionFormat = aFormat;
+            mVersionFormatRE = Utils.getRE(aFormat);
         }
         catch (RESyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
 
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.INTERFACE_DEF, TokenTypes.CLASS_DEF};
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         final DetailAST mods = aAST.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         final Scope typeScope =
             ScopeUtils.inInterfaceBlock(aAST) ? Scope.PUBLIC : declaredScope;
         if (typeScope.isIn(mScope)) {
             final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
             if ((surroundingScope == null) || surroundingScope.isIn(mScope)) {
                 final FileContents contents = getFileContents();
+                final int lineNo = aAST.getLineNo();
                 final String[] cmt =
-                    contents.getJavadocBefore(aAST.getLineNo());
+                    contents.getJavadocBefore(lineNo);
                 if (cmt == null) {
-                    log(aAST.getLineNo(), "javadoc.missing");
+                    log(lineNo, "javadoc.missing");
                 }
                 else if (ScopeUtils.isOuterMostType(aAST)) {
                     // don't check author/version for inner classes
-                    if ((mAuthorRE != null)
-                        && (mAuthorRE.grep(cmt).length == 0))
-                    {
-                        // TODO: better error message
-                        log(aAST.getLineNo(), "type.missingTag", "@author");
-                    }
+                    checkTag(lineNo, cmt, "@author",
+                            mAuthorTagRE, mAuthorFormatRE, mAuthorFormat);
+                    checkTag(lineNo, cmt, "@version",
+                            mVersionTagRE, mVersionFormatRE, mVersionFormat);
+                }
+            }
+        }
+    }
 
-                    if ((mVersionRE != null)
-                        && (mVersionRE.grep(cmt).length == 0))
-                    {
-                        // TODO: better error message
-                        log(aAST.getLineNo(), "type.missingTag", "@version");
-                    }
+    private void checkTag(
+            int aLineNo, String[] aCmt,
+            String aTag, RE aTagRE, RE aFormatRE, String aFormat)
+    {
+        if (aTagRE == null) {
+            return;
+        }
 
+        int tagCount = 0;
+        for (int i = 0; i < aCmt.length; i++) {
+            final String s = aCmt[i];
+            if (aTagRE.match(s)) {
+                tagCount += 1;
+                final int contentStart = aTagRE.getParenStart(1);
+                final String content = s.substring(contentStart);
+                if (!aFormatRE.match(content))
+                {
+                    log(aLineNo, "type.tagFormat", aTag, aFormat);
                 }
+
             }
         }
+        if (tagCount == 0) {
+            log(aLineNo, "type.missingTag", aTag);
+        }
+
     }
 
 }
