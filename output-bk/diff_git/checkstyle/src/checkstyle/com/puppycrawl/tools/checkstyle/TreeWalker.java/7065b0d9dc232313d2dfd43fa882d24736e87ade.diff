diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 7d2c1360d..71aab5ec2 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -1,159 +1,109 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2007  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle;
 
 import antlr.RecognitionException;
-import antlr.TokenStream;
 import antlr.TokenStreamException;
 import antlr.TokenStreamRecognitionException;
 import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.api.Context;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 import com.puppycrawl.tools.checkstyle.grammars.GeneratedJavaLexer;
 import com.puppycrawl.tools.checkstyle.grammars.GeneratedJavaRecognizer;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 /**
  * Responsible for walking an abstract syntax tree and notifying interested
  * checks at each each node.
  *
  * @author Oliver Burn
  * @version 1.0
  */
 public final class TreeWalker
     extends AbstractFileSetCheck
 {
-    /**
-     * Overrides ANTLR error reporting so we completely control
-     * checkstyle's output during parsing. This is important because
-     * we try parsing with several grammers (with/without support for
-     * <code>assert</code>). We must not write any error messages when
-     * parsing fails because with the next grammar it might succeed
-     * and the user will be confused.
-     */
-    private static final class SilentJavaRecognizer
-        extends GeneratedJavaRecognizer
-    {
-        /**
-         * Creates a new <code>SilentJavaRecognizer</code> instance.
-         *
-         * @param aLexer the tokenstream the recognizer operates on.
-         */
-        public SilentJavaRecognizer(TokenStream aLexer)
-        {
-            super(aLexer);
-        }
-
-        /**
-         * Parser error-reporting function, does nothing.
-         * @param aRex the exception to be reported
-         */
-        @Override
-        public void reportError(RecognitionException aRex)
-        {
-        }
-
-        /**
-         * Parser error-reporting function, does nothing.
-         * @param aMsg the error message
-         */
-        @Override
-        public void reportError(String aMsg)
-        {
-        }
-
-        /**
-         * Parser warning-reporting function, does nothing.
-         * @param aMsg the error message
-         */
-        @Override
-        public void reportWarning(String aMsg)
-        {
-        }
-    }
-
     /** default distance between tab stops */
     private static final int DEFAULT_TAB_WIDTH = 8;
 
     /** maps from token name to checks */
     private final Map<String, List<Check>> mTokenToChecks =
         new HashMap<String, List<Check>>();
     /** all the registered checks */
     private final Set<Check> mAllChecks = new HashSet<Check>();
     /** the distance between tab stops */
     private int mTabWidth = DEFAULT_TAB_WIDTH;
     /** cache file **/
     private PropertyCacheFile mCache = new PropertyCacheFile(null, null);
 
     /** class loader to resolve classes with. **/
     private ClassLoader mClassLoader;
 
     /** context of child components */
     private Context mChildContext;
 
     /** a factory for creating submodules (i.e. the Checks) */
     private ModuleFactory mModuleFactory;
 
     /** controls whether we should use recursive or iterative
      * algorithm for tree processing.
      */
     private final boolean mRecursive;
 
     /** logger for debug purpose */
     private static final Log LOG =
         LogFactory.getLog("com.puppycrawl.tools.checkstyle.TreeWalker");
 
     /**
      * Creates a new <code>TreeWalker</code> instance.
      */
     public TreeWalker()
     {
         setFileExtensions(new String[]{"java"});
         // Tree walker can use two possible algorithms for
         // tree processing (iterative and recursive.
         // Recursive is default for now.
         final String recursive =
             System.getProperty("checkstyle.use.recursive.algorithm", "false");
         mRecursive = "true".equals(recursive);
         if (mRecursive) {
             LOG.debug("TreeWalker uses recursive algorithm");
         }
         else {
             LOG.debug("TreeWalker uses iterative algorithm");
         }
     }
@@ -474,146 +424,110 @@ public final class TreeWalker
             processRec(child);
         }
 
         notifyLeave(aAST);
 
         final DetailAST sibling = (DetailAST) aAST.getNextSibling();
         if (sibling != null) {
             processRec(sibling);
         }
     }
 
     /**
      * Notify interested checks that visiting a node.
      * @param aAST the node to notify for
      */
     private void notifyVisit(DetailAST aAST)
     {
         final List<Check> visitors = mTokenToChecks.get(TokenTypes
                 .getTokenName(aAST.getType()));
         if (visitors != null) {
             for (Check c : visitors) {
                 c.visitToken(aAST);
             }
         }
     }
 
     /**
      * Notify interested checks that leaving a node.
      * @param aAST the node to notify for
      */
     private void notifyLeave(DetailAST aAST)
     {
         final List<Check> visitors = mTokenToChecks.get(TokenTypes
                 .getTokenName(aAST.getType()));
         if (visitors != null) {
             for (Check ch : visitors) {
                 ch.leaveToken(aAST);
             }
         }
     }
 
     /**
      * Static helper method to parses a Java source file.
      * @param aContents contains the contents of the file
      * @throws TokenStreamException if lexing failed
      * @throws RecognitionException if parsing failed
      * @return the root of the AST
      */
     public static DetailAST parse(FileContents aContents)
         throws RecognitionException, TokenStreamException
-    {
-        DetailAST rootAST = null;
-
-        try {
-            rootAST = parse(aContents, true, true, true);
-        }
-        catch (final RecognitionException exception) {
-            try {
-                rootAST = parse(aContents, true, true, false);
-            }
-            catch (final RecognitionException exception2) {
-                rootAST = parse(aContents, false, false, false);
-            }
-        }
-        return rootAST;
-    }
-
-    /**
-     * Static helper method to parses a Java source file with a given
-     * lexer class and parser class.
-     * @param aContents contains the contents of the file
-     * @param aSilentlyConsumeErrors flag to output errors to stdout or not
-     * @param aTreatAssertAsKeyword flag to treat 'assert' as a keyowrd
-     * @param aTreatEnumAsKeyword flag to treat 'enum' as a keyowrd
-     * @throws TokenStreamException if lexing failed
-     * @throws RecognitionException if parsing failed
-     * @return the root of the AST
-     */
-    private static DetailAST parse(
-        FileContents aContents,
-        boolean aSilentlyConsumeErrors,
-        boolean aTreatAssertAsKeyword,
-        boolean aTreatEnumAsKeyword)
-        throws RecognitionException, TokenStreamException
     {
         final Reader sar = new StringArrayReader(aContents.getLines());
         final GeneratedJavaLexer lexer = new GeneratedJavaLexer(sar);
         lexer.setFilename(aContents.getFilename());
         lexer.setCommentListener(aContents);
-        lexer.setTreatAssertAsKeyword(aTreatAssertAsKeyword);
-        lexer.setTreatEnumAsKeyword(aTreatEnumAsKeyword);
+        lexer.setTreatAssertAsKeyword(true);
+        lexer.setTreatEnumAsKeyword(true);
 
         final GeneratedJavaRecognizer parser =
-            aSilentlyConsumeErrors
-                ? new SilentJavaRecognizer(lexer)
-                : new GeneratedJavaRecognizer(lexer);
+            new GeneratedJavaRecognizer(lexer);
         parser.setFilename(aContents.getFilename());
         parser.setASTNodeClass(DetailAST.class.getName());
         parser.compilationUnit();
 
         return (DetailAST) parser.getAST();
     }
 
     /** {@inheritDoc} */
     public void process(List<File> aFiles)
     {
         final List<File> javaFiles = filter(aFiles);
 
         for (File element : javaFiles) {
             process(element);
         }
     }
 
     /**
      * @see com.puppycrawl.tools.checkstyle.api.FileSetCheck
      */
     @Override
     public void destroy()
     {
         for (Check c : mAllChecks) {
             c.destroy();
         }
         mCache.destroy();
         super.destroy();
     }
 
     /**
      * @return true if we should use recursive algorithm
      *         for tree processing, false for iterative one.
      */
     private boolean useRecursiveAlgorithm()
     {
         return mRecursive;
     }
 
     /**
      * Processes a node calling interested checks at each node.
      * Uses iterative algorithm.
      * @param aRoot the root of tree for process
      */
     private void processIter(DetailAST aRoot)
     {
         DetailAST curNode = aRoot;
         while (curNode != null) {
             notifyVisit(curNode);
             DetailAST toVisit = (DetailAST) curNode.getFirstChild();
