diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index e9c1e28d3..5f31f90d9 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -131,247 +131,249 @@ public class Checker
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(String[] aFiles)
     {
         int total = 0;
         fireAuditStarted();
 
         // If you move checkPackageHtml() around beware of the caching
         // functionality of checkstyle. Make sure that package.html
         // checks are not skipped because of caching. Otherwise you
         // might e.g. have a package.html file, check all java files
         // without errors, delete package.html and then recheck without
         // errors because the html file is not covered by the cache.
         total += checkPackageHtml(aFiles);
 
         for (int i = 0; i < aFiles.length; i++) {
             total += process(aFiles[i]);
         }
         fireAuditFinished();
         return total;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
      * @param aFileName the name of the file to process
      **/
     private int process(String aFileName)
     {
         // check if already checked and passed the file
         final File f = new File(aFileName);
         final long timestamp = f.lastModified();
         if (mCache.alreadyChecked(aFileName, timestamp)) {
             return 0;
         }
 
         // Create a stripped down version
         final String stripped;
         final String basedir = mConfig.getBasedir();
         if ((basedir == null) || !aFileName.startsWith(basedir)) {
             stripped = aFileName;
         }
         else {
             // making the assumption that there is text after basedir
             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;
             stripped = aFileName.substring(basedir.length() + skipSep);
         }
 
-        LineText[] errors;
+        LocalizedMessage[] errors;
         try {
             fireFileStarted(stripped);
             final String[] lines = getLines(aFileName);
             try {
                 // try the 1.4 grammar first, this will succeed for
                 // all code that compiles without any warnings in JDK 1.4,
                 // that should cover most cases
                 VerifierSingleton.getInstance().clearMessages();
                 VerifierSingleton.getInstance().setLines(lines);
                 final Reader sar = new StringArrayReader(lines);
                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJava14Recognizer jr =
                     new SilentJava14Recognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             catch (RecognitionException re) {
                 // Parsing might have failed because the checked
                 // file contains "assert" as an identifier. Retry with a
                 // grammar that treats "assert" as an identifier
                 // and not as a keyword
 
                 // Arghh - the pain - duplicate code!
                 VerifierSingleton.getInstance().clearMessages();
                 VerifierSingleton.getInstance().setLines(lines);
                 final Reader sar = new StringArrayReader(lines);
                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJavaRecognizer jr =
                     new GeneratedJavaRecognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             errors = VerifierSingleton.getInstance().getMessages();
         }
         catch (FileNotFoundException fnfe) {
-            errors = new LineText[] {new LineText(0, "File not found!")};
+            errors = new LocalizedMessage[] {
+                new LocalizedMessage(0, "general.fileNotFound", null)};
         }
         catch (IOException ioe) {
-            errors = new LineText[] {
-                new LineText(0, "Got an IOException -" + ioe.getMessage())};
+            errors = new LocalizedMessage[] {
+                new LocalizedMessage(0, "general.exception",
+                                     new String[] {ioe.getMessage()})};
         }
         catch (RecognitionException re) {
-            errors = new LineText[] {
-                new LineText(0,
-                             "Got a RecognitionException -" + re.getMessage())};
+            errors = new LocalizedMessage[] {
+                new LocalizedMessage(0, "general.exception",
+                                     new String[] {re.getMessage()})};
         }
         catch (TokenStreamException te) {
-            errors = new LineText[] {
-                new LineText(0,
-                             "Got a TokenStreamException -" + te.getMessage())};
+            errors = new LocalizedMessage[] {
+                new LocalizedMessage(0, "general.exception",
+                                     new String[] {te.getMessage()})};
         }
 
         if (errors.length == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(stripped, errors);
         }
 
         fireFileFinished(stripped);
         return errors.length;
     }
 
     /**
      * Checks for a package.html file for all java files in parameter list.
      * @param aFiles the filenames of the java files to check
      * @return the number of errors found
      */
     private int checkPackageHtml(String[] aFiles)
     {
         if (!mConfig.isRequirePackageHtml()) {
             return 0;
         }
 
         int packageHtmlErrors = 0;
         final HashSet checkedPackages = new HashSet();
         for (int i = 0; i < aFiles.length; i++) {
             final File file = new File(aFiles[i]);
             final File packageDir = file.getParentFile();
             if (!checkedPackages.contains(packageDir)) {
                 final File packageDoc =
                     new File(packageDir, "package.html");
                 final String docFile = packageDoc.toString();
                 fireFileStarted(docFile);
                 if (!packageDoc.exists()) {
-                    final LineText error =
-                        new LineText(0, "missing package documentation file.");
-                    fireErrors(docFile, new LineText[]{error});
+                    final LocalizedMessage error =
+                        new LocalizedMessage(0, "javadoc.packageHtml", null);
+                    fireErrors(docFile, new LocalizedMessage[]{error});
                     packageHtmlErrors++;
                 }
                 fireFileFinished(docFile);
                 checkedPackages.add(packageDir);
             }
         }
         return packageHtmlErrors;
     }
 
 
     /**
      * Loads the contents of a file in a String array.
      * @return the lines in the file
      * @param aFileName the name of the file to load
      * @throws IOException error occurred
      **/
     private String[] getLines(String aFileName)
         throws IOException
     {
         final LineNumberReader lnr =
             new LineNumberReader(new FileReader(aFileName));
         final ArrayList lines = new ArrayList();
         while (true) {
             final String l = lnr.readLine();
             if (l == null) {
                 break;
             }
             lines.add(l);
         }
 
         return (String[]) lines.toArray(new String[0]);
     }
 
     /** notify all listeners about the audit start */
     protected void fireAuditStarted()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.auditStarted(evt);
         }
     }
 
     /** notify all listeners about the audit end */
     protected void fireAuditFinished()
     {
         final AuditEvent evt = new AuditEvent(this);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.auditFinished(evt);
         }
     }
 
     /**
      * notify all listeners about the beginning of a file audit
      * @param aFileName the file to be audited
      */
     protected void fireFileStarted(String aFileName)
     {
         final AuditEvent evt = new AuditEvent(this, aFileName);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.fileStarted(evt);
         }
     }
 
     /**
      * notify all listeners about the end of a file audit
      * @param aFileName the audited file
      */
     protected void fireFileFinished(String aFileName)
     {
         final AuditEvent evt = new AuditEvent(this, aFileName);
         final Iterator it = mListeners.iterator();
         while (it.hasNext()) {
             final AuditListener listener = (AuditListener) it.next();
             listener.fileFinished(evt);
         }
     }
 
     /**
      * notify all listeners about the errors in a file.
      * @param aFileName the audited file
      * @param aErrors the audit errors from the file
      */
-    protected void fireErrors(String aFileName, LineText[] aErrors)
+    protected void fireErrors(String aFileName, LocalizedMessage[] aErrors)
     {
         for (int i = 0; i < aErrors.length; i++) {
             final AuditEvent evt =
                 new AuditEvent(this, aFileName,
                                aErrors[i].getLineNo(),
                                aErrors[i].getColumnNo(),
-                               aErrors[i].getText());
+                               aErrors[i].getMessage());
             final Iterator it = mListeners.iterator();
             while (it.hasNext()) {
                 final AuditListener listener = (AuditListener) it.next();
                 listener.addError(evt);
             }
         }
     }
 }
