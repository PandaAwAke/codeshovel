diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java
index 167b24129..904598bc6 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java
@@ -40,109 +40,109 @@ import java.util.Arrays;
  *    &lt;property name="ignoreNumbers" value="0, 1, 1.5, 2"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Rick Giles
  * @author Lars Kï¿½hne
  */
 public class MagicNumberCheck extends Check
 {
     /**
      * The token types that are allowed in the AST path from the
      * number literal to the enclosing constant definition.
      */
     private static final int[] ALLOWED_PATH_TOKENTYPES = {
         TokenTypes.ASSIGN,
         TokenTypes.ARRAY_INIT,
         TokenTypes.EXPR,
         TokenTypes.UNARY_PLUS,
         TokenTypes.UNARY_MINUS,
         TokenTypes.TYPECAST,
         TokenTypes.ELIST,
         TokenTypes.LITERAL_NEW,
         TokenTypes.METHOD_CALL,
         TokenTypes.STAR,
     };
 
     static {
         Arrays.sort(ALLOWED_PATH_TOKENTYPES);
     }
 
     /** the numbers to ignore in the check, sorted */
     private double[] mIgnoreNumbers = {-1, 0, 1, 2};
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.NUM_DOUBLE,
             TokenTypes.NUM_FLOAT,
             TokenTypes.NUM_INT,
             TokenTypes.NUM_LONG,
         };
     }
 
     /** @see com.puppycrawl.tools.checkstyle.api.Check */
     public void visitToken(DetailAST aAST)
     {
         if (inIgnoreList(aAST)) {
             return;
         }
 
-        DetailAST constantDefAST = findContainingConstantDef(aAST);
+        final DetailAST constantDefAST = findContainingConstantDef(aAST);
 
         if (constantDefAST == null) {
             reportMagicNumber(aAST);
         }
         else {
             DetailAST ast = aAST.getParent();
             while (ast != constantDefAST) {
-                int type = ast.getType();
+                final int type = ast.getType();
                 if (Arrays.binarySearch(ALLOWED_PATH_TOKENTYPES, type) < 0) {
                     reportMagicNumber(aAST);
                     break;
                 }
 
                 ast = ast.getParent();
             }
         }
     }
 
     /**
      * Finds the constant definition that contains aAST.
      * @param aAST the AST
      * @return the constant def or null if aAST is not
      * contained in a constant definition
      */
     private DetailAST findContainingConstantDef(DetailAST aAST)
     {
         DetailAST varDefAST = aAST;
         while (varDefAST != null
                 && varDefAST.getType() != TokenTypes.VARIABLE_DEF)
         {
             varDefAST = varDefAST.getParent();
         }
 
         // no containing variable definition?
         if (varDefAST == null) {
             return null;
         }
 
         // implicit constant?
         if (ScopeUtils.inInterfaceBlock(varDefAST)) {
             return varDefAST;
         }
 
         // explicit constant
         final DetailAST modifiersAST =
                 varDefAST.findFirstToken(TokenTypes.MODIFIERS);
         if (modifiersAST.branchContains(TokenTypes.FINAL)) {
             return varDefAST;
         }
 
         return null;
     }
 
     /**
      * Reports aAST as a magic number, includes unary operators as needed.
      * @param aAST the AST node that contains the number to report
      */
     private void reportMagicNumber(DetailAST aAST)
