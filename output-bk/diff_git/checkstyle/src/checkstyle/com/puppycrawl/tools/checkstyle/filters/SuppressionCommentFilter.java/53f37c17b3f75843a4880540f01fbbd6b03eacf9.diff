diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
index 9f74fa3ae..a9df5a057 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
@@ -373,100 +373,105 @@ public class SuppressionCommentFilter
         }
     }
 
     /**
      * Set the format for a message.
      * @param aFormat a <code>String</code> value
      * @throws ConversionException unable to parse aFormat
      */
     public void setMessageFormat(String aFormat)
         throws ConversionException
     {
         // check that aFormat parses
         try {
             Utils.getPattern(aFormat);
         }
         catch (PatternSyntaxException e) {
             throw new ConversionException("unable to parse " + aFormat, e);
         }
         mMessageFormat = aFormat;
     }
 
 
     /**
      * Set whether to look in C++ comments.
      * @param aCheckCPP <code>true</code> if C++ comments are checked.
      */
     public void setCheckCPP(boolean aCheckCPP)
     {
         mCheckCPP = aCheckCPP;
     }
 
     /**
      * Set whether to look in C comments.
      * @param aCheckC <code>true</code> if C comments are checked.
      */
     public void setCheckC(boolean aCheckC)
     {
         mCheckC = aCheckC;
     }
 
     /** @see Filter */
     public boolean accept(AuditEvent aEvent)
     {
         if (aEvent.getLocalizedMessage() == null) {
             return true;        // A special event.
         }
 
         // Lazy update. If the first event for the current file, update file
         // contents and tag suppressions
         final FileContents currentContents = FileContentsHolder.getContents();
+        if (currentContents == null) {
+            // we have no contents, so we can not filter.
+            // TODO: perhaps we should notify user somehow?
+            return true;
+        }
         if (getFileContents() != currentContents) {
             setFileContents(currentContents);
             tagSuppressions();
         }
         final Tag matchTag = findNearestMatch(aEvent);
         if ((matchTag != null) && !matchTag.isOn()) {
             return false;
         }
         return true;
     }
 
     /**
      * Finds the nearest comment text tag that matches an audit event.
      * The nearest tag is before the line and column of the event.
      * @param aEvent the <code>AuditEvent</code> to match.
      * @return The <code>Tag</code> nearest aEvent.
      */
     private Tag findNearestMatch(AuditEvent aEvent)
     {
         Tag result = null;
         // TODO: try binary search if sequential search becomes a performance
         // problem.
         for (Iterator iter = mTags.iterator(); iter.hasNext();) {
             final Tag tag = (Tag) iter.next();
             if ((tag.getLine() > aEvent.getLine())
                 || ((tag.getLine() == aEvent.getLine())
                     && (tag.getColumn() > aEvent.getColumn())))
             {
                 break;
             }
             if (tag.isMatch(aEvent)) {
                 result = tag;
             }
         };
         return result;
     }
 
     /**
      * Collects all the suppression tags for all comments into a list and
      * sorts the list.
      */
     private void tagSuppressions()
     {
         mTags.clear();
         final FileContents contents = getFileContents();
         if (mCheckCPP) {
             tagSuppressions(contents.getCppComments().values());
         }
         if (mCheckC) {
             final Collection cComments = contents.getCComments().values();
