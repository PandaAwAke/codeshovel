diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
index c9e4d1aeb..e68f17508 100755
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
@@ -18,177 +18,188 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 /*
  * %W% %E%
  *
  * Copyright 1997, 1998 Sun Microsystems, Inc. All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or
  * without modification, are permitted provided that the following
  * conditions are met:
  *
  * - Redistributions of source code must retain the above copyright
  *   notice, this list of conditions and the following disclaimer.
  *
  * - Redistribution in binary form must reproduce the above
  *   copyright notice, this list of conditions and the following
  *   disclaimer in the documentation and/or other materials
  *   provided with the distribution.
  *
  * Neither the name of Sun Microsystems, Inc. or the names of
  * contributors may be used to endorse or promote products derived
  * from this software without specific prior written permission.
  *
  * This software is provided "AS IS," without a warranty of any
  * kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND
  * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
  * EXCLUDED. SUN AND ITS LICENSORS SHALL NOT BE LIABLE FOR ANY
  * DAMAGES OR LIABILITIES SUFFERED BY LICENSEE AS A RESULT OF OR
  * RELATING TO USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE OR
  * ITS DERIVATIVES. IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE
  * FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR DIRECT, INDIRECT,
  * SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER
  * CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF
  * THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS
  * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
  *
  * You acknowledge that this software is not designed, licensed or
  * intended for use in the design, construction, operation or
  * maintenance of any nuclear facility.
  */
 
 package com.puppycrawl.tools.checkstyle.gui;
 
 import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.Graphics;
 import java.awt.event.ActionEvent;
 import java.awt.event.MouseEvent;
 import java.util.EventObject;
+import java.util.List;
+
 import javax.swing.Action;
 import javax.swing.AbstractAction;
 import javax.swing.JTable;
+import javax.swing.JTextArea;
 import javax.swing.JTree;
 import javax.swing.KeyStroke;
 import javax.swing.ListSelectionModel;
 import javax.swing.LookAndFeel;
 import javax.swing.UIManager;
 import javax.swing.event.ListSelectionEvent;
 import javax.swing.event.ListSelectionListener;
 import javax.swing.table.TableCellEditor;
 import javax.swing.table.TableCellRenderer;
 import javax.swing.tree.DefaultTreeCellRenderer;
 import javax.swing.tree.DefaultTreeSelectionModel;
 import javax.swing.tree.TreeCellRenderer;
 import javax.swing.tree.TreeModel;
 import javax.swing.tree.TreePath;
 
+import com.puppycrawl.tools.checkstyle.api.DetailAST;
+
 /**
  * This example shows how to create a simple JTreeTable component,
  * by using a JTree as a renderer (and editor) for the cells in a
  * particular column in the JTable.
  *
  * <a href="http://java.sun.com/products/jfc/tsc/articles/treetable1/index.html">Original&nbsp;Source&nbsp;Location</a>
  *
  * @author Philip Milne
  * @author Scott Violet
  * @author Lars Kï¿½hne
  */
 public class JTreeTable extends JTable
 {
     /** For Serialisation that will never happen. */
     private static final long serialVersionUID = -8493693409423365387L;
     /** A subclass of JTree. */
     protected TreeTableCellRenderer tree;
+    private JTextArea editor;
+    private List<Integer> lines2position;
 
     public JTreeTable(TreeTableModel treeTableModel)
     {
         super();
 
         // Create the tree. It will be used as a renderer and editor.
         tree = new TreeTableCellRenderer(treeTableModel);
 
         // Install a tableModel representing the visible rows in the tree.
         super.setModel(new TreeTableModelAdapter(treeTableModel, tree));
 
         // Force the JTable and JTree to share their row selection models.
         final ListToTreeSelectionModelWrapper selectionWrapper = new
                 ListToTreeSelectionModelWrapper();
         tree.setSelectionModel(selectionWrapper);
         setSelectionModel(selectionWrapper.getListSelectionModel());
 
         // Install the tree editor renderer and editor.
         setDefaultRenderer(TreeTableModel.class, tree);
         setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
 
         // No grid.
         setShowGrid(false);
 
         // No intercell spacing
         setIntercellSpacing(new Dimension(0, 0));
 
         // And update the height of the trees row to match that of
         // the table.
         if (tree.getRowHeight() < 1) {
             // Metal looks better like this.
             setRowHeight(getRowHeight());
         }
 
         final Action expand = new AbstractAction() {
                 /**
              *
              */
             private static final long serialVersionUID = -5859674518660156121L;
 
                 public void actionPerformed(ActionEvent e) {
                     final TreePath selected = tree.getSelectionPath();
+
+                    DetailAST ast = (DetailAST) selected.getLastPathComponent();
+                    new CodeSelector(ast, editor, lines2position).select();
+
                     if (tree.isExpanded(selected)) {
                         tree.collapsePath(selected);
                     }
                     else {
                         tree.expandPath(selected);
                     }
                     tree.setSelectionPath(selected);
                 }
             };
         final KeyStroke stroke = KeyStroke.getKeyStroke("ENTER");
         final String command = "expand/collapse";
         getInputMap().put(stroke, command);
         getActionMap().put(command, expand);
     }
 
     /**
      * Overridden to message super and forward the method to the tree.
      * Since the tree is not actually in the component hierarchy it will
      * never receive this unless we forward it in this manner.
      */
     @Override
     public void updateUI()
     {
         super.updateUI();
         if (tree != null) {
             tree.updateUI();
         }
         // Use the tree's default foreground and background colors in the
         // table.
         LookAndFeel.installColorsAndFont(this, "Tree.background",
                 "Tree.foreground", "Tree.font");
     }
 
     /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to
      * paint the editor. The UI currently uses different techniques to
      * paint the renderers and editors and overriding setBounds() below
      * is not the right thing to do for an editor. Returning -1 for the
      * editing row in this case, ensures the editor is never painted.
      */
     @Override
     public int getEditingRow()
     {
         final Class<?> editingClass = getColumnClass(editingColumn);
         return (editingClass == TreeTableModel.class) ? -1 : editingRow;
     }
 
     /**
      * Overridden to pass the new rowHeight to the tree.
      */
     @Override
@@ -433,51 +444,61 @@ public class JTreeTable extends JTable
         {
             return new ListSelectionHandler();
         }
 
         /**
          * If <code>updatingListSelectionModel</code> is false, this will
          * reset the selected paths from the selected rows in the list
          * selection model.
          */
         protected void updateSelectedPathsFromSelectedRows()
         {
             if (!updatingListSelectionModel) {
                 updatingListSelectionModel = true;
                 try {
                     // This is way expensive, ListSelectionModel needs an
                     // enumerator for iterating.
                     final int min = listSelectionModel.getMinSelectionIndex();
                     final int max = listSelectionModel.getMaxSelectionIndex();
 
                     clearSelection();
                     if ((min != -1) && (max != -1)) {
                         for (int counter = min; counter <= max; counter++) {
                             if (listSelectionModel.isSelectedIndex(counter)) {
                                 final TreePath selPath = tree.getPathForRow
                                         (counter);
 
                                 if (selPath != null) {
                                     addSelectionPath(selPath);
                                 }
                             }
                         }
                     }
                 } finally {
                     updatingListSelectionModel = false;
                 }
             }
         }
 
         /**
          * Class responsible for calling updateSelectedPathsFromSelectedRows
          * when the selection of the list changse.
          */
         class ListSelectionHandler implements ListSelectionListener
         {
             public void valueChanged(ListSelectionEvent e)
             {
                 updateSelectedPathsFromSelectedRows();
             }
         }
     }
+
+    public void setEditor(JTextArea mJTextArea)
+    {
+         this.editor = mJTextArea;
+    }
+
+    public void setLinePositionMap(List<Integer> lines2position)
+    {
+        this.lines2position = lines2position;
+    }
 }
