diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java
index 17867341a..89f5feba7 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java
@@ -30,80 +30,81 @@ import com.puppycrawl.tools.checkstyle.checks.AbstractFormatCheck;
  * <p>
  * Rationale: Abstract classes are convenience base class
  * implementations of interfaces, not types as such. As such
  * they should be named to indicate this.
  * </p>
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  */
 public final class AbstractClassNameCheck extends AbstractFormatCheck
 {
     /** Defualt format for abstract class names */
     private static final String DEFAULT_FORMAT = "^Abstract.*$|^.*Factory$";
 
     /** Creates new instance of the check. */
     public AbstractClassNameCheck()
     {
         super(DEFAULT_FORMAT);
     }
 
     /** {@inheritDoc} */
     public int[] getDefaultTokens()
     {
         return new int[]{TokenTypes.CLASS_DEF};
     }
 
     /** {@inheritDoc} */
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     /** {@inheritDoc} */
     public void visitToken(DetailAST aAST)
     {
         switch (aAST.getType()) {
         case TokenTypes.CLASS_DEF:
             visitClassDef(aAST);
             break;
         default:
             throw new IllegalStateException(aAST.toString());
         }
     }
 
     /**
      * Checks class definition.
      * @param aAST class definition for check.
      */
     private void visitClassDef(DetailAST aAST)
     {
         if (isAbstract(aAST)) {
-            String className = aAST.findFirstToken(TokenTypes.IDENT).getText();
+            final String className =
+                aAST.findFirstToken(TokenTypes.IDENT).getText();
 
             if (!isMatchingClassName(className)) {
                 log(aAST.getLineNo(), aAST.getColumnNo(),
                     "illegal.abstract.class.name", className, getFormat());
             }
         }
     }
 
     /**
      * @param aAST class definition for check.
      * @return true if a given class declared as abstract.
      */
     private boolean isAbstract(DetailAST aAST)
     {
         final DetailAST abstractAST = aAST.findFirstToken(TokenTypes.MODIFIERS)
             .findFirstToken(TokenTypes.ABSTRACT);
 
         return abstractAST != null;
     }
 
     /**
      * @param aClassName class name for check.
      * @return true if class name matches format of abstract class names.
      */
     private boolean isMatchingClassName(String aClassName)
     {
         return getRegexp().matcher(aClassName).find();
     }
 }
