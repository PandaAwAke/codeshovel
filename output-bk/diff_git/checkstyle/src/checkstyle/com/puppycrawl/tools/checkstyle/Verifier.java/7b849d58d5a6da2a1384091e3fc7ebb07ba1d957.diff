diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
index fc342422b..9ee5deca9 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Verifier.java
@@ -874,101 +874,101 @@ class Verifier
     ////////////////////////////////////////////////////////////////////////////
     // Private methods
     ////////////////////////////////////////////////////////////////////////////
 
     /**
      * Checks if aScope is a part of the Source code where we have
      * to verify correct javadoc.
      * @param aScope a <code>Scope</code> value
      * @return if a Scope is a part of the Source code where we have
      * to verify correct javadoc.
      */
     private boolean inCheckScope(Scope aScope)
     {
         final Scope configScope = mConfig.getJavadocScope();
         boolean retVal = aScope.isIn(configScope);
 
         // Need to handle where the scope of the enclosing type is not
         // in the scope to be checked. For example:
         // class Outer {
         //     public class Inner {
         //     }
         // }
         //
         // If the scope we are checking is "protected", then even though
         // Inner is public, we do not require Javadoc because Outer does
         // not require it.
 
         // to implement this we search up the scope stack
         // that all stack elements are also in configScope
 
         final Iterator scopeIterator = mInScope.iterator();
         while (retVal && scopeIterator.hasNext()) {
             final Scope stackScope = (Scope) scopeIterator.next();
             retVal = stackScope.isIn(configScope);
         }
         return retVal;
     }
 
 
 
     /**
      * Helper method to create a regular expression. Will exit if unable to
      * create the object.
      * @param aPattern the pattern to match
      * @return a created regexp object
      **/
     private static RE createRE(String aPattern)
     {
         RE retVal = null;
         try {
-            retVal = new RE(aPattern);
+            retVal = Utils.getRE(aPattern);
         }
         catch (RESyntaxException e) {
             System.out.println("Failed to initialise regexp expression " +
                                aPattern);
             e.printStackTrace(System.out);
             System.exit(1);
         }
         return retVal;
     }
 
     /**
      * Logs a message to be reported. The column defaults to 0.
      * @param aLineNo the line number associated with the message
      * @param aMsg the message to log
      **/
     private void log(int aLineNo, String aMsg)
     {
         mMessages.add(new LineText(aLineNo, aMsg));
     }
 
     /**
      * Logs a message to be reported.
      * @param aLineNo the line number associated with the message
      * @param aColNo the column number associated with the message
      * @param aMsg the message to log
      **/
     private void log(int aLineNo, int aColNo, String aMsg)
     {
         // message must account for tabs before the error column
         int colNo = Utils.lengthExpandedTabs(
             mLines[aLineNo - 1], aColNo, mConfig.getTabWidth());
         mMessages.add(new LineText(aLineNo, colNo + 1, aMsg));
     }
 
 
     /**
      * Checks that a variable confirms to a specified regular expression. Logs
      * a message if it does not.
      * @param aVar the variable to check
      * @param aRegexp the regexp to match against
      * @param aPattern text representation of regexp
      **/
     private void checkVariable(MyVariable aVar, RE aRegexp, String aPattern)
     {
         if (!aRegexp.match(aVar.getText())) {
             log(aVar.getLineNo(), aVar.getColumnNo() - 1,
                 "variable '" + aVar.getText() +
                 "' must match pattern '" + aPattern + "'.");
         }
     }
@@ -1185,115 +1185,117 @@ class Verifier
             if (!tag.isThrowsTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getArg1();
             boolean found = foundThrows.contains(documentedEx);
             final ListIterator throwIt = aThrows.listIterator();
             while (!found && throwIt.hasNext()) {
                 final LineText t = (LineText) throwIt.next();
                 if (t.getText().equals(documentedEx)) {
                     found = true;
                     throwIt.remove();
                     foundThrows.add(documentedEx);
                 }
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(),
                     "Unused @throws tag for '" + tag.getArg1() + "'.");
             }
         }
 
         // Now dump out all throws without tags
         final ListIterator throwIt = aThrows.listIterator();
         while (throwIt.hasNext()) {
             final LineText t = (LineText) throwIt.next();
             log(t.getLineNo(), t.getColumnNo() - 1,
                 "Expected @throws tag for '" + t.getText() + "'.");
         }
     }
 
 
     /** checks that a file contains a valid header **/
     private void checkHeader()
     {
         if (mConfig.getHeaderLines().length > mLines.length) {
             log(1, "Missing a header - not enough lines in file.");
         }
         else {
             for (int i = 0; i < mConfig.getHeaderLines().length; i++) {
                 // skip lines we are meant to ignore
                 if (mConfig.isHeaderIgnoreLineNo(i + 1)) {
                     continue;
                 }
 
                 final String headerLine = mConfig.getHeaderLines()[i];
-
-                // TODO: RE creation should be cached to avoid
-                // re-compilation when multiple files are checked. Will wait
-                // until this is shown to be a performance problem. Really
-                // should create a factory method for creating RE objects.
-                final boolean match =
-                    mConfig.getHeaderLinesRegexp() ?
-                    createRE(headerLine).match(mLines[i]) :
-                    headerLine.equals(mLines[i]);
-
-                if (!match) {
+                try {
+                    final boolean match =
+                        mConfig.getHeaderLinesRegexp()
+                        ? Utils.getRE(headerLine).match(mLines[i])
+                        : headerLine.equals(mLines[i]);
+    
+                    if (!match) {
+                        log(i + 1,
+                            "Line does not match expected header line of '" +
+                            mConfig.getHeaderLines()[i] + "'.");
+                        break; // stop checking
+                    }
+                }
+                catch (RESyntaxException e) {
                     log(i + 1,
-                        "Line does not match expected header line of '" +
-                        mConfig.getHeaderLines()[i] + "'.");
-                    break; // stop checking
+                        "Unable to parse regular expression '"
+                        + headerLine + "'.");
                 }
             }
         }
     }
 
     /**
      * checks if the order of modifiers follows the suggestions
      * in the JLS and logs an error message accordingly.
      *
      * @param aModSet the set of modifiers
      */
     private void checkModOrder(MyModifierSet aModSet)
     {
         final MyCommonAST error = aModSet.checkOrderSuggestedByJLS();
         if (error != null) {
             log(error.getLineNo(), error.getColumnNo(),
                 "'" + error.getText()
                 + "' modifier out of order with the JLS suggestions.");
         }
     }
 
     /**
      * @return the class name from a fully qualified name
      * @param aType the fully qualified name
      */
     private String basename(String aType)
     {
         final int i = aType.lastIndexOf(".");
         return (i == -1) ? aType : aType.substring(i + 1);
     }
 
     /** Check the imports that are unused or unrequired. **/
     private void checkImports()
     {
         if (mConfig.isIgnoreImports()) {
             return;
         }
 
         // Loop checking imports
         final Iterator it = mImports.iterator();
         while (it.hasNext()) {
             final LineText imp = (LineText) it.next();
 
             if (fromPackage(imp.getText(), "java.lang")) {
                 log(imp.getLineNo(),
                     "Redundant import from the java.lang package.");
             }
             else if (fromPackage(imp.getText(), mPkgName)) {
                 log(imp.getLineNo(), "Redundant import from the same package.");
             }
