diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
index d26cb3469..58074f0d7 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java
@@ -182,119 +182,124 @@ public class Checker
     public void addListener(AuditListener aListener)
     {
         mListeners.add(aListener);
     }
 
     /**
      * Processes a set of files.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param aFiles the list of files to be audited.
      * @return the total number of errors found
      * @see #destroy()
      */
     public int process(String[] aFiles)
     {
         int total = 0;
         fireAuditStarted();
 
         // If you move checkPackageHtml() around beware of the caching
         // functionality of checkstyle. Make sure that package.html
         // checks are not skipped because of caching. Otherwise you
         // might e.g. have a package.html file, check all java files
         // without errors, delete package.html and then recheck without
         // errors because the html file is not covered by the cache.
         total += checkPackageHtml(aFiles);
 
         for (int i = 0; i < aFiles.length; i++) {
             total += process(aFiles[i]);
         }
         fireAuditFinished();
         return total;
     }
 
     /**
      * Processes a specified file and prints out all errors found.
      * @return the number of errors found
      * @param aFileName the name of the file to process
      **/
     private int process(String aFileName)
     {
         final File f = new File(aFileName);
         final long timestamp = f.lastModified();
         if (mCache.alreadyChecked(aFileName, timestamp)) {
             return 0;
         }
 
         LineText[] errors;
         try {
             fireFileStarted(aFileName);
             final String[] lines = getLines(aFileName);
-            final Reader sar = new StringArrayReader(lines);
             VerifierSingleton.getInstance().clearMessages();
             VerifierSingleton.getInstance().setLines(lines);
             try {
+                // try the 1.4 grammar first, this will succeed for
+                // all code that compiles without any warnings in JDK 1.4,
+                // that should cover most cases
+
+                final Reader sar = new StringArrayReader(lines);
                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJava14Recognizer jr =
                     new SilentJava14Recognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             catch (RecognitionException re) {
                 // Parsing might have failed because the checked
-                // filecontains "assert" statement. Retry with a
+                // file contains "assert" as an identifier. Retry with a
                 // grammar that treats "assert" as an identifier
                 // and not as a keyword
 
                 // Arghh - the pain - duplicate code!
+                final Reader sar = new StringArrayReader(lines);
                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);
                 jl.setFilename(aFileName);
                 final GeneratedJavaRecognizer jr =
                     new GeneratedJavaRecognizer(jl);
                 jr.setFilename(aFileName);
                 jr.setASTNodeClass(MyCommonAST.class.getName());
                 jr.compilationUnit();
             }
             errors = VerifierSingleton.getInstance().getMessages();
         }
         catch (FileNotFoundException fnfe) {
             errors = new LineText[] {new LineText(0, "File not found!")};
         }
         catch (IOException ioe) {
             errors = new LineText[] {
                 new LineText(0, "Got an IOException -" + ioe.getMessage())};
         }
         catch (RecognitionException re) {
             errors = new LineText[] {
                 new LineText(0,
                              "Got a RecognitionException -" + re.getMessage())};
         }
         catch (TokenStreamException te) {
             errors = new LineText[] {
                 new LineText(0,
                              "Got a TokenStreamException -" + te.getMessage())};
         }
 
         if (errors.length == 0) {
             mCache.checkedOk(aFileName, timestamp);
         }
         else {
             fireErrors(aFileName, errors);
         }
 
         fireFileFinished(aFileName);
         return errors.length;
     }
 
     /**
      * Checks for a package.html file for all java files in parameter list.
      * @param aFiles the filenames of the java files to check
      * @return the number of errors found
      */
     private int checkPackageHtml(String[] aFiles)
     {
         if (!mConfig.isRequirePackageHtml()) {
             return 0;
         }
 
