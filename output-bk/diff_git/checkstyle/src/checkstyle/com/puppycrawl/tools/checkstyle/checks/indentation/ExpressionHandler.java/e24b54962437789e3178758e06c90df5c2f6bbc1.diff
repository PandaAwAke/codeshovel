diff --git a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
index 7fdac66ab..baea8f03f 100644
--- a/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
+++ b/src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/ExpressionHandler.java
@@ -420,101 +420,101 @@ public abstract class ExpressionHandler
         boolean aFirstLineMatches, boolean aAllowNesting)
     {
         Arrays.sort(aTokenTypes);
         for (DetailAST child = (DetailAST) aParent.getFirstChild();
                 child != null;
                 child = (DetailAST) child.getNextSibling())
         {
             if (Arrays.binarySearch(aTokenTypes, child.getType()) >= 0) {
                 checkExpressionSubtree(child, aStartLevel,
                     aFirstLineMatches, aAllowNesting);
             }
         }
     }
 
     /**
      * Check the indentation level for an expression subtree.
      *
      * @param aTree               the expression subtree to check
      * @param aLevel              the indentation level
      * @param aFirstLineMatches   whether or not the first line has to match
      * @param aAllowNesting       whether or not subtree nesting is allowed
      */
     protected final void checkExpressionSubtree(
         DetailAST aTree,
         int aLevel,
         boolean aFirstLineMatches,
         boolean aAllowNesting
     )
     {
         LineSet subtreeLines = new LineSet();
         int firstLine = getFirstLine(Integer.MAX_VALUE, aTree);
         if (aFirstLineMatches && !aAllowNesting) {
             subtreeLines.addLineAndCol(new Integer(firstLine),
                 getLineStart(
                     mIndentCheck.getLines()[firstLine - 1]));
         }
         findSubtreeLines(subtreeLines, aTree, aAllowNesting);
 
         checkLinesIndent(subtreeLines, aLevel, aFirstLineMatches,
                          firstLine);
     }
 
     /**
      * Get the first line for a given expression.
      *
      * @param aStartLine   the line we are starting from
      * @param aTree        the expression to find the first line for
      *
      * @return the first line of the expression
      */
-    private int getFirstLine(int aStartLine, DetailAST aTree)
+    protected final int getFirstLine(int aStartLine, DetailAST aTree)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
         // the interface methods... I should ask about this
 
         int currLine = aTree.getLineNo();
         if (currLine < aStartLine) {
             aStartLine = currLine;
         }
 
         // check children
         for (DetailAST node = (DetailAST) aTree.getFirstChild();
             node != null;
             node = (DetailAST) node.getNextSibling())
         {
             aStartLine = getFirstLine(aStartLine, node);
         }
 
         return aStartLine;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param aAst   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     protected final int expandedTabsColumnNo(DetailAST aAst)
     {
         String line =
             mIndentCheck.getLines()[aAst.getLineNo() - 1];
 
         return Utils.lengthExpandedTabs(line, aAst.getColumnNo(),
             mIndentCheck.getIndentationTabWidth());
     }
 
     /**
      * Find the set of lines for a given subtree.
      *
      * @param aLines          the set of lines to add to
      * @param aTree           the subtree to examine
      * @param aAllowNesting   whether or not to allow nested subtrees
      */
     protected final void findSubtreeLines(LineSet aLines, DetailAST aTree,
         boolean aAllowNesting)
     {
         // find line for this node
         // TODO: getLineNo should probably not return < 0, but it is for
