diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
index 897b08577..73ef8f1d1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
@@ -330,113 +330,118 @@ public class SuppressWarningsHolder
             }
         }
         return targetAST;
     }
 
     /**
      * Returns the n'th child of an AST node.
      * @param ast the AST node to get the child of
      * @param index the index of the child to get
      * @return the n'th child of the given AST node, or {@code null} if none
      */
     private static DetailAST getNthChild(DetailAST ast, int index) {
         DetailAST child = ast.getFirstChild();
         if (child != null) {
             for (int i = 0; i < index && child != null; ++i) {
                 child = child.getNextSibling();
             }
         }
         return child;
     }
 
     /**
      * Returns the Java identifier represented by an AST.
      * @param ast an AST node for an IDENT or DOT
      * @return the Java identifier represented by the given AST subtree
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getIdentifier(DetailAST ast) {
         if (ast != null) {
             if (ast.getType() == TokenTypes.IDENT) {
                 return ast.getText();
             }
             else if (ast.getType() == TokenTypes.DOT) {
                 return getIdentifier(ast.getFirstChild()) + "."
                     + getIdentifier(ast.getLastChild());
             }
         }
         throw new IllegalArgumentException("Identifier AST expected: " + ast);
     }
 
     /**
      * Returns the literal string expression represented by an AST.
      * @param ast an AST node for an EXPR
      * @return the Java string represented by the given AST expression
      *         or empty string if expression is too complex
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getStringExpr(DetailAST ast) {
         if (ast != null && ast.getType() == TokenTypes.EXPR) {
             final DetailAST firstChild = ast.getFirstChild();
+            String expr = "";
+
             switch (firstChild.getType()) {
                 case TokenTypes.STRING_LITERAL:
                     // NOTE: escaped characters are not unescaped
                     final String quotedText = firstChild.getText();
-                    return quotedText.substring(1, quotedText.length() - 1);
+                    expr = quotedText.substring(1, quotedText.length() - 1);
+                    break;
                 case TokenTypes.IDENT:
-                    return firstChild.getText();
+                    expr = firstChild.getText();
+                    break;
                 case TokenTypes.DOT:
-                    return firstChild.getLastChild().getText();
+                    expr = firstChild.getLastChild().getText();
+                    break;
                 default:
                     // annotations with complex expressions cannot suppress warnings
-                    return "";
             }
+            return expr;
         }
         throw new IllegalArgumentException("Expression AST expected: " + ast);
     }
 
     /**
      * Returns the annotation values represented by an AST.
      * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT
      * @return the list of Java string represented by the given AST for an
      *         expression or annotation array initializer
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static List<String> getAnnotationValues(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.EXPR:
                 return ImmutableList.of(getStringExpr(ast));
 
             case TokenTypes.ANNOTATION_ARRAY_INIT:
                 final List<String> valueList = Lists.newLinkedList();
                 DetailAST childAST = ast.getFirstChild();
                 while (childAST != null) {
                     if (childAST.getType() == TokenTypes.EXPR) {
                         valueList.add(getStringExpr(childAST));
                     }
                     childAST = childAST.getNextSibling();
                 }
                 return valueList;
 
             default:
         }
         throw new IllegalArgumentException(
             "Expression or annotation array initializer AST expected: " + ast);
     }
 
     /** Records a particular suppression for a region of a file */
     private static class Entry {
         /** The source name of the suppressed check */
         private final String checkName;
         /** The suppression region for the check - first line */
         private final int firstLine;
         /** The suppression region for the check - first column */
         private final int firstColumn;
         /** The suppression region for the check - last line */
         private final int lastLine;
         /** The suppression region for the check - last column */
         private final int lastColumn;
 
         /**
          * Constructs a new suppression region entry.
          * @param checkName the source name of the suppressed check
          * @param firstLine the first line of the suppression region
