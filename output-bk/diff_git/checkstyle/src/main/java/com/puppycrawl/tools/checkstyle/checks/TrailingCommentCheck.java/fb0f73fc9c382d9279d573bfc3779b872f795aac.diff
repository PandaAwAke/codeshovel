diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
index 390359ad9..781322682 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
@@ -147,68 +147,70 @@ public class TrailingCommentCheck extends AbstractFormatCheck {
     public void visitToken(DetailAST ast) {
         throw new IllegalStateException("visitToken() shouldn't be called.");
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         final Pattern blankLinePattern = getRegexp();
         final Map<Integer, TextBlock> cppComments = getFileContents()
                 .getCppComments();
         final Map<Integer, List<TextBlock>> cComments = getFileContents()
                 .getCComments();
         final Set<Integer> lines = Sets.newHashSet();
         lines.addAll(cppComments.keySet());
         lines.addAll(cComments.keySet());
 
         for (Integer lineNo : lines) {
             final String line = getLines()[lineNo - 1];
             String lineBefore;
             TextBlock comment;
             if (cppComments.containsKey(lineNo)) {
                 comment = cppComments.get(lineNo);
                 lineBefore = line.substring(0, comment.getStartColNo());
             }
             else {
                 final List<TextBlock> commentList = cComments.get(lineNo);
                 comment = commentList.get(commentList.size() - 1);
                 lineBefore = line.substring(0, comment.getStartColNo());
                 if (comment.getText().length == 1) {
                     final String lineAfter =
                         line.substring(comment.getEndColNo() + 1).trim();
                     if (!lineAfter.isEmpty()) {
                         // do not check comment which doesn't end line
                         continue;
                     }
                 }
             }
             if (!blankLinePattern.matcher(lineBefore).find()
                 && !isLegalComment(comment)) {
                 log(lineNo.intValue(), MSG_KEY);
             }
         }
     }
 
     /**
      * Checks if given comment is legal (single-line and matches to the
      * pattern).
      * @param comment comment to check.
      * @return true if the comment if legal.
      */
     private boolean isLegalComment(final TextBlock comment) {
-        if (legalComment == null) {
-            return false;
-        }
+        boolean legal;
+
         // multi-line comment can not be legal
-        if (comment.getStartLineNo() != comment.getEndLineNo()) {
-            return false;
+        if (legalComment == null || comment.getStartLineNo() != comment.getEndLineNo()) {
+            legal = false;
         }
-        String commentText = comment.getText()[0];
-        // remove chars which start comment
-        commentText = commentText.substring(2);
-        // if this is a C-style comment we need to remove its end
-        if (commentText.endsWith("*/")) {
-            commentText = commentText.substring(0, commentText.length() - 2);
+        else {
+            String commentText = comment.getText()[0];
+            // remove chars which start comment
+            commentText = commentText.substring(2);
+            // if this is a C-style comment we need to remove its end
+            if (commentText.endsWith("*/")) {
+                commentText = commentText.substring(0, commentText.length() - 2);
+            }
+            commentText = commentText.trim();
+            legal = legalComment.matcher(commentText).find();
         }
-        commentText = commentText.trim();
-        return legalComment.matcher(commentText).find();
+        return legal;
     }
 }
