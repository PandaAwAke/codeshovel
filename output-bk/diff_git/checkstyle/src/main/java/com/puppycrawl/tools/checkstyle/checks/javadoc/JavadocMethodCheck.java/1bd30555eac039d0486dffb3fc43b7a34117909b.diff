diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index a9d16e03b..a39670e18 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -320,281 +320,281 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
      * Controls whether to ignore errors when there is no javadoc. Defaults to
      * false.
      *
      * @param flag a <code>Boolean</code> value
      */
     public void setAllowMissingJavadoc(boolean flag)
     {
         allowMissingJavadoc = flag;
     }
 
     /**
      * Controls whether to ignore errors when there is no javadoc for a
      * property accessor (setter/getter methods). Defaults to false.
      *
      * @param flag a <code>Boolean</code> value
      */
     public void setAllowMissingPropertyJavadoc(final boolean flag)
     {
         allowMissingPropertyJavadoc = flag;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.PACKAGE_DEF, TokenTypes.IMPORT,
                           TokenTypes.CLASS_DEF, TokenTypes.ENUM_DEF,
                           TokenTypes.INTERFACE_DEF,
                           TokenTypes.METHOD_DEF, TokenTypes.CTOR_DEF,
                           TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {TokenTypes.METHOD_DEF, TokenTypes.CTOR_DEF,
                           TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     public boolean isCommentNodesRequired()
     {
         return true;
     }
 
     @Override
     protected final void processAST(DetailAST ast)
     {
         if ((ast.getType() == TokenTypes.METHOD_DEF || ast.getType() == TokenTypes.CTOR_DEF)
-            && (getMethodsNumberOfLine(ast) <= minLineCount)
+            && getMethodsNumberOfLine(ast) <= minLineCount
             || hasAllowedAnnotations(ast))
         {
             return;
         }
         final Scope theScope = calculateScope(ast);
         if (shouldCheck(ast, theScope)) {
             final FileContents contents = getFileContents();
             final TextBlock cmt = contents.getJavadocBefore(ast.getLineNo());
 
             if (cmt == null) {
                 if (!isMissingJavadocAllowed(ast)) {
                     log(ast, MSG_JAVADOC_MISSING);
                 }
             }
             else {
                 checkComment(ast, cmt);
             }
         }
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private boolean hasAllowedAnnotations(DetailAST methodDef)
     {
         final DetailAST modifiersNode = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         DetailAST annotationNode = modifiersNode.findFirstToken(TokenTypes.ANNOTATION);
         while (annotationNode != null && annotationNode.getType() == TokenTypes.ANNOTATION) {
             DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);
             if (identNode == null) {
                 identNode = annotationNode.findFirstToken(TokenTypes.DOT)
                     .findFirstToken(TokenTypes.IDENT);
             }
             if (allowedAnnotations.contains(identNode.getText())) {
                 return true;
             }
             annotationNode = annotationNode.getNextSibling();
         }
         return false;
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private int getMethodsNumberOfLine(DetailAST methodDef)
     {
         int numberOfLines;
         final DetailAST lcurly = methodDef.getLastChild();
         final DetailAST rcurly = lcurly.getLastChild();
 
         if (lcurly.getFirstChild() == rcurly) {
             numberOfLines = 1;
         }
         else {
             numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;
         }
         return numberOfLines;
     }
 
     @Override
     protected final void logLoadError(Token ident)
     {
         logLoadErrorImpl(ident.getLineNo(), ident.getColumnNo(),
             MSG_CLASS_INFO,
             JavadocTagInfo.THROWS.getText(), ident.getText());
     }
 
     /**
      * The JavadocMethodCheck is about to report a missing Javadoc.
      * This hook can be used by derived classes to allow a missing javadoc
      * in some situations.  The default implementation checks
      * <code>allowMissingJavadoc</code> and
      * <code>allowMissingPropertyJavadoc</code> properties, do not forget
      * to call <code>super.isMissingJavadocAllowed(ast)</code> in case
      * you want to keep this logic.
      * @param ast the tree node for the method or constructor.
      * @return True if this method or constructor doesn't need Javadoc.
      */
     protected boolean isMissingJavadocAllowed(final DetailAST ast)
     {
         return allowMissingJavadoc
-            || (allowMissingPropertyJavadoc
-                && (isSetterMethod(ast) || isGetterMethod(ast)))
+            || allowMissingPropertyJavadoc
+                && (isSetterMethod(ast) || isGetterMethod(ast))
             || matchesSkipRegex(ast);
     }
 
     /**
      * Checks if the given method name matches the regex. In that case
      * we skip enforcement of javadoc for this method
      * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
      * @return true if given method name matches the regex.
      */
     private boolean matchesSkipRegex(DetailAST methodDef)
     {
         if (ignoreMethodNamesRegex != null) {
             final DetailAST ident = methodDef.findFirstToken(TokenTypes.IDENT);
             final String methodName = ident.getText();
 
             final Matcher matcher = ignoreMethodNamesRegex.matcher(methodName);
             if (matcher.matches()) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Whether we should check this node.
      *
      * @param ast a given node.
      * @param scope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST ast, final Scope scope)
     {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(ast);
 
         return scope.isIn(this.scope)
                 && surroundingScope.isIn(this.scope)
-                && ((excludeScope == null) || !scope.isIn(excludeScope)
+                && (excludeScope == null || !scope.isIn(excludeScope)
                     || !surroundingScope.isIn(excludeScope));
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param ast the token for the method
      * @param comment the Javadoc comment
      */
     private void checkComment(DetailAST ast, TextBlock comment)
     {
         final List<JavadocTag> tags = getMethodTags(comment);
 
         if (hasShortCircuitTag(ast, tags)) {
             return;
         }
 
         Iterator<JavadocTag> it = tags.iterator();
         if (ast.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
-                hasInheritDocTag |= (it.next()).isInheritDocTag();
+                hasInheritDocTag |= it.next().isInheritDocTag();
             }
 
             checkParamTags(tags, ast, !hasInheritDocTag);
             checkThrowsTags(tags, getThrows(ast), !hasInheritDocTag);
             if (isFunction(ast)) {
                 checkReturnTag(tags, ast.getLineNo(), !hasInheritDocTag);
             }
         }
 
         // Dump out all unused tags
         it = tags.iterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (!jt.isSeeOrInheritDocTag()) {
                 log(jt.getLineNo(), MSG_UNUSED_TAG_GENERAL);
             }
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param ast the construct being checked
      * @param tags the list of Javadoc tags associated with the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST ast,
             final List<JavadocTag> tags)
     {
         // Check if it contains {@inheritDoc} tag
-        if ((tags.size() != 1)
-                || !(tags.get(0)).isInheritDocTag())
+        if (tags.size() != 1
+                || !tags.get(0).isInheritDocTag())
         {
             return false;
         }
 
         // Invalid if private, a constructor, or a static method
         if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
             log(ast, MSG_INVALID_INHERIT_DOC);
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private Scope calculateScope(final DetailAST ast)
     {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
         return ScopeUtils.inInterfaceOrAnnotationBlock(ast) ? Scope.PUBLIC
                 : declaredScope;
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      *
      * @return the tags found
      * @param comment the Javadoc comment
      */
     private List<JavadocTag> getMethodTags(TextBlock comment)
     {
         final String[] lines = comment.getText();
         final List<JavadocTag> tags = Lists.newArrayList();
         int currentLine = comment.getStartLineNo() - 1;
 
         for (int i = 0; i < lines.length; i++) {
             currentLine++;
             final Matcher javadocArgMatcher =
                 MATCH_JAVADOC_ARG.matcher(lines[i]);
             final Matcher javadocNoargMatcher =
                 MATCH_JAVADOC_NOARG.matcher(lines[i]);
             final Matcher noargCurlyMatcher =
                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);
             final Matcher argMultilineStart =
@@ -674,102 +674,102 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
                         final String lFin = multilineCont.group(1);
                         if (!lFin.equals(NEXT_TAG)
                             && !lFin.equals(END_JAVADOC))
                         {
                             tags.add(new JavadocTag(currentLine, col, p1));
                         }
                     }
                     remIndex++;
                 }
             }
         }
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private List<DetailAST> getParameters(DetailAST ast)
     {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
         final List<DetailAST> retVal = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = child.getNextSibling();
         }
         return retVal;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast)
     {
         final List<ExceptionInfo> retVal = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
-                if ((child.getType() == TokenTypes.IDENT)
-                        || (child.getType() == TokenTypes.DOT))
+                if (child.getType() == TokenTypes.IDENT
+                        || child.getType() == TokenTypes.DOT)
                 {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     final ExceptionInfo ei = new ExceptionInfo(new Token(fi),
                             getCurrentClassName());
                     retVal.add(ei);
                 }
                 child = child.getNextSibling();
             }
         }
         return retVal;
     }
 
     /**
      * Checks a set of tags for matching parameters.
      *
      * @param tags the tags to check
      * @param parent the node which takes the parameters
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkParamTags(final List<JavadocTag> tags,
             final DetailAST parent, boolean reportExpectedTags)
     {
         final List<DetailAST> params = getParameters(parent);
         final List<DetailAST> typeParams = CheckUtils
                 .getTypeParameters(parent);
 
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             boolean found = false;
 
             // Loop looking for matching param
             final Iterator<DetailAST> paramIt = params.iterator();
             while (paramIt.hasNext()) {
                 final DetailAST param = paramIt.next();
                 if (param.getText().equals(tag.getArg1())) {
                     found = true;
                     paramIt.remove();
                     break;
                 }
             }
@@ -780,102 +780,102 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
                 while (typeParamsIt.hasNext()) {
                     final DetailAST typeParam = typeParamsIt.next();
                     if (typeParam.findFirstToken(TokenTypes.IDENT).getText()
                             .equals(
                                     tag.getArg1().substring(1,
                                             tag.getArg1().length() - 1)))
                     {
                         found = true;
                         typeParamsIt.remove();
                         break;
                     }
                 }
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", tag.getArg1());
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingParamTags && reportExpectedTags) {
             for (DetailAST param : params) {
                 log(param, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(), param.getText());
             }
 
             for (DetailAST typeParam : typeParams) {
                 log(typeParam, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(),
                     "<" + typeParam.findFirstToken(TokenTypes.IDENT).getText()
                     + ">");
             }
         }
     }
 
     /**
      * Checks whether a method is a function.
      *
      * @param ast the method node.
      * @return whether the method is a function.
      */
     private boolean isFunction(DetailAST ast)
     {
         boolean retVal = false;
         if (ast.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = ast.findFirstToken(TokenTypes.TYPE);
-            if ((typeAST != null)
-                && (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null))
+            if (typeAST != null
+                && typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null)
             {
                 retVal = true;
             }
         }
         return retVal;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      *
      * @param tags the tags to check
      * @param lineNo the line number of the expected tag
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkReturnTag(List<JavadocTag> tags, int lineNo,
         boolean reportExpectedTags)
     {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator<JavadocTag> it = tags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), jt.getColumnNo(),
                         MSG_DUPLICATE_TAG,
                         JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !allowMissingReturnTag && reportExpectedTags) {
             log(lineNo, MSG_RETURN_EXPECTED);
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
@@ -926,195 +926,195 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
                 if (documentedCI.getClazz() == ei.getClazz()) {
                     found = true;
                     ei.setFound();
                     foundThrows.add(documentedEx);
                 }
                 else if (allowThrowsTagsForSubclasses) {
                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());
                 }
             }
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedCI.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getArg1());
 
                 }
             }
         }
 
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
             for (ExceptionInfo ei : throwsList) {
                 if (!ei.isFound()) {
                     final Token fi = ei.getName();
                     log(fi.getLineNo(), fi.getColumnNo(),
                         MSG_EXCPECTED_TAG,
                         JavadocTagInfo.THROWS.getText(), fi.getText());
                 }
             }
         }
     }
 
     /**
      * Returns whether an AST represents a setter method.
      * @param ast the AST to check with
      * @return whether the AST represents a setter method
      */
     private boolean isSetterMethod(final DetailAST ast)
     {
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper setter method which does not throw any
         // exceptions.
-        if ((ast.getType() != TokenTypes.METHOD_DEF)
-                || (ast.getChildCount() != MAX_CHILDREN))
+        if (ast.getType() != TokenTypes.METHOD_DEF
+                || ast.getChildCount() != MAX_CHILDREN)
         {
             return false;
         }
 
         // Should I handle only being in a class????
 
         // Check the name matches format setX...
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final String name = type.getNextSibling().getText();
         if (!name.matches("^set[A-Z].*")) { // Depends on JDK 1.4
             return false;
         }
 
         // Check the return type is void
         if (type.getChildCount(TokenTypes.LITERAL_VOID) == 0) {
             return false;
         }
 
         // Check that is had only one parameter
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if ((params == null)
-                || (params.getChildCount(TokenTypes.PARAMETER_DEF) != 1))
+        if (params == null
+                || params.getChildCount(TokenTypes.PARAMETER_DEF) != 1)
         {
             return false;
         }
 
         // Now verify that the body consists of:
         // SLIST -> EXPR -> ASSIGN
         // SEMI
         // RCURLY
         final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
-        if ((slist == null) || (slist.getChildCount() != BODY_SIZE)) {
+        if (slist == null || slist.getChildCount() != BODY_SIZE) {
             return false;
         }
 
         final AST expr = slist.getFirstChild();
-        if ((expr.getType() != TokenTypes.EXPR)
-                || (expr.getFirstChild().getType() != TokenTypes.ASSIGN))
+        if (expr.getType() != TokenTypes.EXPR
+                || expr.getFirstChild().getType() != TokenTypes.ASSIGN)
         {
             return false;
         }
 
         return true;
     }
 
     /**
      * Returns whether an AST represents a getter method.
      * @param ast the AST to check with
      * @return whether the AST represents a getter method
      */
     private boolean isGetterMethod(final DetailAST ast)
     {
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper getter method which does not throw any
         // exceptions.
-        if ((ast.getType() != TokenTypes.METHOD_DEF)
-                || (ast.getChildCount() != MAX_CHILDREN))
+        if (ast.getType() != TokenTypes.METHOD_DEF
+                || ast.getChildCount() != MAX_CHILDREN)
         {
             return false;
         }
 
         // Check the name matches format of getX or isX. Technically I should
         // check that the format isX is only used with a boolean type.
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final String name = type.getNextSibling().getText();
         if (!name.matches("^(is|get)[A-Z].*")) { // Depends on JDK 1.4
             return false;
         }
 
         // Check the return type is void
         if (type.getChildCount(TokenTypes.LITERAL_VOID) > 0) {
             return false;
         }
 
         // Check that is had only one parameter
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if ((params == null)
-                || (params.getChildCount(TokenTypes.PARAMETER_DEF) > 0))
+        if (params == null
+                || params.getChildCount(TokenTypes.PARAMETER_DEF) > 0)
         {
             return false;
         }
 
         // Now verify that the body consists of:
         // SLIST -> RETURN
         // RCURLY
         final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
-        if ((slist == null) || (slist.getChildCount() != 2)) {
+        if (slist == null || slist.getChildCount() != 2) {
             return false;
         }
 
         final AST expr = slist.getFirstChild();
-        if ((expr.getType() != TokenTypes.LITERAL_RETURN)
-                || (expr.getFirstChild().getType() != TokenTypes.EXPR))
+        if (expr.getType() != TokenTypes.LITERAL_RETURN
+                || expr.getFirstChild().getType() != TokenTypes.EXPR)
         {
             return false;
         }
 
         return true;
     }
 
     /** Stores useful information about declared exception. */
     private class ExceptionInfo
     {
         /** does the exception have throws tag associated with. */
         private boolean found;
         /** class information associated with this exception. */
         private final ClassInfo classInfo;
 
         /**
          * Creates new instance for <code>FullIdent</code>.
          *
          * @param ident the exception
          * @param currentClass name of current class.
          */
         ExceptionInfo(Token ident, String currentClass)
         {
             classInfo = createClassInfo(ident, currentClass);
         }
 
         /** Mark that the exception has associated throws tag */
         final void setFound()
         {
             found = true;
         }
 
         /** @return whether the exception has throws tag associated with */
         final boolean isFound()
         {
             return found;
         }
 
         /** @return exception's name */
         final Token getName()
         {
             return classInfo.getName();
         }
 
         /** @return class for this exception */
         final Class<?> getClazz()
         {
             return classInfo.getClazz();
         }
     }
