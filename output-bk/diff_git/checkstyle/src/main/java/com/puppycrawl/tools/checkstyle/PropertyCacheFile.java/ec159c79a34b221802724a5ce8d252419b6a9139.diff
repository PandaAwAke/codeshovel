diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index f87f654c4..5c38a4826 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -23,100 +23,108 @@ import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.net.URI;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 
 import javax.xml.bind.DatatypeConverter;
 
 import com.google.common.io.ByteStreams;
 import com.google.common.io.Closeables;
 import com.google.common.io.Flushables;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * This class maintains a persistent(on file-system) store of the files
  * that have checked ok(no validation events) and their associated
  * timestamp. It is used to optimize Checkstyle between few launches.
  * It is mostly useful for plugin and extensions of Checkstyle.
  * It uses a property file
  * for storage.  A hashcode of the Configuration is stored in the
  * cache file to ensure the cache is invalidated when the
  * configuration has changed.
  *
  * @author Oliver Burn
  * @author Andrei Selkin
  */
 final class PropertyCacheFile {
 
     /**
      * The property key to use for storing the hashcode of the
      * configuration. To avoid name clashes with the files that are
      * checked the key is chosen in such a way that it cannot be a
      * valid file name.
      */
     public static final String CONFIG_HASH_KEY = "configuration*?";
 
+    /**
+     * The property prefix to use for storing the hashcode of an
+     * external resource. To avoid name clashes with the files that are
+     * checked the prefix is chosen in such a way that it cannot be a
+     * valid file name and makes it clear it is a resource.
+     */
+    public static final String EXTERNAL_RESOURCE_KEY_PREFIX = "module-resource*?:";
+
     /** The details on files. **/
     private final Properties details = new Properties();
 
     /** Configuration object. **/
     private final Configuration config;
 
     /** File name of cache. **/
     private final String fileName;
 
     /** Generated configuration hash. **/
     private String configHash;
 
     /**
      * Creates a new {@code PropertyCacheFile} instance.
      *
      * @param config the current configuration, not null
      * @param fileName the cache file
      */
     PropertyCacheFile(Configuration config, String fileName) {
         if (config == null) {
             throw new IllegalArgumentException("config can not be null");
         }
         if (fileName == null) {
             throw new IllegalArgumentException("fileName can not be null");
         }
         this.config = config;
         this.fileName = fileName;
     }
 
     /**
      * Load cached values from file.
      * @throws IOException when there is a problems with file read
      */
     public void load() throws IOException {
         // get the current config so if the file isn't found
         // the first time the hash will be added to output file
         configHash = getHashCodeBasedOnObjectContent(config);
         if (new File(fileName).exists()) {
             FileInputStream inStream = null;
             try {
                 inStream = new FileInputStream(fileName);
                 details.load(inStream);
                 final String cachedConfigHash = details.getProperty(CONFIG_HASH_KEY);
                 if (!configHash.equals(cachedConfigHash)) {
                     // Detected configuration change - clear cache
                     reset();
                 }
             }
             finally {
                 Closeables.closeQuietly(inStream);
@@ -226,101 +234,102 @@ final class PropertyCacheFile {
 
             // Instead of hexEncoding outputStream.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             final MessageDigest digest = MessageDigest.getInstance("SHA-1");
             digest.update(outputStream.toByteArray());
 
             return DatatypeConverter.printHexBinary(digest.digest());
         }
         catch (final IOException | NoSuchAlgorithmException ex) {
             // rethrow as unchecked exception
             throw new IllegalStateException("Unable to calculate hashcode.", ex);
         }
     }
 
     /**
      * Puts external resources in cache.
      * If at least one external resource changed, clears the cache.
      * @param locations locations of external resources.
      */
     public void putExternalResources(Set<String> locations) {
         final Set<ExternalResource> resources = loadExternalResources(locations);
         if (areExternalResourcesChanged(resources)) {
             reset();
         }
         fillCacheWithExternalResources(resources);
     }
 
     /**
      * Loads a set of {@link ExternalResource} based on their locations.
      * @param resourceLocations locations of external configuration resources.
      * @return a set of {@link ExternalResource}.
      */
     private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {
         final Set<ExternalResource> resources = new HashSet<>();
         for (String location : resourceLocations) {
             String contentHashSum = null;
             try {
                 final byte[] content = loadExternalResource(location);
                 contentHashSum = getHashCodeBasedOnObjectContent(content);
             }
             catch (CheckstyleException ex) {
                 // if exception happened (configuration resource was not found, connection is not
                 // available, resource is broken, etc), we need to calculate hash sum based on
                 // exception object content in order to check whether problem is resolved later
                 // and/or the configuration is changed.
                 contentHashSum = getHashCodeBasedOnObjectContent(ex);
             }
             finally {
-                resources.add(new ExternalResource(location, contentHashSum));
+                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,
+                        contentHashSum));
             }
         }
         return resources;
     }
 
     /**
      * Loads the content of external resource.
      * @param location external resource location.
      * @return array of bytes which represents the content of external resource in binary form.
      * @throws CheckstyleException if error while loading occurs.
      */
     private static byte[] loadExternalResource(String location) throws CheckstyleException {
         final byte[] content;
         final URI uri = CommonUtils.getUriByFilename(location);
 
         try {
             content = ByteStreams.toByteArray(new BufferedInputStream(uri.toURL().openStream()));
         }
         catch (IOException ex) {
             throw new CheckstyleException("Unable to load external resource file " + location, ex);
         }
 
         return content;
     }
 
     /**
      * Checks whether the contents of external configuration resources were changed.
      * @param resources a set of {@link ExternalResource}.
      * @return true if the contents of external configuration resources were changed.
      */
     private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {
         return resources.stream().filter(resource -> {
             boolean changed = false;
             if (isResourceLocationInCache(resource.location)) {
                 final String contentHashSum = resource.contentHashSum;
                 final String cachedHashSum = details.getProperty(resource.location);
                 if (!cachedHashSum.equals(contentHashSum)) {
                     changed = true;
                 }
             }
             else {
                 changed = true;
             }
             return changed;
         }).findFirst().isPresent();
     }
 
     /**
      * Fills cache with a set of {@link ExternalResource}.
      * If external resource from the set is already in cache, it will be skipped.
