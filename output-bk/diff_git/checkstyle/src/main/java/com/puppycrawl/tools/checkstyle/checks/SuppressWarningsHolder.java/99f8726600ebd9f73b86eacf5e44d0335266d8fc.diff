diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
index 89d13fd72..f04e800ee 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
@@ -260,227 +260,251 @@ public class SuppressWarningsHolder
      * @param ast annotation token
      * @return list values
      */
     private static List<String> getAllAnnotationValues(DetailAST ast) {
         // get values of annotation
         List<String> values = null;
         final DetailAST lparenAST = ast.findFirstToken(TokenTypes.LPAREN);
         if (lparenAST != null) {
             final DetailAST nextAST = lparenAST.getNextSibling();
             final int nextType = nextAST.getType();
             switch (nextType) {
                 case TokenTypes.EXPR:
                 case TokenTypes.ANNOTATION_ARRAY_INIT:
                     values = getAnnotationValues(nextAST);
                     break;
 
                 case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:
                     // expected children: IDENT ASSIGN ( EXPR |
                     // ANNOTATION_ARRAY_INIT )
                     values = getAnnotationValues(getNthChild(nextAST, 2));
                     break;
 
                 case TokenTypes.RPAREN:
                     // no value present (not valid Java)
                     break;
 
                 default:
                     // unknown annotation value type (new syntax?)
                     throw new IllegalArgumentException("Unexpected AST: " + nextAST);
             }
         }
         return values;
     }
 
     /**
      * Checks that annotation is empty.
      * @param values list of values in the annotation
      * @return whether annotation is empty or contains some values
      */
     private static boolean isAnnotationEmpty(List<String> values) {
         return values == null;
     }
 
     /**
      * Get target of annotation.
      * @param ast the AST node to get the child of
      * @return get target of annotation
      */
     private static DetailAST getAnnotationTarget(DetailAST ast) {
         DetailAST targetAST = null;
-        DetailAST parentAST = ast.getParent();
+        final DetailAST parentAST = ast.getParent();
         switch (parentAST.getType()) {
             case TokenTypes.MODIFIERS:
             case TokenTypes.ANNOTATIONS:
-                parentAST = parentAST.getParent();
-                switch (parentAST.getType()) {
-                    case TokenTypes.ANNOTATION_DEF:
-                    case TokenTypes.PACKAGE_DEF:
-                    case TokenTypes.CLASS_DEF:
-                    case TokenTypes.INTERFACE_DEF:
-                    case TokenTypes.ENUM_DEF:
-                    case TokenTypes.ENUM_CONSTANT_DEF:
-                    case TokenTypes.CTOR_DEF:
-                    case TokenTypes.METHOD_DEF:
-                    case TokenTypes.PARAMETER_DEF:
-                    case TokenTypes.VARIABLE_DEF:
-                    case TokenTypes.ANNOTATION_FIELD_DEF:
-                    case TokenTypes.TYPE:
-                    case TokenTypes.LITERAL_NEW:
-                    case TokenTypes.LITERAL_THROWS:
-                    case TokenTypes.TYPE_ARGUMENT:
-                    case TokenTypes.IMPLEMENTS_CLAUSE:
-                    case TokenTypes.DOT:
-                        targetAST = parentAST;
-                        break;
-                    default:
-                        // it's possible case, but shouldn't be processed here
-                }
+                targetAST = getAcceptableParent(parentAST);
                 break;
             default:
                 // unexpected container type
                 throw new IllegalArgumentException("Unexpected container AST: " + parentAST);
         }
         return targetAST;
     }
 
+    /**
+     * Returns parent of given ast if parent has one of the following types:
+     * ANNOTATION_DEF, PACKAGE_DEF, CLASS_DEF, ENUM_DEF, ENUM_CONSTANT_DEF, CTOR_DEF,
+     * METHOD_DEF, PARAMETER_DEF, VARIABLE_DEF, ANNOTATION_FIELD_DEF, TYPE, LITERAL_NEW,
+     * LITERAL_THROWS, TYPE_ARGUMENT, IMPLEMENTS_CLAUSE, DOT.
+     * @param child an ast
+     * @return returns ast - parent of given
+     */
+    private static DetailAST getAcceptableParent(DetailAST child) {
+        DetailAST result;
+        final DetailAST parent = child.getParent();
+        switch (parent.getType()) {
+            case TokenTypes.ANNOTATION_DEF:
+            case TokenTypes.PACKAGE_DEF:
+            case TokenTypes.CLASS_DEF:
+            case TokenTypes.INTERFACE_DEF:
+            case TokenTypes.ENUM_DEF:
+            case TokenTypes.ENUM_CONSTANT_DEF:
+            case TokenTypes.CTOR_DEF:
+            case TokenTypes.METHOD_DEF:
+            case TokenTypes.PARAMETER_DEF:
+            case TokenTypes.VARIABLE_DEF:
+            case TokenTypes.ANNOTATION_FIELD_DEF:
+            case TokenTypes.TYPE:
+            case TokenTypes.LITERAL_NEW:
+            case TokenTypes.LITERAL_THROWS:
+            case TokenTypes.TYPE_ARGUMENT:
+            case TokenTypes.IMPLEMENTS_CLAUSE:
+            case TokenTypes.DOT:
+                result = parent;
+                break;
+            default:
+                // it's possible case, but shouldn't be processed here
+                result = null;
+        }
+        return result;
+    }
+
     /**
      * Returns the n'th child of an AST node.
      * @param ast the AST node to get the child of
      * @param index the index of the child to get
      * @return the n'th child of the given AST node, or {@code null} if none
      */
     private static DetailAST getNthChild(DetailAST ast, int index) {
         DetailAST child = ast.getFirstChild();
         for (int i = 0; i < index && child != null; ++i) {
             child = child.getNextSibling();
         }
         return child;
     }
 
     /**
      * Returns the Java identifier represented by an AST.
      * @param ast an AST node for an IDENT or DOT
      * @return the Java identifier represented by the given AST subtree
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getIdentifier(DetailAST ast) {
         if (ast != null) {
             if (ast.getType() == TokenTypes.IDENT) {
                 return ast.getText();
             }
             else {
                 return getIdentifier(ast.getFirstChild()) + "."
                         + getIdentifier(ast.getLastChild());
             }
         }
         throw new IllegalArgumentException("Identifier AST expected, but get null.");
     }
 
     /**
      * Returns the literal string expression represented by an AST.
      * @param ast an AST node for an EXPR
      * @return the Java string represented by the given AST expression
      *         or empty string if expression is too complex
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getStringExpr(DetailAST ast) {
         final DetailAST firstChild = ast.getFirstChild();
         String expr = "";
 
         switch (firstChild.getType()) {
             case TokenTypes.STRING_LITERAL:
                 // NOTE: escaped characters are not unescaped
                 final String quotedText = firstChild.getText();
                 expr = quotedText.substring(1, quotedText.length() - 1);
                 break;
             case TokenTypes.IDENT:
                 expr = firstChild.getText();
                 break;
             case TokenTypes.DOT:
                 expr = firstChild.getLastChild().getText();
                 break;
             default:
                 // annotations with complex expressions cannot suppress warnings
         }
         return expr;
     }
 
     /**
      * Returns the annotation values represented by an AST.
      * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT
      * @return the list of Java string represented by the given AST for an
      *         expression or annotation array initializer
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static List<String> getAnnotationValues(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.EXPR:
                 return ImmutableList.of(getStringExpr(ast));
 
             case TokenTypes.ANNOTATION_ARRAY_INIT:
-                final List<String> valueList = Lists.newLinkedList();
-                DetailAST childAST = ast.getFirstChild();
-                while (childAST != null) {
-                    if (childAST.getType() == TokenTypes.EXPR) {
-                        valueList.add(getStringExpr(childAST));
-                    }
-                    childAST = childAST.getNextSibling();
-                }
-                return valueList;
+                return findAllExpressionsInChildren(ast);
 
             default:
                 throw new IllegalArgumentException(
                         "Expression or annotation array initializer AST expected: " + ast);
         }
     }
 
+    /**
+     * Method looks at children and returns list of expressions in strings.
+     * @param parent ast, that contains children
+     * @return list of expressions in strings
+     */
+    private static List<String> findAllExpressionsInChildren(DetailAST parent) {
+        final List<String> valueList = Lists.newLinkedList();
+        DetailAST childAST = parent.getFirstChild();
+        while (childAST != null) {
+            if (childAST.getType() == TokenTypes.EXPR) {
+                valueList.add(getStringExpr(childAST));
+            }
+            childAST = childAST.getNextSibling();
+        }
+        return valueList;
+    }
+
     /** Records a particular suppression for a region of a file. */
     private static class Entry {
         /** The source name of the suppressed check. */
         private final String checkName;
         /** The suppression region for the check - first line. */
         private final int firstLine;
         /** The suppression region for the check - first column. */
         private final int firstColumn;
         /** The suppression region for the check - last line. */
         private final int lastLine;
         /** The suppression region for the check - last column. */
         private final int lastColumn;
 
         /**
          * Constructs a new suppression region entry.
          * @param checkName the source name of the suppressed check
          * @param firstLine the first line of the suppression region
          * @param firstColumn the first column of the suppression region
          * @param lastLine the last line of the suppression region
          * @param lastColumn the last column of the suppression region
          */
         Entry(String checkName, int firstLine, int firstColumn,
             int lastLine, int lastColumn) {
             this.checkName = checkName;
             this.firstLine = firstLine;
             this.firstColumn = firstColumn;
             this.lastLine = lastLine;
             this.lastColumn = lastColumn;
         }
 
         /**
          * Gets he source name of the suppressed check.
          * @return the source name of the suppressed check
          */
         public String getCheckName() {
             return checkName;
         }
 
         /**
          * Gets the first line of the suppression region.
          * @return the first line of the suppression region
          */
         public int getFirstLine() {
             return firstLine;
         }
 
         /**
          * Gets the first column of the suppression region.
          * @return the first column of the suppression region
          */
