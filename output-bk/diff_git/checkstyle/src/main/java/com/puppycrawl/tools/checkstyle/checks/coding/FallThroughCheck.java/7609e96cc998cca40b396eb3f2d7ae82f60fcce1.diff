diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
index d7244f1ee..0a4236cfd 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
@@ -1,77 +1,78 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
+import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * Checks for fall through in switch statements
  * Finds locations where a case <b>contains</b> Java code -
  * but lacks a break, return, throw or continue statement.
  *
  * <p>
  * The check honors special comments to suppress warnings about
  * the fall through. By default the comments "fallthru",
  * "fall through", "falls through" and "fallthrough" are recognized.
  * </p>
  * <p>
  * The following fragment of code will NOT trigger the check,
  * because of the comment "fallthru" and absence of any Java code
  * in case 5.
  * </p>
  * <pre>
  * case 3:
  *     x = 2;
  *     // fallthru
  * case 4:
  * case 5:
  * case 6:
  *     break;
  * </pre>
  * <p>
  * The recognized relief comment can be configured with the property
  * {@code reliefPattern}. Default value of this regular expression
  * is "fallthru|fall through|fallthrough|falls through".
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="FallThrough"&gt;
  *     &lt;property name=&quot;reliefPattern&quot;
  *                  value=&quot;Fall Through&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author o_sukhodolsky
  */
 public class FallThroughCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_FALL_THROUGH = "fall.through";
 
@@ -306,83 +307,83 @@ public class FallThroughCheck extends AbstractCheck {
             caseGroup = caseGroup.getNextSibling();
         }
         return isTerminated;
     }
 
     /**
      * Determines if the fall through case between {@code currentCase} and
      * {@code nextCase} is relieved by a appropriate comment.
      *
      * @param currentCase AST of the case that falls through to the next case.
      * @param nextCase AST of the next case.
      * @return True if a relief comment was found
      */
     private boolean hasFallThroughComment(DetailAST currentCase, DetailAST nextCase) {
         boolean allThroughComment = false;
         final int endLineNo = nextCase.getLineNo();
         final int endColNo = nextCase.getColumnNo();
 
         // Remember: The lines number returned from the AST is 1-based, but
         // the lines number in this array are 0-based. So you will often
         // see a "lineNo-1" etc.
         final String[] lines = getLines();
 
         // Handle:
         //    case 1:
         //    /+ FALLTHRU +/ case 2:
         //    ....
         // and
         //    switch(i) {
         //    default:
         //    /+ FALLTHRU +/}
         //
         final String linePart = lines[endLineNo - 1].substring(0, endColNo);
         if (matchesComment(reliefPattern, linePart, endLineNo)) {
             allThroughComment = true;
         }
         else {
             // Handle:
             //    case 1:
             //    .....
             //    // FALLTHRU
             //    case 2:
             //    ....
             // and
             //    switch(i) {
             //    default:
             //    // FALLTHRU
             //    }
             final int startLineNo = currentCase.getLineNo();
             for (int i = endLineNo - 2; i > startLineNo - 1; i--) {
-                if (!lines[i].trim().isEmpty()) {
+                if (!CommonUtils.isBlank(lines[i])) {
                     allThroughComment = matchesComment(reliefPattern, lines[i], i + 1);
                     break;
                 }
             }
         }
         return allThroughComment;
     }
 
     /**
      * Does a regular expression match on the given line and checks that a
      * possible match is within a comment.
      * @param pattern The regular expression pattern to use.
      * @param line The line of test to do the match on.
      * @param lineNo The line number in the file.
      * @return True if a match was found inside a comment.
      */
     private boolean matchesComment(Pattern pattern, String line, int lineNo
     ) {
         final Matcher matcher = pattern.matcher(line);
 
         final boolean hit = matcher.find();
 
         if (hit) {
             final int startMatch = matcher.start();
             // -1 because it returns the char position beyond the match
             final int endMatch = matcher.end() - 1;
             return getFileContents().hasIntersectionWithComment(lineNo,
                     startMatch, lineNo, endMatch);
         }
         return false;
     }
 }
