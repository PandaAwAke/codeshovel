diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index d0ba6e6ce..8cc49a5a2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -128,101 +128,101 @@ public class RightCurlyCheck extends AbstractCheck {
     }
 
     /**
      * Does the check need to check if right curly starts line.
      * @param flag new value of this property.
      */
     public void setShouldStartLine(boolean flag) {
         shouldStartLine = flag;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final Details details = getDetails(ast);
         final DetailAST rcurly = details.rcurly;
 
-        if (rcurly != null && rcurly.getType() == TokenTypes.RCURLY) {
+        if (rcurly != null) {
             final String violation;
             if (shouldStartLine) {
                 final String targetSourceLine = getLines()[rcurly.getLineNo() - 1];
                 violation = validate(details, option, true, targetSourceLine);
             }
             else {
                 violation = validate(details, option, false, "");
             }
 
             if (!violation.isEmpty()) {
                 log(rcurly, violation, "}", rcurly.getColumnNo() + 1);
             }
         }
     }
 
     /**
      * Does general validation.
      * @param details for validation.
      * @param bracePolicy for placing the right curly brace.
      * @param shouldStartLine do we need to check if right curly starts line.
      * @param targetSourceLine line that we need to check if shouldStartLine is true.
      * @return violation message or empty string
      *     if there was not violation during validation.
      */
     private static String validate(Details details, RightCurlyOption bracePolicy,
                                    boolean shouldStartLine, String targetSourceLine) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;
         String violation = "";
 
         if (bracePolicy == RightCurlyOption.SAME
                 && !hasLineBreakBefore(rcurly)
                 && lcurly.getLineNo() != rcurly.getLineNo()) {
             violation = MSG_KEY_LINE_BREAK_BEFORE;
         }
         else if (shouldCheckLastRcurly) {
             if (rcurly.getLineNo() == nextToken.getLineNo()) {
                 violation = MSG_KEY_LINE_ALONE;
             }
         }
         else if (shouldBeOnSameLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_SAME;
         }
         else if (shouldBeAloneOnLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_ALONE;
         }
         else if (shouldStartLine && !isOnStartOfLine(details, targetSourceLine)) {
             violation = MSG_KEY_LINE_NEW;
@@ -293,113 +293,116 @@ public class RightCurlyCheck extends AbstractCheck {
         final DetailAST nextToken = details.nextToken;
         return rcurly.getLineNo() == lcurly.getLineNo()
             && rcurly.getLineNo() != nextToken.getLineNo();
     }
 
     /**
      * Checks whether lcurly is in anonymous inner class initialization.
      * @param lcurly left curly token.
      * @return true if lcurly begins anonymous inner class initialization.
      */
     private static boolean isAnonInnerClassInit(DetailAST lcurly) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(lcurly);
         return surroundingScope.ordinal() == Scope.ANONINNER.ordinal();
     }
 
     /**
      * Collects validation details.
      * @param ast detail ast.
      * @return object that contain all details to make a validation.
      */
     // -@cs[JavaNCSS] getDetails() method is a huge SWITCH, it has to be monolithic
     // -@cs[ExecutableStatementCount] getDetails() method is a huge SWITCH, it has to be monolithic
     private static Details getDetails(DetailAST ast) {
         // Attempt to locate the tokens to do the check
         boolean shouldCheckLastRcurly = false;
         DetailAST rcurly = null;
         final DetailAST lcurly;
         DetailAST nextToken;
 
         switch (ast.getType()) {
             case TokenTypes.LITERAL_TRY:
                 lcurly = ast.getFirstChild();
                 nextToken = lcurly.getNextSibling();
                 rcurly = lcurly.getLastChild();
                 break;
             case TokenTypes.LITERAL_CATCH:
                 nextToken = ast.getNextSibling();
                 lcurly = ast.getLastChild();
                 rcurly = lcurly.getLastChild();
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                 }
                 break;
             case TokenTypes.LITERAL_IF:
                 nextToken = ast.findFirstToken(TokenTypes.LITERAL_ELSE);
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                     lcurly = ast.getLastChild();
-                    rcurly = lcurly.getLastChild();
                 }
                 else {
                     lcurly = nextToken.getPreviousSibling();
+                }
+                if (lcurly.getType() == TokenTypes.SLIST) {
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             case TokenTypes.LITERAL_ELSE:
             case TokenTypes.LITERAL_FINALLY:
                 shouldCheckLastRcurly = true;
                 nextToken = getNextToken(ast);
                 lcurly = ast.getFirstChild();
-                rcurly = lcurly.getLastChild();
+                if (lcurly.getType() == TokenTypes.SLIST) {
+                    rcurly = lcurly.getLastChild();
+                }
                 break;
             case TokenTypes.CLASS_DEF:
                 final DetailAST child = ast.getLastChild();
                 lcurly = child.getFirstChild();
                 rcurly = child.getLastChild();
                 nextToken = ast;
                 break;
             case TokenTypes.CTOR_DEF:
             case TokenTypes.STATIC_INIT:
             case TokenTypes.INSTANCE_INIT:
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 rcurly = lcurly.getLastChild();
                 nextToken = getNextToken(ast);
                 break;
             case TokenTypes.LITERAL_DO:
                 nextToken = ast.findFirstToken(TokenTypes.DO_WHILE);
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 if (lcurly != null) {
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             default:
                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,
                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.
                 // It has been done to improve coverage to 100%. I couldn't replace it with
                 // if-else-if block because code was ugly and didn't pass pmd check.
 
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 if (lcurly != null) {
                     // SLIST could be absent if method is abstract,
                     // and code like "while(true);"
                     rcurly = lcurly.getLastChild();
                 }
                 nextToken = getNextToken(ast);
                 break;
         }
 
         final Details details = new Details();
         details.rcurly = rcurly;
         details.lcurly = lcurly;
         details.nextToken = nextToken;
         details.shouldCheckLastRcurly = shouldCheckLastRcurly;
 
         return details;
     }
 
     /**
      * Checks if definition body is empty.
      * @param lcurly left curly.
      * @return true if definition body is empty.
