diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index dc95860ad..767b78933 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -170,116 +170,116 @@ public class DeclarationOrderCheck extends Check {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
             case TokenTypes.MODIFIERS:
                 if (parentType == TokenTypes.VARIABLE_DEF
                     && ast.getParent().getParent().getType() == TokenTypes.OBJBLOCK) {
                     processModifiers(ast);
                 }
                 break;
             case TokenTypes.CTOR_DEF:
                 if (parentType == TokenTypes.OBJBLOCK) {
                     processConstructor(ast);
                 }
                 break;
             case TokenTypes.METHOD_DEF:
                 if (parentType == TokenTypes.OBJBLOCK) {
                     final ScopeState state = scopeStates.peek();
                     // nothing can be bigger than method's state
                     state.currentScopeState = STATE_METHOD_DEF;
                 }
                 break;
             default:
                 break;
         }
     }
 
     /**
      * Process constructor.
      * @param ast constructor AST
      */
     private void processConstructor(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
         if (state.currentScopeState > STATE_CTOR_DEF) {
             if (!ignoreConstructors) {
                 log(ast, MSG_CONSTRUCTOR);
             }
         }
         else {
             state.currentScopeState = STATE_CTOR_DEF;
         }
     }
 
     /**
      * Process modifiers.
      * @param ast ast of Modifiers
      */
     private void processModifiers(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
-        if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
+        if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) == null) {
+            if (state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
+                log(ast, MSG_INSTANCE);
+            }
+            else if (state.currentScopeState == STATE_STATIC_VARIABLE_DEF) {
+                state.declarationAccess = Scope.PUBLIC;
+                state.currentScopeState = STATE_INSTANCE_VARIABLE_DEF;
+            }
+        }
+        else {
             if (state.currentScopeState > STATE_STATIC_VARIABLE_DEF) {
                 if (!ignoreModifiers
-                    || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
+                        || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
                     log(ast, MSG_STATIC);
                 }
             }
             else {
                 state.currentScopeState = STATE_STATIC_VARIABLE_DEF;
             }
         }
-        else {
-            if (state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
-                log(ast, MSG_INSTANCE);
-            }
-            else if (state.currentScopeState == STATE_STATIC_VARIABLE_DEF) {
-                state.declarationAccess = Scope.PUBLIC;
-                state.currentScopeState = STATE_INSTANCE_VARIABLE_DEF;
-            }
-        }
 
         final Scope access = ScopeUtils.getScopeFromMods(ast);
         if (state.declarationAccess.compareTo(access) > 0) {
             if (!ignoreModifiers) {
                 log(ast, MSG_ACCESS);
             }
         }
         else {
             state.declarationAccess = access;
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.OBJBLOCK) {
             scopeStates.pop();
         }
     }
 
     /**
      * Sets whether to ignore constructors.
      * @param ignoreConstructors whether to ignore constructors.
      */
     public void setIgnoreConstructors(boolean ignoreConstructors) {
         this.ignoreConstructors = ignoreConstructors;
     }
 
     /**
      * Sets whether to ignore modifiers.
      * @param ignoreModifiers whether to ignore modifiers.
      */
     public void setIgnoreModifiers(boolean ignoreModifiers) {
         this.ignoreModifiers = ignoreModifiers;
     }
 
     /**
      * Private class to encapsulate the state.
      */
     private static class ScopeState {
         /** The state the check is in. */
         private int currentScopeState = STATE_STATIC_VARIABLE_DEF;
 
         /** The sub-state the check is in. */
         private Scope declarationAccess = Scope.PUBLIC;
     }
 }
