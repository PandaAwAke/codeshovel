diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
index f79f1859a..c6aaa56bb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
@@ -86,101 +86,101 @@ public class FallThroughCheck extends Check
         return new int[]{TokenTypes.CASE_GROUP};
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     /**
      * Set the relief pattern.
      *
      * @param aPattern
      *            The regular expression pattern.
      */
     public void setReliefPattern(String aPattern)
     {
         mReliefPattern = aPattern;
     }
 
     /**
      * Configures whether we need to check last case group or not.
      * @param aValue new value of the property.
      */
     public void setCheckLastCaseGroup(boolean aValue)
     {
         mCheckLastGroup = aValue;
     }
 
     @Override
     public void init()
     {
         super.init();
         mRegExp = Utils.getPattern(mReliefPattern);
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST nextGroup = aAST.getNextSibling();
         final boolean isLastGroup =
             ((nextGroup == null)
              || (nextGroup.getType() != TokenTypes.CASE_GROUP));
         if (isLastGroup && !mCheckLastGroup) {
             // we do not need to check last group
             return;
         }
 
         final DetailAST slist = aAST.findFirstToken(TokenTypes.SLIST);
 
-        if (!isTerminated(slist, true, true)
+        if (slist != null && !isTerminated(slist, true, true)
             && !hasFallTruComment(aAST, nextGroup))
         {
             if (!isLastGroup) {
                 log(nextGroup, "fall.through");
             }
             else {
                 log(aAST, "fall.through.last");
             }
         }
     }
 
     /**
      * Checks if a given subtree terminated by return, throw or,
      * if allowed break, continue.
      * @param aAST root of given subtree
      * @param aUseBreak should we consider break as terminator.
      * @param aUseContinue should we consider continue as terminator.
      * @return true if the subtree is terminated.
      */
     private boolean isTerminated(final DetailAST aAST, boolean aUseBreak,
                                  boolean aUseContinue)
     {
         switch (aAST.getType()) {
         case TokenTypes.LITERAL_RETURN:
         case TokenTypes.LITERAL_THROW:
             return true;
         case TokenTypes.LITERAL_BREAK:
             return aUseBreak;
         case TokenTypes.LITERAL_CONTINUE:
             return aUseContinue;
         case TokenTypes.SLIST:
             return checkSlist(aAST, aUseBreak, aUseContinue);
         case TokenTypes.LITERAL_IF:
             return checkIf(aAST, aUseBreak, aUseContinue);
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_DO:
             return checkLoop(aAST);
         case TokenTypes.LITERAL_TRY:
             return checkTry(aAST, aUseBreak, aUseContinue);
         case TokenTypes.LITERAL_SWITCH:
             return checkSwitch(aAST, aUseContinue);
         default:
             return false;
         }
     }
 
     /**
      * Checks if a given SLIST terminated by return, throw or,
      * if allowed break, continue.
