diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index e390065da..59ae414a6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -300,56 +300,57 @@ public class UnnecessaryParenthesesCheck extends AbstractCheck {
      *         parentheses.
      */
     private static boolean isExprSurrounded(DetailAST ast) {
         return ast.getFirstChild().getType() == TokenTypes.LPAREN;
     }
 
     /**
      * Tests if the given lambda node has a single parameter, no defined type, and is surrounded
      * by parentheses.
      * @param ast a {@code DetailAST} whose type is
      *        {@code TokenTypes.LAMBDA}.
      * @return {@code true} if the lambda has a single parameter, no defined type, and is
      *         surrounded by parentheses.
      */
     private static boolean isLambdaSingleParameterSurrounded(DetailAST ast) {
         final DetailAST firstChild = ast.getFirstChild();
         return firstChild.getType() == TokenTypes.LPAREN
                 && firstChild.getNextSibling().getChildCount(TokenTypes.PARAMETER_DEF) == 1
                 && firstChild.getNextSibling().getFirstChild().findFirstToken(TokenTypes.TYPE)
                         .getChildCount() == 0;
     }
 
     /**
      * Check if the given token type can be found in an array of token types.
      * @param type the token type.
      * @param tokens an array of token types to search.
      * @return {@code true} if {@code type} was found in {@code
      *         tokens}.
      */
     private static boolean isInTokenList(int type, int... tokens) {
         // NOTE: Given the small size of the two arrays searched, I'm not sure
         //       it's worth bothering with doing a binary search or using a
         //       HashMap to do the searches.
 
         boolean found = false;
         for (int i = 0; i < tokens.length && !found; i++) {
             found = tokens[i] == type;
         }
         return found;
     }
 
     /**
      * Returns the specified string chopped to {@code MAX_QUOTED_LENGTH}
      * plus an ellipsis (...) if the length of the string exceeds {@code
      * MAX_QUOTED_LENGTH}.
      * @param value the string to potentially chop.
      * @return the chopped string if {@code string} is longer than
      *         {@code MAX_QUOTED_LENGTH}; otherwise {@code string}.
      */
     private static String chopString(String value) {
+        String result = value;
         if (value.length() > MAX_QUOTED_LENGTH) {
-            return value.substring(0, MAX_QUOTED_LENGTH) + "...\"";
+            result = value.substring(0, MAX_QUOTED_LENGTH) + "...\"";
         }
-        return value;
+        return result;
     }
 }
