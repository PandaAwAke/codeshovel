diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index 74498e6e9..e07906f5a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -125,101 +125,101 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * <pre>   &lt;property name="allowEmptyMethods" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty constructor blocks use
  *
  *
  * <pre>   &lt;property name="allowEmptyConstructors" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty type blocks use
  *
  *
  * <pre>   &lt;property name="allowEmptyTypes" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty loop blocks use
  *
  *
  * <pre>   &lt;property name="allowEmptyLoops" value="true" /&gt;</pre>
  *
  *
  * <p>
  * Also, this check can be configured to ignore the colon in an enhanced for
  * loop. The colon in an enhanced for loop is ignored by default
  *
  * <p>
  * To configure the check to ignore the colon
  *
  *
  * <pre>   &lt;property name="ignoreEnhancedForColon" value="true" /&gt;</pre>
  *
  *
  * @author Oliver Burn
  * @author maxvetrenko
  */
 public class WhitespaceAroundCheck extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_PRECEDED = "ws.notPreceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_FOLLOWED = "ws.notFollowed";
 
     /** Whether or not empty constructor bodies are allowed. */
-    private boolean allowEmptyCtors;
+    private boolean allowEmptyConstructors;
     /** Whether or not empty method bodies are allowed. */
     private boolean allowEmptyMethods;
     /** Whether or not empty classes, enums and interfaces are allowed*/
     private boolean allowEmptyTypes;
     /** Whether or not empty loops are allowed*/
     private boolean allowEmptyLoops;
     /** Whether or not to ignore a colon in a enhanced for loop */
     private boolean ignoreEnhancedForColon = true;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.ASSIGN,
             TokenTypes.BAND,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.COLON,
             TokenTypes.DIV,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.DO_WHILE,
             TokenTypes.EQUAL,
             TokenTypes.GE,
             TokenTypes.GT,
             TokenTypes.LAND,
             TokenTypes.LCURLY,
             TokenTypes.LE,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LOR,
             TokenTypes.LT,
             TokenTypes.MINUS,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.NOT_EQUAL,
             TokenTypes.PLUS,
@@ -266,101 +266,101 @@ public class WhitespaceAroundCheck extends Check {
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LOR,
             TokenTypes.LT,
             TokenTypes.MINUS,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.NOT_EQUAL,
             TokenTypes.PLUS,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.QUESTION,
             TokenTypes.RCURLY,
             TokenTypes.SL,
             TokenTypes.SLIST,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.LITERAL_ASSERT,
             TokenTypes.TYPE_EXTENSION_AND,
             TokenTypes.WILDCARD_TYPE,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     /**
      * Sets whether or not empty method bodies are allowed.
      * @param allow {@code true} to allow empty method bodies.
      */
     public void setAllowEmptyMethods(boolean allow) {
         allowEmptyMethods = allow;
     }
 
     /**
      * Sets whether or not empty constructor bodies are allowed.
      * @param allow {@code true} to allow empty constructor bodies.
      */
     public void setAllowEmptyConstructors(boolean allow) {
-        allowEmptyCtors = allow;
+        allowEmptyConstructors = allow;
     }
 
     /**
      * Sets whether or not to ignore the whitespace around the
      * colon in an enhanced for loop.
      * @param ignore {@code true} to ignore enhanced for colon.
      */
     public void setIgnoreEnhancedForColon(boolean ignore) {
         ignoreEnhancedForColon = ignore;
     }
 
     /**
      * Sets whether or not empty type bodies are allowed.
      * @param allow {@code true} to allow empty type bodies.
      */
     public void setAllowEmptyTypes(boolean allow) {
         allowEmptyTypes = allow;
     }
 
     /**
      * Sets whether or not empty loop bodies are allowed.
      * @param allow {@code true} to allow empty loops bodies.
      */
     public void setAllowEmptyLoops(boolean allow) {
         allowEmptyLoops = allow;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int currentType = ast.getType();
         if (isNotRelevantSituation(ast, currentType)) {
             return;
         }
 
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + ast.getText().length();
 
         if (before >= 0 && !Character.isWhitespace(line.charAt(before))) {
             log(ast.getLineNo(), ast.getColumnNo(),
                     WS_NOT_PRECEDED, ast.getText());
         }
 
         if (after >= line.length()) {
             return;
         }
 
         final char nextChar = line.charAt(after);
         if (!Character.isWhitespace(nextChar)
             // Check for "return;"
@@ -447,101 +447,101 @@ public class WhitespaceAroundCheck extends Check {
     private boolean isColonOfCaseOrDefault(int currentType, int parentType) {
         if (currentType == TokenTypes.COLON) {
             //we do not want to check colon for cases and defaults
             if (parentType == TokenTypes.LITERAL_DEFAULT
                 || parentType == TokenTypes.LITERAL_CASE) {
                 return true;
             }
             else if (parentType == TokenTypes.FOR_EACH_CLAUSE
                 && ignoreEnhancedForColon) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Is array initialization
      * @param currentType curret token
      * @param parentType parent token
      * @return true is current token inside array initialization
      */
     private static boolean isArrayInitialization(int currentType, int parentType) {
         return (currentType == TokenTypes.RCURLY
                 || currentType == TokenTypes.LCURLY)
             && (parentType == TokenTypes.ARRAY_INIT
                 || parentType == TokenTypes.ANNOTATION_ARRAY_INIT);
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an allowed empty
      * method block.
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty method block.
      */
     private boolean isEmptyMethodBlock(DetailAST ast, int parentType) {
         return allowEmptyMethods
             && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an allowed empty
      * constructor (ctor) block.
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty constructor block.
      */
     private boolean isEmptyCtorBlock(DetailAST ast, int parentType) {
-        return allowEmptyCtors
+        return allowEmptyConstructors
             && isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
      * @param ast ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty loop block.
      */
     private boolean isEmptyLoop(DetailAST ast, int parentType) {
         return allowEmptyLoops
             && (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)
                     || isEmptyBlock(ast,
                             parentType, TokenTypes.LITERAL_WHILE)
                             || isEmptyBlock(ast,
                                     parentType, TokenTypes.LITERAL_DO));
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
      *
      * @param ast ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         empty block contained under a {@code match} token type
      *         node.
      */
     private static boolean isEmptyType(DetailAST ast, int parentType) {
         final int type = ast.getType();
         return (type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
                 && parentType == TokenTypes.OBJBLOCK;
     }
 
     /**
      * Tests if a given {@code DetailAST} is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * </p>
      * In the above, the method body is an empty block ("{}").
      *
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @param match the parent token type we're looking to match.
      * @return {@code true} if {@code ast} makes up part of an
