diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 0a4e9f6e2..bb5fac4d8 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -584,120 +584,116 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                     col += comment.getStartColNo();
                 }
                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher
                         .group(1), javadocArgMatcher.group(2)));
             }
             else if (javadocNoargMatcher.find()) {
                 int col = javadocNoargMatcher.start(1) - 1;
                 if (i == 0) {
                     col += comment.getStartColNo();
                 }
                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher
                         .group(1)));
             }
             else if (noargCurlyMatcher.find()) {
                 int col = noargCurlyMatcher.start(1) - 1;
                 if (i == 0) {
                     col += comment.getStartColNo();
                 }
                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher
                         .group(1)));
             }
             else if (argMultilineStart.find()) {
                 final String p1 = argMultilineStart.group(1);
                 final String p2 = argMultilineStart.group(2);
                 int col = argMultilineStart.start(1) - 1;
                 if (i == 0) {
                     col += comment.getStartColNo();
                 }
 
                 // Look for the rest of the comment if all we saw was
                 // the tag and the name. Stop when we see '*/' (end of
                 // Javadoc), '@' (start of next tag), or anything that's
                 // not whitespace or '*' characters.
                 int remIndex = i + 1;
                 while (remIndex < lines.length) {
                     final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                             .matcher(lines[remIndex]);
                     if (multilineCont.find()) {
                         remIndex = lines.length;
                         final String lFin = multilineCont.group(1);
                         if (!lFin.equals(NEXT_TAG)
                             && !lFin.equals(END_JAVADOC)) {
                             tags.add(new JavadocTag(currentLine, col, p1, p2));
                         }
                     }
                     remIndex++;
                 }
             }
             else if (noargMultilineStart.find()) {
                 final String p1 = noargMultilineStart.group(1);
-                int col = noargMultilineStart.start(1) - 1;
-                if (i == 0) {
-                    col += comment.getStartColNo();
-                }
+                final int col = noargMultilineStart.start(1) - 1;
 
                 // Look for the rest of the comment if all we saw was
                 // the tag and the name. Stop when we see '*/' (end of
                 // Javadoc), '@' (start of next tag), or anything that's
                 // not whitespace or '*' characters.
                 int remIndex = i + 1;
                 while (remIndex < lines.length) {
                     final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                             .matcher(lines[remIndex]);
-                    if (multilineCont.find()) {
-                        remIndex = lines.length;
-                        final String lFin = multilineCont.group(1);
-                        if (!lFin.equals(NEXT_TAG)
-                            && !lFin.equals(END_JAVADOC)) {
-                            tags.add(new JavadocTag(currentLine, col, p1));
-                        }
+                    multilineCont.find();
+                    remIndex = lines.length;
+                    final String lFin = multilineCont.group(1);
+                    if (!lFin.equals(NEXT_TAG)
+                        && !lFin.equals(END_JAVADOC)) {
+                        tags.add(new JavadocTag(currentLine, col, p1));
                     }
                     remIndex++;
                 }
             }
         }
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private static List<DetailAST> getParameters(DetailAST ast) {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
         final List<DetailAST> retVal = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = child.getNextSibling();
         }
         return retVal;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
         final List<ExceptionInfo> retVal = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     final ExceptionInfo ei = new ExceptionInfo(createClassInfo(new Token(fi),
                             getCurrentClassName()));
                     retVal.add(ei);
                 }
                 child = child.getNextSibling();
@@ -749,102 +745,101 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                 // Loop looking for matching type param
                 final Iterator<DetailAST> typeParamsIt = typeParams.iterator();
                 while (typeParamsIt.hasNext()) {
                     final DetailAST typeParam = typeParamsIt.next();
                     if (typeParam.findFirstToken(TokenTypes.IDENT).getText()
                             .equals(
                                     arg1.substring(1,
                                         arg1.length() - 1))) {
                         found = true;
                         typeParamsIt.remove();
                         break;
                     }
                 }
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", arg1);
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingParamTags && reportExpectedTags) {
             for (DetailAST param : params) {
                 log(param, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(), param.getText());
             }
 
             for (DetailAST typeParam : typeParams) {
                 log(typeParam, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(),
                     "<" + typeParam.findFirstToken(TokenTypes.IDENT).getText()
                     + ">");
             }
         }
     }
 
     /**
      * Checks whether a method is a function.
      *
      * @param ast the method node.
      * @return whether the method is a function.
      */
     private static boolean isFunction(DetailAST ast) {
         boolean retVal = false;
         if (ast.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = ast.findFirstToken(TokenTypes.TYPE);
-            if (typeAST != null
-                && typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null) {
+            if (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null) {
                 retVal = true;
             }
         }
         return retVal;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      *
      * @param tags the tags to check
      * @param lineNo the line number of the expected tag
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkReturnTag(List<JavadocTag> tags, int lineNo,
         boolean reportExpectedTags) {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator<JavadocTag> it = tags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), jt.getColumnNo(),
                         MSG_DUPLICATE_TAG,
                         JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !allowMissingReturnTag && reportExpectedTags) {
             log(lineNo, MSG_RETURN_EXPECTED);
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
@@ -911,154 +906,150 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                         JavadocTagInfo.THROWS.getText(), tag.getArg1());
 
                 }
             }
         }
 
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
             for (ExceptionInfo ei : throwsList) {
                 if (!ei.isFound()) {
                     final Token fi = ei.getName();
                     log(fi.getLineNo(), fi.getColumnNo(),
                         MSG_EXCPECTED_TAG,
                         JavadocTagInfo.THROWS.getText(), fi.getText());
                 }
             }
         }
     }
 
     /**
      * Returns whether an AST represents a setter method.
      * @param ast the AST to check with
      * @return whether the AST represents a setter method
      */
     private static boolean isSetterMethod(final DetailAST ast) {
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper setter method which does not throw any
         // exceptions.
         if (ast.getType() != TokenTypes.METHOD_DEF
                 || ast.getChildCount() != MAX_CHILDREN) {
             return false;
         }
 
         // Should I handle only being in a class????
 
         // Check the name matches format setX...
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final String name = type.getNextSibling().getText();
         if (!name.matches("^set[A-Z].*")) { // Depends on JDK 1.4
             return false;
         }
 
         // Check the return type is void
         if (type.getChildCount(TokenTypes.LITERAL_VOID) == 0) {
             return false;
         }
 
         // Check that is had only one parameter
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if (params == null
-                || params.getChildCount(TokenTypes.PARAMETER_DEF) != 1) {
+        if (params.getChildCount(TokenTypes.PARAMETER_DEF) != 1) {
             return false;
         }
 
         // Now verify that the body consists of:
         // SLIST -> EXPR -> ASSIGN
         // SEMI
         // RCURLY
         final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
         if (slist == null || slist.getChildCount() != BODY_SIZE) {
             return false;
         }
 
         final AST expr = slist.getFirstChild();
-        return expr.getType() == TokenTypes.EXPR
-                && expr.getFirstChild().getType() == TokenTypes.ASSIGN;
+        return expr.getFirstChild().getType() == TokenTypes.ASSIGN;
     }
 
     /**
      * Returns whether an AST represents a getter method.
      * @param ast the AST to check with
      * @return whether the AST represents a getter method
      */
     private static boolean isGetterMethod(final DetailAST ast) {
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper getter method which does not throw any
         // exceptions.
         if (ast.getType() != TokenTypes.METHOD_DEF
                 || ast.getChildCount() != MAX_CHILDREN) {
             return false;
         }
 
         // Check the name matches format of getX or isX. Technically I should
         // check that the format isX is only used with a boolean type.
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final String name = type.getNextSibling().getText();
         if (!name.matches("^(is|get)[A-Z].*")) { // Depends on JDK 1.4
             return false;
         }
 
         // Check the return type is void
         if (type.getChildCount(TokenTypes.LITERAL_VOID) > 0) {
             return false;
         }
 
         // Check that is had only one parameter
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if (params == null
-                || params.getChildCount(TokenTypes.PARAMETER_DEF) > 0) {
+        if (params.getChildCount(TokenTypes.PARAMETER_DEF) > 0) {
             return false;
         }
 
         // Now verify that the body consists of:
         // SLIST -> RETURN
         // RCURLY
         final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
         if (slist == null || slist.getChildCount() != 2) {
             return false;
         }
 
         final AST expr = slist.getFirstChild();
-        return expr.getType() == TokenTypes.LITERAL_RETURN
-                && expr.getFirstChild().getType() == TokenTypes.EXPR;
+        return expr.getType() == TokenTypes.LITERAL_RETURN;
 
     }
 
     /** Stores useful information about declared exception. */
     private static class ExceptionInfo {
         /** does the exception have throws tag associated with. */
         private boolean found;
         /** class information associated with this exception. */
         private final AbstractClassInfo classInfo;
 
         /**
          * Creates new instance for <code>FullIdent</code>.
          *
          * @param classInfo clas info
          */
         ExceptionInfo(AbstractClassInfo classInfo) {
             this.classInfo = classInfo;
         }
 
         /** Mark that the exception has associated throws tag */
         final void setFound() {
             found = true;
         }
 
         /** @return whether the exception has throws tag associated with */
         final boolean isFound() {
             return found;
         }
 
         /** @return exception's name */
         final Token getName() {
             return classInfo.getName();
         }
 
         /** @return class for this exception */
         final Class<?> getClazz() {
             return classInfo.getClazz();
         }
     }
 }
