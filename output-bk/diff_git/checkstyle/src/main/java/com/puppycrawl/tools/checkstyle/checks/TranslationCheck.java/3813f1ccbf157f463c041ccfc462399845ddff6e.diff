diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
index 3610f4fcc..fff37eb5f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
@@ -354,122 +354,122 @@ public class TranslationCheck
      * @param propFiles the set of property files
      * @param basenameSeparator the basename separator
      * @return a Map object which holds the arranged property file sets
      */
     private static SetMultimap<String, File> arrangePropertyFiles(
         List<File> propFiles, String basenameSeparator) {
         final SetMultimap<String, File> propFileMap = HashMultimap.create();
 
         for (final File file : propFiles) {
             final String identifier = extractPropertyIdentifier(file,
                 basenameSeparator);
 
             final Set<File> fileSet = propFileMap.get(identifier);
             fileSet.add(file);
         }
         return propFileMap;
     }
 
     /**
      * Loads the keys of the specified property file into a set.
      * @param file the property file
      * @return a Set object which holds the loaded keys
      */
     private Set<Object> loadKeys(File file) {
         final Set<Object> keys = Sets.newHashSet();
         InputStream inStream = null;
 
         try {
             // Load file and properties.
             inStream = new FileInputStream(file);
             final Properties props = new Properties();
             props.load(inStream);
 
             // Gather the keys and put them into a set
             final Enumeration<?> element = props.propertyNames();
             while (element.hasMoreElements()) {
                 keys.add(element.nextElement());
             }
         }
         catch (final IOException ex) {
             logIoException(ex, file);
         }
         finally {
             Closeables.closeQuietly(inStream);
         }
         return keys;
     }
 
     /**
      * Helper method to log an io exception.
-     * @param ex the exception that occurred
+     * @param exception the exception that occurred
      * @param file the file that could not be processed
      */
-    private void logIoException(IOException ex, File file) {
+    private void logIoException(IOException exception, File file) {
         String[] args = null;
         String key = "general.fileNotFound";
-        if (!(ex instanceof FileNotFoundException)) {
-            args = new String[] {ex.getMessage()};
+        if (!(exception instanceof FileNotFoundException)) {
+            args = new String[] {exception.getMessage()};
             key = "general.exception";
         }
         final LocalizedMessage message =
             new LocalizedMessage(
                 0,
                 Definitions.CHECKSTYLE_BUNDLE,
                 key,
                 args,
                 getId(),
                 getClass(), null);
         final SortedSet<LocalizedMessage> messages = Sets.newTreeSet();
         messages.add(message);
         getMessageDispatcher().fireErrors(file.getPath(), messages);
-        LOG.debug("IOException occurred.", ex);
+        LOG.debug("IOException occurred.", exception);
     }
 
     /**
      * Compares the key sets of the given property files (arranged in a map)
      * with the specified key set. All missing keys are reported.
      * @param keys the set of keys to compare with
      * @param fileMap a Map from property files to their key sets
      */
     private void compareKeySets(Set<Object> keys,
             SetMultimap<File, Object> fileMap) {
 
         for (File currentFile : fileMap.keySet()) {
             final MessageDispatcher dispatcher = getMessageDispatcher();
             final String path = currentFile.getPath();
             dispatcher.fireFileStarted(path);
             final Set<Object> currentKeys = fileMap.get(currentFile);
 
             // Clone the keys so that they are not lost
             final Set<Object> keysClone = Sets.newHashSet(keys);
             keysClone.removeAll(currentKeys);
 
             // Remaining elements in the key set are missing in the current file
             if (!keysClone.isEmpty()) {
                 for (Object key : keysClone) {
                     log(0, MSG_KEY, key);
                 }
             }
             fireErrors(path);
             dispatcher.fireFileFinished(path);
         }
     }
 
     /**
      * Tests whether the given property files (arranged by their prefixes
      * in a Map) contain the proper keys.
      *
      * <p>Each group of files must have the same keys. If this is not the case
      * an error message is posted giving information which key misses in
      * which file.
      *
      * @param propFiles the property files organized as Map
      */
     private void checkPropertyFileSets(SetMultimap<String, File> propFiles) {
 
         for (String key : propFiles.keySet()) {
             final Set<File> files = propFiles.get(key);
 
             if (files.size() >= 2) {
                 // build a map from files to the keys they contain
                 final Set<Object> keys = Sets.newHashSet();
