diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 39fab4548..f579345b6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -865,103 +865,103 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getFirstArg();
             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag
                     .getColumnNo());
             final AbstractClassInfo documentedClassInfo = createClassInfo(token,
                     getCurrentClassName());
             final boolean found = foundThrows.contains(documentedEx)
                     || isInThrows(throwsList, documentedClassInfo, foundThrows);
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedClassInfo.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());
 
                 }
             }
         }
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
-            for (ExceptionInfo ei : throwsList) {
-                if (!ei.isFound()) {
-                    final Token token = ei.getName();
+            for (ExceptionInfo exceptionInfo : throwsList) {
+                if (!exceptionInfo.isFound()) {
+                    final Token token = exceptionInfo.getName();
                     log(token.getLineNo(), token.getColumnNo(),
                             MSG_EXPECTED_TAG,
                             JavadocTagInfo.THROWS.getText(), token.getText());
                 }
             }
         }
     }
 
     /**
      * Verifies that documented exception is in throws.
      *
      * @param throwsList list of throws
      * @param documentedClassInfo documented exception class info
      * @param foundThrows previously found throws
      * @return true if documented exception is in throws.
      */
     private boolean isInThrows(List<ExceptionInfo> throwsList,
             AbstractClassInfo documentedClassInfo, Set<String> foundThrows) {
         boolean found = false;
         ExceptionInfo foundException = null;
 
         // First look for matches on the exception name
         final ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();
         while (!found && throwIt.hasNext()) {
             final ExceptionInfo exceptionInfo = throwIt.next();
 
             if (exceptionInfo.getName().getText().equals(
                     documentedClassInfo.getName().getText())) {
                 found = true;
                 foundException = exceptionInfo;
             }
         }
 
         // Now match on the exception type
         final ListIterator<ExceptionInfo> exceptionInfoIt = throwsList.listIterator();
         while (!found && exceptionInfoIt.hasNext()) {
             final ExceptionInfo exceptionInfo = exceptionInfoIt.next();
 
             if (documentedClassInfo.getClazz() == exceptionInfo.getClazz()) {
                 found = true;
                 foundException = exceptionInfo;
             }
             else if (allowThrowsTagsForSubclasses) {
                 found = isSubclass(documentedClassInfo.getClazz(), exceptionInfo.getClazz());
             }
         }
 
         if (foundException != null) {
             foundException.setFound();
             foundThrows.add(documentedClassInfo.getName().getText());
