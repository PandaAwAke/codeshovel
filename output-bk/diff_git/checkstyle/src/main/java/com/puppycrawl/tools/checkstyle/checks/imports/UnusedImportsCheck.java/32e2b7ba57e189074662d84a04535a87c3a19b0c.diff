diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
index 19a9f8543..23d0df8a4 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
@@ -69,143 +69,128 @@ public class UnusedImportsCheck extends AbstractCheck {
     /** Regex to match argument names. */
     private static final Pattern ARGUMENT_NAME = CommonUtils.createPattern(
            "[(,]\\s*" + CLASS_NAME.pattern());
 
     /** Regexp pattern to match java.lang package. */
     private static final Pattern JAVA_LANG_PACKAGE_PATTERN =
         CommonUtils.createPattern("^java\\.lang\\.[a-zA-Z]+$");
 
     /** Suffix for the star import. */
     private static final String STAR_IMPORT_SUFFIX = ".*";
 
     /** Set of the imports. */
     private final Set<FullIdent> imports = new HashSet<>();
 
     /** Set of references - possibly to imports or other things. */
     private final Set<String> referenced = new HashSet<>();
 
     /** Flag to indicate when time to start collecting references. */
     private boolean collect;
     /** Flag whether to process Javadoc comments. */
     private boolean processJavadoc = true;
 
     /**
      * Sets whether to process JavaDoc or not.
      *
      * @param value Flag for processing JavaDoc.
      */
     public void setProcessJavadoc(boolean value) {
         processJavadoc = value;
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         collect = false;
         imports.clear();
         referenced.clear();
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
         // loop over all the imports to see if referenced.
         imports.stream()
             .filter(imprt -> isUnusedImport(imprt.getText()))
             .forEach(imprt -> log(imprt.getLineNo(),
                 imprt.getColumnNo(),
                 MSG_KEY, imprt.getText()));
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {
-            TokenTypes.IDENT,
-            TokenTypes.IMPORT,
-            TokenTypes.STATIC_IMPORT,
-            // Definitions that may contain Javadoc...
-            TokenTypes.PACKAGE_DEF,
-            TokenTypes.ANNOTATION_DEF,
-            TokenTypes.ANNOTATION_FIELD_DEF,
-            TokenTypes.ENUM_DEF,
-            TokenTypes.ENUM_CONSTANT_DEF,
-            TokenTypes.CLASS_DEF,
-            TokenTypes.INTERFACE_DEF,
-            TokenTypes.METHOD_DEF,
-            TokenTypes.CTOR_DEF,
-            TokenTypes.VARIABLE_DEF,
-        };
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getDefaultTokens();
-    }
-
-    @Override
-    public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.IMPORT,
             TokenTypes.STATIC_IMPORT,
             // Definitions that may contain Javadoc...
             TokenTypes.PACKAGE_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.IDENT) {
             if (collect) {
                 processIdent(ast);
             }
         }
         else if (ast.getType() == TokenTypes.IMPORT) {
             processImport(ast);
         }
         else if (ast.getType() == TokenTypes.STATIC_IMPORT) {
             processStaticImport(ast);
         }
         else {
             collect = true;
             if (processJavadoc) {
                 collectReferencesFromJavadoc(ast);
             }
         }
     }
 
     /**
      * Checks whether an import is unused.
      * @param imprt an import.
      * @return true if an import is unused.
      */
     private boolean isUnusedImport(String imprt) {
         final Matcher javaLangPackageMatcher = JAVA_LANG_PACKAGE_PATTERN.matcher(imprt);
         return !referenced.contains(CommonUtils.baseClassName(imprt))
             || javaLangPackageMatcher.matches();
     }
 
     /**
      * Collects references made by IDENT.
      * @param ast the IDENT node to process
      */
     private void processIdent(DetailAST ast) {
         final DetailAST parent = ast.getParent();
         final int parentType = parent.getType();
         if (parentType != TokenTypes.DOT
             && parentType != TokenTypes.METHOD_DEF
             || parentType == TokenTypes.DOT
                 && ast.getNextSibling() != null) {
             referenced.add(ast.getText());
         }
     }
 
     /**
      * Collects the details of imports.
      * @param ast node containing the import details
