diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index 6f4b14b15..ebbf88f20 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -77,153 +77,166 @@ import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
  * <ul>
  * <li>GregorianCalendar</li>
  * <li>Hashtable</li>
  * <li>ArrayList</li>
  * <li>LinkedList</li>
  * <li>Vector</li>
  * </ul>
  *
  * <p>as methods that are differ from interface methods are rear used, so in most cases user will
  *  benefit from checking for them.
  * </p>
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  * @author <a href="mailto:andreyselkin@gmail.com">Andrei Selkin</a>
  */
 public final class IllegalTypeCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "illegal.type";
 
     /** Abstract classes legal by default. */
     private static final String[] DEFAULT_LEGAL_ABSTRACT_NAMES = {};
     /** Types illegal by default. */
     private static final String[] DEFAULT_ILLEGAL_TYPES = {
         "HashSet",
         "HashMap",
         "LinkedHashMap",
         "LinkedHashSet",
         "TreeSet",
         "TreeMap",
         "java.util.HashSet",
         "java.util.HashMap",
         "java.util.LinkedHashMap",
         "java.util.LinkedHashSet",
         "java.util.TreeSet",
         "java.util.TreeMap",
     };
 
     /** Default ignored method names. */
     private static final String[] DEFAULT_IGNORED_METHOD_NAMES = {
         "getInitialContext",
         "getEnvironment",
     };
 
     /** Illegal classes. */
     private final Set<String> illegalClassNames = new HashSet<>();
+    /** Illegal short classes. */
+    private final Set<String> illegalShortClassNames = new HashSet<>();
     /** Legal abstract classes. */
     private final Set<String> legalAbstractClassNames = new HashSet<>();
     /** Methods which should be ignored. */
     private final Set<String> ignoredMethodNames = new HashSet<>();
     /** Check methods and fields with only corresponding modifiers. */
     private List<Integer> memberModifiers;
 
     /** The regexp to match against. */
     private Pattern format = Pattern.compile("^(.*[.])?Abstract.*$");
 
     /**
      * Controls whether to validate abstract class names.
      */
     private boolean validateAbstractClassNames;
 
     /** Creates new instance of the check. */
     public IllegalTypeCheck() {
         setIllegalClassNames(DEFAULT_ILLEGAL_TYPES);
         setLegalAbstractClassNames(DEFAULT_LEGAL_ABSTRACT_NAMES);
         setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);
     }
 
     /**
      * Set the format for the specified regular expression.
      * @param pattern a pattern.
      */
     public void setFormat(Pattern pattern) {
         format = pattern;
     }
 
     /**
      * Sets whether to validate abstract class names.
      * @param validateAbstractClassNames whether abstract class names must be ignored.
      */
     public void setValidateAbstractClassNames(boolean validateAbstractClassNames) {
         this.validateAbstractClassNames = validateAbstractClassNames;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.IMPORT,
         };
     }
 
+    @Override
+    public void beginTree(DetailAST rootAST) {
+        illegalShortClassNames.clear();
+
+        for (String s : illegalClassNames) {
+            if (s.indexOf('.') == -1) {
+                illegalShortClassNames.add(s);
+            }
+        }
+    }
+
     @Override
     public int[] getRequiredTokens() {
         return new int[] {TokenTypes.IMPORT};
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_DEF:
                 if (isVerifiable(ast)) {
                     visitMethodDef(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (isVerifiable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 visitParameterDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Checks if current method's return type or variable's type is verifiable
      * according to <b>memberModifiers</b> option.
      * @param methodOrVariableDef METHOD_DEF or VARIABLE_DEF ast node.
      * @return true if member is verifiable according to <b>memberModifiers</b> option.
      */
     private boolean isVerifiable(DetailAST methodOrVariableDef) {
         boolean result = true;
         if (memberModifiers != null) {
             final DetailAST modifiersAst = methodOrVariableDef
                     .findFirstToken(TokenTypes.MODIFIERS);
             result = isContainVerifiableType(modifiersAst);
         }
         return result;
     }
 
     /**
      * Checks is modifiers contain verifiable type.
      *
      * @param modifiers
      *            parent node for all modifiers
@@ -286,117 +299,117 @@ public final class IllegalTypeCheck extends AbstractCheck {
             extendIllegalClassNamesWithShortName(canonicalName);
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * {@code
      * import java.util.*;
      * }
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks type of given method, parameter or variable.
      * @param ast node to check.
      */
     private void checkClassName(DetailAST ast) {
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final FullIdent ident = CheckUtils.createFullType(type);
 
         if (isMatchingClassName(ident.getText())) {
             log(ident.getLineNo(), ident.getColumnNo(),
                 MSG_KEY, ident.getText());
         }
     }
 
     /**
      * Returns true if given class name is one of illegal classes or else false.
      * @param className class name to check.
      * @return true if given class name is one of illegal classes
      *         or if it matches to abstract class names pattern.
      */
     private boolean isMatchingClassName(String className) {
         final String shortName = className.substring(className.lastIndexOf('.') + 1);
         return illegalClassNames.contains(className)
-                || illegalClassNames.contains(shortName)
+                || illegalShortClassNames.contains(shortName)
                 || validateAbstractClassNames
                     && !legalAbstractClassNames.contains(className)
                     && format.matcher(className).find();
     }
 
     /**
      * Extends illegal class names set via imported short type name.
      * @param canonicalName
      *  <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  Canonical</a> name of imported type.
      */
     private void extendIllegalClassNamesWithShortName(String canonicalName) {
         if (illegalClassNames.contains(canonicalName)) {
             final String shortName = canonicalName
                 .substring(canonicalName.lastIndexOf('.') + 1);
-            illegalClassNames.add(shortName);
+            illegalShortClassNames.add(shortName);
         }
     }
 
     /**
      * Gets imported type's
      * <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  canonical name</a>.
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return Imported canonical type's name.
      */
     private static String getImportedTypeCanonicalName(DetailAST importAst) {
         final StringBuilder canonicalNameBuilder = new StringBuilder(256);
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
                 canonicalNameBuilder.append(toVisit.getText());
                 final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, importAst);
                 if (nextSubTreeNode.getType() != TokenTypes.SEMI) {
                     canonicalNameBuilder.append('.');
                 }
             }
         }
         return canonicalNameBuilder.toString();
     }
 
     /**
      * Gets the next node of a syntactical tree (child of a current node or
      * sibling of a current node, or sibling of a parent of a current node).
      * @param currentNodeAst Current node in considering
      * @param subTreeRootAst SubTree root
      * @return Current node after bypassing, if current node reached the root of a subtree
      *        method returns null
      */
     private static DetailAST
         getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
         DetailAST currentNode = currentNodeAst;
         DetailAST toVisitAst = currentNode.getFirstChild();
         while (toVisitAst == null) {
             toVisitAst = currentNode.getNextSibling();
             if (toVisitAst == null) {
                 if (currentNode.getParent().equals(subTreeRootAst)) {
                     break;
                 }
                 currentNode = currentNode.getParent();
             }
         }
         return toVisitAst;
     }
 
