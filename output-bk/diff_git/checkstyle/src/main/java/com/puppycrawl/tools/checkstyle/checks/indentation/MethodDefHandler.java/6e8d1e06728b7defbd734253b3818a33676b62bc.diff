diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java
index 5f264772c..b6d7324ba 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java
@@ -66,83 +66,83 @@ public class MethodDefHandler extends BlockParentHandler {
         if (throwsAst != null) {
             checkWrappingIndentation(throwsAst, throwsAst.getNextSibling(), getIndentCheck()
                     .getThrowsIndent(), getLineStart(getMethodDefLineStart(getMainAst())),
                     !isOnStartOfLine(throwsAst));
         }
     }
 
     /**
      * Gets the start line of the method, excluding any annotations. This is required because the
      * current {@link TokenTypes#METHOD_DEF} may not always be the start as seen in
      * https://github.com/checkstyle/checkstyle/issues/3145.
      *
      * @param mainAst
      *            The method definition ast.
      * @return The start column position of the method.
      */
     private int getMethodDefLineStart(DetailAST mainAst) {
         // get first type position
         int lineStart = mainAst.findFirstToken(TokenTypes.IDENT).getLineNo();
 
         // check if there is a type before the indent
         final DetailAST typeNode = mainAst.findFirstToken(TokenTypes.TYPE);
         if (typeNode != null) {
             lineStart = getFirstLine(lineStart, typeNode);
         }
 
         // check if there is a modifier before the type
         for (DetailAST node = mainAst.findFirstToken(TokenTypes.MODIFIERS).getFirstChild();
                 node != null;
                 node = node.getNextSibling()) {
             // skip annotations as we check them else where as outside the method
             if (node.getType() == TokenTypes.ANNOTATION) {
                 continue;
             }
 
             if (node.getLineNo() < lineStart) {
                 lineStart = node.getLineNo();
             }
         }
 
         return lineStart;
     }
 
     @Override
     public void checkIndentation() {
         checkModifiers();
         checkThrows();
 
         checkWrappingIndentation(getMainAst(), getMethodDefParamRightParen(getMainAst()));
         // abstract method def -- no body
-        if (getLCurly() != null) {
+        if (getLeftCurly() != null) {
             super.checkIndentation();
         }
     }
 
     /**
      * Returns right parenthesis of method definition parameter list.
      * @param methodDefAst
      *          method definition ast node(TokenTypes.LITERAL_IF)
      * @return right parenthesis of method definition parameter list.
      */
     private static DetailAST getMethodDefParamRightParen(DetailAST methodDefAst) {
         return methodDefAst.findFirstToken(TokenTypes.RPAREN);
     }
 
     /**
      * Creates a handler name for this class according to ast type.
      *
      * @param ast the abstract syntax tree.
      * @return handler name for this class.
      */
     private static String getHandlerName(DetailAST ast) {
         final String name;
 
         if (ast.getType() == TokenTypes.CTOR_DEF) {
             name = "ctor def";
         }
         else {
             name = "method def";
         }
         return name;
     }
 }
