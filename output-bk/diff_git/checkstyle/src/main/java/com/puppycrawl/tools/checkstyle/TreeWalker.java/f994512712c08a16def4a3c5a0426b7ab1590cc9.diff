diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index f0fd4a1b9..c2f9fe17a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -162,131 +162,137 @@ public final class TreeWalker extends AbstractFileSetCheck implements ExternalRe
      * @noinspection ChainOfInstanceofChecks
      */
     @Override
     public void setupChild(Configuration childConf)
             throws CheckstyleException {
         final String name = childConf.getName();
         final Object module = moduleFactory.createModule(name);
         if (module instanceof AutomaticBean) {
             final AutomaticBean bean = (AutomaticBean) module;
             bean.contextualize(childContext);
             bean.configure(childConf);
         }
         if (module instanceof AbstractCheck) {
             final AbstractCheck check = (AbstractCheck) module;
             check.init();
             registerCheck(check);
         }
         else if (module instanceof TreeWalkerFilter) {
             final TreeWalkerFilter filter = (TreeWalkerFilter) module;
             filters.add(filter);
         }
         else {
             throw new CheckstyleException(
                 "TreeWalker is not allowed as a parent of " + name
                         + " Please review 'Parent Module' section for this Check in web"
                         + " documentation if Check is standard.");
         }
     }
 
     @Override
     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {
         // check if already checked and passed the file
         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {
             final String msg = "%s occurred during the analysis of file %s.";
             final String fileName = file.getPath();
 
             try {
                 if (!ordinaryChecks.isEmpty()
                         || !commentChecks.isEmpty()) {
                     final FileContents contents = new FileContents(fileText);
                     final DetailAST rootAST = parse(contents);
 
                     if (!ordinaryChecks.isEmpty()) {
                         walk(rootAST, contents, AstState.ORDINARY);
                     }
                     if (!commentChecks.isEmpty()) {
                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);
 
                         walk(astWithComments, contents, AstState.WITH_COMMENTS);
                     }
-                    final SortedSet<LocalizedMessage> filteredMessages =
-                            getFilteredMessages(fileName, contents);
-                    addMessages(filteredMessages);
+                    if (filters.isEmpty()) {
+                        addMessages(messages);
+                    }
+                    else {
+                        final SortedSet<LocalizedMessage> filteredMessages =
+                            getFilteredMessages(fileName, contents, rootAST);
+                        addMessages(filteredMessages);
+                    }
                     messages.clear();
                 }
             }
             catch (final TokenStreamRecognitionException tre) {
                 final String exceptionMsg = String.format(Locale.ROOT, msg,
                         "TokenStreamRecognitionException", fileName);
                 throw new CheckstyleException(exceptionMsg, tre);
             }
             catch (RecognitionException | TokenStreamException ex) {
                 final String exceptionMsg = String.format(Locale.ROOT, msg,
                         ex.getClass().getSimpleName(), fileName);
                 throw new CheckstyleException(exceptionMsg, ex);
             }
         }
     }
 
     /**
      * Returns filtered set of {@link LocalizedMessage}.
      * @param fileName path to the file
      * @param fileContents the contents of the file
+     * @param rootAST root AST element {@link DetailAST} of the file
      * @return filtered set of messages
      */
-    private SortedSet<LocalizedMessage> getFilteredMessages(String fileName,
-                                                            FileContents fileContents) {
+    private SortedSet<LocalizedMessage> getFilteredMessages(
+            String fileName, FileContents fileContents, DetailAST rootAST) {
         final SortedSet<LocalizedMessage> result = new TreeSet<>(messages);
         for (LocalizedMessage element : messages) {
             final TreeWalkerAuditEvent event =
-                    new TreeWalkerAuditEvent(fileContents, fileName, element);
+                    new TreeWalkerAuditEvent(fileContents, fileName, element, rootAST);
             for (TreeWalkerFilter filter : filters) {
                 if (!filter.accept(event)) {
                     result.remove(element);
                     break;
                 }
             }
         }
         return result;
     }
 
     /**
      * Register a check for a given configuration.
      * @param check the check to register
      * @throws CheckstyleException if an error occurs
      */
     private void registerCheck(AbstractCheck check)
             throws CheckstyleException {
         validateDefaultTokens(check);
         final int[] tokens;
         final Set<String> checkTokens = check.getTokenNames();
         if (checkTokens.isEmpty()) {
             tokens = check.getDefaultTokens();
         }
         else {
             tokens = check.getRequiredTokens();
 
             //register configured tokens
             final int[] acceptableTokens = check.getAcceptableTokens();
             Arrays.sort(acceptableTokens);
             for (String token : checkTokens) {
                 final int tokenId = TokenUtils.getTokenId(token);
                 if (Arrays.binarySearch(acceptableTokens, tokenId) >= 0) {
                     registerCheck(token, check);
                 }
                 else {
                     final String message = String.format(Locale.ROOT, "Token \"%s\" was "
                             + "not found in Acceptable tokens list in check %s",
                             token, check.getClass().getName());
                     throw new CheckstyleException(message);
                 }
             }
         }
         for (int element : tokens) {
             registerCheck(element, check);
         }
         if (check.isCommentNodesRequired()) {
             commentChecks.add(check);
         }
         else {
             ordinaryChecks.add(check);
