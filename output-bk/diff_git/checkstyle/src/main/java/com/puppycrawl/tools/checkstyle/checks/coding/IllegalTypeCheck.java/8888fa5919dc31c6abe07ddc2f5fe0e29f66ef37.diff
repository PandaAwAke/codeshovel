diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index 9825b30e1..c81267b58 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -1,84 +1,83 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2016 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
-import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
 
 /**
  * Checks that particular class are never used as types in variable
  * declarations, return values or parameters.
  *
  * <p>Rationale:
  * Helps reduce coupling on concrete classes.
  *
  * <p>Check has following properties:
  *
  * <p><b>format</b> - Pattern for illegal class names.
  *
  * <p><b>legalAbstractClassNames</b> - Abstract classes that may be used as types.
  *
  * <p><b>illegalClassNames</b> - Classes that should not be used as types in variable
    declarations, return values or parameters.
  * It is possible to set illegal class names via short or
  * <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
  *  canonical</a> name.
  *  Specifying illegal type invokes analyzing imports and Check puts violations at
  *   corresponding declarations
  *  (of variables, methods or parameters). This helps to avoid ambiguous cases, e.g.:
  *
  * <p>{@code java.awt.List} was set as illegal class name, then, code like:
  *
  * <p>{@code
  * import java.util.List;<br>
  * ...<br>
  * List list; //No violation here
  * }
  *
  * <p>will be ok.
  *
  * <p><b>validateAbstractClassNames</b> - controls whether to validate abstract class names.
  * Default value is <b>false</b>
  * </p>
  *
  * <p><b>ignoredMethodNames</b> - Methods that should not be checked.
  *
  * <p><b>memberModifiers</b> - To check only methods and fields with only specified modifiers.
  *
  * <p>In most cases it's justified to put following classes to <b>illegalClassNames</b>:
  * <ul>
  * <li>GregorianCalendar</li>
  * <li>Hashtable</li>
  * <li>ArrayList</li>
  * <li>LinkedList</li>
  * <li>Vector</li>
  * </ul>
@@ -104,107 +103,106 @@ public final class IllegalTypeCheck extends AbstractCheck {
     /** Types illegal by default. */
     private static final String[] DEFAULT_ILLEGAL_TYPES = {
         "HashSet",
         "HashMap",
         "LinkedHashMap",
         "LinkedHashSet",
         "TreeSet",
         "TreeMap",
         "java.util.HashSet",
         "java.util.HashMap",
         "java.util.LinkedHashMap",
         "java.util.LinkedHashSet",
         "java.util.TreeSet",
         "java.util.TreeMap",
     };
 
     /** Default ignored method names. */
     private static final String[] DEFAULT_IGNORED_METHOD_NAMES = {
         "getInitialContext",
         "getEnvironment",
     };
 
     /** Illegal classes. */
     private final Set<String> illegalClassNames = new HashSet<>();
     /** Legal abstract classes. */
     private final Set<String> legalAbstractClassNames = new HashSet<>();
     /** Methods which should be ignored. */
     private final Set<String> ignoredMethodNames = new HashSet<>();
     /** Check methods and fields with only corresponding modifiers. */
     private List<Integer> memberModifiers;
 
     /** The format string of the regexp. */
     private String format = "^(.*[.])?Abstract.*$";
 
     /** The regexp to match against. */
     private Pattern regexp = Pattern.compile(format);
 
     /**
      * Controls whether to validate abstract class names.
      */
     private boolean validateAbstractClassNames;
 
     /** Creates new instance of the check. */
     public IllegalTypeCheck() {
         setIllegalClassNames(DEFAULT_ILLEGAL_TYPES);
         setLegalAbstractClassNames(DEFAULT_LEGAL_ABSTRACT_NAMES);
         setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);
     }
 
     /**
-     * Set the format to the specified regular expression.
-     * @param format a {@code String} value
-     * @throws org.apache.commons.beanutils.ConversionException unable to parse format
+     * Set the format for the specified regular expression.
+     * @param pattern a pattern.
      */
-    public void setFormat(String format) {
-        this.format = format;
-        regexp = CommonUtils.createPattern(format);
+    public void setFormat(Pattern pattern) {
+        format = pattern.pattern();
+        regexp = pattern;
     }
 
     /**
      * Sets whether to validate abstract class names.
      * @param validateAbstractClassNames whether abstract class names must be ignored.
      */
     public void setValidateAbstractClassNames(boolean validateAbstractClassNames) {
         this.validateAbstractClassNames = validateAbstractClassNames;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {TokenTypes.IMPORT};
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_DEF:
                 if (isVerifiable(ast)) {
                     visitMethodDef(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (isVerifiable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 visitParameterDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
