diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
index fa9e3ec21..849e58f38 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
@@ -112,102 +112,114 @@ public class DesignForExtensionCheck extends AbstractCheck {
      */
     public void setIgnoredAnnotations(String... ignoredAnnotations) {
         this.ignoredAnnotations = Arrays.stream(ignoredAnnotations).collect(Collectors.toSet());
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         // The check does not subscribe to CLASS_DEF token as now it is stateless. If the check
         // subscribes to CLASS_DEF token it will become stateful, since we need to have additional
         // stack to hold CLASS_DEF tokens.
         return new int[] {TokenTypes.METHOD_DEF};
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (!hasJavadocComment(ast)
                 && canBeOverridden(ast)
                 && (isNativeMethod(ast)
                     || !hasEmptyImplementation(ast))
                 && !hasIgnoredAnnotation(ast, ignoredAnnotations)) {
             final DetailAST classDef = getNearestClassOrEnumDefinition(ast);
             if (canBeSubclassed(classDef)) {
                 final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();
                 final String methodName = ast.findFirstToken(TokenTypes.IDENT).getText();
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY, className, methodName);
             }
         }
     }
 
     /**
      * Checks whether a method has a javadoc comment.
      * @param methodDef method definition token.
      * @return true if a method has a javadoc comment.
      */
     private static boolean hasJavadocComment(DetailAST methodDef) {
-        final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
-        return modifiers.branchContains(TokenTypes.BLOCK_COMMENT_BEGIN);
+        return hasJavadocCommentOnToken(methodDef, TokenTypes.MODIFIERS)
+                || hasJavadocCommentOnToken(methodDef, TokenTypes.TYPE);
+    }
+
+    /**
+     * Checks whether a token has a javadoc comment.
+     *
+     * @param methodDef method definition token.
+     * @param tokenType token type.
+     * @return true if a token has a javadoc comment.
+     */
+    private static boolean hasJavadocCommentOnToken(DetailAST methodDef, int tokenType) {
+        final DetailAST token = methodDef.findFirstToken(tokenType);
+        return token.branchContains(TokenTypes.BLOCK_COMMENT_BEGIN);
     }
 
     /**
      * Checks whether a methods is native.
      * @param ast method definition token.
      * @return true if a methods is native.
      */
     private static boolean isNativeMethod(DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         return mods.findFirstToken(TokenTypes.LITERAL_NATIVE) != null;
     }
 
     /**
      * Checks whether a method has only comments in the body (has an empty implementation).
      * Method is OK if its implementation is empty.
      * @param ast method definition token.
      * @return true if a method has only comments in the body.
      */
     private static boolean hasEmptyImplementation(DetailAST ast) {
         boolean hasEmptyBody = true;
         final DetailAST methodImplOpenBrace = ast.findFirstToken(TokenTypes.SLIST);
         final DetailAST methodImplCloseBrace = methodImplOpenBrace.getLastChild();
         final Predicate<DetailAST> predicate = currentNode -> {
             return currentNode != methodImplCloseBrace
                 && !TokenUtils.isCommentType(currentNode.getType());
         };
         final Optional<DetailAST> methodBody =
             TokenUtils.findFirstTokenByPredicate(methodImplOpenBrace, predicate);
         if (methodBody.isPresent()) {
             hasEmptyBody = false;
         }
         return hasEmptyBody;
     }
 
     /**
      * Checks whether a method can be overridden.
      * Method can be overridden if it is not private, abstract, final or static.
      * Note that the check has nothing to do for interfaces.
      * @param methodDef method definition token.
      * @return true if a method can be overridden in a subclass.
      */
     private static boolean canBeOverridden(DetailAST methodDef) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         return ScopeUtils.getSurroundingScope(methodDef).isIn(Scope.PROTECTED)
             && !ScopeUtils.isInInterfaceOrAnnotationBlock(methodDef)
             && modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null
             && modifiers.findFirstToken(TokenTypes.ABSTRACT) == null
             && modifiers.findFirstToken(TokenTypes.FINAL) == null
             && modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) == null;
     }
