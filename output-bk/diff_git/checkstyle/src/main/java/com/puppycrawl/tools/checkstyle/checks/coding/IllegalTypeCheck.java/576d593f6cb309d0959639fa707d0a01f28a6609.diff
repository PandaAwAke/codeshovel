diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index 49f3c0632..b3ba08b86 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -204,245 +204,216 @@ public final class IllegalTypeCheck extends AbstractFormatCheck {
                 for (DetailAST modifier = modifiersAst.getFirstChild(); modifier != null;
                          modifier = modifier.getNextSibling()) {
                     if (memberModifiers.contains(modifier.getType())) {
                         result = true;
                     }
                 }
             }
         }
         return result;
     }
 
     /**
      * Checks return type of a given method.
      * @param methodDef method for check.
      */
     private void visitMethodDef(DetailAST methodDef) {
         if (isCheckedMethod(methodDef)) {
             checkClassName(methodDef);
         }
     }
 
     /**
      * Checks type of parameters.
      * @param paradef parameter list for check.
      */
     private void visitParameterDef(DetailAST paradef) {
         final DetailAST grandParentAST = paradef.getParent().getParent();
 
         if (grandParentAST.getType() == TokenTypes.METHOD_DEF
             && isCheckedMethod(grandParentAST)) {
             checkClassName(paradef);
         }
     }
 
     /**
      * Checks type of given variable.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         checkClassName(variableDef);
     }
 
     /**
      * Checks imported type (as static and star imports are not supported by Check,
      *  only type is in the consideration).<br>
      * If this type is illegal due to Check's options - puts violation on it.
      * @param importAst {@link TokenTypes#IMPORT Import}
      */
     private void visitImport(DetailAST importAst) {
         if (!isStarImport(importAst)) {
-            final String canonicalName = getCanonicalName(importAst);
+            final String canonicalName = getImportedTypeCanonicalName(importAst);
             extendIllegalClassNamesWithShortName(canonicalName);
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * <code>
      * import java.util.*;
      * </code>
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks type of given method, parameter or variable.
      * @param ast node to check.
      */
     private void checkClassName(DetailAST ast) {
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final FullIdent ident = CheckUtils.createFullType(type);
 
         if (isMatchingClassName(ident.getText())) {
             log(ident.getLineNo(), ident.getColumnNo(),
                 MSG_KEY, ident.getText());
         }
     }
 
     /**
      * @param className class name to check.
      * @return true if given class name is one of illegal classes
      *         or if it matches to abstract class names pattern.
      */
     private boolean isMatchingClassName(String className) {
         final String shortName = className.substring(className.lastIndexOf('.') + 1);
         return illegalClassNames.contains(className)
                 || illegalClassNames.contains(shortName)
                 || !legalAbstractClassNames.contains(className)
                     && getRegexp().matcher(className).find();
     }
 
     /**
      * Extends illegal class names set via imported short type name.
      * @param canonicalName
      *  <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  Canonical</a> name of imported type.
      */
     private void extendIllegalClassNamesWithShortName(String canonicalName) {
         if (illegalClassNames.contains(canonicalName)) {
             final String shortName = canonicalName
                 .substring(canonicalName.lastIndexOf('.') + 1);
             illegalClassNames.add(shortName);
         }
     }
 
     /**
      * Gets imported type's
      * <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  canonical name</a>.
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return Imported canonical type's name.
      */
-    private static String getCanonicalName(DetailAST importAst) {
+    private static String getImportedTypeCanonicalName(DetailAST importAst) {
         final StringBuilder canonicalNameBuilder = new StringBuilder();
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
-            if (toVisit != null
-                   && (toVisit.getType() == TokenTypes.IDENT
-                      || toVisit.getType() == TokenTypes.STAR)) {
+            if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
                 canonicalNameBuilder.append(toVisit.getText());
                 final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, importAst);
                 if (nextSubTreeNode.getType() != TokenTypes.SEMI) {
                     canonicalNameBuilder.append('.');
                 }
             }
         }
         return canonicalNameBuilder.toString();
     }
 
     /**
      * Gets the next node of a syntactical tree (child of a current node or
      * sibling of a current node, or sibling of a parent of a current node)
      * @param currentNodeAst Current node in considering
      * @param subTreeRootAst SubTree root
      * @return Current node after bypassing, if current node reached the root of a subtree
      *        method returns null
      */
     private static DetailAST
         getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
         DetailAST currentNode = currentNodeAst;
         DetailAST toVisitAst = currentNode.getFirstChild();
         while (toVisitAst == null) {
             toVisitAst = currentNode.getNextSibling();
             if (toVisitAst == null) {
                 if (currentNode.getParent().equals(subTreeRootAst)) {
                     break;
                 }
                 currentNode = currentNode.getParent();
             }
         }
         currentNode = toVisitAst;
         return currentNode;
     }
 
     /**
      * @param ast method def to check.
      * @return true if we should check this method.
      */
     private boolean isCheckedMethod(DetailAST ast) {
         final String methodName =
             ast.findFirstToken(TokenTypes.IDENT).getText();
         return !ignoredMethodNames.contains(methodName);
     }
 
     /**
      * Set the list of illegal variable types.
      * @param classNames array of illegal variable types
      */
     public void setIllegalClassNames(String... classNames) {
         illegalClassNames.clear();
         Collections.addAll(illegalClassNames, classNames);
     }
 
-    /**
-     * Get the list of illegal variable types.
-     * @return array of illegal variable types
-     */
-    public String[] getIllegalClassNames() {
-        return illegalClassNames.toArray(
-            new String[illegalClassNames.size()]);
-    }
-
     /**
      * Set the list of ignore method names.
      * @param methodNames array of ignored method names
      */
     public void setIgnoredMethodNames(String... methodNames) {
         ignoredMethodNames.clear();
         Collections.addAll(ignoredMethodNames, methodNames);
     }
 
-    /**
-     * Get the list of ignored method names.
-     * @return array of ignored method names
-     */
-    public String[] getIgnoredMethodNames() {
-        return ignoredMethodNames.toArray(
-            new String[ignoredMethodNames.size()]);
-    }
-
     /**
      * Set the list of legal abstract class names.
      * @param classNames array of legal abstract class names
      */
     public void setLegalAbstractClassNames(String... classNames) {
         legalAbstractClassNames.clear();
         Collections.addAll(legalAbstractClassNames, classNames);
     }
 
-    /**
-     * Get the list of legal abstract class names.
-     * @return array of legal abstract class names
-     */
-    public String[] getLegalAbstractClassNames() {
-        return legalAbstractClassNames.toArray(
-            new String[legalAbstractClassNames.size()]);
-    }
-
     /**
      * Set the list of member modifiers (of methods and fields) which should be checked.
      * @param modifiers String contains modifiers.
      */
     public void setMemberModifiers(String modifiers) {
         final List<Integer> modifiersList = new ArrayList<>();
         for (String modifier : modifiers.split(",")) {
             modifiersList.add(Utils.getTokenId(modifier.trim()));
         }
         this.memberModifiers = modifiersList;
     }
 }
