diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index 47f63ec86..59e0ad0ef 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -281,101 +281,101 @@ public class CustomImportOrderCheck extends Check
                     lineNo, getImportGroup(isStatic, importFullPath),
                     isStatic));
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST)
     {
 
         if (importToGroupList.isEmpty()) {
             return;
         }
 
         final ImportDetails firstImport = importToGroupList.get(0);
         String currentGroup = getImportGroup(firstImport.isStatic(),
                 firstImport.getImportFullPath());
         int groupNumber = customImportOrderRules.indexOf(currentGroup);
         String previousImport = null;
 
         for (ImportDetails importObject : importToGroupList) {
             final String importGroup = importObject.getImportGroup();
             final String fullImportIdent = importObject.importFullPath;
 
             if (!importGroup.equals(currentGroup)) {
                 if (customImportOrderRules.size() > groupNumber + 1) {
                     final String nextGroup = getNextImportGroup(groupNumber + 1);
                     if (importGroup.equals(nextGroup)) {
                         if (separateLineBetweenGroups && previousImport != null
                                 && !hasEmptyLineBefore(importObject.getLineNumber()))
                         {
                             log(importObject.getLineNumber(), "custom.import.order.line.separator",
                                     fullImportIdent);
                         }
                         currentGroup = nextGroup;
                         groupNumber = customImportOrderRules.indexOf(nextGroup);
                     }
                     else {
                         logWrongImportGroupOrder(importObject.getLineNumber(),
                                 importGroup);
                     }
                 }
                 else {
                     logWrongImportGroupOrder(importObject.getLineNumber(),
                             importGroup);
                 }
             }
             else if (sortImportsInGroupAlphabetically
                     && previousImport != null
                     && matchesImportGroup(importObject.isStatic(),
                             fullImportIdent, currentGroup)
-                    && !(compare(fullImportIdent, previousImport) >= 0))
+                    && !(compareImports(fullImportIdent, previousImport) >= 0))
             {
                 log(importObject.getLineNumber(), "custom.import.order.lex", fullImportIdent);
             }
             previousImport = fullImportIdent;
         }
     }
 
     /**
      * Log wrong import group order.
      * @param currentImportLine
      *        line number of current import current import.
      * @param importGroup
      *        import group.
      */
     private void logWrongImportGroupOrder(int currentImportLine, String importGroup)
     {
         if (NON_GROUP_RULE_GROUP.equals(importGroup)) {
             log(currentImportLine, "custom.import.order.nongroup.import");
         }
         else {
             log(currentImportLine, "custom.import.order", importGroup);
         }
     }
 
     /**
      * Get next import group.
      * @param currentGroupNumber
      *        current group number.
      * @return
      *        next import group.
      */
     private String getNextImportGroup(int currentGroupNumber)
     {
         int nextGroupNumber = currentGroupNumber;
 
         while (customImportOrderRules.size() > nextGroupNumber + 1) {
             if (hasAnyImportInCurrentGroup(customImportOrderRules.get(nextGroupNumber)))
             {
                 break;
             }
             nextGroupNumber++;
         }
         return customImportOrderRules.get(nextGroupNumber);
     }
 
     /**
      * Checks if current group contains any import.
      * @param currentGroup
      *        current group.
      * @return
@@ -466,189 +466,141 @@ public class CustomImportOrderCheck extends Check
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the static group.
      */
     private boolean matchesStandartImportGroup(boolean isStatic,
         String currentImport, String currentGroup)
     {
         return !isStatic && STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && standardPackageRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the static group.
      */
     private boolean matchesSpecialImportsGroup(boolean isStatic,
         String currentImport, String currentGroup)
     {
         return !isStatic && SPECIAL_IMPORTS_RULE_GROUP.equals(currentGroup)
                 && specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the static group.
      */
     private boolean matcheasthirdPartyImportGroup(boolean isStatic,
         String currentImport, String currentGroup)
     {
         return !isStatic && THIRD_PARTY_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && thirdPartyPackageRegExp.matcher(currentImport).find()
                 && !standardPackageRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks compare two import paths.
-     * @param currentImport
+     * @param import1
      *        current import.
-     * @param previousImport
+     * @param import2
      *        previous import.
      * @return a negative integer, zero, or a positive integer as the
      *        specified String is greater than, equal to, or less
      *        than this String, ignoring case considerations.
      */
-    private int compare(String currentImport, String previousImport)
+    private static int compareImports(String import1, String import2)
     {
-        int indexOfPreviousDotCurrent = 0;
-        int indexOfNextDotCurrent = 0;
-        String tokenCurrent = "";
-        int indexOfPreviousDotPrevious = 0;
-        int indexOfNextDotPrevious = 0;
-        String tokenPrevious = "";
-        final int currentImportDomainCount = countDomains(currentImport);
-        final int previousImportDomainCount = countDomains(previousImport);
         int result = 0;
-
-        while (currentImport.lastIndexOf(".") != indexOfPreviousDotCurrent - 1
-                && previousImport.lastIndexOf(".") != indexOfPreviousDotPrevious - 1)
-        {
-            indexOfNextDotCurrent = currentImport.indexOf(".", indexOfPreviousDotCurrent + 1);
-            indexOfNextDotPrevious = previousImport.indexOf(".", indexOfPreviousDotPrevious + 1);
-            tokenCurrent = currentImport.substring(indexOfPreviousDotCurrent,
-                    indexOfNextDotCurrent);
-            tokenPrevious = previousImport.substring(indexOfPreviousDotPrevious,
-                    indexOfNextDotPrevious);
-            result = tokenCurrent.compareToIgnoreCase(tokenPrevious);
-            if (result != 0) {
-                return result;
-            }
-            indexOfPreviousDotCurrent = indexOfNextDotCurrent + 1;
-            indexOfPreviousDotPrevious = indexOfNextDotPrevious + 1;
-        }
-
-        if (result == 0 && (currentImport.lastIndexOf(".") == indexOfPreviousDotCurrent - 1
-                || previousImport.lastIndexOf(".") == indexOfPreviousDotPrevious - 1))
-        {
-            if (currentImportDomainCount != previousImportDomainCount) {
-                getClassName(indexOfNextDotPrevious, previousImport);
-                return currentImportDomainCount - previousImportDomainCount;
+        final String[] import1Tokens = import1.split("\\.");
+        final String[] import2Tokens = import2.split("\\.");
+        for (int i = 0; i < import1Tokens.length; i++) {
+            if (i == import2Tokens.length) {
+                break;
             }
-            else {
-                getClassName(indexOfNextDotPrevious, previousImport);
-                return getClassName(indexOfNextDotCurrent,
-                        currentImport).compareToIgnoreCase(getClassName(indexOfNextDotPrevious,
-                                previousImport));
+            final String import1Token = import1Tokens[i];
+            final String import2Token = import2Tokens[i];
+            result = import1Token.compareToIgnoreCase(import2Token);
+            if (result != 0) {
+                break;
             }
         }
-        return 0;
+        return result;
     }
 
     /**
      * Return class name from import full path.
      * @param startFrom number of start.
      * @param importPath import full path.
      * @return class name.
      */
     private String getClassName(int startFrom, String importPath)
     {
         String className = importPath;
         className = className.substring(startFrom, className.length());
         final StringTokenizer token = new StringTokenizer(className, ".\r");
         return token.nextToken();
     }
 
-    /**
-     * Count number of domains.
-     * @param importPath current import.
-     * @return number of domains.
-     */
-    private static int countDomains(String importPath)
-    {
-        final StringTokenizer tokens = new StringTokenizer(importPath, ".");
-        int count = 0;
-
-        while (tokens.hasMoreTokens()) {
-            if (!Character.isUpperCase(tokens.nextToken().toString().charAt(0))) {
-                count++;
-            }
-            else {
-                break;
-            }
-        }
-        return count - 1;
-    }
-
     /**
      * Checks if a token has a empty line before.
      * @param lineNo
      *        Line number of current import.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(int lineNo)
     {
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         final String lineBefore = getLine(lineNo - 2);
         return lineBefore.trim().isEmpty();
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token)
     {
         return token != null ? FullIdent.createFullIdent(token.
                 findFirstToken(TokenTypes.DOT)).getText() : "";
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRuleastoList(String ruleStr)
     {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr))
         {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
             final String rule = ruleStr.substring(ruleStr.indexOf("(") + 1,
                     ruleStr.indexOf(")"));
             try {
                 samePackageMatchingDepth = Integer.parseInt(rule);
             }
             catch (Exception e) {
                 samePackageDomainsRegExp = rule;
