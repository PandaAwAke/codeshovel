diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 4a18bfb97..3f664d523 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -442,101 +442,101 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
             final DetailAST ident = methodDef.findFirstToken(TokenTypes.IDENT);
             final String methodName = ident.getText();
 
             final Matcher matcher = ignoreMethodNamesRegex.matcher(methodName);
             if (matcher.matches()) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Whether we should check this node.
      *
      * @param ast a given node.
      * @param nodeScope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST ast, final Scope nodeScope) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(ast);
 
         return nodeScope.isIn(scope)
                 && surroundingScope.isIn(scope)
                 && (excludeScope == null || !nodeScope.isIn(excludeScope)
                     || !surroundingScope.isIn(excludeScope));
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param ast the token for the method
      * @param comment the Javadoc comment
      */
     private void checkComment(DetailAST ast, TextBlock comment) {
         final List<JavadocTag> tags = getMethodTags(comment);
 
         if (hasShortCircuitTag(ast, tags)) {
             return;
         }
 
         Iterator<JavadocTag> it = tags.iterator();
         if (ast.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
                 hasInheritDocTag = it.next().isInheritDocTag();
             }
 
             checkParamTags(tags, ast, !hasInheritDocTag);
             checkThrowsTags(tags, getThrows(ast), !hasInheritDocTag);
-            if (isFunction(ast)) {
+            if (CheckUtils.isVoidMethod(ast)) {
                 checkReturnTag(tags, ast.getLineNo(), !hasInheritDocTag);
             }
         }
 
         // Dump out all unused tags
         it = tags.iterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (!jt.isSeeOrInheritDocTag()) {
                 log(jt.getLineNo(), MSG_UNUSED_TAG_GENERAL);
             }
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param ast the construct being checked
      * @param tags the list of Javadoc tags associated with the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST ast,
             final List<JavadocTag> tags) {
         // Check if it contains {@inheritDoc} tag
         if (tags.size() != 1
                 || !tags.get(0).isInheritDocTag()) {
             return false;
         }
 
         // Invalid if private, a constructor, or a static method
         if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
             log(ast, MSG_INVALID_INHERIT_DOC);
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private static Scope calculateScope(final DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
 
@@ -700,169 +700,162 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
         final List<ExceptionInfo> retVal = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     final ExceptionInfo ei = new ExceptionInfo(createClassInfo(new Token(fi),
                             getCurrentClassName()));
                     retVal.add(ei);
                 }
                 child = child.getNextSibling();
             }
         }
         return retVal;
     }
 
     /**
      * Checks a set of tags for matching parameters.
      *
      * @param tags the tags to check
      * @param parent the node which takes the parameters
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkParamTags(final List<JavadocTag> tags,
             final DetailAST parent, boolean reportExpectedTags) {
         final List<DetailAST> params = getParameters(parent);
         final List<DetailAST> typeParams = CheckUtils
                 .getTypeParameters(parent);
 
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             boolean found = false;
-
-            // Loop looking for matching param
-            final Iterator<DetailAST> paramIt = params.iterator();
             final String arg1 = tag.getFirstArg();
-            while (paramIt.hasNext()) {
-                final DetailAST param = paramIt.next();
-                if (param.getText().equals(arg1)) {
-                    found = true;
-                    paramIt.remove();
-                    break;
-                }
-            }
+            found = removeMatchingParam(params, arg1);
 
             if (CommonUtils.startsWithChar(arg1, '<') && CommonUtils.endsWithChar(arg1, '>')) {
                 // Loop looking for matching type param
                 final Iterator<DetailAST> typeParamsIt = typeParams.iterator();
                 while (typeParamsIt.hasNext()) {
                     final DetailAST typeParam = typeParamsIt.next();
                     if (typeParam.findFirstToken(TokenTypes.IDENT).getText()
                             .equals(
                                     arg1.substring(1,
                                         arg1.length() - 1))) {
                         found = true;
                         typeParamsIt.remove();
                         break;
                     }
                 }
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", arg1);
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingParamTags && reportExpectedTags) {
             for (DetailAST param : params) {
                 log(param, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(), param.getText());
             }
 
             for (DetailAST typeParam : typeParams) {
                 log(typeParam, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(),
                     "<" + typeParam.findFirstToken(TokenTypes.IDENT).getText()
                     + ">");
             }
         }
     }
 
     /**
-     * Checks whether a method is a function.
-     *
-     * @param ast the method node.
-     * @return whether the method is a function.
-     */
-    private static boolean isFunction(DetailAST ast) {
-        boolean retVal = false;
-        if (ast.getType() == TokenTypes.METHOD_DEF) {
-            final DetailAST typeAST = ast.findFirstToken(TokenTypes.TYPE);
-            if (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null) {
-                retVal = true;
+     * Remove parameter from params collection by name.
+     * @param params collection of DetailAST parameters
+     * @param paramName name of parameter
+     * @return true if parameter found and removed
+     */
+    private boolean removeMatchingParam(List<DetailAST> params, String paramName) {
+        boolean found = false;
+        final Iterator<DetailAST> paramIt = params.iterator();
+        while (paramIt.hasNext()) {
+            final DetailAST param = paramIt.next();
+            if (param.getText().equals(paramName)) {
+                found = true;
+                paramIt.remove();
+                break;
             }
         }
-        return retVal;
+        return found;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      *
      * @param tags the tags to check
      * @param lineNo the line number of the expected tag
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkReturnTag(List<JavadocTag> tags, int lineNo,
         boolean reportExpectedTags) {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator<JavadocTag> it = tags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), jt.getColumnNo(),
                         MSG_DUPLICATE_TAG,
                         JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !allowMissingReturnTag && reportExpectedTags) {
             log(lineNo, MSG_RETURN_EXPECTED);
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
