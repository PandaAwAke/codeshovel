diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index cef7ab6a0..5933f0620 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -119,128 +119,126 @@ public final class TreeWalker extends AbstractFileSetCheck implements ExternalRe
     public void setCacheFile(String fileName) {
         // Deprecated
     }
 
     /**
      * @param classLoader class loader to resolve classes with.
      */
     public void setClassLoader(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 
     /**
      * Sets the module factory for creating child modules (Checks).
      * @param moduleFactory the factory
      */
     public void setModuleFactory(ModuleFactory moduleFactory) {
         this.moduleFactory = moduleFactory;
     }
 
     @Override
     public void finishLocalSetup() {
         final DefaultContext checkContext = new DefaultContext();
         checkContext.add("classLoader", classLoader);
         checkContext.add("messages", getMessageCollector());
         checkContext.add("severity", getSeverity());
         checkContext.add("tabWidth", String.valueOf(tabWidth));
 
         childContext = checkContext;
     }
 
     @Override
     public void setupChild(Configuration childConf)
             throws CheckstyleException {
         final String name = childConf.getName();
         final Object module = moduleFactory.createModule(name);
         if (!(module instanceof AbstractCheck)) {
             throw new CheckstyleException(
                 "TreeWalker is not allowed as a parent of " + name);
         }
         final AbstractCheck check = (AbstractCheck) module;
         check.contextualize(childContext);
         check.configure(childConf);
         check.init();
 
         registerCheck(check);
     }
 
     @Override
     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {
         // check if already checked and passed the file
-        if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {
-            return;
-        }
-
-        final String msg = "%s occurred during the analysis of file %s.";
-        final String fileName = file.getPath();
-        try {
-            final FileText text = FileText.fromLines(file, lines);
-            final FileContents contents = new FileContents(text);
-            final DetailAST rootAST = parse(contents);
+        if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {
+            final String msg = "%s occurred during the analysis of file %s.";
+            final String fileName = file.getPath();
+            try {
+                final FileText text = FileText.fromLines(file, lines);
+                final FileContents contents = new FileContents(text);
+                final DetailAST rootAST = parse(contents);
 
-            getMessageCollector().reset();
+                getMessageCollector().reset();
 
-            walk(rootAST, contents, AstState.ORDINARY);
+                walk(rootAST, contents, AstState.ORDINARY);
 
-            final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);
+                final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);
 
-            walk(astWithComments, contents, AstState.WITH_COMMENTS);
-        }
-        catch (final TokenStreamRecognitionException tre) {
-            final String exceptionMsg = String.format(Locale.ROOT, msg,
-                    "TokenStreamRecognitionException", fileName);
-            throw new CheckstyleException(exceptionMsg, tre);
-        }
-        catch (RecognitionException | TokenStreamException ex) {
-            final String exceptionMsg = String.format(Locale.ROOT, msg,
-                    ex.getClass().getSimpleName(), fileName);
-            throw new CheckstyleException(exceptionMsg, ex);
+                walk(astWithComments, contents, AstState.WITH_COMMENTS);
+            }
+            catch (final TokenStreamRecognitionException tre) {
+                final String exceptionMsg = String.format(Locale.ROOT, msg,
+                        "TokenStreamRecognitionException", fileName);
+                throw new CheckstyleException(exceptionMsg, tre);
+            }
+            catch (RecognitionException | TokenStreamException ex) {
+                final String exceptionMsg = String.format(Locale.ROOT, msg,
+                        ex.getClass().getSimpleName(), fileName);
+                throw new CheckstyleException(exceptionMsg, ex);
+            }
         }
     }
 
     /**
      * Register a check for a given configuration.
      * @param check the check to register
      * @throws CheckstyleException if an error occurs
      */
     private void registerCheck(AbstractCheck check)
             throws CheckstyleException {
         validateDefaultTokens(check);
         final int[] tokens;
         final Set<String> checkTokens = check.getTokenNames();
         if (checkTokens.isEmpty()) {
             tokens = check.getDefaultTokens();
         }
         else {
             tokens = check.getRequiredTokens();
 
             //register configured tokens
             final int[] acceptableTokens = check.getAcceptableTokens();
             Arrays.sort(acceptableTokens);
             for (String token : checkTokens) {
                 final int tokenId = TokenUtils.getTokenId(token);
                 if (Arrays.binarySearch(acceptableTokens, tokenId) >= 0) {
                     registerCheck(token, check);
                 }
                 else {
                     final String message = String.format(Locale.ROOT, "Token \"%s\" was "
                             + "not found in Acceptable tokens list in check %s",
                             token, check.getClass().getName());
                     throw new CheckstyleException(message);
                 }
             }
         }
         for (int element : tokens) {
             registerCheck(element, check);
         }
         if (check.isCommentNodesRequired()) {
             commentChecks.add(check);
         }
         else {
             ordinaryChecks.add(check);
         }
     }
 
     /**
      * Register a check for a specified token id.
      * @param tokenId the id of the token
      * @param check the check to register
