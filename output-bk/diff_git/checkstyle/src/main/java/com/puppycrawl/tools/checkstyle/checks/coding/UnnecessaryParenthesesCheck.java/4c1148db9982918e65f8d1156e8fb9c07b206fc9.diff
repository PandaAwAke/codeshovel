diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index 32fcfbf70..67f9bf4c3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -275,61 +275,61 @@ public class UnnecessaryParenthesesCheck extends Check {
      * Tests if the given <code>DetailAST</code> is surrounded by parentheses.
      * In short, does <code>ast</code> have a previous sibling whose type is
      * <code>TokenTypes.LPAREN</code> and a next sibling whose type is <code>
      * TokenTypes.RPAREN</code>.
      * @param ast the <code>DetailAST</code> to check if it is surrounded by
      *        parentheses.
      * @return <code>true</code> if <code>ast</code> is surrounded by
      *         parentheses.
      */
     private static boolean isSurrounded(DetailAST ast) {
         // if previous sibling is left parenthesis,
         // next sibling can't be other than right parenthesis
         final DetailAST prev = ast.getPreviousSibling();
         return prev != null && prev.getType() == TokenTypes.LPAREN;
     }
 
     /**
      * Tests if the given expression node is surrounded by parentheses.
      * @param ast a <code>DetailAST</code> whose type is
      *        <code>TokenTypes.EXPR</code>.
      * @return <code>true</code> if the expression is surrounded by
      *         parentheses.
      */
     private static boolean isExprSurrounded(DetailAST ast) {
         return ast.getFirstChild().getType() == TokenTypes.LPAREN;
     }
 
     /**
      * Check if the given token type can be found in an array of token types.
      * @param type the token type.
      * @param tokens an array of token types to search.
      * @return <code>true</code> if <code>type</code> was found in <code>
      *         tokens</code>.
      */
     private static boolean inTokenList(int type, int... tokens) {
         // NOTE: Given the small size of the two arrays searched, I'm not sure
         //       it's worth bothering with doing a binary search or using a
         //       HashMap to do the searches.
 
         boolean found = false;
         for (int i = 0; i < tokens.length && !found; i++) {
             found = tokens[i] == type;
         }
         return found;
     }
 
     /**
      * Returns the specified string chopped to <code>MAX_QUOTED_LENGTH</code>
      * plus an ellipsis (...) if the length of the string exceeds <code>
      * MAX_QUOTED_LENGTH</code>.
-     * @param string the string to potentially chop.
+     * @param value the string to potentially chop.
      * @return the chopped string if <code>string</code> is longer than
      *         <code>MAX_QUOTED_LENGTH</code>; otherwise <code>string</code>.
      */
-    private static String chopString(String string) {
-        if (string.length() > MAX_QUOTED_LENGTH) {
-            return string.substring(0, MAX_QUOTED_LENGTH) + "...\"";
+    private static String chopString(String value) {
+        if (value.length() > MAX_QUOTED_LENGTH) {
+            return value.substring(0, MAX_QUOTED_LENGTH) + "...\"";
         }
-        return string;
+        return value;
     }
 }
