diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index 76e418cc0..7112ca330 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -166,123 +166,123 @@ public abstract class AbstractTypeAwareCheck extends Check {
                 currentClass = currentClass.substring(0, dotIdx);
             }
             typeParams.pop();
         }
         else if (ast.getType() == TokenTypes.METHOD_DEF) {
             typeParams.pop();
         }
     }
 
     /**
      * Is exception is unchecked (subclass of {@code RuntimeException}
      * or {@code Error}
      *
      * @param exception {@code Class} of exception to check
      * @return true  if exception is unchecked
      *         false if exception is checked
      */
     protected static boolean isUnchecked(Class<?> exception) {
         return isSubclass(exception, RuntimeException.class)
             || isSubclass(exception, Error.class);
     }
 
     /**
      * Checks if one class is subclass of another
      *
      * @param child {@code Class} of class
      *               which should be child
      * @param parent {@code Class} of class
      *                which should be parent
      * @return true  if aChild is subclass of aParent
      *         false otherwise
      */
     protected static boolean isSubclass(Class<?> child, Class<?> parent) {
         return parent != null && child != null
             &&  parent.isAssignableFrom(child);
     }
 
     /** @return {@code ClassResolver} for current tree. */
     private ClassResolver getClassResolver() {
         if (classResolver == null) {
             classResolver =
                 new ClassResolver(getClassLoader(),
                                   packageFullIdent.getText(),
                                   imports);
         }
         return classResolver;
     }
 
     /**
      * Attempts to resolve the Class for a specified name.
-     * @param className name of the class to resolve
-     * @param currentClass name of surrounding class.
+     * @param resolvableClassName name of the class to resolve
+     * @param currentClassName name of surrounding class.
      * @return the resolved class or {@code null}
      *          if unable to resolve the class.
      */
-    protected final Class<?> resolveClass(String className,
-            String currentClass) {
+    protected final Class<?> resolveClass(String resolvableClassName,
+            String currentClassName) {
         try {
-            return getClassResolver().resolve(className, currentClass);
+            return getClassResolver().resolve(resolvableClassName, currentClassName);
         }
         catch (final ClassNotFoundException ignored) {
             return null;
         }
     }
 
     /**
      * Tries to load class. Logs error if unable.
      * @param ident name of class which we try to load.
-     * @param currentClass name of surrounding class.
+     * @param currentClassName name of surrounding class.
      * @return {@code Class} for a ident.
      */
-    protected final Class<?> tryLoadClass(Token ident, String currentClass) {
-        final Class<?> clazz = resolveClass(ident.getText(), currentClass);
+    protected final Class<?> tryLoadClass(Token ident, String currentClassName) {
+        final Class<?> clazz = resolveClass(ident.getText(), currentClassName);
         if (clazz == null) {
             logLoadError(ident);
         }
         return clazz;
     }
 
     /**
      * Logs error if unable to load class information.
      * Abstract, should be overrided in subclasses.
      * @param ident class name for which we can no load class.
      */
     protected abstract void logLoadError(Token ident);
 
     /**
      * Common implementation for logLoadError() method.
      * @param lineNo line number of the problem.
      * @param columnNo column number of the problem.
      * @param msgKey message key to use.
      * @param values values to fill the message out.
      */
     protected final void logLoadErrorImpl(int lineNo, int columnNo,
                                           String msgKey, Object... values) {
         if (!logLoadErrors) {
             final LocalizedMessage msg = new LocalizedMessage(lineNo,
                                                     columnNo,
                                                     getMessageBundle(),
                                                     msgKey,
                                                     values,
                                                     getSeverityLevel(),
                                                     getId(),
                                                     getClass(),
                                                     null);
             throw new IllegalStateException(msg.getMessage());
         }
 
         if (!suppressLoadErrors) {
             log(lineNo, columnNo, msgKey, values);
         }
     }
 
     /**
      * Collects the details of a package.
      * @param ast node containing the package details
      */
     private void processPackage(DetailAST ast) {
         final DetailAST nameAST = ast.getLastChild().getPreviousSibling();
         packageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
@@ -403,105 +403,105 @@ public abstract class AbstractTypeAwareCheck extends Check {
 
         /** @return class name */
         public final Token getName() {
             return name;
         }
 
         /** @return {@code Class} associated with an object. */
         public abstract Class<?> getClazz();
     }
 
     /** Represents regular classes/enumes. */
     @SuppressWarnings("deprecation")
     private static final class RegularClass extends AbstractClassInfo {
         /** name of surrounding class. */
         private final String surroundingClass;
         /** is class loadable. */
         private boolean loadable = true;
         /** {@code Class} object of this class if it's loadable. */
         private Class<?> classObj;
         /** the check we use to resolve classes. */
         private final AbstractTypeAwareCheck check;
 
         /**
          * Creates new instance of of class information object.
          * @param name {@code FullIdent} associated with new object.
          * @param surroundingClass name of current surrounding class.
          * @param check the check we use to load class.
          */
         public RegularClass(final Token name,
                              final String surroundingClass,
                              final AbstractTypeAwareCheck check) {
             super(name);
             this.surroundingClass = surroundingClass;
             this.check = check;
         }
         /** @return if class is loadable ot not. */
         private boolean isLoadable() {
             return loadable;
         }
 
         @Override
         public Class<?> getClazz() {
             if (isLoadable() && classObj == null) {
                 setClazz(check.tryLoadClass(getName(), surroundingClass));
             }
             return classObj;
         }
 
         /**
          * Associates {@code Class} with an object.
-         * @param classObj {@code Class} to associate with.
+         * @param clazz {@code Class} to associate with.
          */
-        private void setClazz(Class<?> classObj) {
-            this.classObj = classObj;
-            loadable = classObj != null;
+        private void setClazz(Class<?> clazz) {
+            this.classObj = clazz;
+            loadable = clazz != null;
         }
 
         @Override
         public String toString() {
             return "RegularClass[name=" + getName()
                 + ", in class=" + surroundingClass
                 + ", loadable=" + loadable
                 + ", class=" + classObj + "]";
         }
     }
 
     /** Represents type param which is "alias" for real type. */
     private static class ClassAlias extends AbstractClassInfo {
         /** Class information associated with the alias. */
         private final AbstractClassInfo classInfo;
 
         /**
          * Creates nnew instance of the class.
          * @param name token which represents name of class alias.
          * @param classInfo class information associated with the alias.
          */
         ClassAlias(final Token name, AbstractClassInfo classInfo) {
             super(name);
             this.classInfo = classInfo;
         }
 
         @Override
         public final Class<?> getClazz() {
             return classInfo.getClazz();
         }
 
         @Override
         public String toString() {
             return "ClassAlias[alias " + getName()
                 + " for " + classInfo + "]";
         }
     }
 
     /**
      * Represents text element with location in the text.
      */
     protected static class Token {
         /** token's column number. */
         private final int column;
         /** token's line number. */
         private final int line;
         /** token's text. */
         private final String text;
 
         /**
