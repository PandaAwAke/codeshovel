diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index 36f7d0ef1..05589450c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -107,132 +107,143 @@ public class RightCurlyCheck extends AbstractOptionCheck<RightCurlyOption> {
 
     /**
      * Does the check need to check if rcurly starts line.
      * @param flag new value of this property.
      */
     public void setShouldStartLine(boolean flag) {
         shouldStartLine = flag;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final Details details = getDetails(ast);
         final DetailAST rcurly = details.rcurly;
 
         if (rcurly == null || rcurly.getType() != TokenTypes.RCURLY) {
             // we need to have both tokens to perform the check
             return;
         }
 
         final DetailAST lcurly = details.lcurly;
+
+        validate(details, rcurly, lcurly);
+
+        if (!shouldStartLine) {
+            return;
+        }
+        final boolean startsLine =
+                Utils.whitespaceBefore(rcurly.getColumnNo(),
+                        getLines()[rcurly.getLineNo() - 1]);
+
+        if (!startsLine && lcurly.getLineNo() != rcurly.getLineNo()) {
+            log(rcurly, MSG_KEY_LINE_NEW, "}");
+        }
+    }
+
+    /**
+     * do general validation
+     * @param details details
+     * @param rcurly right curly token
+     * @param lcurly left curly token
+     */
+    private void validate(Details details, DetailAST rcurly, DetailAST lcurly) {
         final DetailAST nextToken = details.nextToken;
         final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;
 
         if (getAbstractOption() == RightCurlyOption.SAME && !hasLineBreakBefore(rcurly)) {
             log(rcurly, MSG_KEY_LINE_BREAK_BEFORE);
         }
 
         if (shouldCheckLastRcurly) {
             if (rcurly.getLineNo() == nextToken.getLineNo()) {
                 log(rcurly, MSG_KEY_LINE_ALONE, "}");
             }
         }
         else if (getAbstractOption() == RightCurlyOption.SAME
                 && rcurly.getLineNo() != nextToken.getLineNo()) {
             log(rcurly, MSG_KEY_LINE_SAME, "}");
         }
         else if (getAbstractOption() == RightCurlyOption.ALONE
                 && rcurly.getLineNo() == nextToken.getLineNo()
                 && !isEmptyBody(lcurly)) {
             log(rcurly, MSG_KEY_LINE_ALONE, "}");
         }
-
-        if (!shouldStartLine) {
-            return;
-        }
-        final boolean startsLine =
-                Utils.whitespaceBefore(rcurly.getColumnNo(),
-                        getLines()[rcurly.getLineNo() - 1]);
-
-        if (!startsLine && lcurly.getLineNo() != rcurly.getLineNo()) {
-            log(rcurly, MSG_KEY_LINE_NEW, "}");
-        }
     }
 
     /**
      * Collect validation details
      * @param ast detail ast.
      * @return object that contain all details to make a validation.
      */
     private Details getDetails(DetailAST ast) {
         // Attempt to locate the tokens to do the check
         boolean shouldCheckLastRcurly = false;
         DetailAST rcurly = null;
         DetailAST lcurly = null;
         DetailAST nextToken = null;
 
         switch (ast.getType()) {
             case TokenTypes.LITERAL_TRY:
                 lcurly = ast.getFirstChild();
                 nextToken = lcurly.getNextSibling();
                 rcurly = lcurly.getLastChild();
                 break;
             case TokenTypes.LITERAL_CATCH:
                 nextToken = ast.getNextSibling();
                 lcurly = ast.getLastChild();
                 rcurly = lcurly.getLastChild();
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                 }
                 break;
             case TokenTypes.LITERAL_IF:
                 nextToken = ast.findFirstToken(TokenTypes.LITERAL_ELSE);
                 if (nextToken != null) {
                     lcurly = nextToken.getPreviousSibling();
                     rcurly = lcurly.getLastChild();
                 }
                 else {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                     lcurly = ast.getLastChild();
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             case TokenTypes.LITERAL_ELSE:
             case TokenTypes.LITERAL_FINALLY:
                 shouldCheckLastRcurly = true;
                 nextToken = getNextToken(ast);
                 lcurly = ast.getFirstChild();
                 rcurly = lcurly.getLastChild();
                 break;
             case TokenTypes.CLASS_DEF:
