diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/Main.java b/src/main/java/com/puppycrawl/tools/checkstyle/Main.java
index b29bf206c..8b2792ca2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/Main.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/Main.java
@@ -71,100 +71,103 @@ public final class Main {
     private static final String OPTION_V_NAME = "v";
 
     /** Name for the option 'c'. */
     private static final String OPTION_C_NAME = "c";
 
     /** Name for the option 'f'. */
     private static final String OPTION_F_NAME = "f";
 
     /** Name for the option 'p'. */
     private static final String OPTION_P_NAME = "p";
 
     /** Name for the option 'o'. */
     private static final String OPTION_O_NAME = "o";
 
     /** Name for the option 't'. */
     private static final String OPTION_T_NAME = "t";
 
     /** Name for the option '--tree'. */
     private static final String OPTION_TREE_NAME = "tree";
 
     /** Name for the option '-T'. */
     private static final String OPTION_CAPITAL_T_NAME = "T";
 
     /** Name for the option '--treeWithComments'. */
     private static final String OPTION_TREE_COMMENT_NAME = "treeWithComments";
 
     /** Name for the option '-j'. */
     private static final String OPTION_J_NAME = "j";
 
     /** Name for the option '--javadocTree'. */
     private static final String OPTION_JAVADOC_TREE_NAME = "javadocTree";
 
     /** Name for the option '-J'. */
     private static final String OPTION_CAPITAL_J_NAME = "J";
 
     /** Name for the option '--treeWithJavadoc'. */
     private static final String OPTION_TREE_JAVADOC_NAME = "treeWithJavadoc";
 
     /** Name for the option '-d'. */
     private static final String OPTION_D_NAME = "d";
 
     /** Name for the option '--debug'. */
     private static final String OPTION_DEBUG_NAME = "debug";
 
     /** Name for the option 'e'. */
     private static final String OPTION_E_NAME = "e";
 
     /** Name for the option '--exclude'. */
     private static final String OPTION_EXCLUDE_NAME = "exclude";
 
+    /** Name for the option '--executeIgnoredModules'. */
+    private static final String OPTION_EXECUTE_IGNORED_MODULES_NAME = "executeIgnoredModules";
+
     /** Name for the option 'x'. */
     private static final String OPTION_X_NAME = "x";
 
     /** Name for the option '--exclude-regexp'. */
     private static final String OPTION_EXCLUDE_REGEXP_NAME = "exclude-regexp";
 
     /** Name for 'xml' format. */
     private static final String XML_FORMAT_NAME = "xml";
 
     /** Name for 'plain' format. */
     private static final String PLAIN_FORMAT_NAME = "plain";
 
     /** Don't create instance of this class, use {@link #main(String[])} method instead. */
     private Main() {
     }
 
     /**
      * Loops over the files specified checking them for errors. The exit code
      * is the number of errors found in all the files.
      * @param args the command line arguments.
      * @throws IOException if there is a problem with files access
      * @noinspection CallToPrintStackTrace
      **/
     public static void main(String... args) throws IOException {
         int errorCounter = 0;
         boolean cliViolations = false;
         // provide proper exit code based on results.
         final int exitWithCliViolation = -1;
         int exitStatus = 0;
 
         try {
             //parse CLI arguments
             final CommandLine commandLine = parseCli(args);
 
             // show version and exit if it is requested
             if (commandLine.hasOption(OPTION_V_NAME)) {
                 System.out.println("Checkstyle version: "
                         + Main.class.getPackage().getImplementationVersion());
                 exitStatus = 0;
             }
             else {
                 final List<File> filesToProcess = getFilesToProcess(getExclusions(commandLine),
                         commandLine.getArgs());
 
                 // return error if something is wrong in arguments
                 final List<String> messages = validateCli(commandLine, filesToProcess);
                 cliViolations = !messages.isEmpty();
                 if (cliViolations) {
                     exitStatus = exitWithCliViolation;
                     errorCounter = 1;
@@ -331,128 +334,130 @@ public final class Main {
         else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {
             final File file = config.files.get(0);
             final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);
             System.out.print(stringAst);
         }
         else {
             if (commandLine.hasOption(OPTION_D_NAME)) {
                 final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();
                 final ConsoleHandler handler = new ConsoleHandler();
                 handler.setLevel(Level.FINEST);
                 handler.setFilter(new Filter() {
                     private final String packageName = Main.class.getPackage().getName();
 
                     @Override
                     public boolean isLoggable(LogRecord record) {
                         return record.getLoggerName().startsWith(packageName);
                     }
                 });
                 parentLogger.addHandler(handler);
                 parentLogger.setLevel(Level.FINEST);
             }
             if (LOG.isDebugEnabled()) {
                 LOG.debug("Checkstyle debug logging enabled");
                 LOG.debug("Running Checkstyle with version: "
                         + Main.class.getPackage().getImplementationVersion());
             }
 
             // run Checker
             result = runCheckstyle(config);
         }
 
         return result;
     }
 
     /**
      * Util method to convert CommandLine type to POJO object.
      * @param cmdLine command line object
      * @param filesToProcess List of files to process found from the command line.
      * @return command line option as POJO object
      */
     private static CliOptions convertCliToPojo(CommandLine cmdLine, List<File> filesToProcess) {
         final CliOptions conf = new CliOptions();
         conf.format = cmdLine.getOptionValue(OPTION_F_NAME);
         if (conf.format == null) {
             conf.format = PLAIN_FORMAT_NAME;
         }
         conf.outputLocation = cmdLine.getOptionValue(OPTION_O_NAME);
         conf.configLocation = cmdLine.getOptionValue(OPTION_C_NAME);
         conf.propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);
         conf.files = filesToProcess;
+        conf.executeIgnoredModules = cmdLine.hasOption(OPTION_EXECUTE_IGNORED_MODULES_NAME);
         return conf;
     }
 
     /**
      * Executes required Checkstyle actions based on passed parameters.
      * @param cliOptions
      *        pojo object that contains all options
      * @return number of violations of ERROR level
      * @throws FileNotFoundException
      *         when output file could not be found
      * @throws CheckstyleException
      *         when properties file could not be loaded
      */
     private static int runCheckstyle(CliOptions cliOptions)
             throws CheckstyleException, FileNotFoundException {
         // setup the properties
         final Properties props;
 
         if (cliOptions.propertiesLocation == null) {
             props = System.getProperties();
         }
         else {
             props = loadProperties(new File(cliOptions.propertiesLocation));
         }
 
         // create a configuration
         final Configuration config = ConfigurationLoader.loadConfiguration(
-                cliOptions.configLocation, new PropertiesExpander(props));
+                cliOptions.configLocation, new PropertiesExpander(props),
+                !cliOptions.executeIgnoredModules);
 
         // create a listener for output
         final AuditListener listener = createListener(cliOptions.format, cliOptions.outputLocation);
 
         // create RootModule object and run it
         final int errorCounter;
         final ClassLoader moduleClassLoader = Checker.class.getClassLoader();
         final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);
 
         try {
 
             rootModule.setModuleClassLoader(moduleClassLoader);
             rootModule.configure(config);
             rootModule.addListener(listener);
 
             // run RootModule
             errorCounter = rootModule.process(cliOptions.files);
 
         }
         finally {
             rootModule.destroy();
         }
 
         return errorCounter;
     }
 
     /**
      * Creates a new instance of the root module that will control and run
      * Checkstyle.
      * @param name The name of the module. This will either be a short name that
      *        will have to be found or the complete package name.
      * @param moduleClassLoader Class loader used to load the root module.
      * @return The new instance of the root module.
      * @throws CheckstyleException if no module can be instantiated from name
      */
     private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)
             throws CheckstyleException {
         final ModuleFactory factory = new PackageObjectFactory(
                 Checker.class.getPackage().getName(), moduleClassLoader);
 
         return (RootModule) factory.createModule(name);
     }
 
     /**
      * Loads properties from a File.
      * @param file
      *        the properties file
      * @return the properties in file
      * @throws CheckstyleException
      *         when could not load properties file
@@ -580,67 +585,71 @@ public final class Main {
      * @return True if the directory matches one of the patterns.
      */
     private static boolean isDirectoryExcluded(String path, List<Pattern> patternsToExclude) {
         boolean result = false;
 
         for (Pattern pattern : patternsToExclude) {
             if (pattern.matcher(path).find()) {
                 result = true;
                 break;
             }
         }
 
         return result;
     }
 
     /** Prints the usage information. **/
     private static void printUsage() {
         final HelpFormatter formatter = new HelpFormatter();
         formatter.setWidth(HELP_WIDTH);
         formatter.printHelp(String.format("java %s [options] -c <config.xml> file...",
                 Main.class.getName()), buildOptions());
     }
 
     /**
      * Builds and returns list of parameters supported by cli Checkstyle.
      * @return available options
      */
     private static Options buildOptions() {
         final Options options = new Options();
         options.addOption(OPTION_C_NAME, true, "Sets the check configuration file to use.");
         options.addOption(OPTION_O_NAME, true, "Sets the output file. Defaults to stdout");
         options.addOption(OPTION_P_NAME, true, "Loads the properties file");
         options.addOption(OPTION_F_NAME, true, String.format(
                 "Sets the output format. (%s|%s). Defaults to %s",
                 PLAIN_FORMAT_NAME, XML_FORMAT_NAME, PLAIN_FORMAT_NAME));
         options.addOption(OPTION_V_NAME, false, "Print product version and exit");
         options.addOption(OPTION_T_NAME, OPTION_TREE_NAME, false,
                 "Print Abstract Syntax Tree(AST) of the file");
         options.addOption(OPTION_CAPITAL_T_NAME, OPTION_TREE_COMMENT_NAME, false,
                 "Print Abstract Syntax Tree(AST) of the file including comments");
         options.addOption(OPTION_J_NAME, OPTION_JAVADOC_TREE_NAME, false,
                 "Print Parse tree of the Javadoc comment");
         options.addOption(OPTION_CAPITAL_J_NAME, OPTION_TREE_JAVADOC_NAME, false,
                 "Print full Abstract Syntax Tree of the file");
         options.addOption(OPTION_D_NAME, OPTION_DEBUG_NAME, false,
                 "Print all debug logging of CheckStyle utility");
         options.addOption(OPTION_E_NAME, OPTION_EXCLUDE_NAME, true,
                 "Directory path to exclude from CheckStyle");
         options.addOption(OPTION_X_NAME, OPTION_EXCLUDE_REGEXP_NAME, true,
                 "Regular expression of directory to exclude from CheckStyle");
+        options.addOption(OPTION_EXECUTE_IGNORED_MODULES_NAME, false,
+                "Allows ignored modules to be run.");
         return options;
     }
 
     /** Helper structure to clear show what is required for Checker to run. **/
     private static class CliOptions {
         /** Properties file location. */
         private String propertiesLocation;
         /** Config file location. */
         private String configLocation;
         /** Output format. */
         private String format;
         /** Output file location. */
         private String outputLocation;
         /** List of file to validate. */
         private List<File> files;
+        /** Switch whether to execute ignored modules or not. */
+        private boolean executeIgnoredModules;
     }
 }
