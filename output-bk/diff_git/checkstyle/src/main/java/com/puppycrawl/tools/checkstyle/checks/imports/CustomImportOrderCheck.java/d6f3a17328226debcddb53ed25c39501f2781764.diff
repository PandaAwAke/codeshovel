diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index feb3dd540..54a0b7246 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -546,106 +546,108 @@ public class CustomImportOrderCheck extends AbstractCheck {
      * Log wrong import group order.
      * @param currentImportLine
      *        line number of current import current import.
      * @param importGroup
      *        import group.
      * @param currentGroupNumber
      *        current group number we are checking.
      * @param fullImportIdent
      *        full import name.
      */
     private void logWrongImportGroupOrder(int currentImportLine, String importGroup,
             String currentGroupNumber, String fullImportIdent) {
         if (NON_GROUP_RULE_GROUP.equals(importGroup)) {
             log(currentImportLine, MSG_NONGROUP_IMPORT, fullImportIdent);
         }
         else if (NON_GROUP_RULE_GROUP.equals(currentGroupNumber)) {
             log(currentImportLine, MSG_NONGROUP_EXPECTED, importGroup, fullImportIdent);
         }
         else {
             log(currentImportLine, MSG_ORDER, importGroup, currentGroupNumber, fullImportIdent);
         }
     }
 
     /**
      * Get next import group.
      * @param currentGroupNumber
      *        current group number.
      * @return
      *        next import group.
      */
     private String getNextImportGroup(int currentGroupNumber) {
         int nextGroupNumber = currentGroupNumber;
 
         while (customImportOrderRules.size() > nextGroupNumber + 1) {
             if (hasAnyImportInCurrentGroup(customImportOrderRules.get(nextGroupNumber))) {
                 break;
             }
             nextGroupNumber++;
         }
         return customImportOrderRules.get(nextGroupNumber);
     }
 
     /**
      * Checks if current group contains any import.
      * @param currentGroup
      *        current group.
      * @return
      *        true, if current group contains at least one import.
      */
     private boolean hasAnyImportInCurrentGroup(String currentGroup) {
+        boolean result = false;
         for (ImportDetails currentImport : importToGroupList) {
             if (currentGroup.equals(currentImport.getImportGroup())) {
-                return true;
+                result = true;
+                break;
             }
         }
-        return false;
+        return result;
     }
 
     /**
      * Get import valid group.
      * @param isStatic
      *        is static import.
      * @param importPath
      *        full import path.
      * @return import valid group.
      */
     private String getImportGroup(boolean isStatic, String importPath) {
         RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);
         if (isStatic && customImportOrderRules.contains(STATIC_RULE_GROUP)) {
             bestMatch.group = STATIC_RULE_GROUP;
             bestMatch.matchLength = importPath.length();
         }
         else if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
             final String importPathTrimmedToSamePackageDepth =
                     getFirstDomainsFromIdent(samePackageMatchingDepth, importPath);
             if (samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth)) {
                 bestMatch.group = SAME_PACKAGE_RULE_GROUP;
                 bestMatch.matchLength = importPath.length();
             }
         }
         if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)) {
             for (String group : customImportOrderRules) {
                 if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {
                     bestMatch = findBetterPatternMatch(importPath,
                             STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackageRegExp, bestMatch);
                 }
                 if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {
                     bestMatch = findBetterPatternMatch(importPath,
                             SPECIAL_IMPORTS_RULE_GROUP, specialImportsRegExp, bestMatch);
                 }
             }
         }
         if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)
                 && customImportOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)
                 && thirdPartyPackageRegExp.matcher(importPath).find()) {
             bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;
         }
         return bestMatch.group;
     }
 
     /** Tries to find better matching regular expression:
      * longer matching substring wins; in case of the same length,
      * lower position of matching substring wins.
      * @param importPath
      *      Full import identifier
      * @param group
@@ -676,106 +678,105 @@ public class CustomImportOrderCheck extends AbstractCheck {
      * @param import1
      *        current import.
      * @param import2
      *        previous import.
      * @return a negative integer, zero, or a positive integer as the
      *        specified String is greater than, equal to, or less
      *        than this String, ignoring case considerations.
      */
     private static int compareImports(String import1, String import2) {
         int result = 0;
         final String separator = "\\.";
         final String[] import1Tokens = import1.split(separator);
         final String[] import2Tokens = import2.split(separator);
         for (int i = 0; i < import1Tokens.length && i != import2Tokens.length; i++) {
             final String import1Token = import1Tokens[i];
             final String import2Token = import2Tokens[i];
             result = import1Token.compareTo(import2Token);
             if (result != 0) {
                 break;
             }
         }
         return result;
     }
 
     /**
      * Counts empty lines before given.
      * @param lineNo
      *        Line number of current import.
      * @return count of empty lines before given.
      */
     private int getCountOfEmptyLinesBefore(int lineNo) {
         int result = 0;
         final String[] lines = getLines();
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         int lineBeforeIndex = lineNo - 2;
         while (lineBeforeIndex >= 0 && lines[lineBeforeIndex].trim().isEmpty()) {
             lineBeforeIndex--;
             result++;
         }
         return result;
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token) {
-        if (token == null) {
-            return "";
-        }
-        else {
-            return FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
+        String ident = "";
+        if (token != null) {
+            ident = FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
         }
+        return ident;
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRulesToList(String ruleStr) {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
             final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                     ruleStr.indexOf(')'));
             samePackageMatchingDepth = Integer.parseInt(rule);
             if (samePackageMatchingDepth <= 0) {
                 throw new IllegalArgumentException(
                         "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr);
             }
             customImportOrderRules.add(SAME_PACKAGE_RULE_GROUP);
 
         }
         else {
             throw new IllegalStateException("Unexpected rule: " + ruleStr);
         }
     }
 
     /**
      * Creates samePackageDomainsRegExp of the first package domains.
      * @param firstPackageDomainsCount
      *        number of first package domains.
      * @param packageNode
      *        package node.
      * @return same package regexp.
      */
     private static String createSamePackageRegexp(int firstPackageDomainsCount,
              DetailAST packageNode) {
         final String packageFullPath = getFullImportIdent(packageNode);
         return getFirstDomainsFromIdent(firstPackageDomainsCount, packageFullPath);
     }
 
     /**
      * Extracts defined amount of domains from the left side of package/import identifier
      * @param firstPackageDomainsCount
      *        number of first package domains.
