diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
index 567e8fdaa..a333908ec 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
@@ -21,127 +21,127 @@ package com.puppycrawl.tools.checkstyle.checks.metrics;
 import java.math.BigInteger;
 
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Checks the npath complexity against a specified limit (default = 200).
  * The npath metric computes the number of possible execution paths
  * through a function. Similar to the cyclomatic complexity but also
  * takes into account the nesting of conditional statements and
  * multi-part boolean expressions.
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  * @author o_sukhodolsky
  * TODO: For every or: _value += (_orCount * (nestedValue - 1));
  * TODO: For every and: ???
  */
 public final class NPathComplexityCheck extends AbstractComplexityCheck
 {
     /** Default allowed complexity. */
     private static final int DEFAULT_MAX = 200;
 
     /** Creates new instance of the check. */
     public NPathComplexityCheck()
     {
         super(DEFAULT_MAX);
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_CASE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.QUESTION,
         };
     }
 
     @Override
-    public void visitToken(DetailAST aAST)
+    public void visitToken(DetailAST ast)
     {
-        switch (aAST.getType()) {
+        switch (ast.getType()) {
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_IF:
         case TokenTypes.QUESTION:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_SWITCH:
             visitMultiplyingConditional();
             break;
         case TokenTypes.LITERAL_ELSE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_CASE:
             visitAddingConditional();
             break;
         default:
-            super.visitToken(aAST);
+            super.visitToken(ast);
         }
     }
 
     @Override
-    public void leaveToken(DetailAST aAST)
+    public void leaveToken(DetailAST ast)
     {
-        switch (aAST.getType()) {
+        switch (ast.getType()) {
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_IF:
         case TokenTypes.QUESTION:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_SWITCH:
             leaveMultiplyingConditional();
             break;
         case TokenTypes.LITERAL_ELSE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_CASE:
             leaveAddingConditional();
             break;
         default:
-            super.leaveToken(aAST);
+            super.leaveToken(ast);
         }
     }
 
     @Override
     protected String getMessageID()
     {
         return "npathComplexity";
     }
 
     /** Visits else, catch or case. */
     private void visitAddingConditional()
     {
         pushValue();
     }
 
     /** Leaves else, catch or case. */
     private void leaveAddingConditional()
     {
         setCurrentValue(
                 getCurrentValue().subtract(BigInteger.ONE).add(popValue()));
     }
 
     /** Visits while, do, for, if, try, ? (in ?::) or switch. */
     private void visitMultiplyingConditional()
     {
         pushValue();
     }
 
     /** Leaves while, do, for, if, try, ? (in ?::) or switch. */
     private void leaveMultiplyingConditional()
     {
         setCurrentValue(
                 getCurrentValue().add(BigInteger.ONE).multiply(popValue()));
     }
 }
