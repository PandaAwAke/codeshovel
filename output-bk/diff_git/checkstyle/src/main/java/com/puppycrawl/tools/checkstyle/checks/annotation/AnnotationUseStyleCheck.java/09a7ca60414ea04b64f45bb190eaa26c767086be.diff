diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
index 753747929..4d54bf6fb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
@@ -78,100 +78,135 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * is provided.  Set this through the <code>trailingArrayComma</code> property.
  *
  *
  * <p>
  * By default the ElementStyle is set to EXPANDED, the TrailingArrayComma
  * is set to NEVER, and the ClosingParans is set to ALWAYS.
  *
  *
  * <p>
  * According to the JLS, it is legal to include a trailing comma
  * in arrays used in annotations but Sun's Java 5 &amp; 6 compilers will not
  * compile with this syntax. This may in be a bug in Sun's compilers
  * since eclipse 3.4's built-in compiler does allow this syntax as
  * defined in the JLS. Note: this was tested with compilers included with
  * JDK versions 1.5.0.17 and 1.6.0.11 and the compiler included with eclipse
  * 3.4.1.
  *
  * See <a
  * href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">
  * Java Language specification, sections 9.7</a>.
  *
  *
  * <p>
  * An example shown below is set to enforce an EXPANDED style, with a
  * trailing array comma set to NEVER and always including the closing
  * parenthesis.
  *
  *
  * <pre>
  * &lt;module name=&quot;AnnotationUseStyle&quot;&gt;
  *    &lt;property name=&quot;ElementStyle&quot;
  *        value=&quot;EXPANDED&quot;/&gt;
  *    &lt;property name=&quot;TrailingArrayComma&quot;
  *        value=&quot;NEVER&quot;/&gt;
  *    &lt;property name=&quot;ClosingParens&quot;
  *        value=&quot;ALWAYS&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author Travis Schneeberger
  */
 public final class AnnotationUseStyleCheck extends Check
 {
     /**
      * the element name used to receive special linguistic support
      * for annotation use.
      */
     private static final String ANNOTATION_ELEMENT_SINGLE_NAME =
         "value";
 
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_INCORRECT_STYLE =
+        "annotation.incorrect.style";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_PARENS_MISSING =
+        "annotation.parens.missing";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_PARENS_PRESENT =
+        "annotation.parens.present";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING =
+        "annotation.trailing.comma.missing";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT =
+        "annotation.trailing.comma.present";
+
     //not extending AbstractOptionCheck because check
     //has more than one option type.
 
     /** @see #setElementStyle(String) */
     private ElementStyle mStyle = ElementStyle.COMPACT_NO_ARRAY;
 
     //defaulting to NEVER because of the strange compiler behavior
     /** @see #setTrailingArrayComma(String) */
     private TrailingArrayComma mComma = TrailingArrayComma.NEVER;
 
     /** @see #setClosingParens(String) */
     private ClosingParens mParens = ClosingParens.NEVER;
 
     /**
      * Sets the ElementStyle from a string.
      *
      * @param aStyle string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setElementStyle(final String aStyle)
     {
         this.mStyle = this.getOption(ElementStyle.class, aStyle);
     }
 
     /**
      * Sets the TrailingArrayComma from a string.
      *
      * @param aComma string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setTrailingArrayComma(final String aComma)
     {
         this.mComma = this.getOption(TrailingArrayComma.class, aComma);
     }
 
     /**
      * Sets the ClosingParens from a string.
      *
      * @param aParens string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setClosingParens(final String aParens)
     {
         this.mParens = this.getOption(ClosingParens.class, aParens);
     }
 
     /**
      * Retrieves an {@link Enum Enum} type from a @{link String String}.
      * @param <T> the enum type
      * @param aEnumClass the enum class
@@ -213,101 +248,101 @@ public final class AnnotationUseStyleCheck extends Check
     }
 
     /** {@inheritDoc} */
     @Override
     public void visitToken(final DetailAST aAST)
     {
         this.checkStyleType(aAST);
         this.checkCheckClosingParens(aAST);
         this.checkTrailingComma(aAST);
     }
 
     /**
      * Checks to see if the
      * {@link ElementStyle AnnotationElementStyle}
      * is correct.
      *
      * @param aAnnotation the annotation token
      */
     private void checkStyleType(final DetailAST aAnnotation)
     {
         if (ElementStyle.IGNORE.equals(this.mStyle)
             || this.mStyle == null)
         {
             return;
         }
 
         if (ElementStyle.COMPACT_NO_ARRAY.equals(this.mStyle)) {
             this.checkCompactNoArrayStyle(aAnnotation);
         }
         else if (ElementStyle.COMPACT.equals(this.mStyle)) {
             this.checkCompactStyle(aAnnotation);
         }
         else if (ElementStyle.EXPANDED.equals(this.mStyle)) {
             this.checkExpandedStyle(aAnnotation);
         }
     }
 
     /**
      * Checks for expanded style type violations.
      *
      * @param aAnnotation the annotation token
      */
     private void checkExpandedStyle(final DetailAST aAnnotation)
     {
         final int valuePairCount =
             aAnnotation.getChildCount(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         if (valuePairCount == 0
             && aAnnotation.branchContains(TokenTypes.EXPR))
         {
-            this.log(aAnnotation.getLineNo(), "annotation.incorrect.style",
+            this.log(aAnnotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.EXPANDED);
         }
     }
 
     /**
      * Checks for compact style type violations.
      *
      * @param aAnnotation the annotation token
      */
     private void checkCompactStyle(final DetailAST aAnnotation)
     {
         final int valuePairCount =
             aAnnotation.getChildCount(
                 TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         final DetailAST valuePair =
             aAnnotation.findFirstToken(
                 TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         if (valuePairCount == 1
             && AnnotationUseStyleCheck.ANNOTATION_ELEMENT_SINGLE_NAME.equals(
                 valuePair.getFirstChild().getText()))
         {
             this.log(aAnnotation.getLineNo(), "annotation.incorrect.style",
                 ElementStyle.COMPACT);
         }
     }
 
     /**
      * Checks for compact no array style type violations.
      *
      * @param aAnnotation the annotation token
      */
     private void checkCompactNoArrayStyle(final DetailAST aAnnotation)
     {
         final DetailAST arrayInit =
             aAnnotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
 
         final int valuePairCount =
             aAnnotation.getChildCount(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         final DetailAST valuePair =
             aAnnotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         //in compact style with one value
         if (arrayInit != null
             && arrayInit.getChildCount(TokenTypes.EXPR) == 1)
         {
             this.log(aAnnotation.getLineNo(), "annotation.incorrect.style",
                 ElementStyle.COMPACT_NO_ARRAY);
@@ -335,139 +370,139 @@ public final class AnnotationUseStyleCheck extends Check
      *
      * @param aAnnotation the annotation token
      */
     private void checkTrailingComma(final DetailAST aAnnotation)
     {
         if (TrailingArrayComma.IGNORE.equals(this.mComma)
             || this.mComma == null)
         {
             return;
         }
 
         DetailAST child = aAnnotation.getFirstChild();
 
         while (child != null) {
             DetailAST arrayInit = null;
 
             if (child.getType()
                 == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
             {
                 arrayInit =
                     child.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
             }
             else if (child.getType() == TokenTypes.ANNOTATION_ARRAY_INIT) {
                 arrayInit = child;
             }
 
             if (arrayInit != null) {
                 this.logCommaViolation(arrayInit);
             }
             child = child.getNextSibling();
         }
     }
 
     /**
      * logs a trailing array comma violation if one exists.
      *
      * @param aAST the array init
      * {@link TokenTypes#ANNOTATION_ARRAY_INIT ANNOTATION_ARRAY_INIT}.
      */
     private void logCommaViolation(final DetailAST aAST)
     {
         final DetailAST rCurly = aAST.findFirstToken(TokenTypes.RCURLY);
 
         //comma can be null if array is empty
         final DetailAST comma = rCurly.getPreviousSibling();
 
         if (TrailingArrayComma.ALWAYS.equals(this.mComma)
             && (comma == null || comma.getType() != TokenTypes.COMMA))
         {
             this.log(rCurly.getLineNo(),
-                rCurly.getColumnNo(), "annotation.trailing.comma.missing");
+                rCurly.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING);
         }
         else if (TrailingArrayComma.NEVER.equals(this.mComma)
             && comma != null && comma.getType() == TokenTypes.COMMA)
         {
             this.log(comma.getLineNo(),
-                comma.getColumnNo(), "annotation.trailing.comma.present");
+                comma.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT);
         }
     }
 
     /**
      * Checks to see if the closing parenthesis are present if required or
      * prohibited.
      *
      * @param aAST the annotation token
      */
     private void checkCheckClosingParens(final DetailAST aAST)
     {
         if (ClosingParens.IGNORE.equals(this.mParens)
             || this.mParens == null)
         {
             return;
         }
 
         final DetailAST paren = aAST.getLastChild();
         final boolean parenExists = paren.getType() == TokenTypes.RPAREN;
 
         if (ClosingParens.ALWAYS.equals(this.mParens)
             && !parenExists)
         {
-            this.log(aAST.getLineNo(), "annotation.parens.missing");
+            this.log(aAST.getLineNo(), MSG_KEY_ANNOTATION_PARENS_MISSING);
         }
         else if (ClosingParens.NEVER.equals(this.mParens)
             && !aAST.branchContains(TokenTypes.EXPR)
             && !aAST.branchContains(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
             && !aAST.branchContains(TokenTypes.ANNOTATION_ARRAY_INIT)
             && parenExists)
         {
-            this.log(aAST.getLineNo(), "annotation.parens.present");
+            this.log(aAST.getLineNo(), MSG_KEY_ANNOTATION_PARENS_PRESENT);
         }
     }
 
     /**
      * Defines the styles for defining elements in an annotation.
      * @author Travis Schneeberger
      */
     public static enum ElementStyle {
 
         /**
          * expanded example
          *
          * <pre>@SuppressWarnings(value={"unchecked","unused",})</pre>.
          */
         EXPANDED,
 
         /**
          * compact example
          *
          * <pre>@SuppressWarnings({"unchecked","unused",})</pre>
          * <br>or<br>
          * <pre>@SuppressWarnings("unchecked")</pre>.
          */
         COMPACT,
 
         /**
          * compact example.]
          *
          * <pre>@SuppressWarnings("unchecked")</pre>.
          */
         COMPACT_NO_ARRAY,
 
         /**
          * mixed styles.
          */
         IGNORE,
     }
 
     /**
      * Defines the two styles for defining
      * elements in an annotation.
      *
      * @author Travis Schneeberger
      */
     public static enum TrailingArrayComma {
 
         /**
          * with comma example
          *
          * <pre>@SuppressWarnings(value={"unchecked","unused",})</pre>.
