diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 4dd0f4d86..ac95e7740 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -112,196 +112,230 @@ public class FinalLocalVariableCheck extends Check {
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.INSTANCE_INIT,
             TokenTypes.STATIC_INIT,
             TokenTypes.LITERAL_FOR,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
             TokenTypes.PARAMETER_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.INSTANCE_INIT,
             TokenTypes.STATIC_INIT,
             TokenTypes.LITERAL_FOR,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.SLIST:
             case TokenTypes.LITERAL_FOR:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.STATIC_INIT:
             case TokenTypes.INSTANCE_INIT:
                 scopeStack.push(new HashMap<String, DetailAST>());
                 break;
 
             case TokenTypes.PARAMETER_DEF:
                 if (ScopeUtils.inInterfaceBlock(ast)
                     || inAbstractOrNativeMethod(ast)
                     || inLambda(ast)) {
                     break;
                 }
             case TokenTypes.VARIABLE_DEF:
                 if (ast.getParent().getType() != TokenTypes.OBJBLOCK
-                    && shouldCheckEnhancedForLoopVariable(ast)
-                    && isVariableInForInit(ast)) {
+                        && shouldCheckEnhancedForLoopVariable(ast)
+                        && isVariableInForInit(ast)
+                        && !ast.branchContains(TokenTypes.FINAL)) {
                     insertVariable(ast);
                 }
                 break;
 
             case TokenTypes.IDENT:
                 final int parentType = ast.getParent().getType();
                 if (isAssignOperator(parentType)
                         && ast.getParent().getFirstChild() == ast) {
                     removeVariable(ast);
                 }
                 break;
 
             default:
         }
     }
 
     /**
      * is Arithmetic operator
      * @param parentType token AST
      * @return true is token type is in arithmetic operator
      */
     private boolean isAssignOperator(int parentType) {
         return TokenTypes.POST_DEC == parentType
                 || TokenTypes.DEC == parentType
                 || TokenTypes.POST_INC == parentType
                 || TokenTypes.INC == parentType
                 || TokenTypes.ASSIGN == parentType
                 || TokenTypes.PLUS_ASSIGN == parentType
                 || TokenTypes.MINUS_ASSIGN == parentType
                 || TokenTypes.DIV_ASSIGN == parentType
                 || TokenTypes.STAR_ASSIGN == parentType
                 || TokenTypes.MOD_ASSIGN == parentType
                 || TokenTypes.SR_ASSIGN == parentType
                 || TokenTypes.BSR_ASSIGN == parentType
                 || TokenTypes.SL_ASSIGN == parentType
                 || TokenTypes.BXOR_ASSIGN == parentType
                 || TokenTypes.BOR_ASSIGN == parentType
                 || TokenTypes.BAND_ASSIGN == parentType;
     }
 
     /**
      * Determines whether enhanced for-loop variable should be checked or not.
      * @param ast The ast to compare.
      * @return true if enhanced for-loop variable should be checked.
      */
     private boolean shouldCheckEnhancedForLoopVariable(DetailAST ast) {
         return validateEnhancedForLoopVariable
                 || ast.getParent().getType() != TokenTypes.FOR_EACH_CLAUSE;
     }
 
     /**
      * Checks if current variable is defined in
      *  {@link TokenTypes#FOR_INIT for-loop init}, e.g.:
      * <p>
      * <code>
      * for (int i = 0, j = 0; i < j; i++) { . . . }
      * </code>
      * </p>
      * <code>i, j</code> are defined in {@link TokenTypes#FOR_INIT for-loop init}
      * @param variableDef variable definition node.
      * @return true if variable is defined in {@link TokenTypes#FOR_INIT for-loop init}
      */
     private static boolean isVariableInForInit(DetailAST variableDef) {
         return variableDef.getParent().getType() != TokenTypes.FOR_INIT;
     }
 
     /**
      * Determines whether an AST is a descendant of an abstract or native method.
      * @param ast the AST to check.
      * @return true if ast is a descendant of an abstract or native method.
      */
     private static boolean inAbstractOrNativeMethod(DetailAST ast) {
         DetailAST parent = ast.getParent();
         while (parent != null) {
             if (parent.getType() == TokenTypes.METHOD_DEF) {
                 final DetailAST modifiers =
                     parent.findFirstToken(TokenTypes.MODIFIERS);
                 return modifiers.branchContains(TokenTypes.ABSTRACT)
                         || modifiers.branchContains(TokenTypes.LITERAL_NATIVE);
             }
             parent = parent.getParent();
         }
         return false;
     }
 
     /**
      * Check if current param is lamda's param.
      * @param paramDef {@link TokenTypes#PARAMETER_DEF parameter def}.
      * @return true if current param is lamda's param.
      */
     private static boolean inLambda(DetailAST paramDef) {
         return paramDef.getParent().getParent().getType() == TokenTypes.LAMBDA;
     }
 
+    /**
+     * Find the Class or Method in which it is defined.
+     * @param ast Variable for which we want to find the scope in which it is defined
+     * @return ast The Class or Method in which it is defined.
+     */
+    private static DetailAST findClassOrMethodInWhichItIsDefined(DetailAST ast) {
+        DetailAST astTraverse = ast;
+        while (!(astTraverse.getType() == TokenTypes.METHOD_DEF
+                || astTraverse.getType() == TokenTypes.CLASS_DEF)) {
+            astTraverse = astTraverse.getParent();
+        }
+        return astTraverse;
+    }
+
+    /**
+     * Check if both the Variable are same.
+     * @param ast1 Variable to compare
+     * @param ast2 Variable to compare
+     * @return true if both the variable are same, otherwise false
+     */
+    private static boolean isSameVariables(DetailAST ast1, DetailAST ast2) {
+        final DetailAST classOrMethodOfAst1 =
+            findClassOrMethodInWhichItIsDefined(ast1);
+        final DetailAST classOrMethodOfAst2 =
+            findClassOrMethodInWhichItIsDefined(ast2);
+
+        final String identifierOfAst1 =
+            classOrMethodOfAst1.findFirstToken(TokenTypes.IDENT).getText();
+        final String identifierOfAst2 =
+            classOrMethodOfAst2.findFirstToken(TokenTypes.IDENT).getText();
+
+        return identifierOfAst1.equals(identifierOfAst2);
+    }
+
     /**
      * Inserts a variable at the topmost scope stack
      * @param ast the variable to insert
      */
     private void insertVariable(DetailAST ast) {
-        if (!ast.branchContains(TokenTypes.FINAL)) {
-            final Map<String, DetailAST> state = scopeStack.peek();
-            final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
-            state.put(astNode.getText(), astNode);
-        }
+        final Map<String, DetailAST> state = scopeStack.peek();
+        final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
+        state.put(astNode.getText(), astNode);
     }
 
     /**
      * Removes the variable from the Stacks
      * @param ast Variable to remove
      */
     private void removeVariable(DetailAST ast) {
         final Iterator<Map<String, DetailAST>> iterator = scopeStack.descendingIterator();
         while (iterator.hasNext()) {
             final Map<String, DetailAST> state = iterator.next();
-            final Object obj = state.remove(ast.getText());
-            if (obj != null) {
+            final DetailAST storedVariable = state.get(ast.getText());
+            if (storedVariable != null && isSameVariables(storedVariable, ast)) {
+                state.remove(ast.getText());
                 break;
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         super.leaveToken(ast);
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.SLIST:
             case TokenTypes.LITERAL_FOR:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.STATIC_INIT:
             case TokenTypes.INSTANCE_INIT:
             case TokenTypes.METHOD_DEF:
                 final Map<String, DetailAST> state = scopeStack.pop();
                 for (DetailAST var : state.values()) {
                     log(var.getLineNo(), var.getColumnNo(), MSG_KEY, var
                         .getText());
                 }
                 break;
 
             default:
         }
     }
 }
