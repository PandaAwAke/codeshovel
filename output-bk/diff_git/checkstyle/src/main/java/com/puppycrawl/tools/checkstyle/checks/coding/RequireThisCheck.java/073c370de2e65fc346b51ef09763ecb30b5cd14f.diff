diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 8f0aea440..268d333ff 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -617,106 +617,106 @@ public class RequireThisCheck extends AbstractCheck {
         }
         return parent;
     }
 
     /**
      * Checks whether a value can be assigned to a field.
      * A value can be assigned to a final field only in constructor block. If there is a method
      * block, value assignment can be performed only to non final field.
      * @param ast an identifier token.
      * @return true if a value can be assigned to a field.
      */
     private boolean canAssignValueToClassField(DetailAST ast) {
         final AbstractFrame fieldUsageFrame = findFrame(ast, false);
         final boolean fieldUsageInConstructor = isInsideConstructorFrame(fieldUsageFrame);
 
         final AbstractFrame declarationFrame = findFrame(ast, true);
         final boolean finalField = ((ClassFrame) declarationFrame).hasFinalField(ast);
 
         return fieldUsageInConstructor || !finalField;
     }
 
     /**
      * Checks whether a field usage frame is inside constructor frame.
      * @param frame frame, where field is used.
      * @return true if the field usage frame is inside constructor frame.
      */
     private static boolean isInsideConstructorFrame(AbstractFrame frame) {
         boolean assignmentInConstructor = false;
         AbstractFrame fieldUsageFrame = frame;
         if (fieldUsageFrame.getType() == FrameType.BLOCK_FRAME) {
             while (fieldUsageFrame.getType() == FrameType.BLOCK_FRAME) {
                 fieldUsageFrame = fieldUsageFrame.getParent();
             }
             if (fieldUsageFrame.getType() == FrameType.CTOR_FRAME) {
                 assignmentInConstructor = true;
             }
         }
         return assignmentInConstructor;
     }
 
     /**
      * Checks whether an overlapping by method or constructor argument takes place.
      * @param ast an identifier.
      * @return true if an overlapping by method or constructor argument takes place.
      */
     private boolean isOverlappingByArgument(DetailAST ast) {
         boolean overlapping = false;
         final DetailAST parent = ast.getParent();
         final DetailAST sibling = ast.getNextSibling();
         if (sibling != null && isAssignToken(parent.getType())) {
-            final ClassFrame classFrame = (ClassFrame) findFrame(ast, true);
-            final Set<DetailAST> exprIdents = getAllTokensOfType(sibling, TokenTypes.IDENT);
             if (isCompoundAssignToken(parent.getType())) {
                 overlapping = true;
             }
             else {
+                final ClassFrame classFrame = (ClassFrame) findFrame(ast, true);
+                final Set<DetailAST> exprIdents = getAllTokensOfType(sibling, TokenTypes.IDENT);
                 overlapping = classFrame.containsFieldOrVariableDef(exprIdents, ast);
             }
         }
         return overlapping;
     }
 
     /**
      * Checks whether an overlapping by local variable takes place.
      * @param ast an identifier.
      * @return true if an overlapping by local variable takes place.
      */
     private boolean isOverlappingByLocalVariable(DetailAST ast) {
         boolean overlapping = false;
         final DetailAST parent = ast.getParent();
         final DetailAST sibling = ast.getNextSibling();
         if (sibling != null && isAssignToken(parent.getType())) {
             final ClassFrame classFrame = (ClassFrame) findFrame(ast, true);
             final Set<DetailAST> exprIdents = getAllTokensOfType(sibling, TokenTypes.IDENT);
             overlapping = classFrame.containsFieldOrVariableDef(exprIdents, ast);
         }
         return overlapping;
     }
 
     /**
      * Collects all tokens of specific type starting with the current ast node.
      * @param ast ast node.
      * @param tokenType token type.
      * @return a set of all tokens of specific type starting with the current ast node.
      */
     private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {
         DetailAST vertex = ast;
         final Set<DetailAST> result = new HashSet<>();
         final Deque<DetailAST> stack = new ArrayDeque<>();
         while (vertex != null || !stack.isEmpty()) {
             if (!stack.isEmpty()) {
                 vertex = stack.pop();
             }
             while (vertex != null) {
                 if (vertex.getType() == tokenType) {
                     result.add(vertex);
                 }
                 if (vertex.getNextSibling() != null) {
                     stack.push(vertex.getNextSibling());
                 }
                 vertex = vertex.getFirstChild();
             }
         }
         return result;
     }
 
