diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
index 2764e5238..978765658 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
@@ -63,108 +63,100 @@ public abstract class AbstractClassCouplingCheck extends AbstractCheck {
             "Object", "Class",
             "String", "StringBuffer", "StringBuilder",
             // Exceptions
             "ArrayIndexOutOfBoundsException", "Exception",
             "RuntimeException", "IllegalArgumentException",
             "IllegalStateException", "IndexOutOfBoundsException",
             "NullPointerException", "Throwable", "SecurityException",
             "UnsupportedOperationException",
             // java.util.*
             "List", "ArrayList", "Deque", "Queue", "LinkedList",
             "Set", "HashSet", "SortedSet", "TreeSet",
             "Map", "HashMap", "SortedMap", "TreeMap",
         }).collect(Collectors.toSet()));
 
     /** Package names to ignore. */
     private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();
 
     /** User-configured regular expressions to ignore classes. */
     private final List<Pattern> excludeClassesRegexps = new ArrayList<>();
 
     /** User-configured class names to ignore. */
     private Set<String> excludedClasses = DEFAULT_EXCLUDED_CLASSES;
     /** User-configured package names to ignore. */
     private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;
     /** Allowed complexity. */
     private int max;
 
     /** Current file context. */
     private FileContext fileContext;
 
     /**
      * Creates new instance of the check.
      * @param defaultMax default value for allowed complexity.
      */
     protected AbstractClassCouplingCheck(int defaultMax) {
         max = defaultMax;
         excludeClassesRegexps.add(CommonUtils.createPattern("^$"));
     }
 
     /**
      * Returns message key we use for log violations.
      * @return message key we use for log violations.
      */
     protected abstract String getLogMessageId();
 
     @Override
     public final int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
-    /**
-     * Returns allowed complexity.
-     * @return allowed complexity.
-     */
-    public final int getMax() {
-        return max;
-    }
-
     /**
      * Sets maximum allowed complexity.
      * @param max allowed complexity.
      */
     public final void setMax(int max) {
         this.max = max;
     }
 
     /**
      * Sets user-excluded classes to ignore.
      * @param excludedClasses the list of classes to ignore.
      */
     public final void setExcludedClasses(String... excludedClasses) {
         this.excludedClasses =
             Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));
     }
 
     /**
      * Sets user-excluded regular expression of classes to ignore.
      * @param from array representing regular expressions of classes to ignore.
      */
     public void setExcludeClassesRegexps(String... from) {
         excludeClassesRegexps.clear();
         excludeClassesRegexps.addAll(Arrays.stream(from.clone())
                 .map(CommonUtils::createPattern)
                 .collect(Collectors.toSet()));
     }
 
     /**
      * Sets user-excluded pakcages to ignore. All exlcuded packages should end with a period,
      * so it also appends a dot to a package name.
      * @param excludedPackages the list of packages to ignore.
      */
     public final void setExcludedPackages(String... excludedPackages) {
         final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)
             .filter(x -> !CommonUtils.isName(x))
             .collect(Collectors.toList());
         if (!invalidIdentifiers.isEmpty()) {
             throw new IllegalArgumentException(
                 "the following values are not valid identifiers: "
                     + invalidIdentifiers.stream().collect(Collectors.joining(", ", "[", "]")));
         }
 
         this.excludedPackages = Collections.unmodifiableSet(
             Arrays.stream(excludedPackages).collect(Collectors.toSet()));
     }
 
     @Override
     public final void beginTree(DetailAST ast) {
         fileContext = new FileContext();
@@ -381,96 +373,96 @@ public abstract class AbstractClassCouplingCheck extends AbstractCheck {
                  childAST = childAST.getNextSibling()) {
                 if (childAST.getType() != TokenTypes.COMMA) {
                     addReferencedClassName(childAST);
                 }
             }
         }
 
         /**
          * Visits type.
          * @param ast type to process.
          */
         public void visitType(DetailAST ast) {
             final String fullTypeName = CheckUtils.createFullType(ast).getText();
             addReferencedClassName(fullTypeName);
         }
 
         /**
          * Visits NEW.
          * @param ast NEW to process.
          */
         public void visitLiteralNew(DetailAST ast) {
             addReferencedClassName(ast.getFirstChild());
         }
 
         /**
          * Adds new referenced class.
          * @param ast a node which represents referenced class.
          */
         private void addReferencedClassName(DetailAST ast) {
             final String fullIdentName = FullIdent.createFullIdent(ast).getText();
             addReferencedClassName(fullIdentName);
         }
 
         /**
          * Adds new referenced class.
          * @param referencedClassName class name of the referenced class.
          */
         private void addReferencedClassName(String referencedClassName) {
             if (isSignificant(referencedClassName)) {
                 referencedClassNames.add(referencedClassName);
             }
         }
 
         /** Checks if coupling less than allowed or not. */
         public void checkCoupling() {
             referencedClassNames.remove(className);
             referencedClassNames.remove(parentContext.getPackageName() + DOT + className);
 
             if (referencedClassNames.size() > max) {
                 log(lineNo, columnNo, getLogMessageId(),
-                        referencedClassNames.size(), getMax(),
+                        referencedClassNames.size(), max,
                         referencedClassNames.toString());
             }
         }
 
         /**
          * Checks if given class shouldn't be ignored and not from java.lang.
          * @param candidateClassName class to check.
          * @return true if we should count this class.
          */
         private boolean isSignificant(String candidateClassName) {
             boolean result = !excludedClasses.contains(candidateClassName)
                 && !isFromExcludedPackage(candidateClassName);
             if (result) {
                 for (Pattern pattern : excludeClassesRegexps) {
                     if (pattern.matcher(candidateClassName).matches()) {
                         result = false;
                         break;
                     }
                 }
             }
             return result;
         }
 
         /**
          * Checks if given class should be ignored as it belongs to excluded package.
          * @param candidateClassName class to check
          * @return true if we should not count this class.
          */
         private boolean isFromExcludedPackage(String candidateClassName) {
             String classNameWithPackage = candidateClassName;
             if (!candidateClassName.contains(DOT)) {
                 classNameWithPackage = parentContext.getClassNameWithPackage(candidateClassName)
                     .orElse("");
             }
             boolean isFromExcludedPackage = false;
             if (classNameWithPackage.contains(DOT)) {
                 final int lastDotIndex = classNameWithPackage.lastIndexOf(DOT);
                 final String packageName = classNameWithPackage.substring(0, lastDotIndex);
                 isFromExcludedPackage = packageName.startsWith("java.lang")
                     || excludedPackages.contains(packageName);
             }
             return isFromExcludedPackage;
         }
     }
 }
