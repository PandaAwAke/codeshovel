diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 1959c7dff..dbd45a2bd 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -565,102 +565,102 @@ public class FinalLocalVariableCheck extends AbstractCheck {
      * </p>
      * @param variable variable.
      * @return true if a variable which is declared outside loop is used inside loop.
      */
     private static boolean isUseOfExternalVariableInsideLoop(DetailAST variable) {
         DetailAST loop2 = variable.getParent();
         while (loop2 != null
             && !isLoopAst(loop2.getType())) {
             loop2 = loop2.getParent();
         }
         return loop2 != null;
     }
 
     /**
      * Is Arithmetic operator.
      * @param parentType token AST
      * @return true is token type is in arithmetic operator
      */
     private static boolean isAssignOperator(int parentType) {
         return Arrays.binarySearch(ASSIGN_OPERATOR_TYPES, parentType) >= 0;
     }
 
     /**
      * Checks if current variable is defined in
      *  {@link TokenTypes#FOR_INIT for-loop init}, e.g.:
      * <p>
      * {@code
      * for (int i = 0, j = 0; i < j; i++) { . . . }
      * }
      * </p>
      * {@code i, j} are defined in {@link TokenTypes#FOR_INIT for-loop init}
      * @param variableDef variable definition node.
      * @return true if variable is defined in {@link TokenTypes#FOR_INIT for-loop init}
      */
     private static boolean isVariableInForInit(DetailAST variableDef) {
         return variableDef.getParent().getType() == TokenTypes.FOR_INIT;
     }
 
     /**
      * Determines whether an AST is a descendant of an abstract or native method.
      * @param ast the AST to check.
      * @return true if ast is a descendant of an abstract or native method.
      */
     private static boolean isInAbstractOrNativeMethod(DetailAST ast) {
         boolean abstractOrNative = false;
         DetailAST parent = ast.getParent();
         while (parent != null && !abstractOrNative) {
             if (parent.getType() == TokenTypes.METHOD_DEF) {
                 final DetailAST modifiers =
                     parent.findFirstToken(TokenTypes.MODIFIERS);
-                abstractOrNative = modifiers.branchContains(TokenTypes.ABSTRACT)
-                        || modifiers.branchContains(TokenTypes.LITERAL_NATIVE);
+                abstractOrNative = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null
+                        || modifiers.findFirstToken(TokenTypes.LITERAL_NATIVE) != null;
             }
             parent = parent.getParent();
         }
         return abstractOrNative;
     }
 
     /**
      * Check if current param is lambda's param.
      * @param paramDef {@link TokenTypes#PARAMETER_DEF parameter def}.
      * @return true if current param is lambda's param.
      */
     private static boolean isInLambda(DetailAST paramDef) {
         return paramDef.getParent().getParent().getType() == TokenTypes.LAMBDA;
     }
 
     /**
      * Find the Class, Constructor, Enum, Method, or Field in which it is defined.
      * @param ast Variable for which we want to find the scope in which it is defined
      * @return ast The Class or Constructor or Method in which it is defined.
      */
     private static DetailAST findFirstUpperNamedBlock(DetailAST ast) {
         DetailAST astTraverse = ast;
         while (astTraverse.getType() != TokenTypes.METHOD_DEF
                 && astTraverse.getType() != TokenTypes.CLASS_DEF
                 && astTraverse.getType() != TokenTypes.ENUM_DEF
                 && astTraverse.getType() != TokenTypes.CTOR_DEF
                 && !ScopeUtils.isClassFieldDef(astTraverse)) {
             astTraverse = astTraverse.getParent();
         }
         return astTraverse;
     }
 
     /**
      * Check if both the Variables are same.
      * @param ast1 Variable to compare
      * @param ast2 Variable to compare
      * @return true if both the variables are same, otherwise false
      */
     private static boolean isSameVariables(DetailAST ast1, DetailAST ast2) {
         final DetailAST classOrMethodOfAst1 =
             findFirstUpperNamedBlock(ast1);
         final DetailAST classOrMethodOfAst2 =
             findFirstUpperNamedBlock(ast2);
         return classOrMethodOfAst1 == classOrMethodOfAst2 && ast1.getText().equals(ast2.getText());
     }
 
     /**
      * Check if both the variables are in the same loop.
      * @param ast1 variable to compare.
      * @param ast2 variable to compare.
