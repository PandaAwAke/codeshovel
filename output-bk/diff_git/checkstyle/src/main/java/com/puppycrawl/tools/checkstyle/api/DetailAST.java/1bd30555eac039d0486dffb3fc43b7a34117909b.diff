diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java b/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
index 6558a8725..f671cf521 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
@@ -48,169 +48,169 @@ public final class DetailAST extends CommonASTWithHiddenTokens
     private int columnNo = NOT_INITIALIZED;
 
     /** number of children */
     private int childCount = NOT_INITIALIZED;
     /** the parent token */
     private DetailAST parent;
     /** previous sibling */
     private DetailAST previousSibling;
 
     /**
      * All token types in this branch.
      * Token 'x' (where x is an int) is in this branch
      * if branchTokenTypes.get(x) is true.
      */
     private BitSet branchTokenTypes;
 
     @Override
     public void initialize(Token tok)
     {
         super.initialize(tok);
         lineNo = tok.getLine();
         columnNo = tok.getColumn() - 1; // expect columns to start @ 0
     }
 
     @Override
     public void initialize(AST ast)
     {
         final DetailAST da = (DetailAST) ast;
         setText(da.getText());
         setType(da.getType());
         lineNo = da.getLineNo();
         columnNo = da.getColumnNo();
         hiddenAfter = da.getHiddenAfter();
         hiddenBefore = da.getHiddenBefore();
     }
 
     @Override
     public void setFirstChild(AST ast)
     {
         childCount = NOT_INITIALIZED;
         super.setFirstChild(ast);
         if (ast != null) {
             ((DetailAST) ast).setParent(this);
         }
     }
 
     @Override
     public void setNextSibling(AST ast)
     {
         super.setNextSibling(ast);
-        if ((ast != null) && (parent != null)) {
+        if (ast != null && parent != null) {
             ((DetailAST) ast).setParent(parent);
         }
         if (ast != null) {
             ((DetailAST) ast).setPreviousSibling(this);
         }
     }
 
     /**
      * Add previous sibling.
      * @param ast
      *        DetailAST object.
      */
     public void addPreviousSibling(DetailAST ast)
     {
         if (ast != null) {
             ast.setParent(parent);
             final DetailAST previousSibling = this.getPreviousSibling();
 
             if (previousSibling != null) {
                 ast.setPreviousSibling(previousSibling);
                 previousSibling.setNextSibling(ast);
             }
             else if (parent != null) {
                 parent.setFirstChild(ast);
             }
 
             ast.setNextSibling(this);
             this.setPreviousSibling(ast);
         }
     }
 
     /**
      * Add next sibling.
      * @param ast
      *        DetailAST object.
      */
     public void addNextSibling(DetailAST ast)
     {
         if (ast != null) {
             ast.setParent(parent);
             final DetailAST nextSibling = this.getNextSibling();
 
             if (nextSibling != null) {
                 ast.setNextSibling(nextSibling);
                 nextSibling.setPreviousSibling(ast);
             }
 
             ast.setPreviousSibling(this);
             this.setNextSibling(ast);
         }
     }
 
     /**
      * Sets previous sibling.
      * @param ast a previous sibling
      */
     void setPreviousSibling(DetailAST ast)
     {
         previousSibling = ast;
     }
 
     @Override
     public void addChild(AST ast)
     {
         super.addChild(ast);
         if (ast != null) {
             ((DetailAST) ast).setParent(this);
-            (getFirstChild()).setParent(this);
+            getFirstChild().setParent(this);
         }
     }
 
     /**
      * Returns the number of child nodes one level below this node. That is is
      * does not recurse down the tree.
      * @return the number of child nodes
      */
     public int getChildCount()
     {
         // lazy init
         if (childCount == NOT_INITIALIZED) {
             childCount = 0;
             AST child = getFirstChild();
 
             while (child != null) {
                 childCount += 1;
                 child = child.getNextSibling();
             }
         }
         return childCount;
     }
 
     /**
      * Set the parent token.
      * @param parent the parent token
      */
     // TODO: should be private but that breaks the DetailASTTest
     // until we manage parent in DetailAST instead of externally
     void setParent(DetailAST parent)
     {
         // TODO: Check visibility, could be private
         // if set in setFirstChild() and friends
         this.parent = parent;
         final DetailAST nextSibling = getNextSibling();
         if (nextSibling != null) {
             nextSibling.setParent(parent);
             nextSibling.setPreviousSibling(this);
         }
     }
 
     /**
      * Returns the parent token.
      * @return the parent token
      */
     public DetailAST getParent()
     {
         return parent;
     }
 
@@ -253,101 +253,101 @@ public final class DetailAST extends CommonASTWithHiddenTokens
     public void setLineNo(int lineNo)
     {
         this.lineNo = lineNo;
     }
 
     /** @return the column number **/
     public int getColumnNo()
     {
         if (columnNo == NOT_INITIALIZED) {
             // an inner AST that has been initialized
             // with initialize(String text)
             DetailAST child = getFirstChild();
             while (child != null) {
                 // comment node can't be start of any java statement/definition
                 if (TokenTypes.isCommentType(child.getType())) {
                     child = child.getNextSibling();
                 }
                 else {
                     return child.getColumnNo();
                 }
             }
 
             DetailAST sibling = getNextSibling();
             while (sibling != null) {
                 // comment node can't be start of any java statement/definition
                 if (TokenTypes.isCommentType(sibling.getType())) {
                     sibling = sibling.getNextSibling();
                 }
                 else {
                     return sibling.getColumnNo();
                 }
             }
         }
         return columnNo;
     }
 
     /**
      * Set column number.
      * @param columnNo
      *        column number.
      */
     public void setColumnNo(int columnNo)
     {
         this.columnNo = columnNo;
     }
 
     /** @return the last child node */
     public DetailAST getLastChild()
     {
         DetailAST ast = getFirstChild();
-        while ((ast != null) && (ast.getNextSibling() != null)) {
+        while (ast != null && ast.getNextSibling() != null) {
             ast = ast.getNextSibling();
         }
         return ast;
     }
 
     /**
      * @return the token types that occur in the branch as a sorted set.
      */
     private BitSet getBranchTokenTypes()
     {
         // lazy init
         if (branchTokenTypes == null) {
 
             branchTokenTypes = new BitSet();
             branchTokenTypes.set(getType());
 
             // add union of all childs
             DetailAST child = getFirstChild();
             while (child != null) {
                 final BitSet childTypes = child.getBranchTokenTypes();
                 branchTokenTypes.or(childTypes);
 
                 child = child.getNextSibling();
             }
         }
         return branchTokenTypes;
     }
 
     /**
      * Checks if this branch of the parse tree contains a token
      * of the provided type.
      * @param type a TokenType
      * @return true if and only if this branch (including this node)
      * contains a token of type <code>type</code>.
      */
     public boolean branchContains(int type)
     {
         return getBranchTokenTypes().get(type);
     }
 
     /**
      * Returns the number of direct child tokens that have the specified type.
      * @param type the token type to match
      * @return the number of matching token
      */
     public int getChildCount(int type)
     {
         int count = 0;
         for (AST i = getFirstChild(); i != null; i = i.getNextSibling()) {
             if (i.getType() == type) {
