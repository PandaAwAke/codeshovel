diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index 37f91bcff..df30913a6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -111,356 +111,356 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * MyClass c = new MyClass() {}; // empty anonymous class
  * while (i = 1) {} // empty while loop
  * for (int i = 1; i &gt; 1; i++) {} // empty for loop
  * do {} while (i = 1); // empty do-while loop
  * public @interface Beta {} // empty annotation type
  * </code></pre>
  *
  * <p>
  * To configure the check to allow empty method blocks use
  *
  * <p>
  * <pre>   &lt;property name="allowEmptyMethods" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty constructor blocks use
  *
  * <p>
  * <pre>   &lt;property name="allowEmptyConstructors" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty type blocks use
  *
  * <p>
  * <pre>   &lt;property name="allowEmptyTypes" value="true" /&gt;</pre>
  *
  * <p>
  * To configure the check to allow empty loop blocks use
  *
  * <p>
  * <pre>   &lt;property name="allowEmptyLoops" value="true" /&gt;</pre>
  *
  *
  * <p>
  * Also, this check can be configured to ignore the colon in an enhanced for
  * loop. The colon in an enhanced for loop is ignored by default
  *
  * <p>
  * To configure the check to ignore the colon
  *
  * <p>
  * <pre>   &lt;property name="ignoreEnhancedForColon" value="true" /&gt;</pre>
  *
  *
  * @author Oliver Burn
  * @author maxvetrenko
  * @version 1.0
  */
 public class WhitespaceAroundCheck extends Check
 {
     /** Whether or not empty constructor bodies are allowed. */
-    private boolean mAllowEmptyCtors;
+    private boolean allowEmptyCtors;
     /** Whether or not empty method bodies are allowed. */
-    private boolean mAllowEmptyMethods;
+    private boolean allowEmptyMethods;
     /** Whether or not empty classes, enums and interfaces are allowed*/
-    private boolean mAllowEmptyTypes;
+    private boolean allowEmptyTypes;
     /** Whether or not empty loops are allowed*/
-    private boolean mAllowEmptyLoops;
+    private boolean allowEmptyLoops;
     /** whether or not to ignore a colon in a enhanced for loop */
-    private boolean mIgnoreEnhancedForColon = true;
+    private boolean ignoreEnhancedForColon = true;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.ASSIGN,
             TokenTypes.BAND,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.COLON,
             TokenTypes.DIV,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.DO_WHILE,
             TokenTypes.EQUAL,
             TokenTypes.GE,
             TokenTypes.GT,
             TokenTypes.LAND,
             TokenTypes.LCURLY,
             TokenTypes.LE,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LOR,
             TokenTypes.LT,
             TokenTypes.MINUS,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.NOT_EQUAL,
             TokenTypes.PLUS,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.QUESTION,
             TokenTypes.RCURLY,
             TokenTypes.SL,
             TokenTypes.SLIST,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.LITERAL_ASSERT,
             TokenTypes.TYPE_EXTENSION_AND,
         };
     }
 
     /**
      * Sets whether or not empty method bodies are allowed.
-     * @param aAllow <code>true</code> to allow empty method bodies.
+     * @param allow <code>true</code> to allow empty method bodies.
      */
-    public void setAllowEmptyMethods(boolean aAllow)
+    public void setAllowEmptyMethods(boolean allow)
     {
-        mAllowEmptyMethods = aAllow;
+        allowEmptyMethods = allow;
     }
 
     /**
      * Sets whether or not empty constructor bodies are allowed.
-     * @param aAllow <code>true</code> to allow empty constructor bodies.
+     * @param allow <code>true</code> to allow empty constructor bodies.
      */
-    public void setAllowEmptyConstructors(boolean aAllow)
+    public void setAllowEmptyConstructors(boolean allow)
     {
-        mAllowEmptyCtors = aAllow;
+        allowEmptyCtors = allow;
     }
 
     /**
      * Sets whether or not to ignore the whitespace around the
      * colon in an enhanced for loop.
-     * @param aIgnore <code>true</code> to ignore enhanced for colon.
+     * @param ignore <code>true</code> to ignore enhanced for colon.
      */
-    public void setIgnoreEnhancedForColon(boolean aIgnore)
+    public void setIgnoreEnhancedForColon(boolean ignore)
     {
-        mIgnoreEnhancedForColon = aIgnore;
+        ignoreEnhancedForColon = ignore;
     }
 
     /**
      * Sets whether or not empty type bodies are allowed.
-     * @param aAllow <code>true</code> to allow empty type bodies.
+     * @param allow <code>true</code> to allow empty type bodies.
      */
-    public void setAllowEmptyTypes(boolean aAllow)
+    public void setAllowEmptyTypes(boolean allow)
     {
-        mAllowEmptyTypes = aAllow;
+        allowEmptyTypes = allow;
     }
 
     /**
      * Sets whether or not empty loop bodies are allowed.
-     * @param aAllow <code>true</code> to allow empty loops bodies.
+     * @param allow <code>true</code> to allow empty loops bodies.
      */
-    public void setAllowEmptyLoops(boolean aAllow)
+    public void setAllowEmptyLoops(boolean allow)
     {
-        mAllowEmptyLoops = aAllow;
+        allowEmptyLoops = allow;
     }
 
     @Override
-    public void visitToken(DetailAST aAST)
+    public void visitToken(DetailAST ast)
     {
-        final int currentType = aAST.getType();
-        final int parentType = aAST.getParent().getType();
+        final int currentType = ast.getType();
+        final int parentType = ast.getParent().getType();
 
         // Check for CURLY in array initializer
         if (((currentType == TokenTypes.RCURLY)
                 || (currentType == TokenTypes.LCURLY))
             && ((parentType == TokenTypes.ARRAY_INIT)
                 || (parentType == TokenTypes.ANNOTATION_ARRAY_INIT)))
         {
             return;
         }
 
         // Check for import pkg.name.*;
         if ((currentType == TokenTypes.STAR)
             && (parentType == TokenTypes.DOT))
         {
             return;
         }
 
         // Check for an SLIST that has a parent CASE_GROUP. It is not a '{'.
         if ((currentType == TokenTypes.SLIST)
             && (parentType == TokenTypes.CASE_GROUP))
         {
             return;
         }
 
         if ((currentType == TokenTypes.COLON)) {
             //we do not want to check colon for cases and defaults
             if (parentType == TokenTypes.LITERAL_DEFAULT
                 || parentType == TokenTypes.LITERAL_CASE)
             {
                 return;
             }
             else if (parentType == TokenTypes.FOR_EACH_CLAUSE
-                && this.mIgnoreEnhancedForColon)
+                && this.ignoreEnhancedForColon)
             {
                 return;
             }
         }
 
         // Checks if empty methods, ctors or loops are allowed.
-        if (isEmptyMethodBlock(aAST, parentType)
-                || isEmptyCtorBlock(aAST, parentType)
-                || isEmptyLoop(aAST, parentType))
+        if (isEmptyMethodBlock(ast, parentType)
+                || isEmptyCtorBlock(ast, parentType)
+                || isEmptyLoop(ast, parentType))
         {
             return;
         }
 
         // Checks if empty classes, interfaces or enums are allowed
-        if (mAllowEmptyTypes && (isEmptyType(aAST, parentType))) {
+        if (allowEmptyTypes && (isEmptyType(ast, parentType))) {
             return;
         }
 
-        final String line = getLine(aAST.getLineNo() - 1);
-        final int before = aAST.getColumnNo() - 1;
-        final int after = aAST.getColumnNo() + aAST.getText().length();
+        final String line = getLine(ast.getLineNo() - 1);
+        final int before = ast.getColumnNo() - 1;
+        final int after = ast.getColumnNo() + ast.getText().length();
 
         if ((before >= 0) && !Character.isWhitespace(line.charAt(before))) {
-            log(aAST.getLineNo(), aAST.getColumnNo(),
-                    "ws.notPreceded", aAST.getText());
+            log(ast.getLineNo(), ast.getColumnNo(),
+                    "ws.notPreceded", ast.getText());
         }
 
         if (after >= line.length()) {
             return;
         }
 
         final char nextChar = line.charAt(after);
         if (!Character.isWhitespace(nextChar)
             // Check for "return;"
             && !((currentType == TokenTypes.LITERAL_RETURN)
-                && (aAST.getFirstChild().getType() == TokenTypes.SEMI))
+                && (ast.getFirstChild().getType() == TokenTypes.SEMI))
             // Check for "})" or "};" or "},". Happens with anon-inners
             && !((currentType == TokenTypes.RCURLY)
                 && ((nextChar == ')')
                     || (nextChar == ';')
                     || (nextChar == ',')
                     || (nextChar == '.'))))
         {
-            log(aAST.getLineNo(), aAST.getColumnNo() + aAST.getText().length(),
-                    "ws.notFollowed", aAST.getText());
+            log(ast.getLineNo(), ast.getColumnNo() + ast.getText().length(),
+                    "ws.notFollowed", ast.getText());
         }
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * method block.
-     * @param aAST the <code>DetailAST</code> to test.
-     * @param aParentType the token type of <code>aAST</code>'s parent.
-     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     * @param ast the <code>DetailAST</code> to test.
+     * @param parentType the token type of <code>ast</code>'s parent.
+     * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty method block.
      */
-    private boolean isEmptyMethodBlock(DetailAST aAST, int aParentType)
+    private boolean isEmptyMethodBlock(DetailAST ast, int parentType)
     {
-        return mAllowEmptyMethods
-            && isEmptyBlock(aAST, aParentType, TokenTypes.METHOD_DEF);
+        return allowEmptyMethods
+            && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * constructor (ctor) block.
-     * @param aAST the <code>DetailAST</code> to test.
-     * @param aParentType the token type of <code>aAST</code>'s parent.
-     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     * @param ast the <code>DetailAST</code> to test.
+     * @param parentType the token type of <code>ast</code>'s parent.
+     * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty constructor block.
      */
-    private boolean isEmptyCtorBlock(DetailAST aAST, int aParentType)
+    private boolean isEmptyCtorBlock(DetailAST ast, int parentType)
     {
-        return mAllowEmptyCtors
-            && isEmptyBlock(aAST, aParentType, TokenTypes.CTOR_DEF);
+        return allowEmptyCtors
+            && isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
-     * @param aAST aAST the <code>DetailAST</code> to test.
-     * @param aParentType the token type of <code>aAST</code>'s parent.
-     * @return <code>true</code> if <code>aAST</code> makes up part of an
+     * @param ast ast the <code>DetailAST</code> to test.
+     * @param parentType the token type of <code>ast</code>'s parent.
+     * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty loop block.
      */
-    private boolean isEmptyLoop(DetailAST aAST, int aParentType)
+    private boolean isEmptyLoop(DetailAST ast, int parentType)
     {
-        return mAllowEmptyLoops
-            && (isEmptyBlock(aAST, aParentType, TokenTypes.LITERAL_FOR)
-                    || isEmptyBlock(aAST,
-                            aParentType, TokenTypes.LITERAL_WHILE)
-                            || isEmptyBlock(aAST,
-                                    aParentType, TokenTypes.LITERAL_DO));
+        return allowEmptyLoops
+            && (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)
+                    || isEmptyBlock(ast,
+                            parentType, TokenTypes.LITERAL_WHILE)
+                            || isEmptyBlock(ast,
+                                    parentType, TokenTypes.LITERAL_DO));
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
      *
-     * @param aAST aAST the <code>DetailAST</code> to test.
-     * @param aParentType the token type of <code>aAST</code>'s parent.
-     * @return <code>true</code> if <code>aAST</code> makes up part of an
-     *         empty block contained under a <code>aMatch</code> token type
+     * @param ast ast the <code>DetailAST</code> to test.
+     * @param parentType the token type of <code>ast</code>'s parent.
+     * @return <code>true</code> if <code>ast</code> makes up part of an
+     *         empty block contained under a <code>match</code> token type
      *         node.
      */
-    private boolean isEmptyType(DetailAST aAST, int aParentType)
+    private boolean isEmptyType(DetailAST ast, int parentType)
     {
-        final int type = aAST.getType();
+        final int type = ast.getType();
         if ((type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
-                && aParentType == TokenTypes.OBJBLOCK)
+                && parentType == TokenTypes.OBJBLOCK)
         {
-            final DetailAST typeNode = aAST.getParent().getParent();
+            final DetailAST typeNode = ast.getParent().getParent();
             final int matchType = typeNode.getType();
             if (matchType == TokenTypes.CLASS_DEF
                     || matchType == TokenTypes.INTERFACE_DEF
                     || matchType == TokenTypes.ENUM_DEF
                     || matchType == TokenTypes.LITERAL_NEW
                     || matchType == TokenTypes.ANNOTATION_DEF)
             {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Tests if a given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * </p>
      * In the above, the method body is an empty block ("{}").
      *
-     * @param aAST the <code>DetailAST</code> to test.
-     * @param aParentType the token type of <code>aAST</code>'s parent.
-     * @param aMatch the parent token type we're looking to match.
-     * @return <code>true</code> if <code>aAST</code> makes up part of an
-     *         empty block contained under a <code>aMatch</code> token type
+     * @param ast the <code>DetailAST</code> to test.
+     * @param parentType the token type of <code>ast</code>'s parent.
+     * @param match the parent token type we're looking to match.
+     * @return <code>true</code> if <code>ast</code> makes up part of an
+     *         empty block contained under a <code>match</code> token type
      *         node.
      */
-    private boolean isEmptyBlock(DetailAST aAST, int aParentType, int aMatch)
+    private boolean isEmptyBlock(DetailAST ast, int parentType, int match)
     {
-        final int type = aAST.getType();
+        final int type = ast.getType();
         if (type == TokenTypes.RCURLY) {
-            final DetailAST grandParent = aAST.getParent().getParent();
-            return (aParentType == TokenTypes.SLIST)
-                && (grandParent.getType() == aMatch);
+            final DetailAST grandParent = ast.getParent().getParent();
+            return (parentType == TokenTypes.SLIST)
+                && (grandParent.getType() == match);
         }
 
         return (type == TokenTypes.SLIST)
-            && (aParentType == aMatch)
-            && (aAST.getFirstChild().getType() == TokenTypes.RCURLY);
+            && (parentType == match)
+            && (ast.getFirstChild().getType() == TokenTypes.RCURLY);
     }
 }
