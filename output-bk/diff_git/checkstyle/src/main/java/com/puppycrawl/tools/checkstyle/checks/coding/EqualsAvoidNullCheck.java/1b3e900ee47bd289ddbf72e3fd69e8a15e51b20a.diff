diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
index 260dc2206..892ec076b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
@@ -106,154 +106,147 @@ public class EqualsAvoidNullCheck extends Check {
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.METHOD_CALL};
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.METHOD_CALL};
     }
 
     @Override
     public void visitToken(final DetailAST methodCall) {
         final DetailAST dot = methodCall.getFirstChild();
         if (dot.getType() != TokenTypes.DOT) {
             return;
         }
 
         final DetailAST objCalledOn = dot.getFirstChild();
         if (isStringLiteral(objCalledOn)) {
             return;
         }
 
 
         final DetailAST method = objCalledOn.getNextSibling();
         final DetailAST expr = dot.getNextSibling().getFirstChild();
 
         if ("equals".equals(method.getText())
             && containsOneArg(expr) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_AVOID_NULL);
         }
 
         if (!ignoreEqualsIgnoreCase
             && "equalsIgnoreCase".equals(method.getText())
             && containsOneArg(expr) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_IGNORE_CASE_AVOID_NULL);
         }
     }
 
     /**
      * checks for calling equals on String literal and
      * anon object which cannot be null
      * Also, checks if calling using strange inner class
      * syntax outter.inner.equals(otherObj) by looking
      * for the dot operator which cannot be improved
      * @param objCalledOn object AST
      * @return if it is string literal
      */
     private boolean isStringLiteral(DetailAST objCalledOn) {
-        if (objCalledOn.getType() == TokenTypes.STRING_LITERAL
+        return objCalledOn.getType() == TokenTypes.STRING_LITERAL
                 || objCalledOn.getType() == TokenTypes.LITERAL_NEW
-                || objCalledOn.getType() == TokenTypes.DOT) {
-            return true;
-        }
-        return false;
+                || objCalledOn.getType() == TokenTypes.DOT;
     }
 
     /**
      * Checks if a method contains no arguments
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains no args, false if not
      */
     private boolean containsNoArgs(final AST expr) {
         return expr == null;
     }
 
     /**
      * Checks if a method contains multiple arguments
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains multiple args, false if not
      */
     private boolean containsMultiArgs(final AST expr) {
         final AST comma = expr.getNextSibling();
         return comma != null && comma.getType() == TokenTypes.COMMA;
     }
 
     /**
      * Checks if a method contains a single argument
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains a single arg, false if not
      */
     private boolean containsOneArg(final AST expr) {
         return !containsNoArgs(expr) && !containsMultiArgs(expr);
     }
 
     /**
      * <p>
      * Looks for all "safe" Token combinations in the argument
      * expression branch.
      * </p>
      *
      * <p>
      * See class documentation for details on autoboxing's affect
      * on this method implementation.
      * </p>
      *
      * @param expr the argument expression
      * @return - true if any child matches the set of tokens, false if not
      */
     private boolean containsAllSafeTokens(final DetailAST expr) {
         DetailAST arg = expr.getFirstChild();
 
         if (arg.branchContains(TokenTypes.METHOD_CALL)) {
             return false;
         }
         arg = skipVariableAssign(arg);
 
         //Plus assignment can have ill affects
         //do not want to recommend moving expression
         //See example:
         //String s = "SweetString";
         //s.equals(s += "SweetString"); //false
         //s = "SweetString";
         //(s += "SweetString").equals(s); //true
         //arg = skipVariablePlusAssign(arg);
 
-        if (arg.branchContains(TokenTypes.PLUS_ASSIGN)
-                || arg.branchContains(TokenTypes.IDENT)) {
-            return false;
-        }
-
-        //must be just String literals if got here
-        return true;
+        //must be just String literals to return true
+        return !arg.branchContains(TokenTypes.PLUS_ASSIGN)
+                && !arg.branchContains(TokenTypes.IDENT);
     }
 
     /**
      * Skips over an inner assign portion of an argument expression.
      * @param currentAST current token in the argument expression
      * @return the next relevant token
      */
     private DetailAST skipVariableAssign(final DetailAST currentAST) {
         if (currentAST.getType() == TokenTypes.ASSIGN
                 && currentAST.getFirstChild().getType() == TokenTypes.IDENT) {
             return currentAST.getFirstChild().getNextSibling();
         }
         return currentAST;
     }
 
     /**
      * Whether to ignore checking {@code String.equalsIgnoreCase(String)}.
      * @param newValue whether to ignore checking
      *    {@code String.equalsIgnoreCase(String)}.
      */
     public void setIgnoreEqualsIgnoreCase(boolean newValue) {
         ignoreEqualsIgnoreCase = newValue;
     }
 }
