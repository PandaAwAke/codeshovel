diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index 1e29ec4cd..5b843e77e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -59,100 +59,101 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  *  {@link TokenTypes#LITERAL_TRY LITERAL_TRY},
  *  {@link TokenTypes#LITERAL_WHILE LITERAL_WHILE},
  *  {@link TokenTypes#LOR LOR},
  *  {@link TokenTypes#LT LT},
  *  {@link TokenTypes#MINUS MINUS},
  *  {@link TokenTypes#MINUS_ASSIGN MINUS_ASSIGN},
  *  {@link TokenTypes#MOD MOD},
  *  {@link TokenTypes#MOD_ASSIGN MOD_ASSIGN},
  *  {@link TokenTypes#NOT_EQUAL NOT_EQUAL},
  *  {@link TokenTypes#PLUS PLUS},
  *  {@link TokenTypes#PLUS_ASSIGN PLUS_ASSIGN},
  *  {@link TokenTypes#QUESTION QUESTION},
  *  {@link TokenTypes#RCURLY RCURLY},
  *  {@link TokenTypes#SL SL},
  *  {@link TokenTypes#SLIST SLIST},
  *  {@link TokenTypes#SL_ASSIGN SL_ASSIGN},
  *  {@link TokenTypes#SR SR},
  *  {@link TokenTypes#SR_ASSIGN SR_ASSIGN},
  *  {@link TokenTypes#STAR STAR},
  *  {@link TokenTypes#STAR_ASSIGN STAR_ASSIGN},
  *  {@link TokenTypes#LITERAL_ASSERT LITERAL_ASSERT},
  *  {@link TokenTypes#TYPE_EXTENSION_AND TYPE_EXTENSION_AND}.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="WhitespaceAround"/&gt;
  * </pre>
  * <p> An example of how to configure the check for whitespace only around
  * assignment operators is:
  * </p>
  * <pre>
  * &lt;module name="WhitespaceAround"&gt;
  *     &lt;property name="tokens"
  *               value="ASSIGN,DIV_ASSIGN,PLUS_ASSIGN,MINUS_ASSIGN,STAR_ASSIGN,MOD_ASSIGN,SR_ASSIGN,BSR_ASSIGN,SL_ASSIGN,BXOR_ASSIGN,BOR_ASSIGN,BAND_ASSIGN"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>
  * In addition, this check can be configured to allow empty methods, types,
  * for, while, do-while loops and constructor bodies.
  * For example:
  * </p>
  * <p>
  * <pre><code>
  * public MyClass() {}      // empty constructor
  * public void func() {}    // empty method
  * public interface Foo {} // empty interface
  * public class Foo {} // empty class
  * public enum Foo {} // empty enum
+ * MyClass c = new MyClass() {}; // empty anonymous class
  * while (i = 1) {} // empty while loop
  * for (int i = 1; i > 1; i++) {} // empty for loop
  * do {} while (i = 1); // empty do-while loop
  * </code></pre>
  * </p>
  * <p>
  * To configure the check to allow empty method blocks use
  * </p>
  * <p>
  * <pre>   &lt;property name="allowEmptyMethods" value="true" /&gt;</pre>
  * </p>
  * <p>
  * To configure the check to allow empty constructor blocks use
  * </p>
  * <p>
  * <pre>   &lt;property name="allowEmptyConstructors" value="true" /&gt;</pre>
  * </p>
  * <p>
  * To configure the check to allow empty type blocks use
  * </p>
  * <p>
  * <pre>   &lt;property name="allowEmptyTypes" value="true" /&gt;</pre>
  * </p>
  * <p>
  * To configure the check to allow empty loop blocks use
  * </p>
  * <p>
  * <pre>   &lt;property name="allowEmptyLoops" value="true" /&gt;</pre>
  * </p>
  *
  * <p>
  * Also, this check can be configured to ignore the colon in an enhanced for
  * loop. The colon in an enhanced for loop is ignored by default
  * </p>
  * <p>
  * To configure the check to ignore the colon
  * </p>
  * <p>
  * <pre>   &lt;property name="ignoreEnhancedForColon" value="true" /&gt;</pre>
  * </p>
  *
  * @author Oliver Burn
  * @author maxvetrenko
  * @version 1.0
  */
 public class WhitespaceAroundCheck extends Check
 {
     /** Whether or not empty constructor bodies are allowed. */
     private boolean mAllowEmptyCtors;
     /** Whether or not empty method bodies are allowed. */
@@ -374,87 +375,88 @@ public class WhitespaceAroundCheck extends Check
      * @param aParentType the token type of <code>aAST</code>'s parent.
      * @return <code>true</code> if <code>aAST</code> makes up part of an
      *         allowed empty constructor block.
      */
     private boolean isEmptyCtorBlock(DetailAST aAST, int aParentType)
     {
         return mAllowEmptyCtors
             && isEmptyBlock(aAST, aParentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
      * @param aAST aAST the <code>DetailAST</code> to test.
      * @param aParentType the token type of <code>aAST</code>'s parent.
      * @return <code>true</code> if <code>aAST</code> makes up part of an
      *         allowed empty loop block.
      */
     private boolean isEmptyLoop(DetailAST aAST, int aParentType)
     {
         return mAllowEmptyLoops
             && (isEmptyBlock(aAST, aParentType, TokenTypes.LITERAL_FOR)
                     || isEmptyBlock(aAST,
                             aParentType, TokenTypes.LITERAL_WHILE)
                             || isEmptyBlock(aAST,
                                     aParentType, TokenTypes.LITERAL_DO));
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
      *
      * @param aAST aAST the <code>DetailAST</code> to test.
      * @param aParentType the token type of <code>aAST</code>'s parent.
      * @return <code>true</code> if <code>aAST</code> makes up part of an
      *         empty block contained under a <code>aMatch</code> token type
      *         node.
      */
     private boolean isEmptyType(DetailAST aAST, int aParentType)
     {
         final int type = aAST.getType();
         if ((type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
                 && aParentType == TokenTypes.OBJBLOCK)
         {
             final DetailAST typeNode = aAST.getParent().getParent();
             final int matchType = typeNode.getType();
             if (matchType == TokenTypes.CLASS_DEF
                     || matchType == TokenTypes.INTERFACE_DEF
-                    || matchType == TokenTypes.ENUM_DEF)
+                    || matchType == TokenTypes.ENUM_DEF
+                    || matchType == TokenTypes.LITERAL_NEW)
             {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Tests if a given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * <p>
      * In the above, the method body is an empty block ("{}").
      *
      * @param aAST the <code>DetailAST</code> to test.
      * @param aParentType the token type of <code>aAST</code>'s parent.
      * @param aMatch the parent token type we're looking to match.
      * @return <code>true</code> if <code>aAST</code> makes up part of an
      *         empty block contained under a <code>aMatch</code> token type
      *         node.
      */
     private boolean isEmptyBlock(DetailAST aAST, int aParentType, int aMatch)
     {
         final int type = aAST.getType();
         if (type == TokenTypes.RCURLY) {
             final DetailAST grandParent = aAST.getParent().getParent();
             return (aParentType == TokenTypes.SLIST)
                 && (grandParent.getType() == aMatch);
         }
 
         return (type == TokenTypes.SLIST)
             && (aParentType == aMatch)
             && (aAST.getFirstChild().getType() == TokenTypes.RCURLY);
     }
 }
