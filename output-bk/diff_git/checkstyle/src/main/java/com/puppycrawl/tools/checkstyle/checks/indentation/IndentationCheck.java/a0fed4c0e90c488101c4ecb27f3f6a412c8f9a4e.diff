diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java
index ba601f92a..a2d8d0d0b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java
@@ -65,100 +65,103 @@ import com.puppycrawl.tools.checkstyle.api.DetailAST;
  * <pre>
  *   - handler class -to-&gt; ID mapping kept in Map
  *   - parent passed in during construction
  *   - suggest child indent level
  *   - allows for some tokens to be on same line (ie inner classes OBJBLOCK)
  *     and not increase indentation level
  *   - looked at using double dispatch for getSuggestedChildIndent(), but it
  *     doesn't seem worthwhile, at least now
  *   - both tabs and spaces are considered whitespace in front of the line...
  *     tabs are converted to spaces
  *   - block parents with parens -- for, while, if, etc... -- are checked that
  *     they match the level of the parent
  * </pre>
  *
  * @author jrichard
  * @author o_sukhodolsky
  * @author Maikel Steneker
  * @author maxvetrenko
  */
 public class IndentationCheck extends AbstractCheck {
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ERROR = "indentation.error";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ERROR_MULTI = "indentation.error.multi";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CHILD_ERROR = "indentation.child.error";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CHILD_ERROR_MULTI = "indentation.child.error.multi";
 
     /** Default indentation amount - based on Sun. */
     private static final int DEFAULT_INDENTATION = 4;
 
     /** Handlers currently in use. */
     private final Deque<AbstractExpressionHandler> handlers = new ArrayDeque<>();
 
+    /** Instance of line wrapping handler to use. */
+    private final LineWrappingHandler lineWrappingHandler = new LineWrappingHandler(this);
+
     /** Factory from which handlers are distributed. */
     private final HandlerFactory handlerFactory = new HandlerFactory();
 
     /** Lines logged as having incorrect indentation. */
     private Set<Integer> incorrectIndentationLines;
 
     /** How many tabs or spaces to use. */
     private int basicOffset = DEFAULT_INDENTATION;
 
     /** How much to indent a case label. */
     private int caseIndent = DEFAULT_INDENTATION;
 
     /** How far brace should be indented when on next line. */
     private int braceAdjustment;
 
     /** How far throws should be indented when on next line. */
     private int throwsIndent = DEFAULT_INDENTATION;
 
     /** How much to indent an array initialization when on next line. */
     private int arrayInitIndent = DEFAULT_INDENTATION;
 
     /** How far continuation line should be indented when line-wrapping is present. */
     private int lineWrappingIndentation = DEFAULT_INDENTATION;
 
     /**
      * Force strict condition in line wrapping case. If value is true, line wrap indent
      * have to be same as lineWrappingIndentation parameter, if value is false, line wrap indent
      * have to be not less than lineWrappingIndentation parameter.
      */
     private boolean forceStrictCondition;
 
     /**
      * Get forcing strict condition.
      * @return forceStrictCondition value.
      */
     public boolean isForceStrictCondition() {
         return forceStrictCondition;
     }
 
     /**
      * Set forcing strict condition.
      * @param value user's value of forceStrictCondition.
      */
     public void setForceStrictCondition(boolean value) {
         forceStrictCondition = value;
     }
 
     /**
      * Set the basic offset.
      *
@@ -283,59 +286,68 @@ public class IndentationCheck extends AbstractCheck {
         }
     }
 
     /**
      * Get the width of a tab.
      *
      * @return the width of a tab
      */
     public int getIndentationTabWidth() {
         return getTabWidth();
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return handlerFactory.getHandledTypes();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST ast) {
         handlerFactory.clearCreatedHandlers();
         handlers.clear();
         final PrimordialHandler primordialHandler = new PrimordialHandler(this);
         handlers.push(primordialHandler);
         primordialHandler.checkIndentation();
         incorrectIndentationLines = new HashSet<>();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final AbstractExpressionHandler handler = handlerFactory.getHandler(this, ast,
             handlers.peek());
         handlers.push(handler);
         handler.checkIndentation();
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         handlers.pop();
     }
 
+    /**
+     * Accessor for the line wrapping handler.
+     *
+     * @return the line wrapping handler
+     */
+    public LineWrappingHandler getLineWrappingHandler() {
+        return lineWrappingHandler;
+    }
+
     /**
      * Accessor for the handler factory.
      *
      * @return the handler factory
      */
     public final HandlerFactory getHandlerFactory() {
         return handlerFactory;
     }
 }
