diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 347382ea2..3c8912c4c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -394,217 +394,199 @@ public class VisibilityModifierCheck
 
     @Override
     public void beginTree(DetailAST rootAst) {
         immutableClassShortNames.clear();
         final List<String> classShortNames =
                 getClassShortNames(immutableClassCanonicalNames);
         immutableClassShortNames.addAll(classShortNames);
 
         ignoreAnnotationShortNames.clear();
         final List<String> annotationShortNames =
                 getClassShortNames(ignoreAnnotationCanonicalNames);
         ignoreAnnotationShortNames.addAll(annotationShortNames);
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF:
                 if (!isAnonymousClassVariable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + ast.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks if current variable definition is definition of an anonymous class.
      * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
      * @return true if current variable definition is definition of an anonymous class.
      */
     private static boolean isAnonymousClassVariable(DetailAST variableDef) {
         return variableDef.getParent().getType() != TokenTypes.OBJBLOCK;
     }
 
     /**
      * Checks access modifier of given variable.
      * If it is not proper according to Check - puts violation on it.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         final boolean inInterfaceOrAnnotationBlock =
                 ScopeUtils.inInterfaceOrAnnotationBlock(variableDef);
 
         if (!inInterfaceOrAnnotationBlock && !hasIgnoreAnnotation(variableDef)) {
-            final DetailAST varNameAST = getVarNameAST(variableDef);
+            final DetailAST varNameAST = variableDef.findFirstToken(TokenTypes.TYPE)
+                .getNextSibling();
             final String varName = varNameAST.getText();
             if (!hasProperAccessModifier(variableDef, varName)) {
                 log(varNameAST.getLineNo(), varNameAST.getColumnNo(),
                         MSG_KEY, varName);
             }
         }
     }
 
     /**
      * Checks if variable def has ignore annotation.
      * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
      * @return true if variable def has ignore annotation.
      */
     private boolean hasIgnoreAnnotation(DetailAST variableDef) {
         final DetailAST firstIgnoreAnnotation =
                  containsMatchingAnnotation(variableDef);
         return firstIgnoreAnnotation != null;
     }
 
     /**
      * Checks imported type. If type's canonical name was not specified in
      * <b>immutableClassCanonicalNames</b>, but it's short name collides with one from
      * <b>immutableClassShortNames</b> - removes it from the last one.
      * @param importAst {@link TokenTypes#IMPORT Import}
      */
     private void visitImport(DetailAST importAst) {
         if (!isStarImport(importAst)) {
             final DetailAST type = importAst.getFirstChild();
             final String canonicalName = getCanonicalName(type);
             final String shortName = getClassShortName(canonicalName);
 
             // If imported canonical class name is not specified as allowed immutable class,
             // but its short name collides with one of specified class - removes the short name
             // from list to avoid names collision
             if (!immutableClassCanonicalNames.contains(canonicalName)
                      && immutableClassShortNames.contains(shortName)) {
                 immutableClassShortNames.remove(shortName);
             }
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName)) {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * <code>
      * import java.util.*;
      * </code>
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if current variable has proper access modifier according to Check's options.
      * @param variableDef Variable definition node.
      * @param variableName Variable's name.
      * @return true if variable has proper access modifier.
      */
     private boolean hasProperAccessModifier(DetailAST variableDef, String variableName) {
         boolean result = true;
 
         final Set<String> mods = getModifiers(variableDef);
         final String variableScope = getVisibilityScope(mods);
 
         if (!"private".equals(variableScope)) {
             final DetailAST classDef = variableDef.getParent().getParent();
             final Set<String> classModifiers = getModifiers(classDef);
 
             result =
                 mods.contains("static") && mods.contains("final")
                 || isPackageAllowed() && "package".equals(variableScope)
                 || isProtectedAllowed() && "protected".equals(variableScope)
                 || "public".equals(variableScope)
                    && getPublicMemberRegexp().matcher(variableName).find()
                    || allowPublicImmutableFields
                       && classModifiers.contains("final") && isImmutableField(variableDef);
         }
 
         return result;
     }
 
-    /**
-     * Returns the variable name in a VARIABLE_DEF AST.
-     * @param variableDefAST an AST where type == VARIABLE_DEF AST.
-     * @return the variable name in variableDefAST
-     */
-    private static DetailAST getVarNameAST(DetailAST variableDefAST) {
-        DetailAST ast = variableDefAST.getFirstChild();
-        DetailAST varNameAst = null;
-        while (ast != null) {
-            final DetailAST nextSibling = ast.getNextSibling();
-            if (ast.getType() == TokenTypes.TYPE) {
-                varNameAst = nextSibling;
-                break;
-            }
-            ast = nextSibling;
-        }
-        return varNameAst;
-    }
-
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST) {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
 
     }
 
     /**
      * Returns the visibility scope specified with a set of modifiers.
      * @param modifiers the set of modifier Strings
      * @return one of "public", "private", "protected", "package"
      */
     private static String getVisibilityScope(Set<String> modifiers) {
         String accessModifier = "package";
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
      * Checks if current field is immutable:
      * has final modifier and either a primitive type or instance of class
      * known to be immutable (such as String, ImmutableCollection from Guava and etc).
      * Classes known to be immutable are listed in
      * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
      * @param variableDef Field in consideration.
      * @return true if field is immutable.
      */
     private boolean isImmutableField(DetailAST variableDef) {
         boolean result = false;
 
         final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);
         final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
         if (isFinal) {
@@ -618,101 +600,101 @@ public class VisibilityModifierCheck
         }
         return result;
     }
 
     /**
      * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
      * If type is specified via its canonical name - canonical name will be returned,
      * else - short type's name.
      * @param type {@link TokenTypes#TYPE TYPE} node.
      * @param isCanonicalName is given name canonical.
      * @return String representation of given type's name.
      */
     private static String getTypeName(DetailAST type, boolean isCanonicalName) {
         String typeName = "";
         if (isCanonicalName) {
             typeName = getCanonicalName(type);
         }
         else {
             typeName = type.getFirstChild().getText();
         }
         return typeName;
     }
 
     /**
      * Checks if current type is primitive type (int, short, float, boolean, double, etc.).
      * As primitive types have special tokens for each one, such as:
      * LITERAL_INT, LITERAL_BOOLEAN, etc.
      * So, if type's identifier differs from {@link TokenTypes#IDENT IDENT} token - it's a
      * primitive type.
      * @param type Ast {@link TokenTypes#TYPE TYPE} node.
      * @return true if current type is primitive type.
      */
     private static boolean isPrimitive(DetailAST type) {
         return type.getFirstChild().getType() != TokenTypes.IDENT;
     }
 
     /**
      * Gets canonical type's name from given {@link TokenTypes#TYPE TYPE} node.
      * @param type DetailAST {@link TokenTypes#TYPE TYPE} node.
      * @return canonical type's name
      */
     private static String getCanonicalName(DetailAST type) {
         final StringBuilder canonicalNameBuilder = new StringBuilder();
         DetailAST toVisit = type.getFirstChild();
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, type);
             if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
                 canonicalNameBuilder.append(toVisit.getText());
                 final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit,
                          type);
-                if (nextSubTreeNode != null && nextSubTreeNode.getType() != TokenTypes.SEMI) {
+                if (nextSubTreeNode != null) {
                     canonicalNameBuilder.append('.');
                 }
             }
         }
         return canonicalNameBuilder.toString();
     }
 
     /**
      * Gets the next node of a syntactical tree (child of a current node or
      * sibling of a current node, or sibling of a parent of a current node)
      * @param currentNodeAst Current node in considering
      * @param subTreeRootAst SubTree root
      * @return Current node after bypassing, if current node reached the root of a subtree
      *        method returns null
      */
     private static DetailAST
         getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
         DetailAST currentNode = currentNodeAst;
         DetailAST toVisitAst = currentNode.getFirstChild();
         while (toVisitAst == null) {
             toVisitAst = currentNode.getNextSibling();
             if (toVisitAst == null) {
                 if (currentNode.getParent().equals(subTreeRootAst)
                          && currentNode.getParent().getColumnNo() == subTreeRootAst.getColumnNo()) {
                     break;
                 }
                 currentNode = currentNode.getParent();
             }
         }
         currentNode = toVisitAst;
         return currentNode;
     }
 
     /**
      * Gets the list with short names classes.
      * These names are taken from array of classes canonical names.
      * @param canonicalClassNames canonical class names.
      * @return the list of short names of classes.
      */
     private static List<String> getClassShortNames(List<String> canonicalClassNames) {
         final List<String> shortNames = new ArrayList<>();
         for (String canonicalClassName : canonicalClassNames) {
             final String shortClassName = canonicalClassName
                     .substring(canonicalClassName.lastIndexOf('.') + 1,
                     canonicalClassName.length());
             shortNames.add(shortClassName);
         }
         return shortNames;
     }
 
