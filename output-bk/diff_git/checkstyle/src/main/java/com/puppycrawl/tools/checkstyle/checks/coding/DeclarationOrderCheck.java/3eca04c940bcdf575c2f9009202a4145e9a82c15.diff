diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 8bc2e095a..33bd811ea 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -100,164 +100,192 @@ public class DeclarationOrderCheck extends Check {
     /** State for the METHOD_DEF */
     private static final int STATE_METHOD_DEF = 4;
 
     /**
      * List of Declaration States. This is necessary due to
      * inner classes that have their own state
      */
     private final Deque<ScopeState> scopeStates = new ArrayDeque<>();
 
     /**
      * private class to encapsulate the state
      */
     private static class ScopeState {
         /** The state the check is in */
         private int currentScopeState = STATE_STATIC_VARIABLE_DEF;
 
         /** The sub-state the check is in */
         private Scope declarationAccess = Scope.PUBLIC;
     }
 
     /** If true, ignores the check to constructors. */
     private boolean ignoreConstructors;
     /** If true, ignore the check to methods. */
     private boolean ignoreMethods;
     /** If true, ignore the check to modifiers (fields, ...). */
     private boolean ignoreModifiers;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int parentType = ast.getParent().getType();
-        ScopeState state;
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
 
             case TokenTypes.CTOR_DEF:
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
-                state = scopeStates.peek();
-                if (state.currentScopeState > STATE_CTOR_DEF) {
-                    if (!ignoreConstructors) {
-                        log(ast, MSG_CONSTRUCTOR);
-                    }
-                }
-                else {
-                    state.currentScopeState = STATE_CTOR_DEF;
-                }
+                processConstructor(ast);
                 break;
 
             case TokenTypes.METHOD_DEF:
-                state = scopeStates.peek();
+
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
-                if (state.currentScopeState > STATE_METHOD_DEF) {
-                    if (!ignoreMethods) {
-                        log(ast, MSG_METHOD);
-                    }
-                }
-                else {
-                    state.currentScopeState = STATE_METHOD_DEF;
-                }
+                processMethod(ast);
                 break;
 
             case TokenTypes.MODIFIERS:
                 if (parentType != TokenTypes.VARIABLE_DEF
-                    || ast.getParent().getParent().getType()
+                        || ast.getParent().getParent().getType()
                         != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
-                state = scopeStates.peek();
-                if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
-                    if (state.currentScopeState > STATE_STATIC_VARIABLE_DEF) {
-                        if (!ignoreModifiers
-                            || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
-                            log(ast, MSG_STATIC);
-                        }
-                    }
-                    else {
-                        state.currentScopeState = STATE_STATIC_VARIABLE_DEF;
-                    }
-                }
-                else {
-                    if (state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
-                        log(ast, MSG_INSTANCE);
-                    }
-                    else if (state.currentScopeState == STATE_STATIC_VARIABLE_DEF) {
-                        state.declarationAccess = Scope.PUBLIC;
-                        state.currentScopeState = STATE_INSTANCE_VARIABLE_DEF;
-                    }
-                }
-
-                final Scope access = ScopeUtils.getScopeFromMods(ast);
-                if (state.declarationAccess.compareTo(access) > 0) {
-                    if (!ignoreModifiers) {
-                        log(ast, MSG_ACCESS);
-                    }
-                }
-                else {
-                    state.declarationAccess = access;
-                }
+                processModifiers(ast);
                 break;
 
             default:
+                break;
+        }
+    }
+
+    /**
+     * process constructor
+     * @param ast constructor AST
+     */
+    private void processConstructor(DetailAST ast) {
+
+        final ScopeState state = scopeStates.peek();
+        if (state.currentScopeState > STATE_CTOR_DEF) {
+            if (!ignoreConstructors) {
+                log(ast, MSG_CONSTRUCTOR);
+            }
+        }
+        else {
+            state.currentScopeState = STATE_CTOR_DEF;
+        }
+    }
+
+    /**
+     * process Method Token
+     * @param ast ,ethod token AST
+     */
+    private void processMethod(DetailAST ast) {
+
+        final ScopeState state = scopeStates.peek();
+        if (state.currentScopeState > STATE_METHOD_DEF) {
+            if (!ignoreMethods) {
+                log(ast, MSG_METHOD);
+            }
+        }
+        else {
+            state.currentScopeState = STATE_METHOD_DEF;
+        }
+    }
+
+    /**
+     * process modifiers
+     * @param ast ast of Modifiers
+     */
+    private void processModifiers(DetailAST ast) {
+
+        final ScopeState state = scopeStates.peek();
+        if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
+            if (state.currentScopeState > STATE_STATIC_VARIABLE_DEF) {
+                if (!ignoreModifiers
+                    || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
+                    log(ast, MSG_STATIC);
+                }
+            }
+            else {
+                state.currentScopeState = STATE_STATIC_VARIABLE_DEF;
+            }
+        }
+        else {
+            if (state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
+                log(ast, MSG_INSTANCE);
+            }
+            else if (state.currentScopeState == STATE_STATIC_VARIABLE_DEF) {
+                state.declarationAccess = Scope.PUBLIC;
+                state.currentScopeState = STATE_INSTANCE_VARIABLE_DEF;
+            }
+        }
+
+        final Scope access = ScopeUtils.getScopeFromMods(ast);
+        if (state.declarationAccess.compareTo(access) > 0) {
+            if (!ignoreModifiers) {
+                log(ast, MSG_ACCESS);
+            }
+        }
+        else {
+            state.declarationAccess = access;
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.OBJBLOCK) {
             scopeStates.pop();
         }
     }
 
     /**
      * Sets whether to ignore constructors.
      * @param ignoreConstructors whether to ignore constructors.
      */
     public void setIgnoreConstructors(boolean ignoreConstructors) {
         this.ignoreConstructors = ignoreConstructors;
     }
 
     /**
      * Sets whether to ignore methods.
      * @param ignoreMethods whether to ignore methods.
      */
     public void setIgnoreMethods(boolean ignoreMethods) {
         this.ignoreMethods = ignoreMethods;
     }
 
     /**
      * Sets whether to ignore modifiers.
      * @param ignoreModifiers whether to ignore modifiers.
      */
     public void setIgnoreModifiers(boolean ignoreModifiers) {
         this.ignoreModifiers = ignoreModifiers;
     }
 }
