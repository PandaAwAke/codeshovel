diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 4d4e85995..45d408c12 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -1,250 +1,250 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.javadoc;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.Scope;
 import com.puppycrawl.tools.checkstyle.api.TextBlock;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.checks.AbstractTypeAwareCheck;
 import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
+import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
-import com.puppycrawl.tools.checkstyle.utils.Utils;
 
 /**
  * Checks the Javadoc of a method or constructor.
  *
  * @author Oliver Burn
  * @author Rick Giles
  * @author o_sukhodoslky
  */
 @SuppressWarnings("deprecation")
 public class JavadocMethodCheck extends AbstractTypeAwareCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_JAVADOC_MISSING = "javadoc.missing";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CLASS_INFO = "javadoc.classInfo";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_UNUSED_TAG_GENERAL = "javadoc.unusedTagGeneral";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_INVALID_INHERIT_DOC = "javadoc.invalidInheritDoc";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_UNUSED_TAG = "javadoc.unusedTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_EXCPECTED_TAG = "javadoc.expectedTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_RETURN_EXPECTED = "javadoc.return.expected";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_DUPLICATE_TAG = "javadoc.duplicateTag";
 
     /** Compiled regexp to match Javadoc tags that take an argument * */
     private static final Pattern MATCH_JAVADOC_ARG =
-        Utils.createPattern("@(throws|exception|param)\\s+(\\S+)\\s+\\S*");
+            CommonUtils.createPattern("@(throws|exception|param)\\s+(\\S+)\\s+\\S*");
 
     /** Compiled regexp to match first part of multilineJavadoc tags * */
     private static final Pattern MATCH_JAVADOC_ARG_MULTILINE_START =
-        Utils.createPattern("@(throws|exception|param)\\s+(\\S+)\\s*$");
+            CommonUtils.createPattern("@(throws|exception|param)\\s+(\\S+)\\s*$");
 
     /** Compiled regexp to look for a continuation of the comment * */
     private static final Pattern MATCH_JAVADOC_MULTILINE_CONT =
-        Utils.createPattern("(\\*/|@|[^\\s\\*])");
+            CommonUtils.createPattern("(\\*/|@|[^\\s\\*])");
 
     /** Multiline finished at end of comment * */
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc * */
     private static final String NEXT_TAG = "@";
 
     /** Compiled regexp to match Javadoc tags with no argument * */
     private static final Pattern MATCH_JAVADOC_NOARG =
-        Utils.createPattern("@(return|see)\\s+\\S");
+            CommonUtils.createPattern("@(return|see)\\s+\\S");
     /** Compiled regexp to match first part of multilineJavadoc tags * */
     private static final Pattern MATCH_JAVADOC_NOARG_MULTILINE_START =
-        Utils.createPattern("@(return|see)\\s*$");
+            CommonUtils.createPattern("@(return|see)\\s*$");
     /** Compiled regexp to match Javadoc tags with no argument and {} * */
     private static final Pattern MATCH_JAVADOC_NOARG_CURLY =
-        Utils.createPattern("\\{\\s*@(inheritDoc)\\s*\\}");
+            CommonUtils.createPattern("\\{\\s*@(inheritDoc)\\s*\\}");
 
     /** Default value of minimal amount of lines in method to demand documentation presence.*/
     private static final int DEFAULT_MIN_LINE_COUNT = -1;
 
     /** The visibility scope where Javadoc comments are checked * */
     private Scope scope = Scope.PRIVATE;
 
     /** The visibility scope where Javadoc comments shouldn't be checked * */
     private Scope excludeScope;
 
     /** Minimal amount of lines in method to demand documentation presence.*/
     private int minLineCount = DEFAULT_MIN_LINE_COUNT;
 
     /**
      * Controls whether to allow documented exceptions that are not declared if
      * they are a subclass of java.lang.RuntimeException.
      */
     private boolean allowUndeclaredRTE;
 
     /**
      * Allows validating throws tags.
      */
     private boolean validateThrows;
 
     /**
      * Controls whether to allow documented exceptions that are subclass of one
      * of declared exception. Defaults to false (backward compatibility).
      */
     private boolean allowThrowsTagsForSubclasses;
 
     /**
      * Controls whether to ignore errors when a method has parameters but does
      * not have matching param tags in the javadoc. Defaults to false.
      */
     private boolean allowMissingParamTags;
 
     /**
      * Controls whether to ignore errors when a method declares that it throws
      * exceptions but does not have matching throws tags in the javadoc.
      * Defaults to false.
      */
     private boolean allowMissingThrowsTags;
 
     /**
      * Controls whether to ignore errors when a method returns non-void type
      * but does not have a return tag in the javadoc. Defaults to false.
      */
     private boolean allowMissingReturnTag;
 
     /**
      * Controls whether to ignore errors when there is no javadoc. Defaults to
      * false.
      */
     private boolean allowMissingJavadoc;
 
     /**
      * Controls whether to allow missing Javadoc on accessor methods for
      * properties (setters and getters).
      */
     private boolean allowMissingPropertyJavadoc;
 
     /** List of annotations that could allow missed documentation. */
     private List<String> allowedAnnotations = Collections.singletonList("Override");
 
     /** Method names that match this pattern do not require javadoc blocks. */
     private Pattern ignoreMethodNamesRegex;
 
     /**
      * Set regex for matching method names to ignore.
      * @param regex regex for matching method names.
      */
     public void setIgnoreMethodNamesRegex(String regex) {
-        ignoreMethodNamesRegex = Utils.createPattern(regex);
+        ignoreMethodNamesRegex = CommonUtils.createPattern(regex);
     }
 
     /**
      * Sets minimal amount of lines in method.
      * @param value user's value.
      */
     public void setMinLineCount(int value) {
         minLineCount = value;
     }
 
     /**
      * Allow validating throws tag.
      * @param value user's value.
      */
     public void setValidateThrows(boolean value) {
         validateThrows = value;
     }
 
     /**
      * Sets list of annotations.
      * @param userAnnotations user's value.
      */
     public void setAllowedAnnotations(String userAnnotations) {
         final List<String> annotations = new ArrayList<>();
         final String[] sAnnotations = userAnnotations.split(",");
         for (int i = 0; i < sAnnotations.length; i++) {
             sAnnotations[i] = sAnnotations[i].trim();
         }
 
         Collections.addAll(annotations, sAnnotations);
         allowedAnnotations = annotations;
     }
 
     /**
      * Set the scope.
      *
      * @param from a {@code String} value
      */
     public void setScope(String from) {
         scope = Scope.getInstance(from);
     }
 
     /**
      * Set the excludeScope.
      *
      * @param excludeScope a {@code String} value
      */
     public void setExcludeScope(String excludeScope) {
         this.excludeScope = Scope.getInstance(excludeScope);
     }
@@ -689,101 +689,101 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     final ExceptionInfo ei = new ExceptionInfo(createClassInfo(new Token(fi),
                             getCurrentClassName()));
                     retVal.add(ei);
                 }
                 child = child.getNextSibling();
             }
         }
         return retVal;
     }
 
     /**
      * Checks a set of tags for matching parameters.
      *
      * @param tags the tags to check
      * @param parent the node which takes the parameters
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkParamTags(final List<JavadocTag> tags,
             final DetailAST parent, boolean reportExpectedTags) {
         final List<DetailAST> params = getParameters(parent);
         final List<DetailAST> typeParams = CheckUtils
                 .getTypeParameters(parent);
 
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             boolean found = false;
 
             // Loop looking for matching param
             final Iterator<DetailAST> paramIt = params.iterator();
             final String arg1 = tag.getFirstArg();
             while (paramIt.hasNext()) {
                 final DetailAST param = paramIt.next();
                 if (param.getText().equals(arg1)) {
                     found = true;
                     paramIt.remove();
                     break;
                 }
             }
 
-            if (Utils.startsWithChar(arg1, '<') && Utils.endsWithChar(arg1, '>')) {
+            if (CommonUtils.startsWithChar(arg1, '<') && CommonUtils.endsWithChar(arg1, '>')) {
                 // Loop looking for matching type param
                 final Iterator<DetailAST> typeParamsIt = typeParams.iterator();
                 while (typeParamsIt.hasNext()) {
                     final DetailAST typeParam = typeParamsIt.next();
                     if (typeParam.findFirstToken(TokenTypes.IDENT).getText()
                             .equals(
                                     arg1.substring(1,
                                         arg1.length() - 1))) {
                         found = true;
                         typeParamsIt.remove();
                         break;
                     }
                 }
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", arg1);
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingParamTags && reportExpectedTags) {
             for (DetailAST param : params) {
                 log(param, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(), param.getText());
             }
 
             for (DetailAST typeParam : typeParams) {
                 log(typeParam, MSG_EXCPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(),
                     "<" + typeParam.findFirstToken(TokenTypes.IDENT).getText()
                     + ">");
             }
         }
     }
 
     /**
      * Checks whether a method is a function.
      *
      * @param ast the method node.
      * @return whether the method is a function.
      */
     private static boolean isFunction(DetailAST ast) {
         boolean retVal = false;
         if (ast.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = ast.findFirstToken(TokenTypes.TYPE);
