diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java
index 11ae51462..3f390658c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java
@@ -50,97 +50,97 @@ class ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel {
     }
 
     /**
      * Returns the list selection model. ListToTreeSelectionModelWrapper
      * listens for changes to this model and updates the selected paths
      * accordingly.
      *
      * @return the list selection model
      */
     final ListSelectionModel getListSelectionModel() {
         return listSelectionModel;
     }
 
     /**
      * This is overridden to set {@code updatingListSelectionModel}
      * and message super. This is the only place DefaultTreeSelectionModel
      * alters the ListSelectionModel.
      */
     @Override
     public void resetRowSelection() {
         if (!updatingListSelectionModel) {
             updatingListSelectionModel = true;
             try {
                 super.resetRowSelection();
             }
             finally {
                 updatingListSelectionModel = false;
             }
         }
         // Notice how we don't message super if
         // updatingListSelectionModel is true. If
         // updatingListSelectionModel is true, it implies the
         // ListSelectionModel has already been updated and the
         // paths are the only thing that needs to be updated.
     }
 
     /**
      * Creates an instance of ListSelectionHandler.
      *
      * @return An instance of ListSelectionHandler
      */
     private ListSelectionListener createListSelectionListener() {
         return new ListSelectionHandler();
     }
 
     /**
      * If {@code updatingListSelectionModel} is false, this will
      * reset the selected paths from the selected rows in the list
      * selection model.
      */
-    protected void updateSelectedPathsFromSelectedRows() {
+    private void updateSelectedPathsFromSelectedRows() {
         if (!updatingListSelectionModel) {
             updatingListSelectionModel = true;
             try {
                 // This is way expensive, ListSelectionModel needs an
                 // enumerator for iterating.
                 final int min = listSelectionModel.getMinSelectionIndex();
                 final int max = listSelectionModel.getMaxSelectionIndex();
 
                 clearSelection();
                 if (min != -1 && max != -1) {
                     for (int counter = min; counter <= max; counter++) {
                         updateSelectedPathIfRowIsSelected(counter);
                     }
                 }
             }
             finally {
                 updatingListSelectionModel = false;
             }
         }
     }
 
     /**
      * If the row at given index is selected, selected paths are updated.
      * @param counter number of row.
      */
     private void updateSelectedPathIfRowIsSelected(int counter) {
         if (listSelectionModel.isSelectedIndex(counter)) {
             final TreePath selPath = treeTable.getTree().getPathForRow(counter);
 
             if (selPath != null) {
                 addSelectionPath(selPath);
             }
         }
     }
 
     /**
      * Class responsible for calling updateSelectedPathsFromSelectedRows
      * when the selection of the list changes.
      */
-    class ListSelectionHandler implements ListSelectionListener {
+    private class ListSelectionHandler implements ListSelectionListener {
         @Override
         public void valueChanged(ListSelectionEvent e) {
             updateSelectedPathsFromSelectedRows();
         }
     }
 }
