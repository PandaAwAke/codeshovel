diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
index 48a01bbf7..4a9eb13f1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
@@ -150,177 +150,177 @@ public class JTreeTable extends JTable
                 @Override
                 public void actionPerformed(ActionEvent e) {
                     final TreePath selected = tree.getSelectionPath();
 
                     DetailAST ast = (DetailAST) selected.getLastPathComponent();
                     new CodeSelector(ast, editor, lines2position).select();
 
                     if (tree.isExpanded(selected)) {
                         tree.collapsePath(selected);
                     }
                     else {
                         tree.expandPath(selected);
                     }
                     tree.setSelectionPath(selected);
                 }
             };
         final KeyStroke stroke = KeyStroke.getKeyStroke("ENTER");
         final String command = "expand/collapse";
         getInputMap().put(stroke, command);
         getActionMap().put(command, expand);
     }
 
     /**
      * Overridden to message super and forward the method to the tree.
      * Since the tree is not actually in the component hierarchy it will
      * never receive this unless we forward it in this manner.
      */
     @Override
     public void updateUI()
     {
         super.updateUI();
         if (tree != null) {
             tree.updateUI();
         }
         // Use the tree's default foreground and background colors in the
         // table.
         LookAndFeel.installColorsAndFont(this, "Tree.background",
                 "Tree.foreground", "Tree.font");
     }
 
     /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to
      * paint the editor. The UI currently uses different techniques to
      * paint the renderers and editors and overriding setBounds() below
      * is not the right thing to do for an editor. Returning -1 for the
      * editing row in this case, ensures the editor is never painted.
      */
     @Override
     public int getEditingRow()
     {
         final Class<?> editingClass = getColumnClass(editingColumn);
-        return (editingClass == TreeTableModel.class) ? -1 : editingRow;
+        return editingClass == TreeTableModel.class ? -1 : editingRow;
     }
 
     /**
      * Overridden to pass the new rowHeight to the tree.
      */
     @Override
     public void setRowHeight(int newRowHeight)
     {
         super.setRowHeight(newRowHeight);
-        if ((tree != null) && (tree.getRowHeight() != newRowHeight)) {
+        if (tree != null && tree.getRowHeight() != newRowHeight) {
             tree.setRowHeight(getRowHeight());
         }
     }
 
     /**
      * @return the tree that is being shared between the model.
      */
     public JTree getTree()
     {
         return tree;
     }
 
     /**
      * A TreeCellRenderer that displays a JTree.
      */
     class TreeTableCellRenderer extends JTree implements
             TableCellRenderer
     {
         /**
          *
          */
         private static final long serialVersionUID = 4324031590789321581L;
         /** Last table/tree row asked to renderer. */
         protected int visibleRow;
 
         /** creates a new instance */
         public TreeTableCellRenderer(TreeModel model)
         {
             super(model);
         }
 
         /**
          * updateUI is overridden to set the colors of the Tree's renderer
          * to match that of the table.
          */
         @Override
         public void updateUI()
         {
             super.updateUI();
             // Make the tree's cell renderer use the table's cell selection
             // colors.
             final TreeCellRenderer tcr = getCellRenderer();
             if (tcr instanceof DefaultTreeCellRenderer) {
-                final DefaultTreeCellRenderer dtcr = ((DefaultTreeCellRenderer) tcr);
+                final DefaultTreeCellRenderer dtcr = (DefaultTreeCellRenderer) tcr;
                 // For 1.1 uncomment this, 1.2 has a bug that will cause an
                 // exception to be thrown if the border selection color is
                 // null.
                 // dtcr.setBorderSelectionColor(null);
                 dtcr.setTextSelectionColor(UIManager.getColor
                         ("Table.selectionForeground"));
                 dtcr.setBackgroundSelectionColor(UIManager.getColor
                         ("Table.selectionBackground"));
             }
         }
 
         /**
          * Sets the row height of the tree, and forwards the row height to
          * the table.
          */
         @Override
         public void setRowHeight(int newRowHeight)
         {
             if (newRowHeight > 0) {
                 super.setRowHeight(newRowHeight);
-                if ((JTreeTable.this != null) &&
-                    (JTreeTable.this.getRowHeight() != newRowHeight))
+                if (JTreeTable.this != null &&
+                        JTreeTable.this.getRowHeight() != newRowHeight)
                 {
                     JTreeTable.this.setRowHeight(getRowHeight());
                 }
             }
         }
 
         /**
          * This is overridden to set the height to match that of the JTable.
          */
         @Override
         public void setBounds(int x, int y, int w, int h)
         {
             super.setBounds(x, 0, w, JTreeTable.this.getHeight());
         }
 
         /**
          * Sublcassed to translate the graphics such that the last visible
          * row will be drawn at 0,0.
          */
         @Override
         public void paint(Graphics g)
         {
             g.translate(0, -visibleRow * getRowHeight());
             super.paint(g);
         }
 
         /**
          * TreeCellRenderer method. Overridden to update the visible row.
          * @see TableCellRenderer
          */
         @Override
         public Component getTableCellRendererComponent(JTable table,
                 Object value,
                 boolean isSelected,
                 boolean hasFocus,
                 int row, int column)
         {
             if (isSelected) {
                 setBackground(table.getSelectionBackground());
             } else {
                 setBackground(table.getBackground());
             }
 
             visibleRow = row;
             return this;
         }
     }
 
 
     /**
@@ -417,92 +417,92 @@ public class JTreeTable extends JTable
             return listSelectionModel;
         }
 
         /**
          * This is overridden to set <code>updatingListSelectionModel</code>
          * and message super. This is the only place DefaultTreeSelectionModel
          * alters the ListSelectionModel.
          */
         @Override
         public void resetRowSelection()
         {
             if (!updatingListSelectionModel) {
                 updatingListSelectionModel = true;
                 try {
                     super.resetRowSelection();
                 } finally {
                     updatingListSelectionModel = false;
                 }
             }
             // Notice how we don't message super if
             // updatingListSelectionModel is true. If
             // updatingListSelectionModel is true, it implies the
             // ListSelectionModel has already been updated and the
             // paths are the only thing that needs to be updated.
         }
 
         /**
          * Creates and returns an instance of ListSelectionHandler.
          */
         private ListSelectionListener createListSelectionListener()
         {
             return new ListSelectionHandler();
         }
 
         /**
          * If <code>updatingListSelectionModel</code> is false, this will
          * reset the selected paths from the selected rows in the list
          * selection model.
          */
         protected void updateSelectedPathsFromSelectedRows()
         {
             if (!updatingListSelectionModel) {
                 updatingListSelectionModel = true;
                 try {
                     // This is way expensive, ListSelectionModel needs an
                     // enumerator for iterating.
                     final int min = listSelectionModel.getMinSelectionIndex();
                     final int max = listSelectionModel.getMaxSelectionIndex();
 
                     clearSelection();
-                    if ((min != -1) && (max != -1)) {
+                    if (min != -1 && max != -1) {
                         for (int counter = min; counter <= max; counter++) {
                             if (listSelectionModel.isSelectedIndex(counter)) {
                                 final TreePath selPath = tree.getPathForRow
                                         (counter);
 
                                 if (selPath != null) {
                                     addSelectionPath(selPath);
                                 }
                             }
                         }
                     }
                 } finally {
                     updatingListSelectionModel = false;
                 }
             }
         }
 
         /**
          * Class responsible for calling updateSelectedPathsFromSelectedRows
          * when the selection of the list changse.
          */
         class ListSelectionHandler implements ListSelectionListener
         {
             @Override
             public void valueChanged(ListSelectionEvent e)
             {
                 updateSelectedPathsFromSelectedRows();
             }
         }
     }
 
     public void setEditor(JTextArea mJTextArea)
     {
          this.editor = mJTextArea;
     }
 
     public void setLinePositionMap(List<Integer> lines2position)
     {
         this.lines2position = lines2position;
     }
 }
