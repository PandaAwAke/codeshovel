diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
index b6a42fe61..0c4795eb1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
@@ -43,111 +43,111 @@ import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
  * </p>
  * <p>
  * <b>ignoredMethodNames</b> - names of methods to ignore.
  * </p>
  * <p>
  * <b>ignoreOverriddenMethods</b> - ignore checking overridden methods (marked with Override
  *  or java.lang.Override annotation) default value is <b>true</b>.
  * </p>
  *
  * @author Oliver Burn
  * @author John Sirois
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  */
 @StatelessCheck
 public final class IllegalThrowsCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "illegal.throw";
 
     /** Methods which should be ignored. */
     private final Set<String> ignoredMethodNames =
         Arrays.stream(new String[] {"finalize", }).collect(Collectors.toSet());
 
     /** Illegal class names. */
     private final Set<String> illegalClassNames = Arrays.stream(
         new String[] {"Error", "RuntimeException", "Throwable", "java.lang.Error",
                       "java.lang.RuntimeException", "java.lang.Throwable", })
         .collect(Collectors.toSet());
 
     /** Property for ignoring overridden methods. */
     private boolean ignoreOverriddenMethods = true;
 
     /**
      * Set the list of illegal classes.
      *
      * @param classNames
      *            array of illegal exception classes
      */
     public void setIllegalClassNames(final String... classNames) {
         illegalClassNames.clear();
         illegalClassNames.addAll(
                 CheckUtils.parseClassNames(classNames));
 
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {TokenTypes.LITERAL_THROWS};
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getDefaultTokens();
+        return new int[] {TokenTypes.LITERAL_THROWS};
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {TokenTypes.LITERAL_THROWS};
+        return getRequiredTokens();
     }
 
     @Override
     public void visitToken(DetailAST detailAST) {
         final DetailAST methodDef = detailAST.getParent();
         // Check if the method with the given name should be ignored.
         if (!isIgnorableMethod(methodDef)) {
             DetailAST token = detailAST.getFirstChild();
             while (token != null) {
                 if (token.getType() != TokenTypes.COMMA) {
                     final FullIdent ident = FullIdent.createFullIdent(token);
                     if (illegalClassNames.contains(ident.getText())) {
                         log(token, MSG_KEY, ident.getText());
                     }
                 }
                 token = token.getNextSibling();
             }
         }
     }
 
     /**
      * Checks if current method is ignorable due to Check's properties.
      * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
      * @return true if method is ignorable.
      */
     private boolean isIgnorableMethod(DetailAST methodDef) {
         return shouldIgnoreMethod(methodDef.findFirstToken(TokenTypes.IDENT).getText())
             || ignoreOverriddenMethods
                && (AnnotationUtility.containsAnnotation(methodDef, "Override")
                   || AnnotationUtility.containsAnnotation(methodDef, "java.lang.Override"));
     }
 
     /**
      * Check if the method is specified in the ignore method list.
      * @param name the name to check
      * @return whether the method with the passed name should be ignored
      */
     private boolean shouldIgnoreMethod(String name) {
         return ignoredMethodNames.contains(name);
     }
 
     /**
      * Set the list of ignore method names.
      * @param methodNames array of ignored method names
      */
     public void setIgnoredMethodNames(String... methodNames) {
         ignoredMethodNames.clear();
         Collections.addAll(ignoredMethodNames, methodNames);
     }
 
