diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java
index 336b309f1..a5ad7a381 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java
@@ -60,67 +60,67 @@ public abstract class AbstractParenPadCheck
     public static final String MSG_WS_NOT_PRECEDED = "ws.notPreceded";
 
     /** Open parenthesis literal. */
     private static final char OPEN_PARENTHESIS = '(';
 
     /** Close parenthesis literal. */
     private static final char CLOSE_PARENTHESIS = ')';
 
     /** The policy to enforce. */
     private PadOption option = PadOption.NOSPACE;
 
     /**
      * Set the option to enforce.
      * @param optionStr string to decode option from
      * @throws IllegalArgumentException if unable to decode
      */
     public void setOption(String optionStr) {
         try {
             option = PadOption.valueOf(optionStr.trim().toUpperCase(Locale.ENGLISH));
         }
         catch (IllegalArgumentException iae) {
             throw new IllegalArgumentException("unable to parse " + optionStr, iae);
         }
     }
 
     /**
      * Process a token representing a left parentheses.
      * @param ast the token representing a left parentheses
      */
     protected void processLeft(DetailAST ast) {
         final String line = getLines()[ast.getLineNo() - 1];
         final int after = ast.getColumnNo() + 1;
         if (after < line.length()) {
             if (option == PadOption.NOSPACE
                 && Character.isWhitespace(line.charAt(after))) {
                 log(ast.getLineNo(), after, MSG_WS_FOLLOWED, OPEN_PARENTHESIS);
             }
             else if (option == PadOption.SPACE
                      && !Character.isWhitespace(line.charAt(after))
                      && line.charAt(after) != CLOSE_PARENTHESIS) {
                 log(ast.getLineNo(), after, MSG_WS_NOT_FOLLOWED, OPEN_PARENTHESIS);
             }
         }
     }
 
     /**
      * Process a token representing a right parentheses.
      * @param ast the token representing a right parentheses
      */
     protected void processRight(DetailAST ast) {
-        final String line = getLines()[ast.getLineNo() - 1];
         final int before = ast.getColumnNo() - 1;
         if (before >= 0) {
+            final String line = getLines()[ast.getLineNo() - 1];
             if (option == PadOption.NOSPACE
                 && Character.isWhitespace(line.charAt(before))
                 && !CommonUtils.hasWhitespaceBefore(before, line)) {
                 log(ast.getLineNo(), before, MSG_WS_PRECEDED, CLOSE_PARENTHESIS);
             }
             else if (option == PadOption.SPACE
                 && !Character.isWhitespace(line.charAt(before))
                 && line.charAt(before) != OPEN_PARENTHESIS) {
                 log(ast.getLineNo(), ast.getColumnNo(),
                     MSG_WS_NOT_PRECEDED, CLOSE_PARENTHESIS);
             }
         }
     }
 }
