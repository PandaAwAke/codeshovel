diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
index fbc47a53a..b14635f90 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
@@ -112,101 +112,101 @@ public class ParenPadCheck extends AbstractParenPadCheck {
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_CALL:
                 processLeft(ast);
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
                 processExpression(ast);
                 break;
             case TokenTypes.EXPR:
             case TokenTypes.QUESTION:
                 processExpression(ast);
                 break;
             case TokenTypes.LITERAL_FOR:
                 visitLiteralFor(ast);
                 break;
             case TokenTypes.ANNOTATION:
             case TokenTypes.ENUM_CONSTANT_DEF:
             case TokenTypes.LITERAL_NEW:
             case TokenTypes.LITERAL_SYNCHRONIZED:
                 visitNewEnumConstDefAnnotationSync(ast);
                 break;
             default:
                 processLeft(ast.findFirstToken(TokenTypes.LPAREN));
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#ENUM_CONSTANT_DEF}, {@link TokenTypes#ANNOTATION}
      * {@link TokenTypes#LITERAL_SYNCHRONIZED} and {@link TokenTypes#LITERAL_NEW}.
      * @param ast the token to check.
      */
     private void visitNewEnumConstDefAnnotationSync(DetailAST ast) {
         final DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
         if (parenAst != null) {
             processLeft(parenAst);
             processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#LITERAL_FOR}.
      * @param ast the token to check.
      */
     private void visitLiteralFor(DetailAST ast) {
         DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
-        if (!isPreceedsEmptyForInit(parenAst)) {
+        if (!isPrecedingEmptyForInit(parenAst)) {
             processLeft(parenAst);
         }
         parenAst = ast.findFirstToken(TokenTypes.RPAREN);
         if (!isFollowsEmptyForIterator(parenAst)) {
             processRight(parenAst);
         }
     }
 
     /**
      * Checks parens inside {@link TokenTypes#EXPR}, {@link TokenTypes#QUESTION}
      * and {@link TokenTypes#METHOD_CALL}.
      * @param ast the token to check.
      */
     private void processExpression(DetailAST ast) {
         if (ast.branchContains(TokenTypes.LPAREN)) {
             DetailAST childAst = ast.getFirstChild();
             while (childAst != null) {
                 if (childAst.getType() == TokenTypes.LPAREN) {
                     processLeft(childAst);
                     processExpression(childAst);
                 }
                 else if (childAst.getType() == TokenTypes.RPAREN && !isInTypecast(childAst)) {
                     processRight(childAst);
                 }
                 else if (!isAcceptableToken(childAst)) {
                     //Traverse all subtree tokens which will never be configured
                     //to be launched in visitToken()
                     processExpression(childAst);
                 }
                 childAst = childAst.getNextSibling();
             }
         }
     }
 
     /**
      * Checks whether AcceptableTokens contains the given ast.
      * @param ast the token to check.
      * @return true if the ast is in AcceptableTokens.
      */
     private boolean isAcceptableToken(DetailAST ast) {
         boolean result = false;
         if (Arrays.binarySearch(acceptableTokens, ast.getType()) >= 0) {
             result = true;
         }
         return result;
     }
 
     /**
      * @return acceptableTokens.
      */
@@ -222,64 +222,64 @@ public class ParenPadCheck extends AbstractParenPadCheck {
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_NEW,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.METHOD_CALL,
             TokenTypes.METHOD_DEF,
             TokenTypes.QUESTION,
             TokenTypes.RESOURCE_SPECIFICATION,
             TokenTypes.SUPER_CTOR_CALL,
         };
     }
 
     /**
      * Checks whether {@link TokenTypes#RPAREN} is a closing paren
      * of a {@link TokenTypes#TYPECAST}.
      * @param ast of a {@link TokenTypes#RPAREN} to check.
      * @return true if ast is a closing paren of a {@link TokenTypes#TYPECAST}.
      */
     private static boolean isInTypecast(DetailAST ast) {
         boolean result = false;
         if (ast.getParent().getType() == TokenTypes.TYPECAST) {
             final DetailAST firstRparen = ast.getParent().findFirstToken(TokenTypes.RPAREN);
             if (firstRparen.getLineNo() == ast.getLineNo()
                     && firstRparen.getColumnNo() == ast.getColumnNo()) {
                 result = true;
             }
         }
         return result;
     }
 
     /**
      * @param ast the token to check
      * @return whether a token follows an empty for iterator
      */
     private static boolean isFollowsEmptyForIterator(DetailAST ast) {
         boolean result = false;
         final DetailAST parent = ast.getParent();
         //Only traditional for statements are examined, not for-each statements
         if (parent.findFirstToken(TokenTypes.FOR_EACH_CLAUSE) == null) {
             final DetailAST forIterator =
                 parent.findFirstToken(TokenTypes.FOR_ITERATOR);
             result = forIterator.getChildCount() == 0;
         }
         return result;
     }
 
     /**
      * @param ast the token to check
-     * @return whether a token preceeds an empty for initializer
+     * @return whether a token precedes an empty for initializer
      */
-    private static boolean isPreceedsEmptyForInit(DetailAST ast) {
+    private static boolean isPrecedingEmptyForInit(DetailAST ast) {
         boolean result = false;
         final DetailAST parent = ast.getParent();
         //Only traditional for statements are examined, not for-each statements
         if (parent.findFirstToken(TokenTypes.FOR_EACH_CLAUSE) == null) {
             final DetailAST forIterator =
                     parent.findFirstToken(TokenTypes.FOR_INIT);
             result = forIterator.getChildCount() == 0;
         }
         return result;
     }
 }
