diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 5c6ebdfe8..3b5d6ce23 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -292,112 +292,112 @@ public class RequireThisCheck extends Check {
      * @param ast variable token
      * @param frame current frame
      */
     private static void collectVariableDeclarations(DetailAST ast, LexicalFrame frame) {
         final DetailAST ident =
                 ast.findFirstToken(TokenTypes.IDENT);
         if (frame instanceof ClassFrame) {
             final DetailAST mods =
                     ast.findFirstToken(TokenTypes.MODIFIERS);
             if (ScopeUtils.isInInterfaceBlock(ast)
                     || mods.branchContains(TokenTypes.LITERAL_STATIC)) {
                 ((ClassFrame) frame).addStaticMember(ident);
             }
             else {
                 ((ClassFrame) frame).addInstanceMember(ident);
             }
         }
         else {
             frame.addIdent(ident);
         }
     }
 
     /**
      * End parsing of the AST for declarations.
      *
      * @param frameStack Stack containing the FrameTree being built
      * @param ast AST that was parsed
      */
     private void endCollectingDeclarations(Queue<LexicalFrame> frameStack,
         DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
                 frames.put(ast, frameStack.poll());
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Check if given name is a name for class field in current environment.
      * @param ident an IDENT ast to check
      * @return true is the given name is name of member.
      */
-    protected final boolean isClassField(DetailAST ident) {
+    private boolean isClassField(DetailAST ident) {
         final LexicalFrame frame = findFrame(ident, false);
         return frame instanceof ClassFrame
                 && ((ClassFrame) frame).hasInstanceMember(ident);
     }
 
     /**
      * Check if given name is a name for class method in current environment.
      * @param ident the IDENT ast of the name to check
      * @return true is the given name is name of method.
      */
-    protected final boolean isClassMethod(DetailAST ident) {
+    private boolean isClassMethod(DetailAST ident) {
         final LexicalFrame frame = findFrame(ident, true);
         return frame instanceof ClassFrame
                 && ((ClassFrame) frame).hasInstanceMethod(ident);
     }
 
     /**
      * Find frame containing declaration.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return LexicalFrame containing declaration or null.
      */
     private LexicalFrame findFrame(DetailAST name, boolean lookForMethod) {
         if (current == null) {
             return null;
         }
         else {
             return current.getIfContains(name, lookForMethod);
         }
     }
 
     /**
      * Check that token is related to Definition tokens.
      * @param parentType token Type
      * @return true if token is related to Definition Tokens
      */
     private static boolean isDeclarationToken(int parentType) {
         return DECLARATION_TOKENS.contains(parentType);
     }
 
     /**
      * A declaration frame.
      * @author Stephen Bloch
      */
     private static class LexicalFrame {
         /** Set of name of variables declared in this frame. */
         private final Set<DetailAST> varIdents;
 
         /**
          * Parent frame.
          */
         private final LexicalFrame parent;
 
         /**
          * Constructor -- invokable only via super() from subclasses.
          *
          * @param parent parent frame
          */
         protected LexicalFrame(LexicalFrame parent) {
             this.parent = parent;
             varIdents = Sets.newHashSet();
