diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java b/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
index fe836372e..5a87c9e41 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java
@@ -33,209 +33,215 @@ import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
  * @author lkuehne
  * @see <a href="http://www.antlr.org/">ANTLR Website</a>
  */
 public final class DetailAST extends CommonASTWithHiddenTokens {
     private static final long serialVersionUID = -2580884815577559874L;
 
     /** Constant to indicate if not calculated the child count. */
     private static final int NOT_INITIALIZED = Integer.MIN_VALUE;
 
     /** The line number. **/
     private int lineNo = NOT_INITIALIZED;
     /** The column number. **/
     private int columnNo = NOT_INITIALIZED;
 
     /** Number of children. */
     private int childCount = NOT_INITIALIZED;
     /** The parent token. */
     private DetailAST parent;
     /** Previous sibling. */
     private DetailAST previousSibling;
 
     /**
      * All token types in this branch.
      * Token 'x' (where x is an int) is in this branch
      * if branchTokenTypes.get(x) is true.
      */
     private BitSet branchTokenTypes;
 
     @Override
     public void initialize(Token tok) {
         super.initialize(tok);
         lineNo = tok.getLine();
 
         // expect columns to start @ 0
         columnNo = tok.getColumn() - 1;
     }
 
     @Override
     public void initialize(AST ast) {
         final DetailAST detailAst = (DetailAST) ast;
         setText(detailAst.getText());
         setType(detailAst.getType());
         lineNo = detailAst.getLineNo();
         columnNo = detailAst.getColumnNo();
         hiddenAfter = detailAst.getHiddenAfter();
         hiddenBefore = detailAst.getHiddenBefore();
     }
 
     @Override
     public void setFirstChild(AST ast) {
+        clearBranchTokenTypesCache();
         childCount = NOT_INITIALIZED;
         super.setFirstChild(ast);
         if (ast != null) {
             ((DetailAST) ast).setParent(this);
         }
     }
 
     @Override
     public void setNextSibling(AST ast) {
+        clearBranchTokenTypesCache();
         super.setNextSibling(ast);
         if (ast != null && parent != null) {
             ((DetailAST) ast).setParent(parent);
         }
         if (ast != null) {
             ((DetailAST) ast).previousSibling = this;
         }
     }
 
     /**
      * Add previous sibling.
      * @param ast
      *        DetailAST object.
      */
     public void addPreviousSibling(DetailAST ast) {
+        clearBranchTokenTypesCache();
         if (ast != null) {
             ast.setParent(parent);
             final DetailAST previousSiblingNode = previousSibling;
 
             if (previousSiblingNode != null) {
                 ast.previousSibling = previousSiblingNode;
                 previousSiblingNode.setNextSibling(ast);
             }
             else if (parent != null) {
                 parent.setFirstChild(ast);
             }
 
             ast.setNextSibling(this);
             previousSibling = ast;
         }
     }
 
     /**
      * Add next sibling.
      * @param ast
      *        DetailAST object.
      */
     public void addNextSibling(DetailAST ast) {
+        clearBranchTokenTypesCache();
         if (ast != null) {
             ast.setParent(parent);
             final DetailAST nextSibling = getNextSibling();
 
             if (nextSibling != null) {
                 ast.setNextSibling(nextSibling);
                 nextSibling.previousSibling = ast;
             }
 
             ast.previousSibling = this;
             setNextSibling(ast);
         }
     }
 
     @Override
     public void addChild(AST ast) {
+        clearBranchTokenTypesCache();
         super.addChild(ast);
         if (ast != null) {
             ((DetailAST) ast).setParent(this);
             getFirstChild().setParent(this);
         }
     }
 
     /**
      * Returns the number of child nodes one level below this node. That is is
      * does not recurse down the tree.
      * @return the number of child nodes
      */
     public int getChildCount() {
         // lazy init
         if (childCount == NOT_INITIALIZED) {
             childCount = 0;
             AST child = getFirstChild();
 
             while (child != null) {
                 childCount += 1;
                 child = child.getNextSibling();
             }
         }
         return childCount;
     }
 
     /**
      * Returns the number of direct child tokens that have the specified type.
      * @param type the token type to match
      * @return the number of matching token
      */
     public int getChildCount(int type) {
         int count = 0;
         for (AST ast = getFirstChild(); ast != null; ast = ast.getNextSibling()) {
             if (ast.getType() == type) {
                 count++;
             }
         }
         return count;
     }
 
     /**
      * Set the parent token.
      * @param parent the parent token
      */
     private void setParent(DetailAST parent) {
+        clearBranchTokenTypesCache();
         this.parent = parent;
         final DetailAST nextSibling = getNextSibling();
         if (nextSibling != null) {
             nextSibling.setParent(parent);
             nextSibling.previousSibling = this;
         }
     }
 
     /**
      * Returns the parent token.
      * @return the parent token
      */
     public DetailAST getParent() {
         return parent;
     }
 
     /**
      * Gets line number.
      * @return the line number
      */
     public int getLineNo() {
         int resultNo = -1;
 
         if (lineNo == NOT_INITIALIZED) {
             // an inner AST that has been initialized
             // with initialize(String text)
             resultNo = findLineNo(getFirstChild());
 
             if (resultNo < 0) {
                 resultNo = findLineNo(getNextSibling());
             }
         }
         if (resultNo < 0) {
             resultNo = lineNo;
         }
         return resultNo;
     }
 
     /**
      * Set line number.
      * @param lineNo
      *        line number.
      */
     public void setLineNo(int lineNo) {
         this.lineNo = lineNo;
     }
 
     /**
      * Gets column number.
      * @return the column number
@@ -348,51 +354,61 @@ public final class DetailAST extends CommonASTWithHiddenTokens {
     /**
      * Checks if this branch of the parse tree contains a token
      * of the provided type.
      * @param type a TokenType
      * @return true if and only if this branch (including this node)
      *     contains a token of type {@code type}.
      */
     public boolean branchContains(int type) {
         return getBranchTokenTypes().get(type);
     }
 
     /**
      * Returns the previous sibling or null if no such sibling exists.
      * @return the previous sibling or null if no such sibling exists.
      */
     public DetailAST getPreviousSibling() {
         return previousSibling;
     }
 
     /**
      * Returns the first child token that makes a specified type.
      * @param type the token type to match
      * @return the matching token, or null if no match
      */
     public DetailAST findFirstToken(int type) {
         DetailAST returnValue = null;
         for (DetailAST ast = getFirstChild(); ast != null; ast = ast.getNextSibling()) {
             if (ast.getType() == type) {
                 returnValue = ast;
                 break;
             }
         }
         return returnValue;
     }
 
     @Override
     public String toString() {
         return super.toString() + "[" + getLineNo() + "x" + getColumnNo() + "]";
     }
 
     @Override
     public DetailAST getNextSibling() {
         return (DetailAST) super.getNextSibling();
     }
 
     @Override
     public DetailAST getFirstChild() {
         return (DetailAST) super.getFirstChild();
     }
 
+    /**
+     * Clears branchTokenTypes cache for all parents of the current DetailAST instance.
+     */
+    private void clearBranchTokenTypesCache() {
+        DetailAST prevParent = getParent();
+        while (prevParent != null) {
+            prevParent.branchTokenTypes = null;
+            prevParent = prevParent.getParent();
+        }
+    }
 }
