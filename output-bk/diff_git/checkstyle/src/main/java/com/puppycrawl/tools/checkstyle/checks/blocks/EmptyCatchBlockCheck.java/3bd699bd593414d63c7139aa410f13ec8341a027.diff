diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
index 3e30900b3..a071c1f5c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
@@ -198,90 +198,90 @@ public class EmptyCatchBlockCheck extends Check {
 
     /**
      * Visits catch ast node, if it is empty catch block - checks it according to
      *  Check's options. If exception's variable name or comment inside block are matching
      *   specified regexp - skips from consideration, else - puts violation.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      */
     private void visitCatchBlock(DetailAST catchAst) {
         if (isEmptyCatchBlock(catchAst)) {
             final String commentContent = getCommentFirstLine(catchAst);
             if (isVerifiable(catchAst, commentContent)) {
                 log(catchAst.getLineNo(), MSG_KEY_CATCH_BLOCK_EMPTY);
             }
         }
     }
 
     /**
      * Gets the first line of comment in catch block. If comment is single-line -
      *  returns it fully, else if comment is multi-line - returns the first line.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      * @return the first line of comment in catch block, "" if no comment was found.
      */
     private static String getCommentFirstLine(DetailAST catchAst) {
         final DetailAST slistToken = catchAst.getLastChild();
         final DetailAST firstElementInBlock = slistToken.getFirstChild();
         String commentContent = "";
         if (firstElementInBlock.getType() == TokenTypes.SINGLE_LINE_COMMENT) {
             commentContent = firstElementInBlock.getFirstChild().getText();
         }
         else if (firstElementInBlock.getType() == TokenTypes.BLOCK_COMMENT_BEGIN) {
             commentContent = firstElementInBlock.getFirstChild().getText();
             final String[] lines = commentContent.split(System.getProperty("line.separator"));
             for (String line : lines) {
                 if (!line.isEmpty()) {
                     commentContent = line;
                     break;
                 }
             }
         }
         return commentContent;
     }
 
     /**
      * Checks if current empty catch block is verifiable according to Check's options
      *  (exception's variable name and comment format are both in consideration).
      * @param emptyCatchAst empty catch {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH} block.
      * @param commentContent text of comment.
      * @return true if empty catch block is verifiable by Check.
      */
     private boolean isVerifiable(DetailAST emptyCatchAst, String commentContent) {
-        final String exceptionVariableName = getExceptionVariableName(emptyCatchAst);
+        final String variableName = getExceptionVariableName(emptyCatchAst);
         final boolean isMatchingVariableName = variableNameRegexp
-                .matcher(exceptionVariableName).find();
+                .matcher(variableName).find();
         final boolean isMatchingCommentContent = !commentContent.isEmpty()
                  && commentRegexp.matcher(commentContent).find();
         return !isMatchingVariableName && !isMatchingCommentContent;
     }
 
     /**
      * Checks if catch block is empty or contains only comments.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      * @return true if catch block is empty.
      */
     private static boolean isEmptyCatchBlock(DetailAST catchAst) {
         boolean result = true;
         final DetailAST slistToken = catchAst.findFirstToken(TokenTypes.SLIST);
         DetailAST catchBlockStmt = slistToken.getFirstChild();
         while (catchBlockStmt.getType() != TokenTypes.RCURLY) {
             if (catchBlockStmt.getType() != TokenTypes.SINGLE_LINE_COMMENT
                  && catchBlockStmt.getType() != TokenTypes.BLOCK_COMMENT_BEGIN) {
                 result = false;
                 break;
             }
             catchBlockStmt = catchBlockStmt.getNextSibling();
         }
         return result;
     }
 
     /**
      * Gets variable's name associated with exception.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      * @return Variable's name associated with exception.
      */
     private static String getExceptionVariableName(DetailAST catchAst) {
         final DetailAST parameterDef = catchAst.findFirstToken(TokenTypes.PARAMETER_DEF);
         final DetailAST variableName = parameterDef.findFirstToken(TokenTypes.IDENT);
         return variableName.getText();
     }
 
 }
