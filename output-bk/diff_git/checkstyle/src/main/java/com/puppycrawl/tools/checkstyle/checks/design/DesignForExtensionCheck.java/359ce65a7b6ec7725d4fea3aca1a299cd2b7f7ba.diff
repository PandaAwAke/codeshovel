diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
index d02f1a87a..c2c5fd7d0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
@@ -110,145 +110,145 @@ public class DesignForExtensionCheck extends AbstractCheck {
      */
     public void setIgnoredAnnotations(String... ignoredAnnotations) {
         this.ignoredAnnotations = Arrays.stream(ignoredAnnotations).collect(Collectors.toSet());
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         // The check does not subscribe to CLASS_DEF token as now it is stateless. If the check
         // subscribes to CLASS_DEF token it will become stateful, since we need to have additional
         // stack to hold CLASS_DEF tokens.
         return new int[] {TokenTypes.METHOD_DEF};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (!hasJavadocComment(ast)
                 && canBeOverridden(ast)
                 && (isNativeMethod(ast)
                     || !hasEmptyImplementation(ast))
                 && !hasIgnoredAnnotation(ast, ignoredAnnotations)) {
 
             final DetailAST classDef = getNearestClassOrEnumDefinition(ast);
             if (canBeSubclassed(classDef)) {
                 final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();
                 final String methodName = ast.findFirstToken(TokenTypes.IDENT).getText();
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY, className, methodName);
             }
         }
     }
 
     /**
      * Checks whether a method has a javadoc comment.
      * @param methodDef method definition token.
      * @return true if a method has a javadoc comment.
      */
-    private boolean hasJavadocComment(DetailAST methodDef) {
+    private static boolean hasJavadocComment(DetailAST methodDef) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         return modifiers.branchContains(TokenTypes.BLOCK_COMMENT_BEGIN);
     }
 
     /**
      * Checks whether a methods is native.
      * @param ast method definition token.
      * @return true if a methods is native.
      */
-    private boolean isNativeMethod(DetailAST ast) {
+    private static boolean isNativeMethod(DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         return mods.branchContains(TokenTypes.LITERAL_NATIVE);
     }
 
     /**
      * Checks whether a method has only comments in the body (has an empty implementation).
      * Method is OK if its implementation is empty.
      * @param ast method definition token.
      * @return true if a method has only comments in the body.
      */
     private static boolean hasEmptyImplementation(DetailAST ast) {
         boolean hasEmptyBody = true;
         final DetailAST methodImplOpenBrace = ast.findFirstToken(TokenTypes.SLIST);
         final DetailAST methodImplCloseBrace = methodImplOpenBrace.getLastChild();
         final Predicate<DetailAST> predicate = currentNode -> {
             return currentNode != methodImplCloseBrace
                 && !TokenUtils.isCommentType(currentNode.getType());
         };
         final Optional<DetailAST> methodBody =
             TokenUtils.findFirstTokenByPredicate(methodImplOpenBrace, predicate);
         if (methodBody.isPresent()) {
             hasEmptyBody = false;
         }
         return hasEmptyBody;
     }
 
     /**
      * Checks whether a method can be overridden.
      * Method can be overridden if it is not private, abstract, final or static.
      * Note that the check has nothing to do for interfaces.
      * @param methodDef method definition token.
      * @return true if a method can be overridden in a subclass.
      */
-    private boolean canBeOverridden(DetailAST methodDef) {
+    private static boolean canBeOverridden(DetailAST methodDef) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         return ScopeUtils.getSurroundingScope(methodDef).isIn(Scope.PROTECTED)
             && !ScopeUtils.isInInterfaceOrAnnotationBlock(methodDef)
             && !modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)
             && !modifiers.branchContains(TokenTypes.ABSTRACT)
             && !modifiers.branchContains(TokenTypes.FINAL)
             && !modifiers.branchContains(TokenTypes.LITERAL_STATIC);
     }
 
     /**
      * Checks whether a method has any of ignored annotations.
      * @param methodDef method definition token.
      * @param annotations a set of ignored annotations.
      * @return true if a method has any of ignored annotations.
      */
     private static boolean hasIgnoredAnnotation(DetailAST methodDef, Set<String> annotations) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         boolean hasIgnoredAnnotation = false;
         if (modifiers.branchContains(TokenTypes.ANNOTATION)) {
             final Optional<DetailAST> annotation = TokenUtils.findFirstTokenByPredicate(modifiers,
                 currentToken -> {
                     return currentToken.getType() == TokenTypes.ANNOTATION
                         && annotations.contains(getAnnotationName(currentToken));
                 });
             if (annotation.isPresent()) {
                 hasIgnoredAnnotation = true;
             }
         }
         return hasIgnoredAnnotation;
     }
 
     /**
      * Gets the name of the annotation.
      * @param annotation to get name of.
      * @return the name of the annotation.
      */
     private static String getAnnotationName(DetailAST annotation) {
         final DetailAST dotAst = annotation.findFirstToken(TokenTypes.DOT);
         final String name;
         if (dotAst == null) {
             name = annotation.findFirstToken(TokenTypes.IDENT).getText();
         }
         else {
             name = dotAst.findFirstToken(TokenTypes.IDENT).getText();
         }
         return name;
     }
 
     /**
      * Returns CLASS_DEF or ENUM_DEF token which is the nearest to the given ast node.
