diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
index 601f7998f..5f62d2c5d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java
@@ -43,130 +43,130 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 public final class NPathComplexityCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "npathComplexity";
 
     /** Default allowed complexity. */
     private static final int DEFAULT_MAX = 200;
 
     /** The initial current value. */
     private static final BigInteger INITIAL_VALUE = BigInteger.ZERO;
 
     /**
      * Stack of NP values for ranges.
      */
     private final Deque<BigInteger> rangeValues = new ArrayDeque<>();
 
     /** Stack of NP values for expressions. */
     private final Deque<Integer> expressionValues = new ArrayDeque<>();
 
     /** Stack of belongs to range values for question operator. */
     private final Deque<Boolean> isAfterValues = new ArrayDeque<>();
 
     /**
      * Range of the last processed expression. Used for checking that ternary operation
      * which is a part of expression won't be processed for second time.
      */
     private final TokenEnd processingTokenEnd = new TokenEnd();
 
     /** NP value for current range. */
     private BigInteger currentRangeValue = INITIAL_VALUE;
 
     /** Threshold to report error for. */
     private int max = DEFAULT_MAX;
 
     /** True, when branch is visited, but not leaved. */
     private boolean branchVisited;
 
     /**
      * Set the maximum threshold allowed.
      * @param max the maximum threshold
      */
     public void setMax(int max) {
         this.max = max;
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
+    @Override
+    public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.CASE_GROUP,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.QUESTION,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_DEFAULT,
         };
     }
 
-    @Override
-    public int[] getRequiredTokens() {
-        return getAcceptableTokens();
-    }
-
     @Override
     public void beginTree(DetailAST rootAST) {
         rangeValues.clear();
         expressionValues.clear();
         isAfterValues.clear();
         processingTokenEnd.reset();
         currentRangeValue = INITIAL_VALUE;
         branchVisited = false;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.LITERAL_IF:
             case TokenTypes.LITERAL_SWITCH:
             case TokenTypes.LITERAL_WHILE:
             case TokenTypes.LITERAL_DO:
             case TokenTypes.LITERAL_FOR:
                 visitConditional(ast, 1);
                 break;
             case TokenTypes.QUESTION:
                 visitUnitaryOperator(ast, 2);
                 break;
             case TokenTypes.LITERAL_RETURN:
                 visitUnitaryOperator(ast, 0);
                 break;
             case TokenTypes.CASE_GROUP:
                 final int caseNumber = countCaseTokens(ast);
                 branchVisited = true;
                 pushValue(caseNumber);
                 break;
             case TokenTypes.LITERAL_ELSE:
                 branchVisited = true;
                 if (currentRangeValue.equals(BigInteger.ZERO)) {
                     currentRangeValue = BigInteger.ONE;
                 }
                 pushValue(0);
                 break;
             case TokenTypes.LITERAL_TRY:
             case TokenTypes.LITERAL_CATCH:
             case TokenTypes.LITERAL_DEFAULT:
                 pushValue(1);
                 break;
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.INSTANCE_INIT:
             case TokenTypes.STATIC_INIT:
                 pushValue(0);
                 break;
             default:
