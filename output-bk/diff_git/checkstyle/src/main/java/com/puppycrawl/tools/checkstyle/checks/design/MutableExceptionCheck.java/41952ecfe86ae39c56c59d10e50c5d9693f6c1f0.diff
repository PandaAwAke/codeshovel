diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
index 6a68c7f03..d0f966c95 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
@@ -32,111 +32,111 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * <p> Ensures that exceptions (classes with names conforming to some regular
  * expression and explicitly extending classes with names conforming to other
  * regular expression) are immutable. That is, they have only final fields.</p>
  * <p> Rationale: Exception instances should represent an error
  * condition. Having non final fields not only allows the state to be
  * modified by accident and therefore mask the original condition but
  * also allows developers to accidentally forget to initialise state
  * thereby leading to code catching the exception to draw incorrect
  * conclusions based on the state.</p>
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  */
 @FileStatefulCheck
 public final class MutableExceptionCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "mutable.exception";
 
     /** Default value for format and extendedClassNameFormat properties. */
     private static final String DEFAULT_FORMAT = "^.*Exception$|^.*Error$|^.*Throwable$";
     /** Stack of checking information for classes. */
     private final Deque<Boolean> checkingStack = new ArrayDeque<>();
     /** Pattern for class name that is being extended. */
     private Pattern extendedClassNameFormat = Pattern.compile(DEFAULT_FORMAT);
     /** Should we check current class or not. */
     private boolean checking;
     /** The regexp to match against. */
     private Pattern format = Pattern.compile(DEFAULT_FORMAT);
 
     /**
      * Sets the format of extended class name to the specified regular expression.
      * @param extendedClassNameFormat a {@code String} value
      */
     public void setExtendedClassNameFormat(Pattern extendedClassNameFormat) {
         this.extendedClassNameFormat = extendedClassNameFormat;
     }
 
     /**
      * Set the format for the specified regular expression.
      * @param pattern the new pattern
      */
     public void setFormat(Pattern pattern) {
         format = pattern;
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {TokenTypes.CLASS_DEF, TokenTypes.VARIABLE_DEF};
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getDefaultTokens();
+        return new int[] {TokenTypes.CLASS_DEF, TokenTypes.VARIABLE_DEF};
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {TokenTypes.CLASS_DEF, TokenTypes.VARIABLE_DEF};
+        return getRequiredTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF:
                 visitClassDef(ast);
                 break;
             case TokenTypes.VARIABLE_DEF:
                 visitVariableDef(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             leaveClassDef();
         }
     }
 
     /**
      * Called when we start processing class definition.
      * @param ast class definition node
      */
     private void visitClassDef(DetailAST ast) {
         checkingStack.push(checking);
         checking = isNamedAsException(ast) && isExtendedClassNamedAsException(ast);
     }
 
     /** Called when we leave class definition. */
     private void leaveClassDef() {
         checking = checkingStack.pop();
     }
 
     /**
      * Checks variable definition.
      * @param ast variable def node for check
      */
     private void visitVariableDef(DetailAST ast) {
         if (checking && ast.getParent().getType() == TokenTypes.OBJBLOCK) {
             final DetailAST modifiersAST =
                 ast.findFirstToken(TokenTypes.MODIFIERS);
 
             if (modifiersAST.findFirstToken(TokenTypes.FINAL) == null) {
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY,
                         ast.findFirstToken(TokenTypes.IDENT).getText());
             }
