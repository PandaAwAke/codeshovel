diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java
index 43858f32a..d76d4a643 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java
@@ -109,123 +109,123 @@ public final class MissingDeprecatedCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_JAVADOC_DUPLICATE_TAG =
             "javadoc.duplicateTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_JAVADOC_MISSING = "javadoc.missing";
 
     /** {@link Deprecated Deprecated} annotation name. */
     private static final String DEPRECATED = "Deprecated";
 
     /** Fully-qualified {@link Deprecated Deprecated} annotation name. */
     private static final String FQ_DEPRECATED = "java.lang." + DEPRECATED;
 
     /** Compiled regexp to match Javadoc tag with no argument. */
     private static final Pattern MATCH_DEPRECATED =
             CommonUtils.createPattern("@(deprecated)\\s+\\S");
 
     /** Compiled regexp to match first part of multilineJavadoc tags. */
     private static final Pattern MATCH_DEPRECATED_MULTILINE_START =
             CommonUtils.createPattern("@(deprecated)\\s*$");
 
     /** Compiled regexp to look for a continuation of the comment. */
     private static final Pattern MATCH_DEPRECATED_MULTILINE_CONT =
             CommonUtils.createPattern("(\\*/|@|[^\\s\\*])");
 
     /** Multiline finished at end of comment. */
     private static final String END_JAVADOC = "*/";
     /** Multiline finished at next Javadoc. */
     private static final String NEXT_TAG = "@";
 
     /** Is deprecated element valid without javadoc. */
     private boolean skipNoJavadoc;
 
     /**
      * Set skipJavadoc value.
      * @param skipNoJavadoc user's value of skipJavadoc
      */
     public void setSkipNoJavadoc(boolean skipNoJavadoc) {
         this.skipNoJavadoc = skipNoJavadoc;
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
+    @Override
+    public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
-    @Override
-    public int[] getRequiredTokens() {
-        return getAcceptableTokens();
-    }
-
     @Override
     public void visitToken(final DetailAST ast) {
         final TextBlock javadoc =
             getFileContents().getJavadocBefore(ast.getLineNo());
 
         final boolean containsAnnotation =
             AnnotationUtility.containsAnnotation(ast, DEPRECATED)
             || AnnotationUtility.containsAnnotation(ast, FQ_DEPRECATED);
 
         final boolean containsJavadocTag = containsJavadocTag(javadoc);
 
         if (containsAnnotation ^ containsJavadocTag && !(skipNoJavadoc && javadoc == null)) {
             log(ast.getLineNo(), MSG_KEY_ANNOTATION_MISSING_DEPRECATED);
         }
     }
 
     /**
      * Checks to see if the text block contains a deprecated tag.
      *
      * @param javadoc the javadoc of the AST
      * @return true if contains the tag
      */
     private boolean containsJavadocTag(final TextBlock javadoc) {
         boolean found = false;
         if (javadoc != null) {
             final String[] lines = javadoc.getText();
             int currentLine = javadoc.getStartLineNo() - 1;
 
             for (int i = 0; i < lines.length; i++) {
                 currentLine++;
                 final String line = lines[i];
 
                 final Matcher javadocNoArgMatcher = MATCH_DEPRECATED.matcher(line);
                 final Matcher noArgMultilineStart = MATCH_DEPRECATED_MULTILINE_START.matcher(line);
 
                 if (javadocNoArgMatcher.find()) {
                     if (found) {
                         log(currentLine, MSG_KEY_JAVADOC_DUPLICATE_TAG,
                                 JavadocTagInfo.DEPRECATED.getText());
                     }
                     found = true;
                 }
                 else if (noArgMultilineStart.find()) {
                     found = checkTagAtTheRestOfComment(lines, found, currentLine, i);
                 }
             }
         }
         return found;
     }
 
