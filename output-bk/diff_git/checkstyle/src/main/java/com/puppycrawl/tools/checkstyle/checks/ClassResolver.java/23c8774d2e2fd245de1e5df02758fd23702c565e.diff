diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
index 035ddf760..1ae78790f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
@@ -74,102 +74,106 @@ public class ClassResolver {
         // try matching explicit imports
         for (String imp : imports) {
             // Very important to add the "." in the check below. Otherwise you
             // when checking for "DataException", it will match on
             // "SecurityDataException". This has been the cause of a very
             // difficult bug to resolve!
             if (imp.endsWith("." + name)) {
                 clazz = resolveQualifiedName(imp);
                 if (clazz != null) {
                     return clazz;
                 }
 
             }
         }
 
         // See if in the package
         if (pkg != null && !pkg.isEmpty()) {
             clazz = resolveQualifiedName(pkg + "." + name);
             if (clazz != null) {
                 return clazz;
             }
         }
 
         // see if inner class of this class
         clazz = resolveInnerClass(name, currentClass);
         if (clazz != null) {
             return clazz;
         }
 
         clazz = resolveByStarImports(name);
         if (clazz != null) {
             return clazz;
         }
 
         // Giving up, the type is unknown, so load the class to generate an
         // exception
         return safeLoad(name);
     }
 
     /**
      * see if inner class of this class
      * @param name name of the search Class to search
      * @param currentClass class where search in
      * @return class if found , or null if not resolved
      * @throws ClassNotFoundException  if an error occurs
      */
     private Class<?> resolveInnerClass(String name, String currentClass)
             throws ClassNotFoundException {
         Class<?> clazz = null;
         if (!currentClass.isEmpty()) {
-            final String innerClass = (pkg.isEmpty() ? "" : pkg + ".")
-                + currentClass + "$" + name;
+            String innerClass = currentClass + "$" + name;
+
+            if (!pkg.isEmpty()) {
+                innerClass = pkg + "." + innerClass;
+            }
+
             if (isLoadable(innerClass)) {
                 clazz = safeLoad(innerClass);
             }
         }
         return clazz;
     }
 
     /**
      * try star imports
      * @param name name of the Class to search
      * @return  class if found , or null if not resolved
      */
     private Class<?> resolveByStarImports(String name) {
         Class<?> clazz = null;
         for (String imp : imports) {
             if (imp.endsWith(".*")) {
                 final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1)
                     + name;
                 clazz = resolveQualifiedName(fqn);
                 if (clazz != null) {
                     break;
                 }
             }
         }
         return clazz;
     }
 
     /**
      * @param name name of the class to check
      * @return whether a specified class is loadable with safeLoad().
      */
     public boolean isLoadable(String name) {
         try {
             safeLoad(name);
             return true;
         }
         catch (final ClassNotFoundException | NoClassDefFoundError ignored) {
             return false;
         }
     }
 
     /**
      * Will load a specified class is such a way that it will NOT be
      * initialised.
      * @param name name of the class to load
      * @return the {@code Class} for the specified class
      * @throws ClassNotFoundException if an error occurs
      * @throws NoClassDefFoundError if an error occurs
      */
     public Class<?> safeLoad(String name)
