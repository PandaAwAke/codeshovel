diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
index 7fdac9494..ccc080d8c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
@@ -109,117 +109,122 @@ public class SuppressWarningsCheck extends AbstractFormatCheck
     @Override
     public final int[] getDefaultTokens()
     {
         return this.getAcceptableTokens();
     }
 
     /** {@inheritDoc} */
     @Override
     public final int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     /** {@inheritDoc} */
     @Override
     public void visitToken(final DetailAST aAST)
     {
         final DetailAST annotation = this.getSuppressWarnings(aAST);
 
         if (annotation == null) {
             return;
         }
 
         final DetailAST warningHolder =
             this.findWarningsHolder(annotation);
 
         DetailAST warning = warningHolder.findFirstToken(TokenTypes.EXPR);
 
         //rare case with empty array ex: @SuppressWarnings({})
         if (warning == null) {
             //check to see if empty warnings are forbidden -- are by default
             this.logMatch(warningHolder.getLineNo(),
                 warningHolder.getColumnNo(), "");
             return;
         }
 
         while (warning != null) {
             if (warning.getType() == TokenTypes.EXPR) {
                 final DetailAST fChild = warning.getFirstChild();
-
+                switch (fChild.getType()) {
                 //typical case
-                if (fChild.getType() == TokenTypes.STRING_LITERAL) {
+                case TokenTypes.STRING_LITERAL:
                     final String warningText =
                         this.removeQuotes(warning.getFirstChild().getText());
                     this.logMatch(warning.getLineNo(),
                         warning.getColumnNo(), warningText);
-
-     //conditional case
-     //ex: @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")
-                }
-                else if (fChild.getType() == TokenTypes.QUESTION) {
+                    break;
+                //conditional case
+                //ex: @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")
+                case TokenTypes.QUESTION:
                     this.walkConditional(fChild);
-                }
-                else {
-                    assert false : "Should never get here, type: "
-                        + fChild.getType() + " text: " + fChild.getText();
+                    break;
+                //param in constant case
+                //ex: public static final String UNCHECKED = "unchecked";
+                //@SuppressWarnings(UNCHECKED) or @SuppressWarnings(SomeClass.UNCHECKED)
+                case TokenTypes.IDENT:
+                case TokenTypes.DOT:
+                    break;
+                default:
+                    throw new IllegalStateException("Should never get here, type: "
+                        + fChild.getType() + " text: " + fChild.getText());
                 }
             }
             warning = warning.getNextSibling();
         }
     }
 
     /**
      * Gets the {@link SuppressWarnings SuppressWarnings} annotation
      * that is annotating the AST.  If the annotation does not exist
      * this method will return {@code null}.
      *
      * @param aAST the AST
      * @return the {@link SuppressWarnings SuppressWarnings} annotation
      */
     private DetailAST getSuppressWarnings(DetailAST aAST)
     {
         final DetailAST annotation = AnnotationUtility.getAnnotation(
             aAST, SuppressWarningsCheck.SUPPRESS_WARNINGS);
 
         return (annotation != null) ? annotation
             : AnnotationUtility.getAnnotation(
                 aAST, SuppressWarningsCheck.FQ_SUPPRESS_WARNINGS);
     }
 
     /**
      * This method looks for a warning that matches a configured expression.
      * If found it logs a violation at the given line and column number.
      *
      * @param aLineNo the line number
      * @param aColNum the column number
      * @param aWarningText the warning.
      */
     private void logMatch(final int aLineNo,
         final int aColNum, final String aWarningText)
     {
         final Matcher matcher = this.getRegexp().matcher(aWarningText);
         if (matcher.matches()) {
             this.log(aLineNo, aColNum,
                 "suppressed.warning.not.allowed", aWarningText);
         }
     }
 
     /**
      * Find the parent (holder) of the of the warnings (Expr).
      *
      * @param aAnnotation the annotation
      * @return a Token representing the expr.
      */
     private DetailAST findWarningsHolder(final DetailAST aAnnotation)
     {
