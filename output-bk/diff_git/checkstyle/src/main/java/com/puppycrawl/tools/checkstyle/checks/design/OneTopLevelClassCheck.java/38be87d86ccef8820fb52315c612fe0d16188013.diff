diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java
index 30d3a9fc3..d02ffd325 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java
@@ -95,75 +95,76 @@ public class OneTopLevelClassCheck extends Check
     /**
      * True if a java source file contains a type
      * with a public access level modifier.
      */
     private boolean publicTypeFound;
 
     /** Mapping between type names and line numbers of the type declarations.*/
     private SortedMap<Integer, String> lineNumberTypeMap = new TreeMap<>();
 
     @Override
     public int[] getDefaultTokens()
     {
         return getAcceptableTokens();
     }
 
     // ZERO tokens as Check do Traverse of Tree himself, he does not need to subscribed to Tokens
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {};
     }
 
     @Override
     public void beginTree(DetailAST rootAST)
     {
         publicTypeFound = false;
         lineNumberTypeMap.clear();
 
         DetailAST currentNode = rootAST;
         while (currentNode != null) {
             if (currentNode.getType() == TokenTypes.CLASS_DEF
                     || currentNode.getType() == TokenTypes.ENUM_DEF
                     || currentNode.getType() == TokenTypes.INTERFACE_DEF)
             {
                 if (isPublic(currentNode)) {
                     publicTypeFound = true;
                 }
                 else {
                     final String typeName = currentNode
                             .findFirstToken(TokenTypes.IDENT).getText();
                     lineNumberTypeMap.put(currentNode.getLineNo(), typeName);
                 }
             }
             currentNode = currentNode.getNextSibling();
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST)
     {
-        if (!publicTypeFound) {
-            // skip first top-level type.
-            lineNumberTypeMap.remove(lineNumberTypeMap.firstKey());
-        }
+        if (!lineNumberTypeMap.isEmpty()) {
+            if (!publicTypeFound) {
+                // skip first top-level type.
+                lineNumberTypeMap.remove(lineNumberTypeMap.firstKey());
+            }
 
-        for (Map.Entry<Integer, String> entry
-                : lineNumberTypeMap.entrySet())
-        {
-            log(entry.getKey(), MSG_KEY, entry.getValue());
+            for (Map.Entry<Integer, String> entry
+                    : lineNumberTypeMap.entrySet())
+            {
+                log(entry.getKey(), MSG_KEY, entry.getValue());
+            }
         }
-
     }
 
     /**
      * Checks if a type is public.
      * @param typeDef type definition node.
      * @return true if a type has a public access level modifier.
      */
     private boolean isPublic(DetailAST typeDef)
     {
         final DetailAST modifiers =
                 typeDef.findFirstToken(TokenTypes.MODIFIERS);
         return modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null;
     }
 }
