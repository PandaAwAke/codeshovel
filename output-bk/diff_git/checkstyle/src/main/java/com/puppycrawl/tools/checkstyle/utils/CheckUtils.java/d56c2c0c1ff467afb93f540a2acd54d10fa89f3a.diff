diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
index 690c334b8..2c2dd2df4 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
@@ -365,106 +365,102 @@ public final class CheckUtils {
         if (ast.getType() == TokenTypes.METHOD_DEF
                 && ast.getChildCount() == SETTER_GETTER_MAX_CHILDREN) {
 
             final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
             final String name = type.getNextSibling().getText();
             final boolean matchesGetterFormat = GETTER_PATTERN.matcher(name).matches();
             final boolean noVoidReturnType = type.findFirstToken(TokenTypes.LITERAL_VOID) == null;
 
             final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
             final boolean noParams = params.getChildCount(TokenTypes.PARAMETER_DEF) == 0;
 
             if (matchesGetterFormat && noVoidReturnType && noParams) {
                 // Now verify that the body consists of:
                 // SLIST -> RETURN
                 // RCURLY
                 final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
 
                 if (slist != null && slist.getChildCount() == GETTER_BODY_SIZE) {
                     final DetailAST expr = slist.getFirstChild();
                     getterMethod = expr.getType() == TokenTypes.LITERAL_RETURN;
                 }
             }
         }
         return getterMethod;
     }
 
     /**
      * Checks whether a method is a not void one.
      *
      * @param methodDefAst the method node.
      * @return true if method is a not void one.
      */
     public static boolean isNonVoidMethod(DetailAST methodDefAst) {
         boolean returnValue = false;
         if (methodDefAst.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = methodDefAst.findFirstToken(TokenTypes.TYPE);
             if (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null) {
                 returnValue = true;
             }
         }
         return returnValue;
     }
 
     /**
      * Checks whether a parameter is a receiver.
      *
      * @param parameterDefAst the parameter node.
      * @return true if the parameter is a receiver.
      */
     public static boolean isReceiverParameter(DetailAST parameterDefAst) {
-        boolean returnValue = false;
-        if (parameterDefAst.getType() == TokenTypes.PARAMETER_DEF
-                && parameterDefAst.findFirstToken(TokenTypes.IDENT) == null) {
-            returnValue = parameterDefAst.branchContains(TokenTypes.LITERAL_THIS);
-        }
-        return returnValue;
+        return parameterDefAst.getType() == TokenTypes.PARAMETER_DEF
+                && parameterDefAst.findFirstToken(TokenTypes.IDENT) == null;
     }
 
     /**
      * Returns {@link AccessModifier} based on the information about access modifier
      * taken from the given token of type {@link TokenTypes#MODIFIERS}.
      * @param modifiersToken token of type {@link TokenTypes#MODIFIERS}.
      * @return {@link AccessModifier}.
      */
     public static AccessModifier getAccessModifierFromModifiersToken(DetailAST modifiersToken) {
         if (modifiersToken == null || modifiersToken.getType() != TokenTypes.MODIFIERS) {
             throw new IllegalArgumentException("expected non-null AST-token with type 'MODIFIERS'");
         }
 
         // default access modifier
         AccessModifier accessModifier = AccessModifier.PACKAGE;
         for (AST token = modifiersToken.getFirstChild(); token != null;
              token = token.getNextSibling()) {
 
             final int tokenType = token.getType();
             if (tokenType == TokenTypes.LITERAL_PUBLIC) {
                 accessModifier = AccessModifier.PUBLIC;
             }
             else if (tokenType == TokenTypes.LITERAL_PROTECTED) {
                 accessModifier = AccessModifier.PROTECTED;
             }
             else if (tokenType == TokenTypes.LITERAL_PRIVATE) {
                 accessModifier = AccessModifier.PRIVATE;
             }
         }
         return accessModifier;
     }
 
     /**
      * Create set of class names and short class names.
      *
      * @param classNames array of class names.
      * @return set of class names and short class names.
      */
     public static Set<String> parseClassNames(String... classNames) {
         final Set<String> illegalClassNames = new HashSet<>();
         for (final String name : classNames) {
             illegalClassNames.add(name);
             final int lastDot = name.lastIndexOf('.');
             if (lastDot != -1 && lastDot < name.length() - 1) {
                 final String shortName = name
                         .substring(name.lastIndexOf('.') + 1);
                 illegalClassNames.add(shortName);
             }
         }
         return illegalClassNames;
