diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index 363663b09..8e670a78e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -370,163 +370,163 @@ public class ImportOrderCheck
             doVisitToken(ident, isStatic, isStaticAndNotLastImport);
 
         }
         else if (option == ImportOrderOption.BOTTOM) {
 
             if (isStaticAndNotLastImport) {
                 lastGroup = Integer.MIN_VALUE;
                 lastImport = "";
             }
             doVisitToken(ident, isStatic, isLastImportAndNonStatic);
 
         }
         else if (option == ImportOrderOption.ABOVE) {
             // previous non-static but current is static
             doVisitToken(ident, isStatic, isStaticAndNotLastImport);
 
         }
         else if (option == ImportOrderOption.UNDER) {
             doVisitToken(ident, isStatic, isLastImportAndNonStatic);
 
         }
         else if (option == ImportOrderOption.INFLOW) {
             // "previous" argument is useless here
             doVisitToken(ident, isStatic, true);
 
         }
         else {
             throw new IllegalStateException(
                     "Unexpected option for static imports: " + option);
         }
 
         lastImportLine = ast.findFirstToken(TokenTypes.SEMI).getLineNo();
         lastImportStatic = isStatic;
         beforeFirstImport = false;
     }
 
     /**
      * Shares processing...
      *
      * @param ident the import to process.
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *                  previous static but current is non-static (under).
      */
     private void doVisitToken(FullIdent ident, boolean isStatic,
             boolean previous) {
         final String name = ident.getText();
         final int groupIdx = getGroupNumber(name);
         final int line = ident.getLineNo();
 
-        if (!beforeFirstImport && isAlphabeticallySortableStaticImport(isStatic)
-                || groupIdx == lastGroup) {
+        if (groupIdx == lastGroup
+            || !beforeFirstImport && isAlphabeticallySortableStaticImport(isStatic)) {
             doVisitTokenInSameGroup(isStatic, previous, name, line);
         }
         else if (groupIdx > lastGroup) {
             if (!beforeFirstImport && separated && line - lastImportLine < 2) {
                 log(line, MSG_SEPARATION, name);
             }
         }
         else {
             log(line, MSG_ORDERING, name);
         }
 
         lastGroup = groupIdx;
         lastImport = name;
     }
 
     /**
      * Checks whether static imports grouped by <b>top</b> or <b>bottom</b> option
      * are sorted alphabetically or not.
      * @param isStatic if current import is static.
      * @return true if static imports should be sorted alphabetically.
      */
     private boolean isAlphabeticallySortableStaticImport(boolean isStatic) {
         return isStatic && sortStaticImportsAlphabetically
                 && (option == ImportOrderOption.TOP
                     || option == ImportOrderOption.BOTTOM);
     }
 
     /**
      * Shares processing...
      *
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *     previous static but current is non-static (under).
      * @param name the name of the current import.
      * @param line the line of the current import.
      */
     private void doVisitTokenInSameGroup(boolean isStatic,
             boolean previous, String name, int line) {
         if (!ordered) {
             return;
         }
 
         if (option == ImportOrderOption.INFLOW) {
             // out of lexicographic order
             if (compare(lastImport, name, caseSensitive) > 0) {
                 log(line, MSG_ORDERING, name);
             }
         }
         else {
             final boolean shouldFireError =
-                // current and previous static or current and
-                // previous non-static
-                lastImportStatic == isStatic
-                &&
-                        // and out of lexicographic order
-                        compare(lastImport, name, caseSensitive) > 0
-                ||
                 // previous non-static but current is static (above)
                 // or
                 // previous static but current is non-static (under)
-                previous;
+                previous
+                    ||
+                    // current and previous static or current and
+                    // previous non-static
+                    lastImportStatic == isStatic
+                &&
+                // and out of lexicographic order
+                compare(lastImport, name, caseSensitive) > 0;
 
             if (shouldFireError) {
                 log(line, MSG_ORDERING, name);
             }
         }
     }
 
     /**
      * Finds out what group the specified import belongs to.
      *
      * @param name the import name to find.
      * @return group number for given import name.
      */
     private int getGroupNumber(String name) {
         int bestIndex = groups.length;
         int bestLength = -1;
         int bestPos = 0;
 
         // find out what group this belongs in
         // loop over groups and get index
         for (int i = 0; i < groups.length; i++) {
             final Matcher matcher = groups[i].matcher(name);
             while (matcher.find()) {
                 final int length = matcher.end() - matcher.start();
                 if (length > bestLength
                     || length == bestLength && matcher.start() < bestPos) {
                     bestIndex = i;
                     bestLength = length;
                     bestPos = matcher.start();
                 }
             }
         }
 
         return bestIndex;
     }
 
     /**
      * Compares two strings.
      *
      * @param string1
      *            the first string.
      * @param string2
      *            the second string.
      * @param caseSensitive
      *            whether the comparison is case sensitive.
      * @return the value {@code 0} if string1 is equal to string2; a value
      *         less than {@code 0} if string1 is lexicographically less
      *         than the string2; and a value greater than {@code 0} if
      *         string1 is lexicographically greater than string2.
      */
