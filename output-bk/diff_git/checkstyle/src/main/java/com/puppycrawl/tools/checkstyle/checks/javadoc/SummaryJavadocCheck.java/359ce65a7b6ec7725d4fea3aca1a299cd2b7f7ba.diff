diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
index 70dd95d3e..58de618b4 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
@@ -114,146 +114,146 @@ public class SummaryJavadocCheck extends AbstractJavadocCheck {
     public void setForbiddenSummaryFragments(Pattern pattern) {
         forbiddenSummaryFragments = pattern;
     }
 
     /**
      * Sets value of period symbol at the end of first javadoc sentence.
      * @param period period's value.
      */
     public void setPeriod(String period) {
         this.period = period;
     }
 
     @Override
     public int[] getDefaultJavadocTokens() {
         return new int[] {
             JavadocTokenTypes.JAVADOC,
         };
     }
 
     @Override
     public int[] getRequiredJavadocTokens() {
         return getAcceptableJavadocTokens();
     }
 
     @Override
     public void visitJavadocToken(DetailNode ast) {
         String firstSentence = getFirstSentence(ast);
         final int endOfSentence = firstSentence.lastIndexOf(period);
         final String summaryDoc = getSummarySentence(ast);
         if (summaryDoc.isEmpty()) {
             log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);
         }
         else if (!period.isEmpty()
                 && !summaryDoc.contains(period)
                 && !summaryDoc.equals(INHERIT_DOC)) {
             log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);
         }
         if (endOfSentence != -1) {
             firstSentence = firstSentence.substring(0, endOfSentence);
             if (containsForbiddenFragment(firstSentence)) {
                 log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);
             }
         }
     }
 
     /**
      * Checks if period is at the end of sentence.
      * @param ast Javadoc root node.
      * @return error string
      */
-    private String getSummarySentence(DetailNode ast) {
+    private static String getSummarySentence(DetailNode ast) {
         boolean flag = true;
         final StringBuilder result = new StringBuilder();
         for (DetailNode child : ast.getChildren()) {
             if (ALLOWED_TYPES.contains(child.getType())) {
                 result.append(child.getText());
             }
             else if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG
                     && getContentOfChild(child).equals(INHERIT_DOC)) {
                 result.append(INHERIT_DOC);
             }
             else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT
                     && CommonUtils.isBlank(result.toString().trim())) {
                 result.append(getStringInsideTag(result.toString(),
                         child.getChildren()[0].getChildren()[0]));
             }
             else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {
                 flag = false;
             }
             if (!flag) {
                 break;
             }
         }
         return result.toString().trim();
     }
 
     /**
      * Returns content when token type is javadoc inline tag.
      * @param child javadoc inline tag ast.
      * @return content of child nodes as string.
      */
     private static String getContentOfChild(DetailNode child) {
         final StringBuilder contents = new StringBuilder();
         for (DetailNode node : child.getChildren()) {
             contents.append(node.getText().trim());
         }
         return contents.toString();
     }
 
     /**
      * Concatenates string within text of html tags.
      * @param result javadoc string
      * @param detailNode javadoc tag node
      * @return java doc tag content appended in result
      */
-    private String getStringInsideTag(String result, DetailNode detailNode) {
+    private static String getStringInsideTag(String result, DetailNode detailNode) {
         final StringBuilder contents = new StringBuilder(result);
         DetailNode tempNode = detailNode;
         while (tempNode != null) {
             if (tempNode.getType() == JavadocTokenTypes.TEXT) {
                 contents.append(tempNode.getText());
             }
             tempNode = JavadocUtils.getNextSibling(tempNode);
         }
         return contents.toString();
     }
 
     /**
      * Finds and returns first sentence.
      * @param ast Javadoc root node.
      * @return first sentence.
      */
     private static String getFirstSentence(DetailNode ast) {
         final StringBuilder result = new StringBuilder();
         final String periodSuffix = PERIOD + ' ';
         for (DetailNode child : ast.getChildren()) {
             final String text;
             if (child.getChildren().length == 0) {
                 text = child.getText();
             }
             else {
                 text = getFirstSentence(child);
             }
 
             if (child.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG
                 && text.contains(periodSuffix)) {
                 result.append(text.substring(0, text.indexOf(periodSuffix) + 1));
                 break;
             }
             else {
                 result.append(text);
             }
         }
         return result.toString();
     }
 
     /**
      * Tests if first sentence contains forbidden summary fragment.
      * @param firstSentence String with first sentence.
      * @return true, if first sentence contains forbidden summary fragment.
      */
     private boolean containsForbiddenFragment(String firstSentence) {
         String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN
                 .matcher(firstSentence).replaceAll(" ");
         javadocText = CharMatcher.whitespace().trimAndCollapseFrom(javadocText, ' ');
         return forbiddenSummaryFragments.matcher(javadocText).find();
