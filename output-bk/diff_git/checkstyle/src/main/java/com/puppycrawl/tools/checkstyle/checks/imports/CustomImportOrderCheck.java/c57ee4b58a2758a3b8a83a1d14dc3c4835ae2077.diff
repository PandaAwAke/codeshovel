diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index 4b5df025f..ab2e890a1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -48,191 +48,191 @@ import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
  * and import name are identical.
  * </p>
  *
  * <pre>
  * {@code
  * package java.util.concurrent.locks;
  *
  * import java.io.File;
  * import java.util.*; //#1
  * import java.util.List; //#2
  * import java.util.StringTokenizer; //#3
  * import java.util.concurrent.*; //#4
  * import java.util.concurrent.AbstractExecutorService; //#5
  * import java.util.concurrent.locks.LockSupport; //#6
  * import java.util.regex.Pattern; //#7
  * import java.util.regex.Matcher; //#8
  * }
  * </pre>
  *
  * <p>
  * If we have SAME_PACKAGE(3) on configuration file,
  * imports #4-6 will be considered as a SAME_PACKAGE group (java.util.concurrent.*,
  * java.util.concurrent.AbstractExecutorService, java.util.concurrent.locks.LockSupport).
  * SAME_PACKAGE(2) will include #1-8. SAME_PACKAGE(4) will include only #6.
  * SAME_PACKAGE(5) will result in no imports assigned to SAME_PACKAGE group because
  * actual package java.util.concurrent.locks has only 4 domains.
  * </p>
  *
  * <p>
  * THIRD_PARTY_PACKAGE group. This group sets ordering of third party imports.
  * Third party imports are all imports except STATIC,
  * SAME_PACKAGE(n), STANDARD_JAVA_PACKAGE and SPECIAL_IMPORTS.
  * </p>
  *
  * <pre>
  * STANDARD_JAVA_PACKAGE group. This group sets ordering of standard java/javax imports.
  * </pre>
  *
  * <pre>
  * SPECIAL_IMPORTS group. This group may contains some imports
  * that have particular meaning for the user.
  * </pre>
  *
  * <p>
  * NOTE!
  * </p>
  * <p>
  * Use the separator '###' between rules.
  * </p>
  * <p>
- * To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
+ * To set Regexps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
  * thirdPartyPackageRegExp and standardPackageRegExp options.
  * </p>
  *
  * <pre>
  * Properties:
  * </pre>
  * <table summary="Properties" border="1">
  *     <tr><th>name</th><th>Description</th><th>type</th><th>default value</th></tr>
  *      <tr><td>customImportOrderRules</td><td>List of order declaration customizing by user.</td>
  *          <td>string</td><td>null</td></tr>
  *      <tr><td>standardPackageRegExp</td><td>RegExp for STANDARD_JAVA_PACKAGE group imports.</td>
  *          <td>regular expression</td><td>^(java|javax)\.</td></tr>
  *      <tr><td>thirdPartyPackageRegExp</td><td>RegExp for THIRDPARTY_PACKAGE group imports.</td>
  *          <td>regular expression</td><td>.*</td></tr>
  *      <tr><td>specialImportsRegExp</td><td>RegExp for SPECIAL_IMPORTS group imports.</td>
  *          <td>regular expression</td><td>^$</td></tr>
  *      <tr><td>samePackageMatchingDepth</td><td>Number of first domains for SAME_PACKAGE group.
  *          </td><td>Integer</td><td>2</td></tr>
  *      <tr><td>separateLineBetweenGroups</td><td>Force empty line separator between import groups.
  *          </td><td>boolean</td><td>true</td></tr>
  *      <tr><td>sortImportsInGroupAlphabetically</td><td>Force grouping alphabetically,
  *          in ASCII sort order.</td><td>boolean</td><td>false</td></tr>
  * </table>
  *
  * <pre>
  * For example:
  * </pre>
  *        <p>To configure the check so that it matches default Eclipse formatter configuration
  *        (tested on Kepler, Luna and Mars):</p>
  *        <ul>
  *          <li>group of static imports is on the top</li>
  *          <li>groups of non-static imports: &quot;java&quot; and &quot;javax&quot; packages
  *          first, then &quot;org&quot; and then all other imports</li>
  *          <li>imports will be sorted in the groups</li>
  *          <li>groups are separated by, at least, one blank line</li>
  *        </ul>
  * <pre>
  *        {@code
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *        value=&quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS&quot;/&gt;
  *    &lt;property name=&quot;specialImportsRegExp&quot; value=&quot;org&quot;/&gt;
  *    &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  *        }
  * </pre>
  *
  *        <p>To configure the check so that it matches default IntelliJ IDEA formatter
  *        configuration (tested on v14):</p>
  *        <ul>
  *          <li>group of static imports is on the bottom</li>
  *          <li>groups of non-static imports: all imports except of &quot;javax&quot;
  *          and &quot;java&quot;, then &quot;javax&quot; and &quot;java&quot;</li>
  *          <li>imports will be sorted in the groups</li>
  *          <li>groups are separated by, at least, one blank line</li>
  *        </ul>
  *
  *        <p>
  *        Note: &quot;separated&quot; option is disabled because IDEA default has blank line
  *        between &quot;java&quot; and static imports, and no blank line between
  *        &quot;javax&quot; and &quot;java&quot;
  *        </p>
  *
  * <pre>
  *        {@code
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *        value=&quot;THIRD_PARTY_PACKAGE###SPECIAL_IMPORTS###STANDARD_JAVA_PACKAGE
  *        ###STATIC&quot;/&gt;
  *    &lt;property name=&quot;specialImportsRegExp&quot; value=&quot;^javax\.&quot;/&gt;
  *    &lt;property name=&quot;standardPackageRegExp&quot; value=&quot;^java\.&quot;/&gt;
  *    &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;false&quot;/&gt;
  *&lt;/module&gt;
  *        }
  * </pre>
  *
  * <p>To configure the check so that it matches default NetBeans formatter
  *    configuration (tested on v8):</p>
  * <ul>
  *     <li>groups of non-static imports are not defined, all imports will be sorted as a one
  *         group</li>
  *     <li>static imports are not separated, they will be sorted along with other imports</li>
  * </ul>
  *
  *        {@code
  *&lt;module name=&quot;CustomImportOrder&quot;/&gt;
  *        }
- * <p>To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
+ * <p>To set Regexps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
  *         thirdPartyPackageRegExp and standardPackageRegExp options.</p>
  * <pre>
  * {@code
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *    value=&quot;STATIC###SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE&quot;/&gt;
  *    &lt;property name=&quot;thirdPartyPackageRegExp&quot; value=&quot;com|org&quot;/&gt;
  *    &lt;property name=&quot;standardPackageRegExp&quot; value=&quot;^(java|javax)\.&quot;/&gt;
  * &lt;/module&gt;
  * }
  * </pre>
  * <p>
  * Also, this check can be configured to force empty line separator between
  * import groups. For example
  * </p>
  *
  * <pre>
  * {@code
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * }
  * </pre>
  * <p>
  * It is possible to enforce
  * <a href="https://en.wikipedia.org/wiki/ASCII#Order">ASCII sort order</a>
  * of imports in groups using the following configuration:
  * </p>
  * <pre>
  * {@code &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * }
  * </pre>
  * <p>
  * Example of ASCII order:
  * </p>
  * <pre>
  * {@code import java.awt.Dialog;
  * import java.awt.Window;
  * import java.awt.color.ColorSpace;
  * import java.awt.Frame; // violation here - in ASCII order 'F' should go before 'c',
  *                        // as all uppercase come before lowercase letters}
  * </pre>
  * <p>
  * To force checking imports sequence such as:
  * </p>
  *
  * <pre>
  * {@code
@@ -356,101 +356,101 @@ public class CustomImportOrderCheck extends Check {
 
     /**
      * Sets thirdPartyRegExp specified by user.
      * @param regexp
      *        user value.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object.
      */
     public final void setThirdPartyPackageRegExp(String regexp) {
         thirdPartyPackageRegExp = CommonUtils.createPattern(regexp);
     }
 
     /**
      * Sets specialImportsRegExp specified by user.
      * @param regexp
      *        user value.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object.
      */
     public final void setSpecialImportsRegExp(String regexp) {
         specialImportsRegExp = CommonUtils.createPattern(regexp);
     }
 
     /**
      * Sets separateLineBetweenGroups specified by user.
      * @param value
      *        user value.
      */
     public final void setSeparateLineBetweenGroups(boolean value) {
         separateLineBetweenGroups = value;
     }
 
     /**
      * Sets sortImportsInGroupAlphabetically specified by user.
      * @param value
      *        user value.
      */
     public final void setSortImportsInGroupAlphabetically(boolean value) {
         sortImportsInGroupAlphabetically = value;
     }
 
     /**
      * Sets a custom import order from the rules in the string format specified
      * by user.
      * @param inputCustomImportOrder
      *        user value.
      */
     public final void setCustomImportOrderRules(final String inputCustomImportOrder) {
         customImportOrderRules.clear();
         for (String currentState : GROUP_SEPARATOR_PATTERN.split(inputCustomImportOrder)) {
-            addRuleastoList(currentState);
+            addRulesToList(currentState);
         }
         customImportOrderRules.add(NON_GROUP_RULE_GROUP);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.STATIC_IMPORT,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         importToGroupList.clear();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.PACKAGE_DEF) {
             if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
                 samePackageDomainsRegExp = createSamePackageRegexp(
                         samePackageMatchingDepth, ast);
             }
         }
         else {
             final String importFullPath = getFullImportIdent(ast);
             final int lineNo = ast.getLineNo();
             final boolean isStatic = ast.getType() == TokenTypes.STATIC_IMPORT;
             importToGroupList.add(new ImportDetails(importFullPath,
                     lineNo, getImportGroup(isStatic, importFullPath),
                     isStatic));
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
 
         if (importToGroupList.isEmpty()) {
@@ -543,244 +543,244 @@ public class CustomImportOrderCheck extends Check {
         return customImportOrderRules.get(nextGroupNumber);
     }
 
     /**
      * Checks if current group contains any import.
      * @param currentGroup
      *        current group.
      * @return
      *        true, if current group contains at least one import.
      */
     private boolean hasAnyImportInCurrentGroup(String currentGroup) {
         for (ImportDetails currentImport : importToGroupList) {
             if (currentGroup.equals(currentImport.getImportGroup())) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Get import valid group.
      * @param isStatic
      *        is static import.
      * @param importPath
      *        full import path.
      * @return import valid group.
      */
     private String getImportGroup(boolean isStatic, String importPath) {
         for (String group : customImportOrderRules) {
             if (matchesImportGroup(isStatic, importPath, group)) {
                 return group;
             }
         }
         return NON_GROUP_RULE_GROUP;
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param importPath
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if import placed in the correct group.
      */
     private boolean matchesImportGroup(boolean isStatic, String importPath, String currentGroup) {
         return matchesStaticImportGroup(isStatic, currentGroup)
                 || matchesSamePackageImportGroup(isStatic, importPath, currentGroup)
                 || matchesSpecialImportsGroup(isStatic, importPath, currentGroup)
-                || matchesStandartImportGroup(isStatic, importPath, currentGroup)
+                || matchesStandardImportGroup(isStatic, importPath, currentGroup)
                 || matchesThirdPartyImportGroup(isStatic, importPath, currentGroup);
     }
 
     /**
      * Checks if the import is placed in the STATIC group.
      * @param isStatic
      *        is static import.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the static group.
      */
     private static boolean matchesStaticImportGroup(boolean isStatic, String currentGroup) {
         return isStatic && STATIC_RULE_GROUP.equals(currentGroup);
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param importFullPath
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the same package group.
      */
     private boolean matchesSamePackageImportGroup(boolean isStatic,
         String importFullPath, String currentGroup) {
         final String importPathTrimmedToSamePackageDepth =
                 getFirstNDomainsFromIdent(samePackageMatchingDepth, importFullPath);
         return !isStatic && SAME_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth);
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the standard group.
      */
-    private boolean matchesStandartImportGroup(boolean isStatic,
+    private boolean matchesStandardImportGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && standardPackageRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the special group.
      */
     private boolean matchesSpecialImportsGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && SPECIAL_IMPORTS_RULE_GROUP.equals(currentGroup)
                 && specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the third party group.
      */
     private boolean matchesThirdPartyImportGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && THIRD_PARTY_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && thirdPartyPackageRegExp.matcher(currentImport).find()
                 && !standardPackageRegExp.matcher(currentImport).find()
                 && !specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks compare two import paths.
      * @param import1
      *        current import.
      * @param import2
      *        previous import.
      * @return a negative integer, zero, or a positive integer as the
      *        specified String is greater than, equal to, or less
      *        than this String, ignoring case considerations.
      */
     private static int compareImports(String import1, String import2) {
         int result = 0;
         final String separator = "\\.";
         final String[] import1Tokens = import1.split(separator);
         final String[] import2Tokens = import2.split(separator);
         for (int i = 0; i < import1Tokens.length && i != import2Tokens.length; i++) {
             final String import1Token = import1Tokens[i];
             final String import2Token = import2Tokens[i];
             result = import1Token.compareTo(import2Token);
             if (result != 0) {
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param lineNo
      *        Line number of current import.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(int lineNo) {
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         final String lineBefore = getLine(lineNo - 2);
         return lineBefore.trim().isEmpty();
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token) {
         if (token == null) {
             return "";
         }
         else {
             return FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
         }
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
-    private void addRuleastoList(String ruleStr) {
+    private void addRulesToList(String ruleStr) {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
             final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                     ruleStr.indexOf(')'));
             samePackageMatchingDepth = Integer.parseInt(rule);
             if (samePackageMatchingDepth <= 0) {
                 throw new IllegalArgumentException(
                         "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr);
             }
             customImportOrderRules.add(SAME_PACKAGE_RULE_GROUP);
 
         }
         else {
             throw new IllegalStateException("Unexpected rule: " + ruleStr);
         }
     }
 
     /**
      * Creates samePackageDomainsRegExp of the first package domains.
      * @param firstPackageDomainsCount
      *        number of first package domains.
      * @param packageNode
      *        package node.
      * @return same package regexp.
      */
     private static String createSamePackageRegexp(int firstPackageDomainsCount,
              DetailAST packageNode) {
         final String packageFullPath = getFullImportIdent(packageNode);
         return getFirstNDomainsFromIdent(firstPackageDomainsCount, packageFullPath);
     }
 
     /**
      * Extracts defined amount of domains from the left side of package/import identifier
      * @param firstPackageDomainsCount
      *        number of first package domains.
      * @param packageFullPath
      *        full identifier containing path to package or imported object.
      * @return String with defined amount of domains or full identifier
      *        (if full identifier had less domain then specified)
      */
     private static String getFirstNDomainsFromIdent(
             final int firstPackageDomainsCount, final String packageFullPath) {
         final StringBuilder builder = new StringBuilder();
