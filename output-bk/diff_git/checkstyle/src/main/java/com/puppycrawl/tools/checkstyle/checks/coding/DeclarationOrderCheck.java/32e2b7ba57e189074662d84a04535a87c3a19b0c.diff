diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 84c09a225..93c4fe778 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -116,119 +116,119 @@ public class DeclarationOrderCheck extends AbstractCheck {
      * file.
      */
     public static final String MSG_CONSTRUCTOR = "declaration.order.constructor";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_STATIC = "declaration.order.static";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_INSTANCE = "declaration.order.instance";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ACCESS = "declaration.order.access";
 
     /** State for the VARIABLE_DEF. */
     private static final int STATE_STATIC_VARIABLE_DEF = 1;
 
     /** State for the VARIABLE_DEF. */
     private static final int STATE_INSTANCE_VARIABLE_DEF = 2;
 
     /** State for the CTOR_DEF. */
     private static final int STATE_CTOR_DEF = 3;
 
     /** State for the METHOD_DEF. */
     private static final int STATE_METHOD_DEF = 4;
 
     /**
      * List of Declaration States. This is necessary due to
      * inner classes that have their own state.
      */
     private Deque<ScopeState> scopeStates;
 
     /** Set of all class field names.*/
     private Set<String> classFieldNames;
 
     /** If true, ignores the check to constructors. */
     private boolean ignoreConstructors;
     /** If true, ignore the check to modifiers (fields, ...). */
     private boolean ignoreModifiers;
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
+    @Override
+    public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
-    @Override
-    public int[] getRequiredTokens() {
-        return getAcceptableTokens();
-    }
-
     @Override
     public void beginTree(DetailAST rootAST) {
         scopeStates = new ArrayDeque<>();
         classFieldNames = new HashSet<>();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int parentType = ast.getParent().getType();
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
             case TokenTypes.MODIFIERS:
                 if (parentType == TokenTypes.VARIABLE_DEF
                     && ast.getParent().getParent().getType() == TokenTypes.OBJBLOCK) {
                     processModifiers(ast);
                 }
                 break;
             case TokenTypes.CTOR_DEF:
                 if (parentType == TokenTypes.OBJBLOCK) {
                     processConstructor(ast);
                 }
                 break;
             case TokenTypes.METHOD_DEF:
                 if (parentType == TokenTypes.OBJBLOCK) {
                     final ScopeState state = scopeStates.peek();
                     // nothing can be bigger than method's state
                     state.currentScopeState = STATE_METHOD_DEF;
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (ScopeUtils.isClassFieldDef(ast)) {
                     final DetailAST fieldDef = ast.findFirstToken(TokenTypes.IDENT);
                     classFieldNames.add(fieldDef.getText());
                 }
                 break;
             default:
                 break;
         }
     }
 
     /**
      * Processes constructor.
      * @param ast constructor AST.
      */
     private void processConstructor(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
