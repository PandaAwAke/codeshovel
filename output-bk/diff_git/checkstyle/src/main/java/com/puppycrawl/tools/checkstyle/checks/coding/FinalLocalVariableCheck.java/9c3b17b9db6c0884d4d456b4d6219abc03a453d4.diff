diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 93082d7ba..7fbce01dd 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -125,152 +125,184 @@ public class FinalLocalVariableCheck extends Check {
     }
 
     /**
      * Whether to check enhanced for-loop variable or not.
      * @param validateEnhancedForLoopVariable whether to check for-loop variable
      */
     public final void setValidateEnhancedForLoopVariable(boolean validateEnhancedForLoopVariable) {
         this.validateEnhancedForLoopVariable = validateEnhancedForLoopVariable;
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
-            case TokenTypes.SLIST:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.CTOR_DEF:
                 scopeStack.push(new ScopeData());
                 break;
-
+            case TokenTypes.SLIST:
+                if (ast.getParent().getType() != TokenTypes.CASE_GROUP
+                    || ast.getParent().getParent().findFirstToken(TokenTypes.CASE_GROUP)
+                    == ast.getParent()) {
+                    scopeStack.push(new ScopeData());
+                }
+                break;
             case TokenTypes.PARAMETER_DEF:
                 if (!isInLambda(ast)
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isInAbstractOrNativeMethod(ast)
                         && !ScopeUtils.isInInterfaceBlock(ast)) {
                     insertParameter(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (ast.getParent().getType() != TokenTypes.OBJBLOCK
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isVariableInForInit(ast)
                         && shouldCheckEnhancedForLoopVariable(ast)) {
                     insertVariable(ast);
                 }
                 break;
 
             case TokenTypes.IDENT:
                 final int parentType = ast.getParent().getType();
                 if (isAssignOperator(parentType)
                         && isFirstChild(ast)) {
                     removeVariable(ast);
                 }
                 break;
 
             default:
                 throw new IllegalStateException("Incorrect token type");
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
+        Map<String, DetailAST> scope = null;
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
-            case TokenTypes.SLIST:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
-                final Map<String, DetailAST> scope = scopeStack.pop().scope;
-                for (DetailAST node : scope.values()) {
-                    log(node.getLineNo(), node.getColumnNo(), MSG_KEY, node
-                        .getText());
+                scope = scopeStack.pop().scope;
+                break;
+            case TokenTypes.SLIST:
+                if (ast.getParent().getType() != TokenTypes.CASE_GROUP
+                    || findLastToken(ast.getParent().getParent(), TokenTypes.CASE_GROUP,
+                        TokenTypes.SLIST) == ast.getParent()) {
+                    scope = scopeStack.pop().scope;
                 }
                 break;
             default:
                 // do nothing
         }
+        if (scope != null) {
+            for (DetailAST node : scope.values()) {
+                log(node.getLineNo(), node.getColumnNo(), MSG_KEY, node.getText());
+            }
+        }
+    }
+
+    /**
+     * Returns the last child token that makes a specified type and contains containType in
+     * its branch.
+     * @param ast token to be tested
+     * @param childType the token type to match
+     * @param containType the token type which has to be present in the branch
+     * @return the matching token, or null if no match
+     */
+    public DetailAST findLastToken(DetailAST ast, int childType, int containType) {
+        DetailAST returnValue = null;
+        for (DetailAST astIterator = ast.getFirstChild(); astIterator != null;
+                astIterator = astIterator.getNextSibling()) {
+            if (astIterator.getType() == childType && astIterator.branchContains(containType)) {
+                returnValue = astIterator;
+            }
+        }
+        return returnValue;
     }
 
     /**
      * Determines whether enhanced for-loop variable should be checked or not.
      * @param ast The ast to compare.
      * @return true if enhanced for-loop variable should be checked.
      */
     private boolean shouldCheckEnhancedForLoopVariable(DetailAST ast) {
         return validateEnhancedForLoopVariable
                 || ast.getParent().getType() != TokenTypes.FOR_EACH_CLAUSE;
     }
 
     /**
      * Insert a parameter at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertParameter(DetailAST ast) {
         final Map<String, DetailAST> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
         scope.put(astNode.getText(), astNode);
     }
 
     /**
      * Insert a variable at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertVariable(DetailAST ast) {
         final Map<String, DetailAST> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
         scope.put(astNode.getText(), astNode);
         if (!isInitialized(astNode)) {
             scopeStack.peek().uninitializedVariables.add(astNode);
         }
     }
 
     /**
      * Check if VARIABLE_DEF is initialized or not.
      * @param ast VARIABLE_DEF to be checked
      * @return true if initialized
      */
     private static boolean isInitialized(DetailAST ast) {
         return ast.getParent().getLastChild().getType() == TokenTypes.ASSIGN;
     }
 
     /**
      * Whether the ast is the first child of its parent.
      * @param ast the ast to check.
      * @return true if the ast is the first child of its parent.
      */
     private static boolean isFirstChild(DetailAST ast) {
