diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index dd7c13b41..d83fe0636 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -596,101 +596,101 @@ public class CustomImportOrderCheck extends Check {
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param lineNo
      *        Line number of current import.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(int lineNo) {
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         final String lineBefore = getLine(lineNo - 2);
         return lineBefore.trim().isEmpty();
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token) {
         return token != null ? FullIdent.createFullIdent(token
                 .findFirstToken(TokenTypes.DOT)).getText() : "";
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRuleastoList(String ruleStr) {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
             final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                     ruleStr.indexOf(')'));
             try {
                 samePackageMatchingDepth = Integer.parseInt(rule);
             }
-            catch (Exception e) {
+            catch (NumberFormatException e) {
                 samePackageDomainsRegExp = rule;
             }
             customImportOrderRules.add(SAME_PACKAGE_RULE_GROUP);
 
         }
         else {
             throw new RuntimeException("Unexpected rule: " + ruleStr);
         }
     }
 
     /**
      * Creates samePackageDomainsRegExp of the first package domains.
      * @param firstPackageDomainsCount
      *        number of first package domains.
      * @param packageNode
      *        package node.
      * @return same package regexp.
      */
     private static String createSamePackageRegexp(int firstPackageDomainsCount,
              DetailAST packageNode) {
         final StringBuilder builder = new StringBuilder();
         final String packageFullPath = getFullImportIdent(packageNode);
         final StringTokenizer tokens = new StringTokenizer(packageFullPath, ".");
         int count = firstPackageDomainsCount;
 
         while (tokens.hasMoreTokens() && count > 0) {
             builder.append(tokens.nextToken()).append('.');
             count--;
         }
         return builder.append("*").toString();
     }
 
     /**
      * Contains import attributes as line number, import full path, import
      * group.
      * @author max
      */
     static class ImportDetails {
         /** Import full path */
         private String importFullPath;
 
         /** Import line number */
         private int lineNumber;
 
         /** Import group */
         private String importGroup;
 
         /** Is static import */
         private boolean staticImport;
 
