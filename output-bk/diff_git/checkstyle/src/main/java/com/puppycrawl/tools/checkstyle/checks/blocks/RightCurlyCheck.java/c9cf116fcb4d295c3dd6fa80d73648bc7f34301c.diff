diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index 36271e652..095e85f53 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -102,218 +102,249 @@ public class RightCurlyCheck extends AbstractOptionCheck<RightCurlyOption>
      * Sets the right curly option to same.
      */
     public RightCurlyCheck()
     {
         super(RightCurlyOption.SAME, RightCurlyOption.class);
     }
 
     /**
      * Does the check need to check if rcurly starts line.
      * @param flag new value of this property.
      */
     public void setShouldStartLine(boolean flag)
     {
         shouldStartLine = flag;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
         };
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast)
+    {
+        final Details details = getDetails(ast);
+        final DetailAST rcurly = details.rcurly;
+        final DetailAST lcurly = details.lcurly;
+        final DetailAST nextToken = details.nextToken;
+        final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;
+
+        if (rcurly == null || rcurly.getType() != TokenTypes.RCURLY) {
+            // we need to have both tokens to perform the check
+            return;
+        }
+
+        if (getAbstractOption() == RightCurlyOption.SAME && !hasLineBreakBefore(rcurly)) {
+            log(rcurly, MSG_KEY_LINE_BREAK_BEFORE);
+        }
+
+        if (shouldCheckLastRcurly) {
+            if (rcurly.getLineNo() == nextToken.getLineNo()) {
+                log(rcurly, MSG_KEY_LINE_ALONE, "}");
+            }
+        }
+        else if (getAbstractOption() == RightCurlyOption.SAME
+                && rcurly.getLineNo() != nextToken.getLineNo())
+        {
+            log(rcurly, MSG_KEY_LINE_SAME, "}");
+        }
+        else if (getAbstractOption() == RightCurlyOption.ALONE
+                && rcurly.getLineNo() == nextToken.getLineNo()
+                && !isEmptyBody(lcurly))
+        {
+            log(rcurly, MSG_KEY_LINE_ALONE, "}");
+        }
+
+        if (!shouldStartLine) {
+            return;
+        }
+        final boolean startsLine =
+                Utils.whitespaceBefore(rcurly.getColumnNo(),
+                        getLines()[rcurly.getLineNo() - 1]);
+
+        if (!startsLine && lcurly.getLineNo() != rcurly.getLineNo()) {
+            log(rcurly, MSG_KEY_LINE_NEW, "}");
+        }
+    }
+
+    /**
+     * Collect validation details
+     * @param ast detail ast.
+     * @return object that contain all details to make a validation.
+     */
+    private Details getDetails(DetailAST ast)
     {
         // Attempt to locate the tokens to do the check
-        DetailAST rcurly;
-        DetailAST lcurly;
-        DetailAST nextToken;
         boolean shouldCheckLastRcurly = false;
+        DetailAST rcurly = null;
+        DetailAST lcurly = null;
+        DetailAST nextToken = null;
 
         switch (ast.getType()) {
             case TokenTypes.LITERAL_TRY:
                 lcurly = ast.getFirstChild();
                 nextToken = lcurly.getNextSibling();
                 rcurly = lcurly.getLastChild();
                 break;
             case TokenTypes.LITERAL_CATCH:
                 nextToken = ast.getNextSibling();
                 lcurly = ast.getLastChild();
                 rcurly = lcurly.getLastChild();
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                 }
                 break;
             case TokenTypes.LITERAL_IF:
                 nextToken = ast.findFirstToken(TokenTypes.LITERAL_ELSE);
                 if (nextToken != null) {
                     lcurly = nextToken.getPreviousSibling();
                     rcurly = lcurly.getLastChild();
                 }
                 else {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                     lcurly = ast.getLastChild();
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             case TokenTypes.LITERAL_ELSE:
-                shouldCheckLastRcurly = true;
-                nextToken = getNextToken(ast);
-                lcurly = ast.getFirstChild();
-                rcurly = lcurly.getLastChild();
-                break;
             case TokenTypes.LITERAL_FINALLY:
                 shouldCheckLastRcurly = true;
                 nextToken = getNextToken(ast);
                 lcurly = ast.getFirstChild();
                 rcurly = lcurly.getLastChild();
                 break;
             case TokenTypes.CLASS_DEF:
                 final DetailAST child = ast.getLastChild();
                 lcurly = child.getFirstChild();
                 rcurly = child.getLastChild();
                 nextToken = ast;
                 break;
             case TokenTypes.CTOR_DEF:
             case TokenTypes.STATIC_INIT:
             case TokenTypes.INSTANCE_INIT:
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 rcurly = lcurly.getLastChild();
                 nextToken = ast;
                 break;
             case TokenTypes.METHOD_DEF:
             case TokenTypes.LITERAL_FOR:
             case TokenTypes.LITERAL_WHILE:
             case TokenTypes.LITERAL_DO:
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
-                //SLIST could be absent if method is abstract, and code like "while(true);"
-                if (lcurly == null) {
-                    return;
+                if (lcurly != null) {
+                    //SLIST could be absent if method is abstract, and code like "while(true);"
+                    rcurly = lcurly.getLastChild();
                 }
-                rcurly = lcurly.getLastChild();
                 nextToken = ast;
                 break;
             default:
                 throw new RuntimeException("Unexpected token type ("
-                    + TokenTypes.getTokenName(ast.getType()) + ")");
-        }
-
-        if (rcurly == null || rcurly.getType() != TokenTypes.RCURLY) {
-            // we need to have both tokens to perform the check
-            return;
-        }
-
-        if (getAbstractOption() == RightCurlyOption.SAME && !hasLineBreakBefore(rcurly)) {
-            log(rcurly, MSG_KEY_LINE_BREAK_BEFORE);
-        }
-
-        if (shouldCheckLastRcurly) {
-            if (rcurly.getLineNo() == nextToken.getLineNo()) {
-                log(rcurly, MSG_KEY_LINE_ALONE, "}");
-            }
-        }
-        else if (getAbstractOption() == RightCurlyOption.SAME
-                && rcurly.getLineNo() != nextToken.getLineNo())
-        {
-            log(rcurly, MSG_KEY_LINE_SAME, "}");
-        }
-        else if (getAbstractOption() == RightCurlyOption.ALONE
-                && rcurly.getLineNo() == nextToken.getLineNo()
-                && !isEmptyBody(lcurly))
-        {
-            log(rcurly, MSG_KEY_LINE_ALONE, "}");
+                        + TokenTypes.getTokenName(ast.getType()) + ")");
         }
 
-        if (!shouldStartLine) {
-            return;
-        }
-        final boolean startsLine =
-                Utils.whitespaceBefore(rcurly.getColumnNo(),
-                        getLines()[rcurly.getLineNo() - 1]);
+        final Details details = new Details();
+        details.rcurly = rcurly;
+        details.lcurly = lcurly;
+        details.nextToken = nextToken;
+        details.shouldCheckLastRcurly = shouldCheckLastRcurly;
 
-        if (!startsLine && lcurly.getLineNo() != rcurly.getLineNo()) {
-            log(rcurly, MSG_KEY_LINE_NEW, "}");
-        }
+        return details;
     }
 
     /**
      * Checks if definition body is empty.
      * @param lcurly left curly.
      * @return true if definition body is empty.
      */
     private boolean isEmptyBody(DetailAST lcurly)
     {
         boolean result = false;
         if (lcurly.getParent().getType() == TokenTypes.OBJBLOCK) {
             if (lcurly.getNextSibling().getType() == TokenTypes.RCURLY) {
                 result = true;
             }
         }
         else if (lcurly.getFirstChild().getType() == TokenTypes.RCURLY) {
             result = true;
         }
         return result;
     }
 
     /**
      * Finds next token after the given one.
      * @param ast the given node.
      * @return the token which represents next lexical item.
      */
     private DetailAST getNextToken(DetailAST ast)
     {
         DetailAST next = null;
         DetailAST parent = ast;
         while (parent != null && next == null) {
             next = parent.getNextSibling();
             parent = parent.getParent();
         }
         return CheckUtils.getFirstNode(next);
     }
 
     /**
      * Checks if right curly has line break before.
      * @param rightCurly
      *        Right curly token.
      * @return
      *        True, if right curly has line break before.
      */
     private boolean hasLineBreakBefore(DetailAST rightCurly)
     {
         if (rightCurly != null) {
             final DetailAST previousToken = rightCurly.getPreviousSibling();
             if (previousToken != null && rightCurly.getLineNo() == previousToken.getLineNo()) {
                 return false;
             }
         }
         return true;
     }
+
+    /**
+     * Structure that contains all details for validation
+     */
+    static class Details
+    {
+        /** right curly */
+        private DetailAST rcurly;
+        /** left curly */
+        private DetailAST lcurly;
+        /** next Token */
+        private DetailAST nextToken;
+        /** should Check Last Rcurly */
+        private boolean shouldCheckLastRcurly;
+    }
 }
