diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 03977238b..679d79a17 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -204,226 +204,226 @@ public class FinalLocalVariableCheck extends AbstractCheck {
             case TokenTypes.PARAMETER_DEF:
                 if (!isInLambda(ast)
                         && ast.findFirstToken(TokenTypes.MODIFIERS)
                             .findFirstToken(TokenTypes.FINAL) == null
                         && !isInAbstractOrNativeMethod(ast)
                         && !ScopeUtils.isInInterfaceBlock(ast)
                         && !isMultipleTypeCatch(ast)) {
                     insertParameter(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (ast.getParent().getType() != TokenTypes.OBJBLOCK
                         && ast.findFirstToken(TokenTypes.MODIFIERS)
                             .findFirstToken(TokenTypes.FINAL) == null
                         && !isVariableInForInit(ast)
                         && shouldCheckEnhancedForLoopVariable(ast)) {
                     insertVariable(ast);
                 }
                 break;
             case TokenTypes.IDENT:
                 final int parentType = ast.getParent().getType();
                 if (isAssignOperator(parentType) && isFirstChild(ast)) {
                     final Optional<FinalVariableCandidate> candidate = getFinalCandidate(ast);
                     if (candidate.isPresent()) {
                         determineAssignmentConditions(ast, candidate.get());
                         currentScopeAssignedVariables.peek().add(ast);
                     }
                     removeFinalVariableCandidateFromStack(ast);
                 }
                 break;
             case TokenTypes.LITERAL_BREAK:
                 scopeStack.peek().containsBreak = true;
                 break;
             default:
                 throw new IllegalStateException("Incorrect token type");
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         Map<String, FinalVariableCandidate> scope = null;
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 scope = scopeStack.pop().scope;
                 break;
             case TokenTypes.SLIST:
                 // -@cs[MoveVariableInsideIf] assignment value is modified later so it can't be
                 // moved
-                final Deque<DetailAST> prevScopeUnitializedVariableData =
+                final Deque<DetailAST> prevScopeUninitializedVariableData =
                     prevScopeUninitializedVariables.peek();
                 boolean containsBreak = false;
                 if (ast.getParent().getType() != TokenTypes.CASE_GROUP
                     || findLastChildWhichContainsSpecifiedToken(ast.getParent().getParent(),
                             TokenTypes.CASE_GROUP, TokenTypes.SLIST) == ast.getParent()) {
                     containsBreak = scopeStack.peek().containsBreak;
                     scope = scopeStack.pop().scope;
                     prevScopeUninitializedVariables.pop();
                 }
                 final DetailAST parent = ast.getParent();
                 if (containsBreak || shouldUpdateUninitializedVariables(parent)) {
-                    updateAllUninitializedVariables(prevScopeUnitializedVariableData);
+                    updateAllUninitializedVariables(prevScopeUninitializedVariableData);
                 }
                 updateCurrentScopeAssignedVariables();
                 break;
             default:
                 // do nothing
         }
         if (scope != null) {
             for (FinalVariableCandidate candidate : scope.values()) {
                 final DetailAST ident = candidate.variableIdent;
                 log(ident.getLineNo(), ident.getColumnNo(), MSG_KEY, ident.getText());
             }
         }
     }
 
     /**
      * Update assigned variables in a temporary stack.
      */
     private void updateCurrentScopeAssignedVariables() {
         // -@cs[MoveVariableInsideIf] assignment value is a modification call so it can't be moved
         final Deque<DetailAST> poppedScopeAssignedVariableData =
                 currentScopeAssignedVariables.pop();
         final Deque<DetailAST> currentScopeAssignedVariableData =
                 currentScopeAssignedVariables.peek();
         if (currentScopeAssignedVariableData != null) {
             currentScopeAssignedVariableData.addAll(poppedScopeAssignedVariableData);
         }
     }
 
     /**
      * Determines identifier assignment conditions (assigned or already assigned).
      * @param ident identifier.
      * @param candidate final local variable candidate.
      */
     private static void determineAssignmentConditions(DetailAST ident,
                                                       FinalVariableCandidate candidate) {
         if (candidate.assigned) {
             if (!isInSpecificCodeBlock(ident, TokenTypes.LITERAL_ELSE)
                     && !isInSpecificCodeBlock(ident, TokenTypes.CASE_GROUP)) {
                 candidate.alreadyAssigned = true;
             }
         }
         else {
             candidate.assigned = true;
         }
     }
 
     /**
      * Checks whether the scope of a node is restricted to a specific code block.
      * @param node node.
      * @param blockType block type.
      * @return true if the scope of a node is restricted to a specific code block.
      */
     private static boolean isInSpecificCodeBlock(DetailAST node, int blockType) {
         boolean returnValue = false;
         for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {
             final int type = token.getType();
             if (type == blockType) {
                 returnValue = true;
                 break;
             }
         }
         return returnValue;
     }
 
     /**
      * Gets final variable candidate for ast.
      * @param ast ast.
      * @return Optional of {@link FinalVariableCandidate} for ast from scopeStack.
      */
     private Optional<FinalVariableCandidate> getFinalCandidate(DetailAST ast) {
         Optional<FinalVariableCandidate> result = Optional.empty();
         final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
         while (iterator.hasNext() && !result.isPresent()) {
             final ScopeData scopeData = iterator.next();
             result = scopeData.findFinalVariableCandidateForAst(ast);
         }
         return result;
     }
 
     /**
      * Store un-initialized variables in a temporary stack for future use.
      */
     private void storePrevScopeUninitializedVariableData() {
         final ScopeData scopeData = scopeStack.peek();
-        final Deque<DetailAST> prevScopeUnitializedVariableData =
+        final Deque<DetailAST> prevScopeUninitializedVariableData =
                 new ArrayDeque<>();
-        scopeData.uninitializedVariables.forEach(prevScopeUnitializedVariableData::push);
-        prevScopeUninitializedVariables.push(prevScopeUnitializedVariableData);
+        scopeData.uninitializedVariables.forEach(prevScopeUninitializedVariableData::push);
+        prevScopeUninitializedVariables.push(prevScopeUninitializedVariableData);
     }
 
     /**
      * Update current scope data uninitialized variable according to the whole scope data.
-     * @param prevScopeUnitializedVariableData variable for previous stack of uninitialized
+     * @param prevScopeUninitializedVariableData variable for previous stack of uninitialized
      *     variables
+     * @noinspection MethodParameterNamingConvention
      */
-    // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation.
     private void updateAllUninitializedVariables(
-            Deque<DetailAST> prevScopeUnitializedVariableData) {
+            Deque<DetailAST> prevScopeUninitializedVariableData) {
         // Check for only previous scope
-        updateUninitializedVariables(prevScopeUnitializedVariableData);
+        updateUninitializedVariables(prevScopeUninitializedVariableData);
         // Check for rest of the scope
         prevScopeUninitializedVariables.forEach(this::updateUninitializedVariables);
     }
 
     /**
      * Update current scope data uninitialized variable according to the specific scope data.
-     * @param scopeUnitializedVariableData variable for specific stack of uninitialized variables
+     * @param scopeUninitializedVariableData variable for specific stack of uninitialized variables
      */
-    private void updateUninitializedVariables(Deque<DetailAST> scopeUnitializedVariableData) {
+    private void updateUninitializedVariables(Deque<DetailAST> scopeUninitializedVariableData) {
         final Iterator<DetailAST> iterator = currentScopeAssignedVariables.peek().iterator();
         while (iterator.hasNext()) {
             final DetailAST assignedVariable = iterator.next();
-            for (DetailAST variable : scopeUnitializedVariableData) {
+            for (DetailAST variable : scopeUninitializedVariableData) {
                 for (ScopeData scopeData : scopeStack) {
                     final FinalVariableCandidate candidate =
                         scopeData.scope.get(variable.getText());
                     DetailAST storedVariable = null;
                     if (candidate != null) {
                         storedVariable = candidate.variableIdent;
                     }
                     if (storedVariable != null
                             && isSameVariables(storedVariable, variable)
                             && isSameVariables(assignedVariable, variable)) {
                         scopeData.uninitializedVariables.push(variable);
                         iterator.remove();
                     }
                 }
             }
         }
     }
 
     /**
      * If token is LITERAL_IF and there is an {@code else} following or token is CASE_GROUP and
      * there is another {@code case} following, then update the uninitialized variables.
      * @param ast token to be checked
      * @return true if should be updated, else false
      */
     private static boolean shouldUpdateUninitializedVariables(DetailAST ast) {
         return isIfTokenWithAnElseFollowing(ast) || isCaseTokenWithAnotherCaseFollowing(ast);
     }
 
     /**
      * If token is LITERAL_IF and there is an {@code else} following.
      * @param ast token to be checked
      * @return true if token is LITERAL_IF and there is an {@code else} following, else false
      */
     private static boolean isIfTokenWithAnElseFollowing(DetailAST ast) {
         return ast.getType() == TokenTypes.LITERAL_IF
                 && ast.getLastChild().getType() == TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * If token is CASE_GROUP and there is another {@code case} following.
      * @param ast token to be checked
      * @return true if token is CASE_GROUP and there is another {@code case} following, else false
      */
     private static boolean isCaseTokenWithAnotherCaseFollowing(DetailAST ast) {
         return ast.getType() == TokenTypes.CASE_GROUP
                 && findLastChildWhichContainsSpecifiedToken(
                         ast.getParent(), TokenTypes.CASE_GROUP, TokenTypes.SLIST) != ast;
     }
 
     /**
