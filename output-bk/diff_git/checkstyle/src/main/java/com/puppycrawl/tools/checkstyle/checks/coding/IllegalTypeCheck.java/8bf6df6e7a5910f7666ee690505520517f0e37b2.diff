diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index bb9f6598a..d702d4ac7 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -138,101 +138,101 @@ public final class IllegalTypeCheck extends Check {
     /** The regexp to match against. */
     private Pattern regexp = Pattern.compile(format);
 
     /**
      * Controls whether to validate abstract class names.
      */
     private boolean validateAbstractClassNames;
 
     /** Creates new instance of the check. */
     public IllegalTypeCheck() {
         setIllegalClassNames(DEFAULT_ILLEGAL_TYPES);
         setLegalAbstractClassNames(DEFAULT_LEGAL_ABSTRACT_NAMES);
         setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);
     }
 
     /**
      * Set the format to the specified regular expression.
      * @param format a {@code String} value
      * @throws org.apache.commons.beanutils.ConversionException unable to parse format
      */
     public void setFormat(String format) {
         this.format = format;
         regexp = CommonUtils.createPattern(format);
     }
 
     /**
      * Sets whether to validate abstract class names.
      * @param validateAbstractClassNames whether abstract class names must be ignored.
      */
     public void setValidateAbstractClassNames(boolean validateAbstractClassNames) {
         this.validateAbstractClassNames = validateAbstractClassNames;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getAcceptableTokens();
+        return new int[] {TokenTypes.IMPORT};
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_DEF:
                 if (isVerifiable(ast)) {
                     visitMethodDef(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (isVerifiable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 visitParameterDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Checks if current method's return type or variable's type is verifiable
      * according to <b>memberModifiers</b> option.
      * @param methodOrVariableDef METHOD_DEF or VARIABLE_DEF ast node.
      * @return true if member is verifiable according to <b>memberModifiers</b> option.
      */
     private boolean isVerifiable(DetailAST methodOrVariableDef) {
         boolean result = true;
         if (memberModifiers != null) {
             final DetailAST modifiersAst = methodOrVariableDef
                     .findFirstToken(TokenTypes.MODIFIERS);
             result = isContainVerifiableType(modifiersAst);
         }
         return result;
     }
 
     /**
      * Checks is modifiers contain verifiable type.
      *
      * @param modifiers
      *            parent node for all modifiers
      * @return true if method or variable can be verified
      */
     private boolean isContainVerifiableType(DetailAST modifiers) {
