diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java
index 7e7510b69..0f2efcdaf 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java
@@ -328,82 +328,82 @@ public final class ModifiedControlVariableCheck extends AbstractCheck {
             getCurrentVariables().pop();
         }
         else {
             final Set<String> variablesManagedByForLoop = getVariablesManagedByForLoop(ast);
             popCurrentVariables(variablesManagedByForLoop.size());
         }
     }
 
     /**
      * Pops given number of variables from currentVariables.
      * @param count Count of variables to be popped from currentVariables
      */
     private void popCurrentVariables(int count) {
         for (int i = 0; i < count; i++) {
             getCurrentVariables().pop();
         }
     }
 
     /**
      * Get all variables initialized In init part of for loop.
      * @param ast for loop token
      * @return set of variables initialized in for loop
      */
     private static Set<String> getForInitVariables(DetailAST ast) {
         final Set<String> initializedVariables = new HashSet<>();
         final DetailAST forInitAST = ast.findFirstToken(TokenTypes.FOR_INIT);
 
         for (DetailAST parameterDefAST = forInitAST.findFirstToken(TokenTypes.VARIABLE_DEF);
              parameterDefAST != null;
              parameterDefAST = parameterDefAST.getNextSibling()) {
             if (parameterDefAST.getType() == TokenTypes.VARIABLE_DEF) {
                 final DetailAST param =
                         parameterDefAST.findFirstToken(TokenTypes.IDENT);
 
                 initializedVariables.add(param.getText());
             }
         }
         return initializedVariables;
     }
 
     /**
      * Get all variables which for loop iterating part change in every loop.
      * @param ast for loop literal(TokenTypes.LITERAL_FOR)
      * @return names of variables change in iterating part of for
      */
     private static Set<String> getForIteratorVariables(DetailAST ast) {
         final Set<String> iteratorVariables = new HashSet<>();
         final DetailAST forIteratorAST = ast.findFirstToken(TokenTypes.FOR_ITERATOR);
         final DetailAST forUpdateListAST = forIteratorAST.findFirstToken(TokenTypes.ELIST);
 
-        for (DetailAST iteratingExpressionAST : findChildrenOfExpressionType(forUpdateListAST)) {
-
-            if (MUTATION_OPERATIONS.contains(iteratingExpressionAST.getType())) {
+        findChildrenOfExpressionType(forUpdateListAST).stream()
+            .filter(iteratingExpressionAST ->
+                MUTATION_OPERATIONS.contains(iteratingExpressionAST.getType()))
+            .forEach(iteratingExpressionAST -> {
                 final DetailAST oneVariableOperatorChild = iteratingExpressionAST.getFirstChild();
                 if (oneVariableOperatorChild.getType() == TokenTypes.IDENT) {
                     iteratorVariables.add(oneVariableOperatorChild.getText());
                 }
-            }
-        }
+            });
 
         return iteratorVariables;
     }
 
     /**
      * Find all child of given AST of type TokenType.EXPR
      * @param ast parent of expressions to find
      * @return all child of given ast
      */
     private static List<DetailAST> findChildrenOfExpressionType(DetailAST ast) {
         final List<DetailAST> foundExpressions = new LinkedList<>();
         if (ast != null) {
             for (DetailAST iteratingExpressionAST = ast.findFirstToken(TokenTypes.EXPR);
                  iteratingExpressionAST != null;
                  iteratingExpressionAST = iteratingExpressionAST.getNextSibling()) {
                 if (iteratingExpressionAST.getType() == TokenTypes.EXPR) {
                     foundExpressions.add(iteratingExpressionAST.getFirstChild());
                 }
             }
         }
         return foundExpressions;
     }
 }
