diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index a59cc0953..5038d1605 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -81,100 +81,106 @@ public class VisibilityModifierCheck
      */
     public void setProtectedAllowed(boolean protectedAllowed)
     {
         this.protectedAllowed = protectedAllowed;
     }
 
     /** @return whether package visible members are allowed */
     public boolean isPackageAllowed()
     {
         return packageAllowed;
     }
 
     /**
      * Set whether package visible members are allowed.
      * @param packageAllowed whether package visible members are allowed
      */
     public void setPackageAllowed(boolean packageAllowed)
     {
         this.packageAllowed = packageAllowed;
     }
 
     /**
      * Set the pattern for public members to ignore.
      * @param pattern pattern for public members to ignore.
      */
     public void setPublicMemberPattern(String pattern)
     {
         try {
             publicMemberPattern = Utils.getPattern(pattern);
             publicMemberFormat = pattern;
         }
         catch (final PatternSyntaxException e) {
             throw new ConversionException("unable to parse " + pattern, e);
         }
     }
 
     /**
      * @return the regexp for public members to ignore.
      */
     private Pattern getPublicMemberRegexp()
     {
         return publicMemberPattern;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {TokenTypes.VARIABLE_DEF, TokenTypes.OBJBLOCK};
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         if ((ast.getType() != TokenTypes.VARIABLE_DEF)
             || (ast.getParent().getType() != TokenTypes.OBJBLOCK))
         {
             return;
         }
 
         final DetailAST varNameAST = getVarNameAST(ast);
         final String varName = varNameAST.getText();
         final boolean inInterfaceOrAnnotationBlock =
             ScopeUtils.inInterfaceOrAnnotationBlock(ast);
         final Set<String> mods = getModifiers(ast);
         final String declaredScope = getVisibilityScope(mods);
         final String variableScope =
              inInterfaceOrAnnotationBlock ? "public" : declaredScope;
 
         if (!("private".equals(variableScope)
                 || inInterfaceOrAnnotationBlock // implicitly static and final
                 || (mods.contains("static") && mods.contains("final"))
                 || ("package".equals(variableScope) && isPackageAllowed())
                 || ("protected".equals(variableScope) && isProtectedAllowed())
                 || ("public".equals(variableScope)
                    && getPublicMemberRegexp().matcher(varName).find())))
         {
             log(varNameAST.getLineNo(), varNameAST.getColumnNo(),
                     "variable.notPrivate", varName);
         }
     }
 
     /**
      * Returns the variable name in a VARIABLE_DEF AST.
      * @param variableDefAST an AST where type == VARIABLE_DEF AST.
      * @return the variable name in variableDefAST
      */
     private DetailAST getVarNameAST(DetailAST variableDefAST)
     {
         DetailAST ast = variableDefAST.getFirstChild();
         while (ast != null) {
             final DetailAST nextSibling = ast.getNextSibling();
             if (ast.getType() == TokenTypes.TYPE) {
                 return nextSibling;
             }
             ast = nextSibling;
         }
         return null;
     }
 
     /**
