diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
index 978765658..c0c720c83 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
@@ -85,101 +85,100 @@ public abstract class AbstractClassCouplingCheck extends AbstractCheck {
     /** User-configured package names to ignore. */
     private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;
     /** Allowed complexity. */
     private int max;
 
     /** Current file context. */
     private FileContext fileContext;
 
     /**
      * Creates new instance of the check.
      * @param defaultMax default value for allowed complexity.
      */
     protected AbstractClassCouplingCheck(int defaultMax) {
         max = defaultMax;
         excludeClassesRegexps.add(CommonUtils.createPattern("^$"));
     }
 
     /**
      * Returns message key we use for log violations.
      * @return message key we use for log violations.
      */
     protected abstract String getLogMessageId();
 
     @Override
     public final int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     /**
      * Sets maximum allowed complexity.
      * @param max allowed complexity.
      */
     public final void setMax(int max) {
         this.max = max;
     }
 
     /**
      * Sets user-excluded classes to ignore.
      * @param excludedClasses the list of classes to ignore.
      */
     public final void setExcludedClasses(String... excludedClasses) {
         this.excludedClasses =
             Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));
     }
 
     /**
      * Sets user-excluded regular expression of classes to ignore.
      * @param from array representing regular expressions of classes to ignore.
      */
     public void setExcludeClassesRegexps(String... from) {
-        excludeClassesRegexps.clear();
         excludeClassesRegexps.addAll(Arrays.stream(from.clone())
                 .map(CommonUtils::createPattern)
                 .collect(Collectors.toSet()));
     }
 
     /**
      * Sets user-excluded pakcages to ignore. All exlcuded packages should end with a period,
      * so it also appends a dot to a package name.
      * @param excludedPackages the list of packages to ignore.
      */
     public final void setExcludedPackages(String... excludedPackages) {
         final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)
             .filter(x -> !CommonUtils.isName(x))
             .collect(Collectors.toList());
         if (!invalidIdentifiers.isEmpty()) {
             throw new IllegalArgumentException(
                 "the following values are not valid identifiers: "
                     + invalidIdentifiers.stream().collect(Collectors.joining(", ", "[", "]")));
         }
 
         this.excludedPackages = Collections.unmodifiableSet(
             Arrays.stream(excludedPackages).collect(Collectors.toSet()));
     }
 
     @Override
     public final void beginTree(DetailAST ast) {
         fileContext = new FileContext();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.PACKAGE_DEF:
                 visitPackageDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 fileContext.registerImport(ast);
                 break;
             case TokenTypes.CLASS_DEF:
             case TokenTypes.INTERFACE_DEF:
             case TokenTypes.ANNOTATION_DEF:
             case TokenTypes.ENUM_DEF:
                 visitClassDef(ast);
                 break;
             case TokenTypes.TYPE:
                 fileContext.visitType(ast);
                 break;
             case TokenTypes.LITERAL_NEW:
                 fileContext.visitLiteralNew(ast);
                 break;
