diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
index 85e821410..9ed2229a0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
@@ -147,122 +147,132 @@ public class SuppressWithNearbyCommentFilter
     /**
      * Set the FileContents for this filter.
      * @param fileContents the FileContents for this filter.
      */
     public void setFileContents(FileContents fileContents) {
         fileContentsReference = new WeakReference<>(fileContents);
     }
 
     /**
      * Set the format for a check.
      * @param format a {@code String} value
      */
     public final void setCheckFormat(String format) {
         checkFormat = format;
     }
 
     /**
      * Set the format for a message.
      * @param format a {@code String} value
      */
     public void setMessageFormat(String format) {
         messageFormat = format;
     }
 
     /**
      * Set the format for the influence of this check.
      * @param format a {@code String} value
      */
     public final void setInfluenceFormat(String format) {
         influenceFormat = format;
     }
 
     /**
      * Set whether to look in C++ comments.
      * @param checkCPP {@code true} if C++ comments are checked.
      */
     public void setCheckCPP(boolean checkCPP) {
         this.checkCPP = checkCPP;
     }
 
     /**
      * Set whether to look in C comments.
      * @param checkC {@code true} if C comments are checked.
      */
     public void setCheckC(boolean checkC) {
         this.checkC = checkC;
     }
 
     @Override
     public boolean accept(AuditEvent event) {
-        if (event.getLocalizedMessage() == null) {
-            // A special event
-            return true;
-        }
+        boolean accepted = true;
 
-        // Lazy update. If the first event for the current file, update file
-        // contents and tag suppressions
-        final FileContents currentContents = FileContentsHolder.getContents();
-        if (currentContents == null) {
-            // we have no contents, so we can not filter.
-            return true;
-        }
-        if (getFileContents() != currentContents) {
-            setFileContents(currentContents);
-            tagSuppressions();
+        if (event.getLocalizedMessage() != null) {
+            // Lazy update. If the first event for the current file, update file
+            // contents and tag suppressions
+            final FileContents currentContents = FileContentsHolder.getContents();
+
+            if (currentContents != null) {
+                if (getFileContents() != currentContents) {
+                    setFileContents(currentContents);
+                    tagSuppressions();
+                }
+                if (matchTag(event)) {
+                    accepted = false;
+                }
+            }
         }
+        return accepted;
+    }
+
+    /**
+     * Whether current event matches any tag from {@link #tags}.
+     * @param event AuditEvent to test match on {@link #tags}.
+     * @return true if event matches any tag from {@link #tags}, false otherwise.
+     */
+    private boolean matchTag(AuditEvent event) {
         for (final Tag tag : tags) {
             if (tag.isMatch(event)) {
-                return false;
+                return true;
             }
         }
-        return true;
+        return false;
     }
 
     /**
      * Collects all the suppression tags for all comments into a list and
      * sorts the list.
      */
     private void tagSuppressions() {
         tags.clear();
         final FileContents contents = getFileContents();
         if (checkCPP) {
             tagSuppressions(contents.getCppComments().values());
         }
         if (checkC) {
             final Collection<List<TextBlock>> cComments =
                 contents.getCComments().values();
             for (final List<TextBlock> element : cComments) {
                 tagSuppressions(element);
             }
         }
         Collections.sort(tags);
     }
 
     /**
      * Appends the suppressions in a collection of comments to the full
      * set of suppression tags.
      * @param comments the set of comments.
      */
     private void tagSuppressions(Collection<TextBlock> comments) {
         for (final TextBlock comment : comments) {
             final int startLineNo = comment.getStartLineNo();
             final String[] text = comment.getText();
             tagCommentLine(text[0], startLineNo);
             for (int i = 1; i < text.length; i++) {
                 tagCommentLine(text[i], startLineNo + i);
             }
         }
     }
 
     /**
      * Tags a string if it matches the format for turning
      * checkstyle reporting on or the format for turning reporting off.
      * @param text the string to tag.
      * @param line the line number of text.
      */
     private void tagCommentLine(String text, int line) {
         final Matcher matcher = commentRegexp.matcher(text);
         if (matcher.find()) {
             addTag(matcher.group(0), line);
         }
     }
@@ -350,100 +360,97 @@ public class SuppressWithNearbyCommentFilter
                     e);
             }
         }
 
         /**
          * Compares the position of this tag in the file
          * with the position of another tag.
          * @param other the tag to compare with this one.
          * @return a negative number if this tag is before the other tag,
          * 0 if they are at the same position, and a positive number if this
          * tag is after the other tag.
          */
         @Override
         public int compareTo(Tag other) {
             if (firstLine == other.firstLine) {
                 return Integer.compare(lastLine, other.lastLine);
             }
 
             return Integer.compare(firstLine, other.firstLine);
         }
 
         @Override
         public boolean equals(Object o) {
             if (this == o) {
                 return true;
             }
             if (o == null || getClass() != o.getClass()) {
                 return false;
             }
             final Tag tag = (Tag) o;
             return Objects.equals(firstLine, tag.firstLine)
                     && Objects.equals(lastLine, tag.lastLine)
                     && Objects.equals(text, tag.text)
                     && Objects.equals(tagCheckRegexp, tag.tagCheckRegexp)
                     && Objects.equals(tagMessageRegexp, tag.tagMessageRegexp);
         }
 
         @Override
         public int hashCode() {
             return Objects.hash(text, firstLine, lastLine, tagCheckRegexp, tagMessageRegexp);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param event the {@code AuditEvent} to check.
          * @return true if the source of event matches the text of this tag.
          */
         public boolean isMatch(AuditEvent event) {
             final int line = event.getLine();
-            if (line < firstLine) {
-                return false;
-            }
-            if (line > lastLine) {
-                return false;
-            }
-            final Matcher tagMatcher =
-                tagCheckRegexp.matcher(event.getSourceName());
-            if (tagMatcher.find()) {
-                return true;
-            }
-            if (tagMessageRegexp != null) {
-                final Matcher messageMatcher =
-                    tagMessageRegexp.matcher(event.getMessage());
-                return messageMatcher.find();
+            boolean match = false;
+
+            if (line >= firstLine && line <= lastLine) {
+                final Matcher tagMatcher = tagCheckRegexp.matcher(event.getSourceName());
+
+                if (tagMatcher.find()) {
+                    match = true;
+                }
+                else if (tagMessageRegexp != null) {
+                    final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
+                    match = messageMatcher.find();
+                }
             }
-            return false;
+            return match;
         }
 
         /**
          * Expand based on a matching comment.
          * @param comment the comment.
          * @param stringToExpand the string to expand.
          * @param regexp the parsed expander.
          * @return the expanded string
          */
         private static String expandFromComment(
             String comment,
             String stringToExpand,
             Pattern regexp) {
             final Matcher matcher = regexp.matcher(comment);
             // Match primarily for effect.
             if (!matcher.find()) {
                 return stringToExpand;
             }
             String result = stringToExpand;
             for (int i = 0; i <= matcher.groupCount(); i++) {
                 // $n expands comment match like in Pattern.subst().
                 result = result.replaceAll("\\$" + i, matcher.group(i));
             }
             return result;
         }
 
         @Override
         public final String toString() {
             return "Tag[lines=[" + firstLine + " to " + lastLine
                 + "]; text='" + text + "']";
         }
     }
 }
