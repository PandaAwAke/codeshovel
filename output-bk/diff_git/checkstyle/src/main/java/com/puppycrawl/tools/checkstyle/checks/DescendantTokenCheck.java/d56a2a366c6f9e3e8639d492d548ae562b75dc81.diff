diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
index b97076092..73b539df0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
@@ -173,100 +173,105 @@ public class DescendantTokenCheck extends Check {
      * file.
      */
     public static final String MSG_KEY_MIN = "descendant.token.min";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_MAX = "descendant.token.max";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_SUM_MIN = "descendant.token.sum.min";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_SUM_MAX = "descendant.token.sum.max";
 
     /** minimum depth */
     private int minimumDepth;
     /** maximum depth */
     private int maximumDepth = Integer.MAX_VALUE;
     /** minimum number */
     private int minimumNumber;
     /** maximum number */
     private int maximumNumber = Integer.MAX_VALUE;
     /** Whether to sum the number of tokens found. */
     private boolean sumTokenCounts;
     /** limited tokens */
     private int[] limitedTokens = ArrayUtils.EMPTY_INT_ARRAY;
     /** error message when minimum count not reached */
     private String minimumMessage;
     /** error message when maximum count exceeded */
     private String maximumMessage;
 
     /**
      * Counts of descendant tokens.
      * Indexed by (token ID - 1) for performance.
      */
     private int[] counts = ArrayUtils.EMPTY_INT_ARRAY;
 
     @Override
     public int[] getDefaultTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
+    @Override
+    public int[] getRequiredTokens() {
+        return ArrayUtils.EMPTY_INT_ARRAY;
+    }
+
     @Override
     public void visitToken(DetailAST ast) {
         //reset counts
         Arrays.fill(counts, 0);
         countTokens(ast, 0);
 
         if (sumTokenCounts) {
             logAsTotal(ast);
         }
         else {
             logAsSeparated(ast);
         }
     }
 
     /**
      * log violations for each Token
      * @param ast token
      */
     private void logAsSeparated(DetailAST ast) {
         // name of this token
         final String name = Utils.getTokenName(ast.getType());
 
         for (int element : limitedTokens) {
             final int tokenCount = counts[element - 1];
             if (tokenCount < minimumNumber) {
                 final String descendantName = Utils
                         .getTokenName(element);
                 log(ast.getLineNo(), ast.getColumnNo(),
                     minimumMessage == null ? MSG_KEY_MIN
                                 : minimumMessage,
                         String.valueOf(tokenCount),
                         String.valueOf(minimumNumber),
                         name,
                         descendantName);
             }
             if (tokenCount > maximumNumber) {
                 final String descendantName = Utils
                         .getTokenName(element);
                 log(ast.getLineNo(), ast.getColumnNo(),
                     maximumMessage == null ? MSG_KEY_MAX
                                 : maximumMessage,
                         String.valueOf(tokenCount),
                         String.valueOf(maximumNumber),
                         name,
                         descendantName);
             }
         }
     }
 
     /**
