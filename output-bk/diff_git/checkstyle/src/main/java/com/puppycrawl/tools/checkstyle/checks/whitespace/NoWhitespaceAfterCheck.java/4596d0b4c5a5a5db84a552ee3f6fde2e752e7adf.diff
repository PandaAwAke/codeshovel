diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
index df1c64280..0c122c5a0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
@@ -18,154 +18,161 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.whitespace;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * <p>
  * Checks that there is no whitespace after a token.
  * More specifically, it checks that it is not followed by whitespace,
  * or (if linebreaks are allowed) all characters on the line after are
  * whitespace. To forbid linebreaks afer a token, set property
  * allowLineBreaks to false.
  * </p>
   * <p> By default the check will check the following operators:
  *  {@link TokenTypes#ARRAY_INIT ARRAY_INIT},
  *  {@link TokenTypes#BNOT BNOT},
  *  {@link TokenTypes#DEC DEC},
  *  {@link TokenTypes#DOT DOT},
  *  {@link TokenTypes#INC INC},
  *  {@link TokenTypes#LNOT LNOT},
  *  {@link TokenTypes#UNARY_MINUS UNARY_MINUS},
  *  {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR},
  *  {@link TokenTypes#UNARY_PLUS UNARY_PLUS}. It also supports the operator
  *  {@link TokenTypes#TYPECAST TYPECAST}.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="NoWhitespaceAfter"/&gt;
  * </pre>
  * <p> An example of how to configure the check to forbid linebreaks after
  * a {@link TokenTypes#DOT DOT} token is:
  * </p>
  * <pre>
  * &lt;module name="NoWhitespaceAfter"&gt;
  *     &lt;property name="tokens" value="DOT"/&gt;
  *     &lt;property name="allowLineBreaks" value="false"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Rick Giles
  * @author lkuehne
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  * @version 1.0
  */
 public class NoWhitespaceAfterCheck extends Check
 {
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY = "ws.followed";
+
     /** Whether whitespace is allowed if the AST is at a linebreak */
     private boolean allowLineBreaks = true;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.ARRAY_INIT,
             TokenTypes.INC,
             TokenTypes.DEC,
             TokenTypes.UNARY_MINUS,
             TokenTypes.UNARY_PLUS,
             TokenTypes.BNOT,
             TokenTypes.LNOT,
             TokenTypes.DOT,
             TokenTypes.ARRAY_DECLARATOR,
         };
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.ARRAY_INIT,
             TokenTypes.INC,
             TokenTypes.DEC,
             TokenTypes.UNARY_MINUS,
             TokenTypes.UNARY_PLUS,
             TokenTypes.BNOT,
             TokenTypes.LNOT,
             TokenTypes.DOT,
             TokenTypes.TYPECAST,
             TokenTypes.ARRAY_DECLARATOR,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         DetailAST astNode = ast;
         if (ast.getType() == TokenTypes.ARRAY_DECLARATOR
                  || ast.getType() == TokenTypes.TYPECAST)
         {
             astNode = getPreceded(ast);
         }
 
         final String line = getLine(ast.getLineNo() - 1);
         final int after = getPositionAfter(astNode);
 
         if ((after >= line.length() || Character.isWhitespace(line.charAt(after)))
                  && hasRedundantWhitespace(line, after))
         {
             log(astNode.getLineNo(), after,
-                "ws.followed", astNode.getText());
+                MSG_KEY, astNode.getText());
         }
     }
 
     /**
      * Gets possible place where redundant whitespace could be.
      * @param arrayOrTypeCast {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR}
      *  or {@link TokenTypes#TYPECAST TYPECAST}.
      * @return possible place of redundant whitespace.
      */
     private static DetailAST getPreceded(DetailAST arrayOrTypeCast)
     {
         DetailAST preceded = arrayOrTypeCast;
         switch (arrayOrTypeCast.getType()) {
             case TokenTypes.TYPECAST:
                 preceded = arrayOrTypeCast.findFirstToken(TokenTypes.RPAREN);
                 break;
             case TokenTypes.ARRAY_DECLARATOR:
                 preceded = getArrayTypeOrIdentifier(arrayOrTypeCast);
                 break;
             default:
                 throw new IllegalStateException(arrayOrTypeCast.toString());
         }
         return preceded;
     }
 
     /**
      * Gets position after token (place of possible redundant whitespace).
      * @param ast Node representing token.
      * @return position after token.
      */
     private static int getPositionAfter(DetailAST ast)
     {
         int after;
         //If target of possible redundant whitespace is in method definition
         if (ast.getType() == TokenTypes.IDENT
                 && ast.getNextSibling() != null
                 && ast.getNextSibling().getType() == TokenTypes.LPAREN)
         {
             final DetailAST methodDef = ast.getParent();
             final DetailAST endOfParams = methodDef.findFirstToken(TokenTypes.RPAREN);
             after = endOfParams.getColumnNo() + 1;
         }
         else {
             after = ast.getColumnNo() + ast.getText().length();
         }
         return after;
     }
 
     /**
      * Gets target place of possible redundant whitespace (array's type or identifier)
