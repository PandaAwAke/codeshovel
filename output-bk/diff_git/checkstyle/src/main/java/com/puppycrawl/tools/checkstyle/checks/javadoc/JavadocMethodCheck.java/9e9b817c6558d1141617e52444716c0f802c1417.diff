diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index a3fc7e20a..1a4b9be90 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -617,106 +617,107 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
         return col;
     }
 
     /**
      * Gets multiline Javadoc tags with arguments.
      * @param argMultilineStart javadoc tag Matcher
      * @param column column number of Javadoc tag
      * @param lines comment text lines
      * @param lineIndex line number that contains the javadoc tag
      * @param tagLine javadoc tag line number in file
      * @return javadoc tags with arguments
      */
     private static List<JavadocTag> getMultilineArgTags(final Matcher argMultilineStart,
             final int column, final String[] lines, final int lineIndex, final int tagLine) {
         final List<JavadocTag> tags = new ArrayList<>();
         final String param1 = argMultilineStart.group(1);
         final String param2 = argMultilineStart.group(2);
         int remIndex = lineIndex + 1;
         while (remIndex < lines.length) {
             final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);
             if (multilineCont.find()) {
                 remIndex = lines.length;
                 final String lFin = multilineCont.group(1);
                 if (!lFin.equals(NEXT_TAG)
                     && !lFin.equals(END_JAVADOC)) {
                     tags.add(new JavadocTag(tagLine, column, param1, param2));
                 }
             }
             remIndex++;
         }
         return tags;
     }
 
     /**
      * Gets multiline Javadoc tags with no arguments.
      * @param noargMultilineStart javadoc tag Matcher
      * @param lines comment text lines
      * @param lineIndex line number that contains the javadoc tag
      * @param tagLine javadoc tag line number in file
      * @return javadoc tags with no arguments
      */
     private static List<JavadocTag> getMultilineNoArgTags(final Matcher noargMultilineStart,
             final String[] lines, final int lineIndex, final int tagLine) {
         final String param1 = noargMultilineStart.group(1);
         final int col = noargMultilineStart.start(1) - 1;
         final List<JavadocTag> tags = new ArrayList<>();
         int remIndex = lineIndex + 1;
         while (remIndex < lines.length) {
             final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                     .matcher(lines[remIndex]);
-            multilineCont.find();
-            remIndex = lines.length;
-            final String lFin = multilineCont.group(1);
-            if (!lFin.equals(NEXT_TAG)
-                && !lFin.equals(END_JAVADOC)) {
-                tags.add(new JavadocTag(tagLine, col, param1));
+            if (multilineCont.find()) {
+                remIndex = lines.length;
+                final String lFin = multilineCont.group(1);
+                if (!lFin.equals(NEXT_TAG)
+                    && !lFin.equals(END_JAVADOC)) {
+                    tags.add(new JavadocTag(tagLine, col, param1));
+                }
             }
             remIndex++;
         }
 
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private static List<DetailAST> getParameters(DetailAST ast) {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
         final List<DetailAST> returnValue = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 returnValue.add(ident);
             }
             child = child.getNextSibling();
         }
         return returnValue;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
         final List<ExceptionInfo> returnValue = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
                     final FullIdent ident = FullIdent.createFullIdent(child);
                     final ExceptionInfo exceptionInfo = new ExceptionInfo(
                             createClassInfo(new Token(ident), getCurrentClassName()));
                     returnValue.add(exceptionInfo);
                 }
                 child = child.getNextSibling();
             }
