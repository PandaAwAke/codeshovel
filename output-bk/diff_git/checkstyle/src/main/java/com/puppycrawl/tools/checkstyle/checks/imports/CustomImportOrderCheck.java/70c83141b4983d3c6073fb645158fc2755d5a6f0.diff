diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index f953ce450..5683b4319 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -1,135 +1,142 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.imports;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.Utils;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * <p>
  * Checks that the groups of import declarations appear in the order specified
  * by the user. If there is an import but its group is not specified in the
  * configuration such an import should be placed at the end of the import list.
  * </p>
  * The rule consists of:
  *
  * <pre>
  * STATIC group. This group sets the ordering of static imports.
  * </pre>
  *
- * <pre>
+ * <p>
  * SAME_PACKAGE(n) group. This group sets the ordering of the same package imports.
- * 'n' - a number of the first package domains. For example:
- * </pre>
+ * Imports are considered on SAME_PACKAGE group if <b>n</b> first domains in package name
+ * and import name are identical.
+ * </p>
  *
  * <pre>
  * <code>
- * package java.util.concurrent;
- *
- * import java.util.regex.Pattern;
- * import java.util.List;
- * import java.util.StringTokenizer;
- * import java.util.regex.Pattern;
- * import java.util.*;
- * import java.util.concurrent.AbstractExecutorService;
- * import java.util.concurrent.*;
+ * package java.util.concurrent.locks;
  *
- * And we have such configuration: SAME_PACKAGE (3).
- * Same package imports are java.util.*, java.util.concurrent.*,
- * java.util.concurrent.AbstractExecutorService,
- * java.util.List and java.util.StringTokenizer
+ * import java.io.File;
+ * import java.util.*; //#1
+ * import java.util.List; //#2
+ * import java.util.StringTokenizer; //#3
+ * import java.util.concurrent.*; //#4
+ * import java.util.concurrent.AbstractExecutorService; //#5
+ * import java.util.concurrent.locks.LockSupport; //#6
+ * import java.util.regex.Pattern; //#7
+ * import java.util.regex.Matcher; //#8
  * </code>
  * </pre>
  *
- * <pre>
+ * <p>
+ * If we have SAME_PACKAGE(3) on configuration file,
+ * imports #4-6 will be considered as a SAME_PACKAGE group (java.util.concurrent.*,
+ * java.util.concurrent.AbstractExecutorService, java.util.concurrent.locks.LockSupport).
+ * SAME_PACKAGE(2) will include #1-8. SAME_PACKAGE(4) will include only #6.
+ * SAME_PACKAGE(5) will result in no imports assigned to SAME_PACKAGE group because
+ * actual package java.util.concurrent.locks has only 4 domains.
+ * </p>
+ *
+ * <p>
  * THIRD_PARTY_PACKAGE group. This group sets ordering of third party imports.
  * Third party imports are all imports except STATIC,
  * SAME_PACKAGE(n), STANDARD_JAVA_PACKAGE and SPECIAL_IMPORTS.
- * </pre>
+ * </p>
  *
  * <pre>
  * STANDARD_JAVA_PACKAGE group. This group sets ordering of standard java/javax imports.
  * </pre>
  *
  * <pre>
  * SPECIAL_IMPORTS group. This group may contains some imports
  * that have particular meaning for the user.
  * </pre>
  *
  * <p>
- * NOTICE!
+ * NOTE!
  * </p>
  * <p>
  * Use the separator '###' between rules.
  * </p>
  * <p>
  * To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
  * thirdPartyPackageRegExp and standardPackageRegExp options.
  * </p>
  *
  * <pre>
  * Properties:
  * </pre>
  * <table summary="Properties" border="1">
  *     <tr><th>name</th><th>Description</th><th>type</th><th>default value</th></tr>
  *      <tr><td>customImportOrderRules</td><td>List of order declaration customizing by user.</td>
  *          <td>string</td><td>null</td></tr>
  *      <tr><td>standardPackageRegExp</td><td>RegExp for STANDARD_JAVA_PACKAGE group imports.</td>
  *          <td>regular expression</td><td>^(java|javax)\.</td></tr>
  *      <tr><td>thirdPartyPackageRegExp</td><td>RegExp for THIRDPARTY_PACKAGE group imports.</td>
  *          <td>regular expression</td><td>.*</td></tr>
  *      <tr><td>specialImportsRegExp</td><td>RegExp for SPECIAL_IMPORTS group imports.</td>
  *          <td>regular expression</td><td>^$</td></tr>
  *      <tr><td>samePackageMatchingDepth</td><td>Number of first domains for SAME_PACKAGE group.
  *          </td><td>Integer</td><td>2</td></tr>
  *      <tr><td>separateLineBetweenGroups</td><td>Force empty line separator between import groups.
  *          </td><td>boolean</td><td>true</td></tr>
  *      <tr><td>sortImportsInGroupAlphabetically</td><td>Force grouping alphabetically,
  *          in ASCII sort order.</td><td>boolean</td><td>false</td></tr>
  * </table>
  *
  * <pre>
  * For example:
  * </pre>
  *        <p>To configure the check so that it matches default Eclipse formatter configuration
  *        (tested on Kepler, Luna and Mars):</p>
  *        <ul>
  *          <li>group of static imports is on the top</li>
  *          <li>groups of non-static imports: &quot;java&quot; and &quot;javax&quot; packages
  *          first, then &quot;org&quot; and then all other imports</li>
  *          <li>imports will be sorted in the groups</li>
  *          <li>groups are separated by, at least, one blank line</li>
  *        </ul>
  * <pre>
  *        <code>
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *        value=&quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS&quot;/&gt;
  *    &lt;property name=&quot;specialImportsRegExp&quot; value=&quot;org&quot;/&gt;
  *    &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;
@@ -546,103 +553,104 @@ public class CustomImportOrderCheck extends Check {
         for (String group : customImportOrderRules) {
             if (matchesImportGroup(isStatic, importPath, group)) {
                 return group;
             }
         }
         return NON_GROUP_RULE_GROUP;
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param importPath
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if import placed in the correct group.
      */
     private boolean matchesImportGroup(boolean isStatic, String importPath, String currentGroup) {
         return matchesStaticImportGroup(isStatic, currentGroup)
                 || matchesSamePackageImportGroup(isStatic, importPath, currentGroup)
                 || matchesSpecialImportsGroup(isStatic, importPath, currentGroup)
                 || matchesStandartImportGroup(isStatic, importPath, currentGroup)
                 || matchesThirdPartyImportGroup(isStatic, importPath, currentGroup);
     }
 
     /**
      * Checks if the import is placed in the STATIC group.
      * @param isStatic
      *        is static import.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the static group.
      */
     private static boolean matchesStaticImportGroup(boolean isStatic, String currentGroup) {
         return isStatic && STATIC_RULE_GROUP.equals(currentGroup);
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param importFullPath
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the same package group.
      */
     private boolean matchesSamePackageImportGroup(boolean isStatic,
         String importFullPath, String currentGroup) {
-        final String importPath = importFullPath.substring(0, importFullPath.lastIndexOf('.'));
+        final String importPathTrimmedToSamePackageDepth =
+                getFirstNDomainsFromIdent(this.samePackageMatchingDepth, importFullPath);
         return !isStatic && SAME_PACKAGE_RULE_GROUP.equals(currentGroup)
-                && samePackageDomainsRegExp.contains(importPath);
+                && samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth);
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the standard group.
      */
     private boolean matchesStandartImportGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && standardPackageRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the special group.
      */
     private boolean matchesSpecialImportsGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && SPECIAL_IMPORTS_RULE_GROUP.equals(currentGroup)
                 && specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the third party group.
      */
     private boolean matchesThirdPartyImportGroup(boolean isStatic,
         String currentImport, String currentGroup) {
         return !isStatic && THIRD_PARTY_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && thirdPartyPackageRegExp.matcher(currentImport).find()
                 && !standardPackageRegExp.matcher(currentImport).find()
                 && !specialImportsRegExp.matcher(currentImport).find();
@@ -693,110 +701,124 @@ public class CustomImportOrderCheck extends Check {
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token) {
         return token != null ? FullIdent.createFullIdent(token
                 .findFirstToken(TokenTypes.DOT)).getText() : "";
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRuleastoList(String ruleStr) {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
             final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                     ruleStr.indexOf(')'));
             samePackageMatchingDepth = Integer.parseInt(rule);
             if (samePackageMatchingDepth <= 0) {
                 throw new IllegalArgumentException(
                         "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr);
             }
             customImportOrderRules.add(SAME_PACKAGE_RULE_GROUP);
 
         }
         else {
             throw new IllegalStateException("Unexpected rule: " + ruleStr);
         }
     }
 
     /**
      * Creates samePackageDomainsRegExp of the first package domains.
      * @param firstPackageDomainsCount
      *        number of first package domains.
      * @param packageNode
      *        package node.
      * @return same package regexp.
      */
     private static String createSamePackageRegexp(int firstPackageDomainsCount,
              DetailAST packageNode) {
-        final StringBuilder builder = new StringBuilder();
         final String packageFullPath = getFullImportIdent(packageNode);
+        return getFirstNDomainsFromIdent(firstPackageDomainsCount, packageFullPath);
+    }
+
+    /**
+     * Extracts defined amount of domains from the left side of package/import identifier
+     * @param firstPackageDomainsCount
+     *        number of first package domains.
+     * @param packageFullPath
+     *        full identifier containing path to package or imported object.
+     * @return String with defined amount of domains or full identifier
+     *        (if full identifier had less domain then specified)
+     */
+    private static String getFirstNDomainsFromIdent(
+            final int firstPackageDomainsCount, final String packageFullPath) {
+        final StringBuilder builder = new StringBuilder();
         final StringTokenizer tokens = new StringTokenizer(packageFullPath, ".");
         int count = firstPackageDomainsCount;
 
         while (tokens.hasMoreTokens() && count > 0) {
             builder.append(tokens.nextToken()).append('.');
             count--;
         }
-        return builder.append("*").toString();
+        return builder.toString();
     }
 
     /**
      * Contains import attributes as line number, import full path, import
      * group.
      * @author max
      */
     static class ImportDetails {
         /** Import full path */
         private String importFullPath;
 
         /** Import line number */
         private int lineNumber;
 
         /** Import group */
         private String importGroup;
 
         /** Is static import */
         private boolean staticImport;
 
         /**
          * @param importFullPath
          *        import full path.
          * @param lineNumber
          *        import line number.
          * @param importGroup
          *        import group.
          * @param staticImport
          *        if import is static.
          */
         public ImportDetails(String importFullPath,
                 int lineNumber, String importGroup, boolean staticImport) {
             setImportFullPath(importFullPath);
             setLineNumber(lineNumber);
             setImportGroup(importGroup);
             setStaticImport(staticImport);
         }
 
         /**
          * Get import full path variable.
          * @return import full path variable.
          */
         public String getImportFullPath() {
             return importFullPath;
         }
 
         /**
          * Set import full path variable.
          * @param importFullPath
          *        import full path variable.
