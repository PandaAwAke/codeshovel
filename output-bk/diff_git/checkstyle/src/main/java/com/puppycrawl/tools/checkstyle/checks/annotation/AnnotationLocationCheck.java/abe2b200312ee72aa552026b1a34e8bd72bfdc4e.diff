diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
index d8c8f714e..ce4034a55 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
@@ -135,100 +135,122 @@ public class AnnotationLocationCheck extends Check
     /**
      * Some javadoc.
      */
     private boolean allowSamelineParameterizedAnnotation;
 
     /**
      * Some javadoc.
      */
     private boolean allowSamelineMultipleAnnotations;
 
     /**
      * Some javadoc.
      * @param allow Some javadoc.
      */
     public final void setAllowSamelineSingleParameterlessAnnotation(boolean allow)
     {
         allowSamelineSingleParameterlessAnnotation = allow;
     }
 
     /**
      * Some javadoc.
      * @param allow Some javadoc.
      */
     public final void setAllowSamelineParametrizedAnnotation(boolean allow)
     {
         allowSamelineParameterizedAnnotation = allow;
     }
 
     /**
      * Some javadoc.
      * @param allow Some javadoc.
      */
     public final void setAllowSamelineMultipleAnnotations(boolean allow)
     {
         allowSamelineMultipleAnnotations = allow;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.CLASS_DEF,
+            TokenTypes.INTERFACE_DEF,
+            TokenTypes.ENUM_DEF,
+            TokenTypes.METHOD_DEF,
+            TokenTypes.CTOR_DEF,
+            TokenTypes.VARIABLE_DEF,
+            TokenTypes.PARAMETER_DEF,
+            TokenTypes.ANNOTATION_DEF,
+            TokenTypes.TYPECAST,
+            TokenTypes.LITERAL_THROWS,
+            TokenTypes.IMPLEMENTS_CLAUSE,
+            TokenTypes.TYPE_ARGUMENT,
+            TokenTypes.LITERAL_NEW,
+            TokenTypes.DOT,
+            TokenTypes.ANNOTATION_FIELD_DEF,
+        };
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         final DetailAST modifiersNode = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         if (hasAnnotations(modifiersNode)) {
             checkAnnotations(modifiersNode, getAnnotationLevel(modifiersNode));
         }
     }
 
     /**
      * Some javadoc.
      * @param modifierNode Some javadoc.
      * @param correctLevel Some javadoc.
      */
     private void checkAnnotations(DetailAST modifierNode, int correctLevel)
     {
         DetailAST annotation = modifierNode.getFirstChild();
 
         while (annotation != null && annotation.getType() == TokenTypes.ANNOTATION) {
             final boolean hasParameters = isParameterized(annotation);
 
             if (!isCorrectLocation(annotation, hasParameters)) {
                 log(annotation.getLineNo(),
                         MSG_KEY_ANNOTATION_LOCATION_ALONE, getAnnotationName(annotation));
             }
             else if (annotation.getColumnNo() != correctLevel && !hasNodeBefore(annotation)) {
                 log(annotation.getLineNo(), MSG_KEY_ANNOTATION_LOCATION,
                     getAnnotationName(annotation), annotation.getColumnNo(), correctLevel);
             }
             annotation = annotation.getNextSibling();
         }
     }
 
     /**
      * Some javadoc.
      * @param annotation Some javadoc.
      * @param hasParams Some javadoc.
      * @return Some javadoc.
      */
     private boolean isCorrectLocation(DetailAST annotation, boolean hasParams)
     {
         final boolean allowingCondition = hasParams ? allowSamelineParameterizedAnnotation
             : allowSamelineSingleParameterlessAnnotation;
         return allowingCondition && !hasNodeBefore(annotation)
             || !allowingCondition && !hasNodeBeside(annotation)
             || allowSamelineMultipleAnnotations;
     }
 
     /**
