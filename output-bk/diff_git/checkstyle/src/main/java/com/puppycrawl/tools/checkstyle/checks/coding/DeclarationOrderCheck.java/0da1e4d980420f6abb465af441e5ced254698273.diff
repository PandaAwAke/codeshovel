diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 67b84835f..ed0571c6b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -139,128 +139,116 @@ public class DeclarationOrderCheck extends Check {
     /** State for the VARIABLE_DEF */
     private static final int STATE_INSTANCE_VARIABLE_DEF = 2;
 
     /** State for the CTOR_DEF */
     private static final int STATE_CTOR_DEF = 3;
 
     /** State for the METHOD_DEF */
     private static final int STATE_METHOD_DEF = 4;
 
     /**
      * List of Declaration States. This is necessary due to
      * inner classes that have their own state
      */
     private final Deque<ScopeState> scopeStates = new ArrayDeque<>();
 
     /** If true, ignores the check to constructors. */
     private boolean ignoreConstructors;
     /** If true, ignore the check to methods. */
     private boolean ignoreMethods;
     /** If true, ignore the check to modifiers (fields, ...). */
     private boolean ignoreModifiers;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int parentType = ast.getParent().getType();
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
-
             case TokenTypes.CTOR_DEF:
-                if (parentType != TokenTypes.OBJBLOCK) {
-                    return;
+                if (parentType == TokenTypes.OBJBLOCK) {
+                    processConstructor(ast);
                 }
-
-                processConstructor(ast);
                 break;
-
             case TokenTypes.METHOD_DEF:
-
-                if (parentType != TokenTypes.OBJBLOCK) {
-                    return;
+                if (parentType == TokenTypes.OBJBLOCK) {
+                    processMethod(ast);
                 }
-
-                processMethod(ast);
                 break;
-
             case TokenTypes.MODIFIERS:
-                if (parentType != TokenTypes.VARIABLE_DEF
-                        || ast.getParent().getParent().getType()
-                        != TokenTypes.OBJBLOCK) {
-                    return;
+                if (parentType == TokenTypes.VARIABLE_DEF
+                        && ast.getParent().getParent().getType() == TokenTypes.OBJBLOCK) {
+                    processModifiers(ast);
                 }
-
-                processModifiers(ast);
                 break;
-
             default:
                 break;
         }
     }
 
     /**
      * Process constructor
      * @param ast constructor AST
      */
     private void processConstructor(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
         if (state.currentScopeState > STATE_CTOR_DEF) {
             if (!ignoreConstructors) {
                 log(ast, MSG_CONSTRUCTOR);
             }
         }
         else {
             state.currentScopeState = STATE_CTOR_DEF;
         }
     }
 
     /**
      * Process Method Token
      * @param ast ,ethod token AST
      */
     private void processMethod(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
         if (state.currentScopeState > STATE_METHOD_DEF) {
             if (!ignoreMethods) {
                 log(ast, MSG_METHOD);
             }
         }
         else {
             state.currentScopeState = STATE_METHOD_DEF;
         }
     }
 
     /**
      * Process modifiers
      * @param ast ast of Modifiers
      */
     private void processModifiers(DetailAST ast) {
 
         final ScopeState state = scopeStates.peek();
         if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
             if (state.currentScopeState > STATE_STATIC_VARIABLE_DEF) {
                 if (!ignoreModifiers
                     || state.currentScopeState > STATE_INSTANCE_VARIABLE_DEF) {
