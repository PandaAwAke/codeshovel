diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java
index ea28627d0..8e82c9bfb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java
@@ -35,91 +35,90 @@ import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;
  * <pre>
  * &lt;module name=&quot;JavadocTagContinuationIndentation&quot;&gt;
  *     &lt;property name=&quot;offset&quot; value=&quot;4&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author max
  *
  */
 public class JavadocTagContinuationIndentationCheck extends AbstractJavadocCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "tag.continuation.indent";
 
     /** Default tag continuation indentation */
     private static final int DEFAULT_INDENTATION = 4;
 
     /**
      * How many spaces to use for new indentation level.
      */
     private int offset = DEFAULT_INDENTATION;
 
     /**
      * Sets custom indentation level.
      * @param offset custom value.
      */
     public void setOffset(int offset) {
         this.offset = offset;
     }
 
     @Override
     public int[] getDefaultJavadocTokens() {
         return new int[] {JavadocTokenTypes.DESCRIPTION };
     }
 
     @Override
     public void visitJavadocToken(DetailNode ast) {
         if (isInlineDescription(ast)) {
             return;
         }
         final List<DetailNode> textNodes = getAllNewlineNodes(ast);
         for (DetailNode newlineNode : textNodes) {
             final DetailNode textNode = JavadocUtils.getNextSibling(JavadocUtils
                     .getNextSibling(newlineNode));
             if (textNode != null && textNode.getType() == JavadocTokenTypes.TEXT
                     && textNode.getChildren().length > 1) {
                 final DetailNode whitespace = JavadocUtils.getFirstChild(textNode);
-                if (whitespace.getType() == JavadocTokenTypes.WS
-                        && whitespace.getText().length() - 1 < offset) {
+                if (whitespace.getText().length() - 1 < offset) {
                     log(textNode.getLineNumber(), MSG_KEY, offset);
                 }
             }
         }
     }
 
     /**
      * Finds and collects all NEWLINE nodes inside DESCRIPTION node.
      * @param descriptionNode DESCRIPTION node.
      * @return List with NEWLINE nodes.
      */
     private List<DetailNode> getAllNewlineNodes(DetailNode descriptionNode) {
         final List<DetailNode> textNodes = new ArrayList<>();
         DetailNode node = JavadocUtils.getFirstChild(descriptionNode);
         while (JavadocUtils.getNextSibling(node) != null) {
             if (node.getType() == JavadocTokenTypes.NEWLINE) {
                 textNodes.add(node);
             }
             node = JavadocUtils.getNextSibling(node);
         }
         return textNodes;
     }
 
     /**
      * Checks, if description node is a description of in-line tag.
      * @param description DESCRIPTION node.
      * @return true, if description node is a description of in-line tag.
      */
     private boolean isInlineDescription(DetailNode description) {
         DetailNode inlineTag = description.getParent();
         while (inlineTag != null) {
             if (inlineTag.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {
                 return true;
             }
             inlineTag = inlineTag.getParent();
         }
         return false;
     }
 }
