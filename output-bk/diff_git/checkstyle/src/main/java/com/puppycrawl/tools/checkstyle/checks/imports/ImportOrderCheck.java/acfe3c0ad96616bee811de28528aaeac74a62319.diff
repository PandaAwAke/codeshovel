diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index c9d4dcb95..f121e5fde 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -393,223 +393,220 @@ public class ImportOrderCheck
             doVisitToken(ident, isStatic, isStaticAndNotLastImport);
 
         }
         else if (option == ImportOrderOption.BOTTOM) {
 
             if (isStaticAndNotLastImport) {
                 lastGroup = Integer.MIN_VALUE;
                 lastImport = "";
             }
             doVisitToken(ident, isStatic, isLastImportAndNonStatic);
 
         }
         else if (option == ImportOrderOption.ABOVE) {
             // previous non-static but current is static
             doVisitToken(ident, isStatic, isStaticAndNotLastImport);
 
         }
         else if (option == ImportOrderOption.UNDER) {
             doVisitToken(ident, isStatic, isLastImportAndNonStatic);
 
         }
         else if (option == ImportOrderOption.INFLOW) {
             // "previous" argument is useless here
             doVisitToken(ident, isStatic, true);
 
         }
         else {
             throw new IllegalStateException(
                     "Unexpected option for static imports: " + option);
         }
 
         lastImportLine = ast.findFirstToken(TokenTypes.SEMI).getLineNo();
         lastImportStatic = isStatic;
         beforeFirstImport = false;
     }
 
     /**
      * Shares processing...
      *
      * @param ident the import to process.
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *                  previous static but current is non-static (under).
      */
     private void doVisitToken(FullIdent ident, boolean isStatic,
             boolean previous) {
         final String name = ident.getText();
         final int groupIdx = getGroupNumber(name);
         final int line = ident.getLineNo();
 
-        if (groupIdx == lastGroup
-            || !beforeFirstImport && isAlphabeticallySortableStaticImport(isStatic)) {
+        if (isInSameGroup(groupIdx, isStatic)) {
             doVisitTokenInSameGroup(isStatic, previous, name, line);
         }
         else if (groupIdx > lastGroup) {
             if (!beforeFirstImport && separated && line - lastImportLine < 2) {
                 log(line, MSG_SEPARATION, name);
             }
         }
         else {
             log(line, MSG_ORDERING, name);
         }
         if (isSeparatorInGroup(groupIdx, isStatic, line)) {
             log(line, MSG_SEPARATED_IN_GROUP, name);
         }
 
         lastGroup = groupIdx;
         lastImport = name;
     }
 
     /**
      * Checks whether imports group separated internally.
      * @param groupIdx group number.
      * @param isStatic whether the token is static or not.
      * @param line the line of the current import.
      * @return true if imports group are separated internally.
      */
     private boolean isSeparatorInGroup(int groupIdx, boolean isStatic, int line) {
         final boolean inSameGroup = isInSameGroup(groupIdx, isStatic);
         return (!separated || inSameGroup) && isSeparatorBeforeImport(line);
     }
 
     /**
      * Checks whether there is any separator before current import.
      * @param line the line of the current import.
      * @return true if there is separator before current import which isn't the first import.
      */
     private boolean isSeparatorBeforeImport(int line) {
         return !beforeFirstImport && line - lastImportLine > 1;
     }
 
     /**
      * Checks whether imports are in same group.
      * @param groupIdx group number.
      * @param isStatic whether the token is static or not.
      * @return true if imports are in same group.
      */
     private boolean isInSameGroup(int groupIdx, boolean isStatic) {
         final boolean isStaticImportGroupIndependent =
             option == ImportOrderOption.TOP || option == ImportOrderOption.BOTTOM;
         final boolean result;
         if (isStaticImportGroupIndependent) {
             result = isStatic && lastImportStatic
                 || groupIdx == lastGroup && isStatic == lastImportStatic;
         }
         else {
             result = groupIdx == lastGroup;
         }
         return result;
     }
 
-    /**
-     * Checks whether static imports grouped by <b>top</b> or <b>bottom</b> option
-     * are sorted alphabetically or not.
-     * @param isStatic if current import is static.
-     * @return true if static imports should be sorted alphabetically.
-     */
-    private boolean isAlphabeticallySortableStaticImport(boolean isStatic) {
-        return isStatic && sortStaticImportsAlphabetically
-                && (option == ImportOrderOption.TOP
-                    || option == ImportOrderOption.BOTTOM);
-    }
-
     /**
      * Shares processing...
      *
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *     previous static but current is non-static (under).
      * @param name the name of the current import.
      * @param line the line of the current import.
      */
     private void doVisitTokenInSameGroup(boolean isStatic,
             boolean previous, String name, int line) {
         if (ordered) {
             if (option == ImportOrderOption.INFLOW) {
                 if (isWrongOrder(name, isStatic)) {
                     log(line, MSG_ORDERING, name);
                 }
             }
             else {
                 final boolean shouldFireError =
                     // previous non-static but current is static (above)
                     // or
                     // previous static but current is non-static (under)
                     previous
                         ||
                         // current and previous static or current and
                         // previous non-static
                         lastImportStatic == isStatic
                     && isWrongOrder(name, isStatic);
 
                 if (shouldFireError) {
                     log(line, MSG_ORDERING, name);
                 }
             }
         }
     }
 
     /**
      * Checks whether import name is in wrong order.
      * @param name import name.
      * @param isStatic whether it is a static import name.
      * @return true if import name is in wrong order.
      */
     private boolean isWrongOrder(String name, boolean isStatic) {
         final boolean result;
-        if (isStatic && useContainerOrderingForStatic) {
-            result = compareContainerOrder(lastImport, name, caseSensitive) > 0;
+        if (isStatic) {
+            if (useContainerOrderingForStatic) {
+                result = compareContainerOrder(lastImport, name, caseSensitive) >= 0;
+            }
+            else if (option == ImportOrderOption.TOP
+                || option == ImportOrderOption.BOTTOM) {
+                result = sortStaticImportsAlphabetically
+                    && compare(lastImport, name, caseSensitive) >= 0;
+            }
+            else {
+                result = compare(lastImport, name, caseSensitive) >= 0;
+            }
         }
         else {
             // out of lexicographic order
-            result = compare(lastImport, name, caseSensitive) > 0;
+            result = compare(lastImport, name, caseSensitive) >= 0;
         }
         return result;
     }
 
     /**
      * Compares two import strings.
      * We first compare the container of the static import, container being the type enclosing
      * the static element being imported. When this returns 0, we compare the qualified
      * import name. For e.g. this is what is considered to be container names:
      * <p>
      * import static HttpConstants.COLON     => HttpConstants
      * import static HttpHeaders.addHeader   => HttpHeaders
      * import static HttpHeaders.setHeader   => HttpHeaders
      * import static HttpHeaders.Names.DATE  => HttpHeaders.Names
      * </p>
      * <p>
      * According to this logic, HttpHeaders.Names would come after HttpHeaders.
      *
      * For more details, see <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=473629#c3">
      * static imports comparison method</a> in Eclipse.
      * </p>
      *
      * @param importName1 first import name.
      * @param importName2 second import name.
      * @param caseSensitive whether the comparison of fully qualified import names is case
      *                      sensitive.
      * @return the value {@code 0} if str1 is equal to str2; a value
      *         less than {@code 0} if str is less than the str2 (container order
      *         or lexicographical); and a value greater than {@code 0} if str1 is greater than str2
      *         (container order or lexicographically).
      */
     private static int compareContainerOrder(String importName1, String importName2,
                                              boolean caseSensitive) {
         final String container1 = getImportContainer(importName1);
         final String container2 = getImportContainer(importName2);
         final int compareContainersOrderResult;
         if (caseSensitive) {
             compareContainersOrderResult = container1.compareTo(container2);
         }
         else {
             compareContainersOrderResult = container1.compareToIgnoreCase(container2);
         }
         final int result;
         if (compareContainersOrderResult == 0) {
             result = compare(importName1, importName2, caseSensitive);
         }
         else {
             result = compareContainersOrderResult;
         }
         return result;
