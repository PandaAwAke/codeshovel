diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index 75b1284ed..6ab4a98d3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -69,101 +69,100 @@ public class IllegalInstantiationCheck
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "instantiation.avoid";
 
     /** {@link java.lang} package as string. */
     private static final String JAVA_LANG = "java.lang.";
 
     /** The imports for the file. */
     private final Set<FullIdent> imports = new HashSet<>();
 
     /** The class names defined in the file. */
     private final Set<String> classNames = new HashSet<>();
 
     /** The instantiations in the file. */
     private final Set<DetailAST> instantiations = new HashSet<>();
 
     /** Set of fully qualified class names. E.g. "java.lang.Boolean" */
     private Set<String> illegalClasses = new HashSet<>();
 
     /** Name of the package. */
     private String pkgName;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.LITERAL_NEW,
             TokenTypes.PACKAGE_DEF,
             TokenTypes.CLASS_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.LITERAL_NEW,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
-        super.beginTree(rootAST);
         pkgName = null;
         imports.clear();
         instantiations.clear();
         classNames.clear();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.LITERAL_NEW:
                 processLiteralNew(ast);
                 break;
             case TokenTypes.PACKAGE_DEF:
                 processPackageDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 processImport(ast);
                 break;
             case TokenTypes.CLASS_DEF:
                 processClassDef(ast);
                 break;
             default:
                 throw new IllegalArgumentException("Unknown type " + ast);
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
         instantiations.forEach(this::postProcessLiteralNew);
     }
 
     /**
      * Collects classes defined in the source file. Required
      * to avoid false alarms for local vs. java.lang classes.
      *
      * @param ast the class def token.
      */
     private void processClassDef(DetailAST ast) {
         final DetailAST identToken = ast.findFirstToken(TokenTypes.IDENT);
         final String className = identToken.getText();
         classNames.add(className);
     }
 
     /**
      * Perform processing for an import token.
      * @param ast the import token
      */
     private void processImport(DetailAST ast) {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
         // Note: different from UnusedImportsCheck.processImport(),
