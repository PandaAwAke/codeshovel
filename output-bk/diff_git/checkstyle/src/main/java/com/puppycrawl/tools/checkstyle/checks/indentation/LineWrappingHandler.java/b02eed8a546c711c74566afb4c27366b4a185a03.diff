diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
index f8af0a778..39f2b9ce6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
@@ -215,101 +215,102 @@ public class LineWrappingHandler {
         }
         return result;
     }
 
     /**
      * Returns next curNode node.
      *
      * @param curNode current node.
      * @return next curNode node.
      */
     private static DetailAST getNextCurNode(DetailAST curNode) {
         DetailAST nodeToVisit = curNode.getFirstChild();
         DetailAST currentNode = curNode;
 
         while (nodeToVisit == null) {
             nodeToVisit = currentNode.getNextSibling();
             if (nodeToVisit == null) {
                 currentNode = currentNode.getParent();
             }
         }
         return nodeToVisit;
     }
 
     /**
      * Checks line wrapping into annotations.
      *
      * @param atNode at-clause node.
      * @param firstNodesOnLines map which contains
      *     first nodes as values and line numbers as keys.
      * @param indentLevel line wrapping indentation.
      */
     private void checkAnnotationIndentation(DetailAST atNode,
             NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {
         final int firstNodeIndent = getLineStart(atNode);
         final int currentIndent = firstNodeIndent + indentLevel;
         final Collection<DetailAST> values = firstNodesOnLines.values();
         final DetailAST lastAnnotationNode = atNode.getParent().getLastChild();
         final int lastAnnotationLine = lastAnnotationNode.getLineNo();
 
         final Iterator<DetailAST> itr = values.iterator();
         while (firstNodesOnLines.size() > 1) {
             final DetailAST node = itr.next();
 
             final DetailAST parentNode = node.getParent();
             final boolean isCurrentNodeCloseAnnotationAloneInLine =
                 node.getLineNo() == lastAnnotationLine
                     && isEndOfScope(lastAnnotationNode, node);
             if (isCurrentNodeCloseAnnotationAloneInLine
                     || node.getType() == TokenTypes.AT
                     && (parentNode.getParent().getType() == TokenTypes.MODIFIERS
-                        || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)) {
+                        || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)
+                    || node.getLineNo() == atNode.getLineNo()) {
                 logWarningMessage(node, firstNodeIndent);
             }
             else {
                 logWarningMessage(node, currentIndent);
             }
             itr.remove();
         }
     }
 
     /**
      * Checks line for end of scope.  Handles occurrences of close braces and close parenthesis on
      * the same line.
      *
      * @param lastAnnotationNode the last node of the annotation
      * @param node the node indicating where to begin checking
      * @return true if all the nodes up to the last annotation node are end of scope nodes
      *         false otherwise
      */
     private static boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {
         DetailAST checkNode = node;
         boolean endOfScope = true;
         while (endOfScope && !checkNode.equals(lastAnnotationNode)) {
             switch (checkNode.getType()) {
                 case TokenTypes.RCURLY:
                 case TokenTypes.RBRACK:
                     while (checkNode.getNextSibling() == null) {
                         checkNode = checkNode.getParent();
                     }
                     checkNode = checkNode.getNextSibling();
                     break;
                 default:
                     endOfScope = false;
 
             }
 
         }
         return endOfScope;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param ast   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     private int expandedTabsColumnNo(DetailAST ast) {
         final String line =
             indentCheck.getLine(ast.getLineNo() - 1);
