diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index 8cc49a5a2..a469de639 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -265,112 +265,123 @@ public class RightCurlyCheck extends AbstractCheck {
      * @return true if right curly brace starts target source line.
      */
     private static boolean isOnStartOfLine(Details details, String targetSourceLine) {
         return CommonUtils.hasWhitespaceBefore(details.rcurly.getColumnNo(), targetSourceLine)
                 || details.lcurly.getLineNo() == details.rcurly.getLineNo();
     }
 
     /**
      * Checks whether right curly is alone on a line.
      * @param details for validation.
      * @return true if right curly is alone on a line.
      */
     private static boolean isAloneOnLine(Details details) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         return rcurly.getLineNo() != lcurly.getLineNo()
             && rcurly.getLineNo() != nextToken.getLineNo();
     }
 
     /**
      * Checks whether block has a single-line format.
      * @param details for validation.
      * @return true if block has single-line format.
      */
     private static boolean isSingleLineBlock(Details details) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         return rcurly.getLineNo() == lcurly.getLineNo()
             && rcurly.getLineNo() != nextToken.getLineNo();
     }
 
     /**
      * Checks whether lcurly is in anonymous inner class initialization.
      * @param lcurly left curly token.
      * @return true if lcurly begins anonymous inner class initialization.
      */
     private static boolean isAnonInnerClassInit(DetailAST lcurly) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(lcurly);
         return surroundingScope.ordinal() == Scope.ANONINNER.ordinal();
     }
 
     /**
      * Collects validation details.
      * @param ast detail ast.
      * @return object that contain all details to make a validation.
      */
     // -@cs[JavaNCSS] getDetails() method is a huge SWITCH, it has to be monolithic
     // -@cs[ExecutableStatementCount] getDetails() method is a huge SWITCH, it has to be monolithic
+    // -@cs[NPathComplexity] getDetails() method is a huge SWITCH, it has to be monolithic
     private static Details getDetails(DetailAST ast) {
         // Attempt to locate the tokens to do the check
         boolean shouldCheckLastRcurly = false;
         DetailAST rcurly = null;
         final DetailAST lcurly;
         DetailAST nextToken;
 
         switch (ast.getType()) {
             case TokenTypes.LITERAL_TRY:
-                lcurly = ast.getFirstChild();
+                if (ast.getFirstChild().getType() == TokenTypes.RESOURCE_SPECIFICATION) {
+                    lcurly = ast.getFirstChild().getNextSibling();
+                }
+                else {
+                    lcurly = ast.getFirstChild();
+                }
                 nextToken = lcurly.getNextSibling();
                 rcurly = lcurly.getLastChild();
+
+                if (nextToken == null) {
+                    shouldCheckLastRcurly = true;
+                    nextToken = getNextToken(ast);
+                }
                 break;
             case TokenTypes.LITERAL_CATCH:
                 nextToken = ast.getNextSibling();
                 lcurly = ast.getLastChild();
                 rcurly = lcurly.getLastChild();
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                 }
                 break;
             case TokenTypes.LITERAL_IF:
                 nextToken = ast.findFirstToken(TokenTypes.LITERAL_ELSE);
                 if (nextToken == null) {
                     shouldCheckLastRcurly = true;
                     nextToken = getNextToken(ast);
                     lcurly = ast.getLastChild();
                 }
                 else {
                     lcurly = nextToken.getPreviousSibling();
                 }
                 if (lcurly.getType() == TokenTypes.SLIST) {
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             case TokenTypes.LITERAL_ELSE:
             case TokenTypes.LITERAL_FINALLY:
                 shouldCheckLastRcurly = true;
                 nextToken = getNextToken(ast);
                 lcurly = ast.getFirstChild();
                 if (lcurly.getType() == TokenTypes.SLIST) {
                     rcurly = lcurly.getLastChild();
                 }
                 break;
             case TokenTypes.CLASS_DEF:
                 final DetailAST child = ast.getLastChild();
                 lcurly = child.getFirstChild();
                 rcurly = child.getLastChild();
                 nextToken = ast;
                 break;
             case TokenTypes.CTOR_DEF:
             case TokenTypes.STATIC_INIT:
             case TokenTypes.INSTANCE_INIT:
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 rcurly = lcurly.getLastChild();
                 nextToken = getNextToken(ast);
                 break;
             case TokenTypes.LITERAL_DO:
                 nextToken = ast.findFirstToken(TokenTypes.DO_WHILE);
                 lcurly = ast.findFirstToken(TokenTypes.SLIST);
                 if (lcurly != null) {
