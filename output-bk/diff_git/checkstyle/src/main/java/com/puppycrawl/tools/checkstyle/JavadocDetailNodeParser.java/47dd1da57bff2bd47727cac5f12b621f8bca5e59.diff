diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java b/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
index 9a9315ee2..4843915a8 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
@@ -437,114 +437,116 @@ public class JavadocDetailNodeParser {
         return CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, classNameWithoutContext);
     }
 
     /**
      * Gets class name of ParseTree node and removes 'Context' postfix at the
      * end.
      * @param node
      *        ParseTree node.
      * @return class name without 'Context'
      */
     private static String getNodeClassNameWithoutContext(ParseTree node) {
         final String className = node.getClass().getSimpleName();
         // remove 'Context' at the end
         final int contextLength = 7;
         return className.substring(0, className.length() - contextLength);
     }
 
     /**
      * Method to get the missed HTML tag to generate more informative error message for the user.
      * This method doesn't concern itself with
      * <a href="https://www.w3.org/TR/html51/syntax.html#void-elements">void elements</a>
      * since it is forbidden to close them.
      * Missed HTML tags for the following tags will <i>not</i> generate an error message from ANTLR:
      * {@code
      * <p>
      * <li>
      * <tr>
      * <td>
      * <th>
      * <body>
      * <colgroup>
      * <dd>
      * <dt>
      * <head>
      * <html>
      * <option>
      * <tbody>
      * <thead>
      * <tfoot>
      * }
      * @param exception {@code NoViableAltException} object catched while parsing javadoc
      * @return returns appropriate {@link Token} if a HTML close tag is missed;
      *     null otherwise
      */
     private static Token getMissedHtmlTag(RecognitionException exception) {
         Token htmlTagNameStart = null;
         final Interval sourceInterval = exception.getCtx().getSourceInterval();
         final List<Token> tokenList = ((BufferedTokenStream) exception.getInputStream())
                 .getTokens(sourceInterval.a, sourceInterval.b);
         final Deque<Token> stack = new ArrayDeque<>();
-        for (int i = 0; i < tokenList.size(); i++) {
-            final Token token = tokenList.get(i);
-            if (token.getType() == JavadocTokenTypes.HTML_TAG_NAME
-                    && tokenList.get(i - 1).getType() == JavadocTokenTypes.START) {
+        int prevTokenType = JavadocTokenTypes.EOF;
+        for (final Token token : tokenList) {
+            final int tokenType = token.getType();
+            if (tokenType == JavadocTokenTypes.HTML_TAG_NAME
+                    && prevTokenType == JavadocTokenTypes.START) {
                 stack.push(token);
             }
-            else if (token.getType() == JavadocTokenTypes.HTML_TAG_NAME && !stack.isEmpty()) {
+            else if (tokenType == JavadocTokenTypes.HTML_TAG_NAME && !stack.isEmpty()) {
                 if (stack.peek().getText().equals(token.getText())) {
                     stack.pop();
                 }
                 else {
                     htmlTagNameStart = stack.pop();
                 }
             }
+            prevTokenType = tokenType;
         }
         if (htmlTagNameStart == null) {
             htmlTagNameStart = stack.pop();
         }
         return htmlTagNameStart;
     }
 
     /**
      * This method is used to get the first non-tight HTML tag encountered while parsing javadoc.
      * This shall eventually be reflected by the {@link ParseStatus} object returned by
      * {@link #parseJavadocAsDetailNode(DetailAST)} method via the instance member
      * {@link ParseStatus#firstNonTightHtmlTag}, and checks not supposed to process non-tight HTML
      * or the ones which are supposed to log violation for non-tight javadocs can utilize that.
      *
      * @param javadocParser The ANTLR recognizer instance which has been used to parse the javadoc
      * @return First non-tight HTML tag if one exists; null otherwise
      */
     private Token getFirstNonTightHtmlTag(JavadocParser javadocParser) {
         final CommonToken offendingToken;
         final ParserRuleContext nonTightTagStartContext = javadocParser.nonTightTagStartContext;
         if (nonTightTagStartContext == null) {
             offendingToken = null;
         }
         else {
             final Token token = ((TerminalNode) nonTightTagStartContext.getChild(1))
                     .getSymbol();
             offendingToken = new CommonToken(token);
             offendingToken.setLine(offendingToken.getLine() + errorListener.offset);
         }
         return offendingToken;
     }
 
     /**
      * Custom error listener for JavadocParser that prints user readable errors.
      */
     private static class DescriptiveErrorListener extends BaseErrorListener {
 
         /**
          * Offset is line number of beginning of the Javadoc comment. Log
          * messages should have line number in scope of file, not in scope of
          * Javadoc comment.
          */
         private int offset;
 
         /**
          * Error message that appeared while parsing.
          */
         private ParseErrorMessage errorMessage;
 
         /**
