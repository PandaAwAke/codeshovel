diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java
index cb69b82a9..2b091d739 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java
@@ -122,123 +122,124 @@ public class InnerAssignmentCheck
             TokenTypes.BXOR_ASSIGN,       // "^="
             TokenTypes.BOR_ASSIGN,        // "|="
             TokenTypes.BAND_ASSIGN,       // "&="
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (!isInContext(ast, ALLOWED_ASSIGNMENT_CONTEXT)
                 && !isInNoBraceControlStatement(ast)
                 && !isInWhileIdiom(ast)) {
             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);
         }
     }
 
     /**
      * Determines if ast is in the body of a flow control statement without
      * braces. An example of such a statement would be
      * <p>
      * <pre>
      * if (y < 0)
      *     x = y;
      * </pre>
      * </p>
      * <p>
      * This leads to the following AST structure:
      * </p>
      * <p>
      * <pre>
      * LITERAL_IF
      *     LPAREN
      *     EXPR // test
      *     RPAREN
      *     EXPR // body
      *     SEMI
      * </pre>
      * </p>
      * <p>
      * We need to ensure that ast is in the body and not in the test.
      * </p>
      *
      * @param ast an assignment operator AST
      * @return whether ast is in the body of a flow control statement
      */
     private static boolean isInNoBraceControlStatement(DetailAST ast) {
-        if (!isInContext(ast, CONTROL_CONTEXT)) {
-            return false;
+        boolean result = false;
+        if (isInContext(ast, CONTROL_CONTEXT)) {
+            final DetailAST expr = ast.getParent();
+            final AST exprNext = expr.getNextSibling();
+            result = exprNext.getType() == TokenTypes.SEMI;
         }
-        final DetailAST expr = ast.getParent();
-        final AST exprNext = expr.getNextSibling();
-        return exprNext.getType() == TokenTypes.SEMI;
+        return result;
     }
 
     /**
      * Tests whether the given AST is used in the "assignment in while" idiom.
      * <pre>
      * String line;
      * while ((line = bufferedReader.readLine()) != null) {
      *    // process the line
      * }
      * </pre>
      * Assignment inside a condition is not a problem here, as the assignment is surrounded by an
      * extra pair of parentheses. The comparison is {@code != null} and there is no chance that
      * intention was to write {@code line == reader.readLine()}.
      *
      * @param ast assignment AST
      * @return whether the context of the assignment AST indicates the idiom
-     * @noinspection SimplifiableIfStatement
      */
     private static boolean isInWhileIdiom(DetailAST ast) {
-        if (!isComparison(ast.getParent())) {
-            return false;
+        boolean result = false;
+        if (isComparison(ast.getParent())) {
+            result = isInContext(
+                    ast.getParent(), ALLOWED_ASSIGNMENT_IN_COMPARISON_CONTEXT);
         }
-        return isInContext(
-                ast.getParent(), ALLOWED_ASSIGNMENT_IN_COMPARISON_CONTEXT);
+        return result;
     }
 
     /**
      * Checks if an AST is a comparison operator.
      * @param ast the AST to check
      * @return true iff ast is a comparison operator.
      */
     private static boolean isComparison(DetailAST ast) {
         final int astType = ast.getType();
         return Arrays.binarySearch(COMPARISON_TYPES, astType) >= 0;
     }
 
     /**
      * Tests whether the provided AST is in
      * one of the given contexts.
      *
      * @param ast the AST from which to start walking towards root
      * @param contextSet the contexts to test against.
      *
      * @return whether the parents nodes of ast match one of the allowed type paths.
      */
     private static boolean isInContext(DetailAST ast, int[]... contextSet) {
         boolean found = false;
         for (int[] element : contextSet) {
             DetailAST current = ast;
             for (int anElement : element) {
                 current = current.getParent();
                 if (current.getType() == anElement) {
                     found = true;
                 }
                 else {
                     found = false;
                     break;
                 }
             }
 
             if (found) {
                 break;
             }
         }
         return found;
     }
 }
