diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index e9d34f1f2..c2e3de96e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -137,121 +137,121 @@ public class RequireThisCheck extends AbstractCheck {
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.SR_ASSIGN,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.SL_ASSIGN,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BXOR_ASSIGN,
         }).collect(Collectors.toSet()));
 
     /** Tree of all the parsed frames. */
     private Map<DetailAST, AbstractFrame> frames;
 
     /** Frame for the currently processed AST. */
     private AbstractFrame current;
 
     /** Whether we should check fields usage. */
     private boolean checkFields = true;
     /** Whether we should check methods usage. */
     private boolean checkMethods = true;
     /** Whether we should check only overlapping by variables or arguments. */
     private boolean validateOnlyOverlapping = true;
 
     /**
      * Setter for checkFields property.
      * @param checkFields should we check fields usage or not.
      */
     public void setCheckFields(boolean checkFields) {
         this.checkFields = checkFields;
     }
 
     /**
      * Setter for checkMethods property.
      * @param checkMethods should we check methods usage or not.
      */
     public void setCheckMethods(boolean checkMethods) {
         this.checkMethods = checkMethods;
     }
 
     /**
      * Setter for validateOnlyOverlapping property.
      * @param validateOnlyOverlapping should we check only overlapping by variables or arguments.
      */
     public void setValidateOnlyOverlapping(boolean validateOnlyOverlapping) {
         this.validateOnlyOverlapping = validateOnlyOverlapping;
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getAcceptableTokens();
-    }
-
-    @Override
-    public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.IDENT,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
     @Override
     public void beginTree(DetailAST rootAST) {
         frames = new HashMap<>();
         current = null;
 
         final Deque<AbstractFrame> frameStack = new LinkedList<>();
         DetailAST curNode = rootAST;
         while (curNode != null) {
             collectDeclarations(frameStack, curNode);
             DetailAST toVisit = curNode.getFirstChild();
             while (curNode != null && toVisit == null) {
                 endCollectingDeclarations(frameStack, curNode);
                 toVisit = curNode.getNextSibling();
                 if (toVisit == null) {
                     curNode = curNode.getParent();
                 }
             }
             curNode = toVisit;
         }
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.IDENT :
                 processIdent(ast);
                 break;
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
                 current = frames.get(ast);
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Checks if a given IDENT is method call or field name which
      * requires explicit {@code this} qualifier.
      * @param ast IDENT to check.
      */
     private void processIdent(DetailAST ast) {
         final int parentType = ast.getParent().getType();
         switch (parentType) {
             case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:
