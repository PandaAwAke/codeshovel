diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
index 789204af2..79c031f10 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
@@ -103,215 +103,227 @@ public class GenericWhitespaceCheck extends AbstractCheck {
     private int depth;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         // Reset for each tree, just increase there are errors in preceding
         // trees.
         depth = 0;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.GENERIC_START:
                 processStart(ast);
                 depth++;
                 break;
             case TokenTypes.GENERIC_END:
                 processEnd(ast);
                 depth--;
                 break;
             default:
                 throw new IllegalArgumentException("Unknown type " + ast);
         }
     }
 
     /**
      * Checks the token for the end of Generics.
      * @param ast the token to check
      */
     private void processEnd(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         if (before >= 0 && Character.isWhitespace(line.charAt(before))
-                && !CommonUtils.hasWhitespaceBefore(before, line)) {
+                && !containsWhitespaceBefore(before, line)) {
             log(ast.getLineNo(), before, MSG_WS_PRECEDED, CLOSE_ANGLE_BRACKET);
         }
 
         if (after < line.length()) {
 
             // Check if the last Generic, in which case must be a whitespace
             // or a '(),[.'.
             if (depth == 1) {
                 processSingleGeneric(ast, line, after);
             }
             else {
                 processNestedGenerics(ast, line, after);
             }
         }
     }
 
     /**
      * Process Nested generics.
      * @param ast token
      * @param line line content
      * @param after position after
      */
     private void processNestedGenerics(DetailAST ast, String line, int after) {
         // In a nested Generic type, so can only be a '>' or ',' or '&'
 
         // In case of several extends definitions:
         //
         //   class IntEnumValueType<E extends Enum<E> & IntEnum>
         //                                          ^
         //   should be whitespace if followed by & -+
         //
         final int indexOfAmp = line.indexOf('&', after);
-        if (indexOfAmp >= 0
+        if (indexOfAmp >= 1
             && containsWhitespaceBetween(after, indexOfAmp, line)) {
             if (indexOfAmp - after == 0) {
                 log(ast.getLineNo(), after, MSG_WS_NOT_PRECEDED, "&");
             }
             else if (indexOfAmp - after != 1) {
                 log(ast.getLineNo(), after, MSG_WS_FOLLOWED, CLOSE_ANGLE_BRACKET);
             }
         }
         else if (line.charAt(after) == ' ') {
             log(ast.getLineNo(), after, MSG_WS_FOLLOWED, CLOSE_ANGLE_BRACKET);
         }
     }
 
     /**
      * Process Single-generic.
      * @param ast token
      * @param line line content
      * @param after position after
      */
     private void processSingleGeneric(DetailAST ast, String line, int after) {
         final char charAfter = line.charAt(after);
 
         // Need to handle a number of cases. First is:
         //    Collections.<Object>emptySet();
         //                        ^
         //                        +--- whitespace not allowed
         if (isGenericBeforeMethod(ast)) {
             if (Character.isWhitespace(charAfter)) {
                 log(ast.getLineNo(), after, MSG_WS_FOLLOWED, CLOSE_ANGLE_BRACKET);
             }
         }
         else if (!isCharacterValidAfterGenericEnd(charAfter)) {
             log(ast.getLineNo(), after, MSG_WS_ILLEGAL_FOLLOW, CLOSE_ANGLE_BRACKET);
         }
     }
 
     /**
      * Is generic before method reference.
      * @param ast ast
      * @return true if generic before a method ref
      */
     private static boolean isGenericBeforeMethod(DetailAST ast) {
         return ast.getParent().getType() == TokenTypes.TYPE_ARGUMENTS
                 && ast.getParent().getParent().getType() == TokenTypes.DOT
                 && ast.getParent().getParent().getParent().getType() == TokenTypes.METHOD_CALL
                 || isAfterMethodReference(ast);
     }
 
     /**
      * Checks if current generic end ('>') is located after
      * {@link TokenTypes#METHOD_REF method reference operator}.
      * @param genericEnd {@link TokenTypes#GENERIC_END}
      * @return true if '>' follows after method reference.
      */
     private static boolean isAfterMethodReference(DetailAST genericEnd) {
         return genericEnd.getParent().getParent().getType() == TokenTypes.METHOD_REF;
     }
 
     /**
      * Checks the token for the start of Generics.
      * @param ast the token to check
      */
     private void processStart(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         // Need to handle two cases as in:
         //
         //   public static <T> Callable<T> callable(Runnable task, T result)
         //                 ^           ^
         //      ws reqd ---+           +--- whitespace NOT required
         //
         if (before >= 0) {
             // Detect if the first case
             final DetailAST parent = ast.getParent();
             final DetailAST grandparent = parent.getParent();
             if (parent.getType() == TokenTypes.TYPE_PARAMETERS
                 && (grandparent.getType() == TokenTypes.CTOR_DEF
                     || grandparent.getType() == TokenTypes.METHOD_DEF)) {
                 // Require whitespace
                 if (!Character.isWhitespace(line.charAt(before))) {
                     log(ast.getLineNo(), before, MSG_WS_NOT_PRECEDED, OPEN_ANGLE_BRACKET);
                 }
             }
             // Whitespace not required
             else if (Character.isWhitespace(line.charAt(before))
-                && !CommonUtils.hasWhitespaceBefore(before, line)) {
+                && !containsWhitespaceBefore(before, line)) {
                 log(ast.getLineNo(), before, MSG_WS_PRECEDED, OPEN_ANGLE_BRACKET);
             }
         }
 
         if (after < line.length()
                 && Character.isWhitespace(line.charAt(after))) {
             log(ast.getLineNo(), after, MSG_WS_FOLLOWED, OPEN_ANGLE_BRACKET);
         }
     }
 
     /**
      * Returns whether the specified string contains only whitespace between
      * specified indices.
      *
      * @param fromIndex the index to start the search from. Inclusive
      * @param toIndex the index to finish the search. Exclusive
      * @param line the line to check
      * @return whether there are only whitespaces (or nothing)
      */
     private static boolean containsWhitespaceBetween(int fromIndex, int toIndex, String line) {
         boolean result = true;
         for (int i = fromIndex; i < toIndex; i++) {
             if (!Character.isWhitespace(line.charAt(i))) {
                 result = false;
                 break;
             }
         }
         return result;
     }
 
+    /**
+     * Returns whether the specified string contains only whitespace up to specified index.
+     *
+     * @param before the index to start the search from. Inclusive
+     * @param line   the index to finish the search. Exclusive
+     * @return {@code true} if there are only whitespaces,
+     *     false if there is nothing before or some other characters
+     */
+    private static boolean containsWhitespaceBefore(int before, String line) {
+        return before != 0 && CommonUtils.hasWhitespaceBefore(before, line);
+    }
+
     /**
      * Checks whether given character is valid to be right after generic ends.
      * @param charAfter character to check
      * @return checks if given character is valid
      */
     private static boolean isCharacterValidAfterGenericEnd(char charAfter) {
         return charAfter == '(' || charAfter == ')'
             || charAfter == ',' || charAfter == '['
             || charAfter == '.' || charAfter == ':'
             || charAfter == ';'
             || Character.isWhitespace(charAfter);
     }
 }
