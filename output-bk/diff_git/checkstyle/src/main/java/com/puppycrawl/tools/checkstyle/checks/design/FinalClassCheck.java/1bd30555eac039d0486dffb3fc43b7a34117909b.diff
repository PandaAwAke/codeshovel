diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
index 0d0e9e361..e5ad78181 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
@@ -21,109 +21,109 @@ package com.puppycrawl.tools.checkstyle.checks.design;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FastStack;
 import com.puppycrawl.tools.checkstyle.api.ScopeUtils;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * <p>
  * Checks that class which has only private ctors
  * is declared as final.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="FinalClass"/&gt;
  * </pre>
  * @author o_sukhodolsky
  */
 public class FinalClassCheck
     extends Check
 {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "final.class";
 
     /** Keeps ClassDesc objects for stack of declared classes. */
     private final FastStack<ClassDesc> classes = FastStack.newInstance();
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[]{TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[]{TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         if (ast.getType() == TokenTypes.CLASS_DEF) {
-            final boolean isFinal = (modifiers != null)
+            final boolean isFinal = modifiers != null
                     && modifiers.branchContains(TokenTypes.FINAL);
-            final boolean isAbstract = (modifiers != null)
+            final boolean isAbstract = modifiers != null
                     && modifiers.branchContains(TokenTypes.ABSTRACT);
             classes.push(new ClassDesc(isFinal, isAbstract));
         }
         else if (!ScopeUtils.inEnumBlock(ast)) { //ctors in enums don't matter
             final ClassDesc desc = classes.peek();
-            if ((modifiers != null)
+            if (modifiers != null
                 && modifiers.branchContains(TokenTypes.LITERAL_PRIVATE))
             {
                 desc.reportPrivateCtor();
             }
             else {
                 desc.reportNonPrivateCtor();
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         if (ast.getType() != TokenTypes.CLASS_DEF) {
             return;
         }
 
         final ClassDesc desc = classes.pop();
         if (!desc.isDeclaredAsFinal()
             && !desc.isDeclaredAsAbstract()
             && desc.hasPrivateCtor()
             && !desc.hasNonPrivateCtor())
         {
             final String className =
                 ast.findFirstToken(TokenTypes.IDENT).getText();
             log(ast.getLineNo(), MSG_KEY, className);
         }
     }
 
     /** maintains information about class' ctors */
     private static final class ClassDesc
     {
         /** is class declared as final */
         private final boolean declaredAsFinal;
 
         /** is class declared as abstract */
         private final boolean declaredAsAbstract;
 
         /** does class have non-provate ctors */
         private boolean hasNonPrivateCtor;
 
         /** does class have private ctors */
         private boolean hasPrivateCtor;
 
         /**
          *  create a new ClassDesc instance.
          *  @param declaredAsFinal indicates if the
          *         class declared as final
          *  @param declaredAsAbstract indicates if the
          *         class declared as abstract
