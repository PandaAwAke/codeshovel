diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index cc32ef218..c4d2d6d57 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -389,101 +389,100 @@ public class CustomImportOrderCheck extends AbstractCheck {
      * @param regexp
      *        user value.
      */
     public final void setStandardPackageRegExp(Pattern regexp) {
         standardPackageRegExp = regexp;
     }
 
     /**
      * Sets thirdPartyRegExp specified by user.
      * @param regexp
      *        user value.
      */
     public final void setThirdPartyPackageRegExp(Pattern regexp) {
         thirdPartyPackageRegExp = regexp;
     }
 
     /**
      * Sets specialImportsRegExp specified by user.
      * @param regexp
      *        user value.
      */
     public final void setSpecialImportsRegExp(Pattern regexp) {
         specialImportsRegExp = regexp;
     }
 
     /**
      * Sets separateLineBetweenGroups specified by user.
      * @param value
      *        user value.
      */
     public final void setSeparateLineBetweenGroups(boolean value) {
         separateLineBetweenGroups = value;
     }
 
     /**
      * Sets sortImportsInGroupAlphabetically specified by user.
      * @param value
      *        user value.
      */
     public final void setSortImportsInGroupAlphabetically(boolean value) {
         sortImportsInGroupAlphabetically = value;
     }
 
     /**
      * Sets a custom import order from the rules in the string format specified
      * by user.
      * @param inputCustomImportOrder
      *        user value.
      */
     public final void setCustomImportOrderRules(final String inputCustomImportOrder) {
-        customImportOrderRules.clear();
         for (String currentState : GROUP_SEPARATOR_PATTERN.split(inputCustomImportOrder)) {
             addRulesToList(currentState);
         }
         customImportOrderRules.add(NON_GROUP_RULE_GROUP);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.IMPORT,
             TokenTypes.STATIC_IMPORT,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         importToGroupList.clear();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.PACKAGE_DEF) {
             if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
                 samePackageDomainsRegExp = createSamePackageRegexp(
                         samePackageMatchingDepth, ast);
             }
         }
         else {
             final String importFullPath = getFullImportIdent(ast);
             final int lineNo = ast.getLineNo();
             final boolean isStatic = ast.getType() == TokenTypes.STATIC_IMPORT;
             importToGroupList.add(new ImportDetails(importFullPath,
                     lineNo, getImportGroup(isStatic, importFullPath),
                     isStatic));
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
@@ -589,163 +588,166 @@ public class CustomImportOrderCheck extends AbstractCheck {
     }
 
     /**
      * Checks if current group contains any import.
      * @param currentGroup
      *        current group.
      * @return
      *        true, if current group contains at least one import.
      */
     private boolean hasAnyImportInCurrentGroup(String currentGroup) {
         boolean result = false;
         for (ImportDetails currentImport : importToGroupList) {
             if (currentGroup.equals(currentImport.getImportGroup())) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Get import valid group.
      * @param isStatic
      *        is static import.
      * @param importPath
      *        full import path.
      * @return import valid group.
      */
     private String getImportGroup(boolean isStatic, String importPath) {
         RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);
         if (isStatic && customImportOrderRules.contains(STATIC_RULE_GROUP)) {
             bestMatch.group = STATIC_RULE_GROUP;
             bestMatch.matchLength = importPath.length();
         }
         else if (customImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
             final String importPathTrimmedToSamePackageDepth =
                     getFirstDomainsFromIdent(samePackageMatchingDepth, importPath);
             if (samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth)) {
                 bestMatch.group = SAME_PACKAGE_RULE_GROUP;
                 bestMatch.matchLength = importPath.length();
             }
         }
         if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)) {
             for (String group : customImportOrderRules) {
                 if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {
                     bestMatch = findBetterPatternMatch(importPath,
                             STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackageRegExp, bestMatch);
                 }
                 if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {
                     bestMatch = findBetterPatternMatch(importPath,
-                            SPECIAL_IMPORTS_RULE_GROUP, specialImportsRegExp, bestMatch);
+                            group, specialImportsRegExp, bestMatch);
                 }
             }
         }
         if (bestMatch.group.equals(NON_GROUP_RULE_GROUP)
                 && customImportOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)
                 && thirdPartyPackageRegExp.matcher(importPath).find()) {
             bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;
         }
         return bestMatch.group;
     }
 
     /** Tries to find better matching regular expression:
      * longer matching substring wins; in case of the same length,
      * lower position of matching substring wins.
      * @param importPath
      *      Full import identifier
      * @param group
      *      Import group we are trying to assign the import
      * @param regExp
      *      Regular expression for import group
      * @param currentBestMatch
      *      object with currently best match
      * @return better match (if found) or the same (currentBestMatch)
      */
     private static RuleMatchForImport findBetterPatternMatch(String importPath, String group,
             Pattern regExp, RuleMatchForImport currentBestMatch) {
         RuleMatchForImport betterMatchCandidate = currentBestMatch;
         final Matcher matcher = regExp.matcher(importPath);
         while (matcher.find()) {
             final int length = matcher.end() - matcher.start();
             if (length > betterMatchCandidate.matchLength
                     || length == betterMatchCandidate.matchLength
                         && matcher.start() < betterMatchCandidate.matchPosition) {
                 betterMatchCandidate = new RuleMatchForImport(group, length, matcher.start());
             }
         }
         return betterMatchCandidate;
     }
 
     /**
      * Checks compare two import paths.
      * @param import1
      *        current import.
      * @param import2
      *        previous import.
      * @return a negative integer, zero, or a positive integer as the
      *        specified String is greater than, equal to, or less
      *        than this String, ignoring case considerations.
      */
     private static int compareImports(String import1, String import2) {
         int result = 0;
         final String separator = "\\.";
         final String[] import1Tokens = import1.split(separator);
         final String[] import2Tokens = import2.split(separator);
-        for (int i = 0; i < import1Tokens.length && i != import2Tokens.length; i++) {
+        for (int i = 0; i != import1Tokens.length && i != import2Tokens.length; i++) {
             final String import1Token = import1Tokens[i];
             final String import2Token = import2Tokens[i];
             result = import1Token.compareTo(import2Token);
             if (result != 0) {
                 break;
             }
         }
+        if (result == 0) {
+            result = Integer.compare(import1Tokens.length, import2Tokens.length);
+        }
         return result;
     }
 
     /**
      * Counts empty lines before given.
      * @param lineNo
      *        Line number of current import.
      * @return count of empty lines before given.
      */
     private int getCountOfEmptyLinesBefore(int lineNo) {
         int result = 0;
         final String[] lines = getLines();
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         int lineBeforeIndex = lineNo - 2;
         while (lineBeforeIndex >= 0
                 && CommonUtils.isBlank(lines[lineBeforeIndex])) {
             lineBeforeIndex--;
             result++;
         }
         return result;
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token) {
         String ident = "";
         if (token != null) {
             ident = FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
         }
         return ident;
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRulesToList(String ruleStr) {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
             customImportOrderRules.add(ruleStr);
 
         }
