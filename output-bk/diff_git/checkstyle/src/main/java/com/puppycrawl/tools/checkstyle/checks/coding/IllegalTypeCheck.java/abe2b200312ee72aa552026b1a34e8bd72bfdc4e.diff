diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index 380dc565a..07838012c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -100,100 +100,111 @@ public final class IllegalTypeCheck extends AbstractFormatCheck
     private static final String[] DEFAULT_ILLEGAL_TYPES = {
         "HashSet",
         "HashMap",
         "LinkedHashMap",
         "LinkedHashSet",
         "TreeSet",
         "TreeMap",
         "java.util.HashSet",
         "java.util.HashMap",
         "java.util.LinkedHashMap",
         "java.util.LinkedHashSet",
         "java.util.TreeSet",
         "java.util.TreeMap",
     };
 
     /** Default ignored method names. */
     private static final String[] DEFAULT_IGNORED_METHOD_NAMES = {
         "getInitialContext",
         "getEnvironment",
     };
 
     /** illegal classes. */
     private final Set<String> illegalClassNames = Sets.newHashSet();
     /** legal abstract classes. */
     private final Set<String> legalAbstractClassNames = Sets.newHashSet();
     /** methods which should be ignored. */
     private final Set<String> ignoredMethodNames = Sets.newHashSet();
     /** check methods and fields with only corresponding modifiers. */
     private List<Integer> memberModifiers;
 
     /** Creates new instance of the check. */
     public IllegalTypeCheck()
     {
         super(DEFAULT_FORMAT);
         setIllegalClassNames(DEFAULT_ILLEGAL_TYPES);
         setLegalAbstractClassNames(DEFAULT_LEGAL_ABSTRACT_NAMES);
         setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.IMPORT,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.VARIABLE_DEF,
+            TokenTypes.PARAMETER_DEF,
+            TokenTypes.METHOD_DEF,
+            TokenTypes.IMPORT,
+        };
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.METHOD_DEF:
                 if (isVerifiable(ast)) {
                     visitMethodDef(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (isVerifiable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 visitParameterDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Checks if current method's return type or variable's type is verifiable
      * according to <b>memberModifiers</b> option.
      * @param methodOrVariableDef METHOD_DEF or VARIABLE_DEF ast node.
      * @return true if member is verifiable according to <b>memberModifiers</b> option.
      */
     private boolean isVerifiable(DetailAST methodOrVariableDef)
     {
         boolean result = true;
         if (memberModifiers != null) {
             result = false;
             final DetailAST modifiersAst = methodOrVariableDef.
                     findFirstToken(TokenTypes.MODIFIERS);
             if (modifiersAst.getFirstChild() != null) {
                 for (DetailAST modifier = modifiersAst.getFirstChild(); modifier != null;
                          modifier = modifier.getNextSibling())
                 {
                     if (memberModifiers.contains(modifier.getType())) {
                         result = true;
                     }
                 }
             }
         }
         return result;
     }
