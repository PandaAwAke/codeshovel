diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
index 34638686a..87c288d5f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
@@ -1,287 +1,341 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.IOException;
 import java.lang.reflect.Constructor;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
 
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.utils.ModuleReflectionUtils;
 
 /**
  * A factory for creating objects from package names and names.
  * Consider the below example for better understanding.
  * <ul>
  *     <li>module name - name of java class that represents module;</li>
  *     <li>module full name - fully qualifies name of java class that represents module;</li>
  *     <li>check module short name - name of Check without 'Check' suffix;</li>
  *     <li>check module name - name of java class that represents Check (with 'Check' suffix);</li>
  *     <li>
  *         check module full name - fully qualifies name of java class
  *         that represents Check (with 'Check' suffix).
  *     </li>
  * </ul>
  * @author Rick Giles
  * @author lkuehne
  */
 public class PackageObjectFactory implements ModuleFactory {
     /** Base package of checkstyle modules checks. */
     public static final String BASE_PACKAGE = "com.puppycrawl.tools.checkstyle";
 
     /** Exception message when it is unable to create a class instance. */
     public static final String UNABLE_TO_INSTANTIATE_EXCEPTION_MESSAGE =
             "PackageObjectFactory.unableToInstantiateExceptionMessage";
 
+    /** Exception message when there is ambigugous module name in config file. */
+    public static final String AMBIGUOUS_MODULE_NAME_EXCEPTION_MESSAGE =
+            "PackageObjectFactory.ambiguousModuleNameExceptionMessage";
+
     /** Suffix of checks. */
     public static final String CHECK_SUFFIX = "Check";
 
     /** Character separate package names in qualified name of java class. */
     public static final String PACKAGE_SEPARATOR = ".";
 
     /** Exception message when null class loader is given. */
     public static final String NULL_LOADER_MESSAGE = "moduleClassLoader must not be null";
 
     /** Exception message when null package name is given. */
     public static final String NULL_PACKAGE_MESSAGE = "package name must not be null";
 
     /** Separator to use in strings. */
     public static final String STRING_SEPARATOR = ", ";
 
     /** Map of Checkstyle module names to their fully qualified names. */
     private static final Map<String, String> NAME_TO_FULL_MODULE_NAME = new HashMap<>();
 
     /** A list of package names to prepend to class names. */
     private final Set<String> packages;
 
     /** The class loader used to load Checkstyle core and custom modules. */
     private final ClassLoader moduleClassLoader;
 
-    /** Map of third party Checkstyle module names to their fully qualified names. */
-    private Map<String, String> thirdPartyNameToFullModuleName;
+    /** Map of third party Checkstyle module names to the set of their fully qualified names. */
+    private Map<String, Set<String>> thirdPartyNameToFullModuleNames;
 
     static {
         fillShortToFullModuleNamesMap();
     }
 
     /**
      * Creates a new {@code PackageObjectFactory} instance.
      * @param packageNames the list of package names to use
      * @param moduleClassLoader class loader used to load Checkstyle
      *          core and custom modules
      */
     public PackageObjectFactory(Set<String> packageNames, ClassLoader moduleClassLoader) {
         if (moduleClassLoader == null) {
             throw new IllegalArgumentException(NULL_LOADER_MESSAGE);
         }
         if (packageNames.contains(null)) {
             throw new IllegalArgumentException(NULL_PACKAGE_MESSAGE);
         }
 
         //create a copy of the given set, but retain ordering
         packages = new LinkedHashSet<>(packageNames);
         this.moduleClassLoader = moduleClassLoader;
     }
 
     /**
      * Creates a new {@code PackageObjectFactory} instance.
      * @param packageName The package name to use
      * @param moduleClassLoader class loader used to load Checkstyle
      *          core and custom modules
      */
     public PackageObjectFactory(String packageName, ClassLoader moduleClassLoader) {
         if (moduleClassLoader == null) {
             throw new IllegalArgumentException(NULL_LOADER_MESSAGE);
         }
         if (packageName == null) {
             throw new IllegalArgumentException(NULL_PACKAGE_MESSAGE);
         }
 
         packages = new LinkedHashSet<>(1);
         packages.add(packageName);
         this.moduleClassLoader = moduleClassLoader;
     }
 
     /**
      * Creates a new instance of a class from a given name, or that name
      * concatenated with &quot;Check&quot;. If the name is
      * a class name, creates an instance of the named class. Otherwise, creates
      * an instance of a class name obtained by concatenating the given name
      * to a package name from a given list of package names.
      * @param name the name of a class.
      * @return the {@code Object} created by loader.
      * @throws CheckstyleException if an error occurs.
      */
     @Override
     public Object createModule(String name) throws CheckstyleException {
         Object instance = null;
         // if the name is a simple class name, try to find it in maps at first
         if (!name.contains(PACKAGE_SEPARATOR)) {
-            instance = createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME);
+            // find the name in hardcode map
+            final String fullModuleName = NAME_TO_FULL_MODULE_NAME.get(name);
+            if (fullModuleName == null) {
+                final String fullCheckModuleName =
+                        NAME_TO_FULL_MODULE_NAME.get(name + CHECK_SUFFIX);
+                if (fullCheckModuleName != null) {
+                    instance = createObject(fullCheckModuleName);
+                }
+            }
+            else {
+                instance = createObject(fullModuleName);
+            }
+
+            // find the name in third party map
             if (instance == null) {
-                if (thirdPartyNameToFullModuleName == null) {
-                    thirdPartyNameToFullModuleName =
+                if (thirdPartyNameToFullModuleNames == null) {
+                    thirdPartyNameToFullModuleNames =
                             generateThirdPartyNameToFullModuleName(moduleClassLoader);
                 }
-                instance = createObjectFromMap(name, thirdPartyNameToFullModuleName);
+                instance = createObjectFromMap(name, thirdPartyNameToFullModuleNames);
             }
         }
 
         if (instance == null) {
             instance = createObject(name);
         }
         final String nameCheck = name + CHECK_SUFFIX;
         if (instance == null) {
             instance = createObject(nameCheck);
         }
         if (instance == null) {
             final String attemptedNames = joinPackageNamesWithClassName(name, packages)
                     + STRING_SEPARATOR + nameCheck + STRING_SEPARATOR
                     + joinPackageNamesWithClassName(nameCheck, packages);
             final LocalizedMessage exceptionMessage = new LocalizedMessage(0,
                 Definitions.CHECKSTYLE_BUNDLE, UNABLE_TO_INSTANTIATE_EXCEPTION_MESSAGE,
                 new String[] {name, attemptedNames}, null, getClass(), null);
             throw new CheckstyleException(exceptionMessage.getMessage());
         }
         return instance;
     }
 
     /**
      * Create object with the help of the supplied map.
      * @param name name of module.
      * @param map the supplied map.
-     * @return instance of module if it is found in modules map.
-     * @throws CheckstyleException if the class fails to instantiate.
+     * @return instance of module if it is found in modules map and no ambiguous classes exist.
+     * @throws CheckstyleException if the class fails to instantiate or there are ambiguous classes.
      */
-    private Object createObjectFromMap(String name, Map<String, String> map)
+    private Object createObjectFromMap(String name, Map<String, Set<String>> map)
             throws CheckstyleException {
-        final String fullModuleName = map.get(name);
+        final Set<String> fullModuleNames = map.get(name);
         Object instance = null;
-        if (fullModuleName == null) {
-            final String fullCheckModuleName = map.get(name + CHECK_SUFFIX);
-            if (fullCheckModuleName != null) {
-                instance = createObject(fullCheckModuleName);
+        if (fullModuleNames == null) {
+            final Set<String> fullCheckModuleNames = map.get(name + CHECK_SUFFIX);
+            if (fullCheckModuleNames != null) {
+                instance = createObjectFromFullModuleNames(name, fullCheckModuleNames);
             }
         }
         else {
-            instance = createObject(fullModuleName);
+            instance = createObjectFromFullModuleNames(name, fullModuleNames);
         }
         return instance;
     }
 
     /**
-     * Generate the map of third party Checkstyle module names to their fully qualified names.
+     * Create Object from optional full module names.
+     * In most case, there should be only one element in {@code fullModuleName}, otherwise
+     * an exception would be thrown.
+     * @param name name of module
+     * @param fullModuleNames the supplied full module names set
+     * @return instance of module if there is only one element in {@code fullModuleName}
+     * @throws CheckstyleException if the class fails to instantiate or there are more than one
+     *      element in {@code fullModuleName}
+     */
+    private Object createObjectFromFullModuleNames(String name, Set<String> fullModuleNames)
+            throws CheckstyleException {
+        final Object returnValue;
+        if (fullModuleNames.size() == 1) {
+            returnValue = createObject(fullModuleNames.iterator().next());
+        }
+        else {
+            final String optionalNames = fullModuleNames.stream()
+                    .sorted()
+                    .collect(Collectors.joining(STRING_SEPARATOR));
+            final LocalizedMessage exceptionMessage = new LocalizedMessage(0,
+                    Definitions.CHECKSTYLE_BUNDLE, AMBIGUOUS_MODULE_NAME_EXCEPTION_MESSAGE,
+                    new String[] {name, optionalNames}, null, getClass(), null);
+            throw new CheckstyleException(exceptionMessage.getMessage());
+        }
+        return returnValue;
+    }
+
+    /**
+     * Generate the map of third party Checkstyle module names to the set of their fully qualified
+     * names.
      * @param loader the class loader used to load Checkstyle package names
-     * @return the map of third party Checkstyle module names to their fully qualified names
+     * @return the map of third party Checkstyle module names to the set of their fully qualified
+     *      names
      */
-    private Map<String, String> generateThirdPartyNameToFullModuleName(ClassLoader loader) {
-        Map<String, String> returnValue;
+    private Map<String, Set<String>> generateThirdPartyNameToFullModuleName(ClassLoader loader) {
+        Map<String, Set<String>> returnValue;
         try {
             returnValue = ModuleReflectionUtils.getCheckstyleModules(packages, loader).stream()
-                .filter(clazz -> !NAME_TO_FULL_MODULE_NAME.keySet().contains(clazz.getSimpleName()))
-                .collect(Collectors.toMap(Class::getSimpleName, Class::getCanonicalName));
+                    .collect(Collectors.toMap(
+                        Class::getSimpleName,
+                        cls -> Collections.singleton(cls.getCanonicalName()),
+                        (fullNames1, fullNames2) -> {
+                            final Set<String> mergedNames = new LinkedHashSet<>(fullNames1);
+                            mergedNames.addAll(fullNames2);
+                            return mergedNames;
+                        }));
         }
         catch (IOException ignore) {
             returnValue = new HashMap<>();
         }
         return returnValue;
     }
 
     /**
      * Creates a string by joining package names with a class name.
      * @param className name of the class for joining.
      * @param packages packages names.
      * @return a string which is obtained by joining package names with a class name.
      */
     private static String joinPackageNamesWithClassName(String className, Set<String> packages) {
         return packages.stream()
             .collect(Collectors.joining(
                     className + STRING_SEPARATOR, "", PACKAGE_SEPARATOR + className));
     }
 
     /**
      * Creates a new instance of a named class.
      * @param className the name of the class to instantiate.
      * @return the {@code Object} created by loader or null.
      * @throws CheckstyleException if the class fails to instantiate.
      */
     private Object createObject(String className) throws CheckstyleException {
         Class<?> clazz = null;
 
         try {
             clazz = Class.forName(className, true, moduleClassLoader);
         }
         catch (final ReflectiveOperationException | NoClassDefFoundError ignored) {
-            // keep looking, ignoring exception
+            // ignore the exception
         }
 
         Object instance = null;
 
         if (clazz != null) {
             try {
                 final Constructor<?> declaredConstructor = clazz.getDeclaredConstructor();
                 declaredConstructor.setAccessible(true);
                 instance = declaredConstructor.newInstance();
             }
             catch (final ReflectiveOperationException ex) {
                 throw new CheckstyleException("Unable to instantiate " + className, ex);
             }
         }
 
         return instance;
     }
 
     /**
      * Fill short-to-full module names map.
      */
     private static void fillShortToFullModuleNamesMap() {
         fillChecksFromAnnotationPackage();
         fillChecksFromBlocksPackage();
         fillChecksFromCodingPackage();
         fillChecksFromDesignPackage();
         fillChecksFromHeaderPackage();
         fillChecksFromImportsPackage();
         fillChecksFromIndentationPackage();
         fillChecksFromJavadocPackage();
         fillChecksFromMetricsPackage();
         fillChecksFromModifierPackage();
         fillChecksFromNamingPackage();
         fillChecksFromRegexpPackage();
         fillChecksFromSizesPackage();
         fillChecksFromWhitespacePackage();
         fillModulesFromChecksPackage();
         fillModulesFromFilefiltersPackage();
         fillModulesFromFiltersPackage();
         fillModulesFromCheckstylePackage();
     }
 
     /**
      * Fill short-to-full module names map with Checks from annotation package.
      */
     private static void fillChecksFromAnnotationPackage() {
         NAME_TO_FULL_MODULE_NAME.put("AnnotationLocationCheck",
                 BASE_PACKAGE + ".checks.annotation.AnnotationLocationCheck");
         NAME_TO_FULL_MODULE_NAME.put("AnnotationUseStyleCheck",
                 BASE_PACKAGE + ".checks.annotation.AnnotationUseStyleCheck");
