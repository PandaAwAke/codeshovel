diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index ac2056ec7..17efdf3da 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -515,110 +515,112 @@ public class FinalLocalVariableCheck extends AbstractCheck {
     private static boolean isAssignOperator(int parentType) {
         return Arrays.binarySearch(ASSIGN_OPERATOR_TYPES, parentType) >= 0;
     }
 
     /**
      * Checks if current variable is defined in
      *  {@link TokenTypes#FOR_INIT for-loop init}, e.g.:
      * <p>
      * {@code
      * for (int i = 0, j = 0; i < j; i++) { . . . }
      * }
      * </p>
      * {@code i, j} are defined in {@link TokenTypes#FOR_INIT for-loop init}
      * @param variableDef variable definition node.
      * @return true if variable is defined in {@link TokenTypes#FOR_INIT for-loop init}
      */
     private static boolean isVariableInForInit(DetailAST variableDef) {
         return variableDef.getParent().getType() == TokenTypes.FOR_INIT;
     }
 
     /**
      * Determines whether an AST is a descendant of an abstract or native method.
      * @param ast the AST to check.
      * @return true if ast is a descendant of an abstract or native method.
      */
     private static boolean isInAbstractOrNativeMethod(DetailAST ast) {
         boolean abstractOrNative = false;
         DetailAST parent = ast.getParent();
         while (parent != null && !abstractOrNative) {
             if (parent.getType() == TokenTypes.METHOD_DEF) {
                 final DetailAST modifiers =
                     parent.findFirstToken(TokenTypes.MODIFIERS);
                 abstractOrNative = modifiers.branchContains(TokenTypes.ABSTRACT)
                         || modifiers.branchContains(TokenTypes.LITERAL_NATIVE);
             }
             parent = parent.getParent();
         }
         return abstractOrNative;
     }
 
     /**
      * Check if current param is lambda's param.
      * @param paramDef {@link TokenTypes#PARAMETER_DEF parameter def}.
      * @return true if current param is lambda's param.
      */
     private static boolean isInLambda(DetailAST paramDef) {
         return paramDef.getParent().getParent().getType() == TokenTypes.LAMBDA;
     }
 
     /**
-     * Find the Class, Constructor, Enum or Method in which it is defined.
+     * Find the Class, Constructor, Enum, Method, or Field in which it is defined.
      * @param ast Variable for which we want to find the scope in which it is defined
      * @return ast The Class or Constructor or Method in which it is defined.
      */
     private static DetailAST findFirstUpperNamedBlock(DetailAST ast) {
         DetailAST astTraverse = ast;
         while (astTraverse.getType() != TokenTypes.METHOD_DEF
                 && astTraverse.getType() != TokenTypes.CLASS_DEF
                 && astTraverse.getType() != TokenTypes.ENUM_DEF
-                && astTraverse.getType() != TokenTypes.CTOR_DEF) {
+                && astTraverse.getType() != TokenTypes.CTOR_DEF
+                && (astTraverse.getType() != TokenTypes.VARIABLE_DEF
+                        || !ScopeUtils.isClassFieldDef(astTraverse))) {
             astTraverse = astTraverse.getParent();
         }
         return astTraverse;
     }
 
     /**
      * Check if both the Variables are same.
      * @param ast1 Variable to compare
      * @param ast2 Variable to compare
      * @return true if both the variables are same, otherwise false
      */
     private static boolean isSameVariables(DetailAST ast1, DetailAST ast2) {
         final DetailAST classOrMethodOfAst1 =
             findFirstUpperNamedBlock(ast1);
         final DetailAST classOrMethodOfAst2 =
             findFirstUpperNamedBlock(ast2);
         return classOrMethodOfAst1 == classOrMethodOfAst2;
     }
 
     /**
      * Check if both the variables are in the same loop.
      * @param ast1 variable to compare.
      * @param ast2 variable to compare.
      * @return true if both the variables are in the same loop.
      */
     private static boolean isInTheSameLoop(DetailAST ast1, DetailAST ast2) {
         DetailAST loop1 = ast1.getParent();
         while (loop1 != null && !isLoopAst(loop1.getType())) {
             loop1 = loop1.getParent();
         }
         DetailAST loop2 = ast2.getParent();
         while (loop2 != null && !isLoopAst(loop2.getType())) {
             loop2 = loop2.getParent();
         }
         return loop1 != null && loop1 == loop2;
     }
 
     /**
      * Checks whether the ast is a loop.
      * @param ast the ast to check.
      * @return true if the ast is a loop.
      */
     private static boolean isLoopAst(int ast) {
         return Arrays.binarySearch(LOOP_TYPES, ast) >= 0;
     }
 
     /**
      * Holder for the scope data.
      */
     private static class ScopeData {
