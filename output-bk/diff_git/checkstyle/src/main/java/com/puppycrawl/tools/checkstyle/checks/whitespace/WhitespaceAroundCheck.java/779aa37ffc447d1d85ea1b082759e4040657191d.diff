diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index a7ebb1edb..ae46406a2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -290,173 +290,230 @@ public class WhitespaceAroundCheck extends Check {
             TokenTypes.LITERAL_ASSERT,
             TokenTypes.TYPE_EXTENSION_AND,
             TokenTypes.WILDCARD_TYPE,
         };
     }
 
     /**
      * Sets whether or not empty method bodies are allowed.
      * @param allow <code>true</code> to allow empty method bodies.
      */
     public void setAllowEmptyMethods(boolean allow) {
         allowEmptyMethods = allow;
     }
 
     /**
      * Sets whether or not empty constructor bodies are allowed.
      * @param allow <code>true</code> to allow empty constructor bodies.
      */
     public void setAllowEmptyConstructors(boolean allow) {
         allowEmptyCtors = allow;
     }
 
     /**
      * Sets whether or not to ignore the whitespace around the
      * colon in an enhanced for loop.
      * @param ignore <code>true</code> to ignore enhanced for colon.
      */
     public void setIgnoreEnhancedForColon(boolean ignore) {
         ignoreEnhancedForColon = ignore;
     }
 
     /**
      * Sets whether or not empty type bodies are allowed.
      * @param allow <code>true</code> to allow empty type bodies.
      */
     public void setAllowEmptyTypes(boolean allow) {
         allowEmptyTypes = allow;
     }
 
     /**
      * Sets whether or not empty loop bodies are allowed.
      * @param allow <code>true</code> to allow empty loops bodies.
      */
     public void setAllowEmptyLoops(boolean allow) {
         allowEmptyLoops = allow;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int currentType = ast.getType();
+        if (isNotRelevantSituation(ast, currentType)) {
+            return;
+        }
+
+        final String line = getLine(ast.getLineNo() - 1);
+        final int before = ast.getColumnNo() - 1;
+        final int after = ast.getColumnNo() + ast.getText().length();
+
+        if (before >= 0 && !Character.isWhitespace(line.charAt(before))) {
+            log(ast.getLineNo(), ast.getColumnNo(),
+                    WS_NOT_PRECEDED, ast.getText());
+        }
+
+        if (after >= line.length()) {
+            return;
+        }
+
+        final char nextChar = line.charAt(after);
+        if (!Character.isWhitespace(nextChar)
+            // Check for "return;"
+            && !(currentType == TokenTypes.LITERAL_RETURN
+                && ast.getFirstChild().getType() == TokenTypes.SEMI)
+            && !isAnnonimousInnerClassEnd(currentType, nextChar)) {
+
+            log(ast.getLineNo(), ast.getColumnNo() + ast.getText().length(),
+                    WS_NOT_FOLLOWED, ast.getText());
+        }
+    }
+
+    /**
+     * Check for "})" or "};" or "},". Happens with anon-inners
+     * @param currentType token
+     * @param nextChar next symbol
+     * @return true is that is end of anon inner class
+     */
+    private boolean isAnnonimousInnerClassEnd(int currentType, char nextChar) {
+        return currentType == TokenTypes.RCURLY
+            && (nextChar == ')'
+                || nextChar == ';'
+                || nextChar == ','
+                || nextChar == '.');
+    }
+
+    /**
+     * is ast is not a target of Check
+     * @param ast ast
+     * @param currentType type of ast
+     * @return true is ok to skip validation
+     */
+    private boolean isNotRelevantSituation(DetailAST ast, int currentType) {
         final int parentType = ast.getParent().getType();
 
         // Check for CURLY in array initializer
-        if ((currentType == TokenTypes.RCURLY
-                || currentType == TokenTypes.LCURLY)
-            && (parentType == TokenTypes.ARRAY_INIT
-                || parentType == TokenTypes.ANNOTATION_ARRAY_INIT)) {
-            return;
+        if (isArrayInitialization(currentType, parentType)) {
+            return true;
         }
 
         // Check for import pkg.name.*;
         if (currentType == TokenTypes.STAR
             && parentType == TokenTypes.DOT) {
-            return;
+            return true;
         }
 
         // Check for an SLIST that has a parent CASE_GROUP. It is not a '{'.
         if (currentType == TokenTypes.SLIST
             && parentType == TokenTypes.CASE_GROUP) {
-            return;
+            return true;
         }
 
-        if (currentType == TokenTypes.COLON) {
-            //we do not want to check colon for cases and defaults
-            if (parentType == TokenTypes.LITERAL_DEFAULT
-                || parentType == TokenTypes.LITERAL_CASE) {
-                return;
-            }
-            else if (parentType == TokenTypes.FOR_EACH_CLAUSE
-                && this.ignoreEnhancedForColon) {
-                return;
-            }
+        if (isColonOfCaseOrDefault(currentType, parentType)) {
+            return true;
         }
 
         // Checks if empty methods, ctors or loops are allowed.
-        if (isEmptyMethodBlock(ast, parentType)
-                || isEmptyCtorBlock(ast, parentType)
-                || isEmptyLoop(ast, parentType)) {
-            return;
+        if (isEmptyBlock(ast, parentType)) {
+            return true;
         }
 
         // Checks if empty classes, interfaces or enums are allowed
         if (allowEmptyTypes && isEmptyType(ast, parentType)) {
-            return;
+            return true;
         }
 
-        final String line = getLine(ast.getLineNo() - 1);
-        final int before = ast.getColumnNo() - 1;
-        final int after = ast.getColumnNo() + ast.getText().length();
+        return false;
+    }
 
-        if (before >= 0 && !Character.isWhitespace(line.charAt(before))) {
-            log(ast.getLineNo(), ast.getColumnNo(),
-                    WS_NOT_PRECEDED, ast.getText());
-        }
+    /**
+     * is empty block
+     * @param ast ast
+     * @param parentType parent
+     * @return true is block is empty
+     */
+    private boolean isEmptyBlock(DetailAST ast, int parentType) {
+        return isEmptyMethodBlock(ast, parentType)
+                || isEmptyCtorBlock(ast, parentType)
+                || isEmptyLoop(ast, parentType);
+    }
 
-        if (after >= line.length()) {
-            return;
+    /**
+     * we do not want to check colon for cases and defaults
+     * @param currentType current
+     * @param parentType parent
+     * @return true is cur token in colon of case or default tokens
+     */
+    private boolean isColonOfCaseOrDefault(int currentType, int parentType) {
+        if (currentType == TokenTypes.COLON) {
+            //we do not want to check colon for cases and defaults
+            if (parentType == TokenTypes.LITERAL_DEFAULT
+                || parentType == TokenTypes.LITERAL_CASE) {
+                return true;
+            }
+            else if (parentType == TokenTypes.FOR_EACH_CLAUSE
+                && this.ignoreEnhancedForColon) {
+                return true;
+            }
         }
+        return false;
+    }
 
-        final char nextChar = line.charAt(after);
-        if (!Character.isWhitespace(nextChar)
-            // Check for "return;"
-            && !(currentType == TokenTypes.LITERAL_RETURN
-                && ast.getFirstChild().getType() == TokenTypes.SEMI)
-            // Check for "})" or "};" or "},". Happens with anon-inners
-            && !(currentType == TokenTypes.RCURLY
-                && (nextChar == ')'
-                    || nextChar == ';'
-                    || nextChar == ','
-                    || nextChar == '.'))) {
-            log(ast.getLineNo(), ast.getColumnNo() + ast.getText().length(),
-                    WS_NOT_FOLLOWED, ast.getText());
-        }
+    /**
+     * is array initialization
+     * @param currentType curret token
+     * @param parentType parent token
+     * @return true is current token inside array initialization
+     */
+    private boolean isArrayInitialization(int currentType, int parentType) {
+        return (currentType == TokenTypes.RCURLY
+                || currentType == TokenTypes.LCURLY)
+            && (parentType == TokenTypes.ARRAY_INIT
+                || parentType == TokenTypes.ANNOTATION_ARRAY_INIT);
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * method block.
      * @param ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty method block.
      */
     private boolean isEmptyMethodBlock(DetailAST ast, int parentType) {
         return allowEmptyMethods
             && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * constructor (ctor) block.
      * @param ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty constructor block.
      */
     private boolean isEmptyCtorBlock(DetailAST ast, int parentType) {
         return allowEmptyCtors
             && isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
      * @param ast ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty loop block.
      */
     private boolean isEmptyLoop(DetailAST ast, int parentType) {
         return allowEmptyLoops
             && (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)
                     || isEmptyBlock(ast,
                             parentType, TokenTypes.LITERAL_WHILE)
                             || isEmptyBlock(ast,
                                     parentType, TokenTypes.LITERAL_DO));
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
