diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index d975f5c63..f0e5ed31b 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -1,131 +1,130 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2016 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.File;
 import java.io.Reader;
 import java.io.StringReader;
 import java.util.AbstractMap.SimpleEntry;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map.Entry;
 import java.util.Set;
 
 import antlr.CommonHiddenStreamToken;
 import antlr.RecognitionException;
 import antlr.Token;
 import antlr.TokenStreamException;
 import antlr.TokenStreamHiddenTokenFilter;
 import antlr.TokenStreamRecognitionException;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Sets;
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.api.Context;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;
 import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.FileText;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.grammars.GeneratedJavaLexer;
 import com.puppycrawl.tools.checkstyle.grammars.GeneratedJavaRecognizer;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
 
 /**
  * Responsible for walking an abstract syntax tree and notifying interested
  * checks at each each node.
  *
  * @author Oliver Burn
  */
 public final class TreeWalker extends AbstractFileSetCheck implements ExternalResourceHolder {
 
     /** Default distance between tab stops. */
     private static final int DEFAULT_TAB_WIDTH = 8;
 
     /** Maps from token name to ordinary checks. */
     private final Multimap<String, AbstractCheck> tokenToOrdinaryChecks =
         HashMultimap.create();
 
     /** Maps from token name to comment checks. */
     private final Multimap<String, AbstractCheck> tokenToCommentChecks =
             HashMultimap.create();
 
     /** Registered ordinary checks, that don't use comment nodes. */
-    private final Set<AbstractCheck> ordinaryChecks = Sets.newHashSet();
+    private final Set<AbstractCheck> ordinaryChecks = new HashSet<>();
 
     /** Registered comment checks. */
-    private final Set<AbstractCheck> commentChecks = Sets.newHashSet();
+    private final Set<AbstractCheck> commentChecks = new HashSet<>();
 
     /** The distance between tab stops. */
     private int tabWidth = DEFAULT_TAB_WIDTH;
 
     /** Class loader to resolve classes with. **/
     private ClassLoader classLoader;
 
     /** Context of child components. */
     private Context childContext;
 
     /** A factory for creating submodules (i.e. the Checks) */
     private ModuleFactory moduleFactory;
 
     /**
      * Creates a new {@code TreeWalker} instance.
      */
     public TreeWalker() {
         setFileExtensions("java");
     }
 
     /**
      * Sets tab width.
      * @param tabWidth the distance between tab stops
      */
     public void setTabWidth(int tabWidth) {
         this.tabWidth = tabWidth;
     }
 
     /**
      * Sets cache file.
      * @deprecated Use {@link Checker#setCacheFile} instead. It does not do anything now. We just
      *             keep the setter for transition period to the same option in Checker. The
      *             method will be completely removed in Checkstyle 8.0. See
      *             <a href="https://github.com/checkstyle/checkstyle/issues/2883">issue#2883</a>
      * @param fileName the cache file
      */
     @Deprecated
     public void setCacheFile(String fileName) {
         // Deprecated
     }
 
     /**
      * @param classLoader class loader to resolve classes with.
      */
     public void setClassLoader(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 
     /**
      * Sets the module factory for creating child modules (Checks).
@@ -431,101 +430,101 @@ public final class TreeWalker extends AbstractFileSetCheck implements ExternalRe
         final TokenStreamHiddenTokenFilter filter =
                 new TokenStreamHiddenTokenFilter(lexer);
         filter.hide(TokenTypes.SINGLE_LINE_COMMENT);
         filter.hide(TokenTypes.BLOCK_COMMENT_BEGIN);
 
         final GeneratedJavaRecognizer parser =
             new GeneratedJavaRecognizer(filter);
         parser.setFilename(contents.getFileName());
         parser.setASTNodeClass(DetailAST.class.getName());
         parser.compilationUnit();
 
         return (DetailAST) parser.getAST();
     }
 
     /**
      * Parses Java source file. Result AST contains comment nodes.
      * @param contents source file content
      * @return DetailAST tree
      * @throws RecognitionException if parser failed
      * @throws TokenStreamException if lexer failed
      */
     public static DetailAST parseWithComments(FileContents contents)
             throws RecognitionException, TokenStreamException {
         return appendHiddenCommentNodes(parse(contents));
     }
 
     @Override
     public void destroy() {
         ordinaryChecks.forEach(AbstractCheck::destroy);
         commentChecks.forEach(AbstractCheck::destroy);
         super.destroy();
     }
 
     @Override
     public Set<String> getExternalResourceLocations() {
         final Set<String> orinaryChecksResources = getExternalResourceLocations(ordinaryChecks);
         final Set<String> commentChecksResources = getExternalResourceLocations(commentChecks);
         final int resultListSize = orinaryChecksResources.size() + commentChecksResources.size();
         final Set<String> resourceLocations = new HashSet<>(resultListSize);
         resourceLocations.addAll(orinaryChecksResources);
         resourceLocations.addAll(commentChecksResources);
         return resourceLocations;
     }
 
     /**
      * Returns a set of external configuration resource locations which are used by the checks set.
      * @param checks a set of checks.
      * @return a set of external configuration resource locations which are used by the checks set.
      */
     private static Set<String> getExternalResourceLocations(Set<AbstractCheck> checks) {
-        final Set<String> externalConfigurationResources = Sets.newHashSet();
+        final Set<String> externalConfigurationResources = new HashSet<>();
         checks.stream().filter(check -> check instanceof ExternalResourceHolder).forEach(check -> {
             final Set<String> checkExternalResources =
                 ((ExternalResourceHolder) check).getExternalResourceLocations();
             externalConfigurationResources.addAll(checkExternalResources);
         });
         return externalConfigurationResources;
     }
 
     /**
      * Processes a node calling interested checks at each node.
      * Uses iterative algorithm.
      * @param root the root of tree for process
      * @param astState state of AST.
      */
     private void processIter(DetailAST root, AstState astState) {
         DetailAST curNode = root;
         while (curNode != null) {
             notifyVisit(curNode, astState);
             DetailAST toVisit = curNode.getFirstChild();
             while (curNode != null && toVisit == null) {
                 notifyLeave(curNode, astState);
                 toVisit = curNode.getNextSibling();
                 if (toVisit == null) {
                     curNode = curNode.getParent();
                 }
             }
             curNode = toVisit;
         }
     }
 
     /**
      * Appends comment nodes to existing AST.
      * It traverses each node in AST, looks for hidden comment tokens
      * and appends found comment tokens as nodes in AST.
      * @param root
      *        root of AST.
      * @return root of AST with comment nodes.
      */
     private static DetailAST appendHiddenCommentNodes(DetailAST root) {
         DetailAST result = root;
         DetailAST curNode = root;
         DetailAST lastNode = root;
 
         while (curNode != null) {
             if (isPositionGreater(curNode, lastNode)) {
                 lastNode = curNode;
             }
 
             CommonHiddenStreamToken tokenBefore = curNode.getHiddenBefore();
             DetailAST currentSibling = curNode;
