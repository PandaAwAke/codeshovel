diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index 9463638c9..1f05a3aa0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -195,129 +195,129 @@ final class PropertyCacheFile {
      * @param object serializable object.
      * @return the hashcode for serializable object.
      */
     private static String getHashCodeBasedOnObjectContent(Serializable object) {
         try {
             // im-memory serialization of Configuration
 
             final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             ObjectOutputStream oos = null;
             try {
                 oos = new ObjectOutputStream(outputStream);
                 oos.writeObject(object);
             }
             finally {
                 flushAndCloseOutStream(oos);
             }
 
             // Instead of hexEncoding outputStream.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             final MessageDigest digest = MessageDigest.getInstance("SHA-1");
             digest.update(outputStream.toByteArray());
 
             return DatatypeConverter.printHexBinary(digest.digest());
         }
         catch (final IOException | NoSuchAlgorithmException ex) {
             // rethrow as unchecked exception
             throw new IllegalStateException("Unable to calculate hashcode.", ex);
         }
     }
 
     /**
      * Puts external resources in cache.
      * If at least one external resource changed, clears the cache.
      * @param locations locations of external resources.
      */
     public void putExternalResources(Set<String> locations) {
         final Set<ExternalResource> resources = loadExternalResources(locations);
         if (areExternalResourcesChanged(resources)) {
             details.clear();
         }
         fillCacheWithExternalResources(resources);
     }
 
     /**
      * Loads a set of {@link ExternalResource} based on their locations.
      * @param resourceLocations locations of external configuration resources.
      * @return a set of {@link ExternalResource}.
      */
-    private Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {
+    private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {
         final Set<ExternalResource> resources = Sets.newHashSet();
         for (String location : resourceLocations) {
             String contentHashSum = null;
             try {
                 final byte[] content = loadExternalResource(location);
                 contentHashSum = getHashCodeBasedOnObjectContent(content);
             }
             catch (CheckstyleException ex) {
                 // if exception happened (configuration resource was not found, connection is not
                 // available, resouce is broken, etc), we need to calculate hash sum based on
                 // exception object content in order to check whether problem is resolved later
                 // and/or the configuration is changed.
                 contentHashSum = getHashCodeBasedOnObjectContent(ex);
             }
             finally {
                 resources.add(new ExternalResource(location, contentHashSum));
             }
         }
         return resources;
     }
 
     /**
      * Loads the content of external resource.
      * @param location external resource location.
      * @return array of bytes which respresents the content of external resource in binary form.
      * @throws CheckstyleException if error while loading occurs.
      */
-    private byte[] loadExternalResource(String location) throws CheckstyleException {
+    private static byte[] loadExternalResource(String location) throws CheckstyleException {
         byte[] content = null;
         final URI uri = CommonUtils.getUriByFilename(location);
         InputStream resourceReader = null;
         try {
             resourceReader = new BufferedInputStream(uri.toURL().openStream());
             final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             final byte[] data = new byte[BUFFER_SIZE];
             int bytesRead = resourceReader.read(data, 0, data.length);
             while (bytesRead != -1) {
                 outputStream.write(data, 0, bytesRead);
                 bytesRead = resourceReader.read(data, 0, data.length);
             }
             outputStream.flush();
             content = outputStream.toByteArray();
         }
         catch (IOException ex) {
             throw new CheckstyleException("Unable to load external resource file " + location, ex);
         }
         finally {
             Closeables.closeQuietly(resourceReader);
         }
         return content;
     }
 
     /**
      * Checks whether the contents of external configuration resources were changed.
      * @param resources a set of {@link ExternalResource}.
      * @return true if the contents of external configuration resources were changed.
      */
     private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {
         return Iterables.tryFind(resources, new Predicate<ExternalResource>() {
             @Override
             public boolean apply(ExternalResource resource) {
                 boolean changed = false;
                 if (isResourceLocationInCache(resource.location)) {
                     final String contentHashSum = resource.contentHashSum;
                     final String cachedHashSum = details.getProperty(resource.location);
                     if (!cachedHashSum.equals(contentHashSum)) {
                         changed = true;
                     }
                 }
                 else {
                     changed = true;
                 }
                 return changed;
             }
         }).isPresent();
     }
 
     /**
