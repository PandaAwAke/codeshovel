diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 67d386005..9de035b32 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -893,108 +893,106 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
             final String documentedEx = tag.getFirstArg();
             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag
                     .getColumnNo());
             final AbstractClassInfo documentedClassInfo = createClassInfo(token,
                     getCurrentClassName());
             final boolean found = foundThrows.contains(documentedEx)
                     || isInThrows(throwsList, documentedClassInfo, foundThrows);
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedClassInfo.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());
 
                 }
             }
         }
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
             throwsList.stream().filter(exceptionInfo -> !exceptionInfo.isFound())
                 .forEach(exceptionInfo -> {
                     final Token token = exceptionInfo.getName();
                     log(token.getLineNo(), token.getColumnNo(),
                         MSG_EXPECTED_TAG,
                         JavadocTagInfo.THROWS.getText(), token.getText());
                 });
         }
     }
 
     /**
      * Verifies that documented exception is in throws.
      *
      * @param throwsList list of throws
      * @param documentedClassInfo documented exception class info
      * @param foundThrows previously found throws
      * @return true if documented exception is in throws.
      */
     private boolean isInThrows(List<ExceptionInfo> throwsList,
             AbstractClassInfo documentedClassInfo, Set<String> foundThrows) {
         boolean found = false;
         ExceptionInfo foundException = null;
 
         // First look for matches on the exception name
-        final ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();
-        while (!found && throwIt.hasNext()) {
-            final ExceptionInfo exceptionInfo = throwIt.next();
-
+        for (ExceptionInfo exceptionInfo : throwsList) {
             if (exceptionInfo.getName().getText().equals(
                     documentedClassInfo.getName().getText())) {
                 found = true;
                 foundException = exceptionInfo;
+                break;
             }
         }
 
         // Now match on the exception type
         final ListIterator<ExceptionInfo> exceptionInfoIt = throwsList.listIterator();
         while (!found && exceptionInfoIt.hasNext()) {
             final ExceptionInfo exceptionInfo = exceptionInfoIt.next();
 
             if (documentedClassInfo.getClazz() == exceptionInfo.getClazz()) {
                 found = true;
                 foundException = exceptionInfo;
             }
             else if (allowThrowsTagsForSubclasses) {
                 found = isSubclass(documentedClassInfo.getClazz(), exceptionInfo.getClazz());
             }
         }
 
         if (foundException != null) {
             foundException.setFound();
             foundThrows.add(documentedClassInfo.getName().getText());
         }
 
         return found;
     }
 
     /** Stores useful information about declared exception. */
     private static class ExceptionInfo {
         /** Class information associated with this exception. */
         private final AbstractClassInfo classInfo;
         /** Does the exception have throws tag associated with. */
         private boolean found;
 
         /**
          * Creates new instance for {@code FullIdent}.
          *
          * @param classInfo class info
          */
         ExceptionInfo(AbstractClassInfo classInfo) {
             this.classInfo = classInfo;
         }
 
         /** Mark that the exception has associated throws tag. */
         private void setFound() {
             found = true;
         }
 
         /**
          * Checks that the exception has throws tag associated with it.
          * @return whether the exception has throws tag associated with
          */
