diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
index 04023f372..f9bd65b2f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
@@ -18,176 +18,176 @@
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
 import org.apache.commons.beanutils.ConversionException;
 
 /**
  * Detects uncommented main methods. Basically detects
  * any main method, since if it is detectable
  * that means it is uncommented.
  *
  * <pre class="body">
  * &lt;module name=&quot;UncommentedMain&quot;/&gt;
  * </pre>
  *
  * @author Michael Yui
  * @author o_sukhodolsky
  */
 public class UncommentedMainCheck
     extends Check
 {
     /** the pattern to exclude classes from the check */
     private String excludedClasses = "^$";
     /** compiled regexp to exclude classes from check */
     private Pattern excludedClassesPattern =
         Utils.createPattern(excludedClasses);
     /** current class name */
     private String currentClass;
     /** current package */
     private FullIdent packageName;
     /** class definition depth */
     private int classDepth;
 
     /**
      * Set the excluded classes pattern.
      * @param excludedClasses a <code>String</code> value
      * @throws ConversionException unable to parse excludedClasses
      */
     public void setExcludedClasses(String excludedClasses)
         throws ConversionException
     {
         try {
-            excludedClasses = excludedClasses;
+            this.excludedClasses = excludedClasses;
             excludedClassesPattern = Utils.getPattern(excludedClasses);
         }
         catch (final PatternSyntaxException e) {
             throw new ConversionException("unable to parse "
                                           + excludedClasses,
                                           e);
         }
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST)
     {
         packageName = FullIdent.createFullIdent(null);
         currentClass = null;
         classDepth = 0;
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             if (classDepth == 1) {
                 currentClass = null;
             }
             classDepth--;
         }
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         switch (ast.getType()) {
         case TokenTypes.PACKAGE_DEF:
             visitPackageDef(ast);
             break;
         case TokenTypes.CLASS_DEF:
             visitClassDef(ast);
             break;
         case TokenTypes.METHOD_DEF:
             visitMethodDef(ast);
             break;
         default:
             throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Sets current package.
-     * @param package node for package definition
+     * @param packageDef node for package definition
      */
     private void visitPackageDef(DetailAST packageDef)
     {
         packageName = FullIdent.createFullIdent(packageDef.getLastChild()
                 .getPreviousSibling());
     }
 
     /**
      * If not inner class then change current class name.
-     * @param class node for class definition
+     * @param classDef node for class definition
      */
     private void visitClassDef(DetailAST classDef)
     {
         // we are not use inner classes because they can not
         // have static methods
         if (classDepth == 0) {
             final DetailAST ident = classDef.findFirstToken(TokenTypes.IDENT);
             currentClass = packageName.getText() + "." + ident.getText();
             classDepth++;
         }
     }
 
     /**
      * Checks method definition if this is
      * <code>public static void main(String[])</code>.
      * @param method method definition node
      */
     private void visitMethodDef(DetailAST method)
     {
         if (classDepth != 1) {
             // method in inner class or in interface definition
             return;
         }
 
         if (checkClassName()
             && checkName(method)
             && checkModifiers(method)
             && checkType(method)
             && checkParams(method))
         {
             log(method.getLineNo(), "uncommented.main");
         }
     }
 
     /**
      * Checks that current class is not excluded
      * @return true if check passed, false otherwise
      */
     private boolean checkClassName()
     {
         return !excludedClassesPattern.matcher(currentClass).find();
     }
 
     /**
      * Checks that method name is @quot;main@quot;.
      * @param method the METHOD_DEF node
      * @return true if check passed, false otherwise
      */
     private boolean checkName(DetailAST method)
     {
