diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index 5e711a6bb..337e68ded 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -89,200 +89,221 @@ public class CommentsIndentationCheck extends Check {
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.SINGLE_LINE_COMMENT,
             TokenTypes.BLOCK_COMMENT_BEGIN,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST commentAst) {
         switch (commentAst.getType()) {
             case TokenTypes.SINGLE_LINE_COMMENT:
                 visitSingleLineComment(commentAst);
                 break;
             case TokenTypes.BLOCK_COMMENT_BEGIN:
                 visitBlockComment(commentAst);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + commentAst.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks single line comment indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * // some comment - this is ok
      * double d = 3.14;
      *     // some comment - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param singleLineComment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      */
     private void visitSingleLineComment(DetailAST singleLineComment) {
         final DetailAST nextStatement = singleLineComment.getNextSibling();
-        final DetailAST prevStatement = getPreviousStmt(singleLineComment);
+        final DetailAST prevStatement = getPrevStatementFromSwitchBlock(singleLineComment);
 
         if (nextStatement != null
             && nextStatement.getType() != TokenTypes.RCURLY
             && !isTrailingSingleLineComment(singleLineComment)
             && !areSameLevelIndented(singleLineComment, prevStatement, nextStatement)) {
 
             log(singleLineComment.getLineNo(), MSG_KEY_SINGLE, nextStatement.getLineNo(),
                 singleLineComment.getColumnNo(), nextStatement.getColumnNo());
         }
     }
 
     /**
-     * Gets previous case block from switch block.
+     * Gets comment's previous statement from switch block.
      * @param comment {@link TokenTypes#SINGLE_LINE_COMMENT single-line comment}.
-     * @return previous case block from switch.
+     * @return comment's previous statement or null if previous statement is absent.
      */
-    private static DetailAST getPreviousStmt(DetailAST comment) {
-        final DetailAST parentStatement = comment.getParent();
+    private static DetailAST getPrevStatementFromSwitchBlock(DetailAST comment) {
         DetailAST prevStmt = null;
+        final DetailAST parentStatement = comment.getParent();
         if (parentStatement != null) {
-            DetailAST prevBlock;
             if (parentStatement.getType() == TokenTypes.CASE_GROUP) {
-                prevBlock = parentStatement.getPreviousSibling();
-                if (prevBlock.getLastChild() != null) {
-                    DetailAST blockBody = prevBlock.getLastChild().getLastChild();
-                    if (blockBody.getPreviousSibling() != null) {
-                        blockBody = blockBody.getPreviousSibling();
-                    }
-                    if (blockBody.getType() == TokenTypes.EXPR) {
-                        prevStmt = blockBody.getFirstChild().getFirstChild();
-                    }
-                    else {
-                        prevStmt = blockBody;
-
-                    }
-                }
+                prevStmt = getPrevStatementWhenCommentIsUnderCase(parentStatement);
             }
             else {
-                final DetailAST parentBlock = parentStatement.getParent();
-
-                if (parentBlock != null && parentBlock.getParent() != null
-                    && parentBlock.getParent().getPreviousSibling() != null
-                    && parentBlock.getParent().getPreviousSibling()
-                        .getType() == TokenTypes.LITERAL_CASE) {
+                prevStmt = getPrevCaseToken(parentStatement);
+            }
+        }
+        return prevStmt;
+    }
 
-                    prevBlock = parentBlock.getParent().getPreviousSibling();
-                    prevStmt = prevBlock;
-                }
+    /**
+     * Gets previous statement for comment which is placed immediatly under case.
+     * @param parentStatement comment's parent statement.
+     * @return comment's previous statement or null if previous statement is absent.
+     */
+    private static DetailAST getPrevStatementWhenCommentIsUnderCase(DetailAST parentStatement) {
+        DetailAST prevStmt = null;
+        final DetailAST prevBlock = parentStatement.getPreviousSibling();
+        if (prevBlock.getLastChild() != null) {
+            DetailAST blockBody = prevBlock.getLastChild().getLastChild();
+            if (blockBody.getPreviousSibling() != null) {
+                blockBody = blockBody.getPreviousSibling();
+            }
+            if (blockBody.getType() == TokenTypes.EXPR) {
+                prevStmt = blockBody.getFirstChild().getFirstChild();
+            }
+            else {
+                prevStmt = blockBody;
             }
         }
         return prevStmt;
     }
 
+    /**
+     * Gets previous case-token for comment.
+     * @param parentStatement comment's parent statement.
+     * @return previous case-token or null if previous case-token is absent.
+     */
+    private static DetailAST getPrevCaseToken(DetailAST parentStatement) {
+        final DetailAST prevCaseToken;
+        final DetailAST parentBlock = parentStatement.getParent();
+        if (parentBlock != null && parentBlock.getParent() != null
+            && parentBlock.getParent().getPreviousSibling() != null
+            && parentBlock.getParent().getPreviousSibling()
+                .getType() == TokenTypes.LITERAL_CASE) {
+
+            prevCaseToken = parentBlock.getParent().getPreviousSibling();
+        }
+        else {
+            prevCaseToken = null;
+        }
+        return prevCaseToken;
+    }
+
     /**
      * Checks if comment and next code statement
      * (or previous code stmt like <b>case</b> in switch block) are indented at the same level,
      * e.g.:
      * <p>
      * <pre>
      * {@code
      * // some comment - same indentation level
      * int x = 10;
      *     // some comment - different indentation level
      * int x1 = 5;
      * /*
      *  *
      *  *&#47;
      *  boolean bool = true; - same indentation level
      * }
      * </pre>
      * </p>
      * @param singleLineComment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      * @param prevStmt previous code statement.
      * @param nextStmt next code statement.
      * @return true if comment and next code statement are indented at the same level.
      */
     private static boolean areSameLevelIndented(DetailAST singleLineComment,
                                                 DetailAST prevStmt, DetailAST nextStmt) {
         boolean result;
         if (prevStmt == null) {
             result = singleLineComment.getColumnNo() == nextStmt.getColumnNo();
         }
         else {
             result = singleLineComment.getColumnNo() == nextStmt.getColumnNo()
                 || singleLineComment.getColumnNo() == prevStmt.getColumnNo();
         }
         return result;
     }
 
     /**
      * Checks if current single line comment is trailing comment, e.g.:
      * <p>
      * {@code
      * double d = 3.14; // some comment
      * }
      * </p>
      * @param singleLineComment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      * @return true if current single line comment is trailing comment.
      */
     private boolean isTrailingSingleLineComment(DetailAST singleLineComment) {
         final String targetSourceLine = getLine(singleLineComment.getLineNo() - 1);
         final int commentColumnNo = singleLineComment.getColumnNo();
         return !Utils.whitespaceBefore(commentColumnNo, targetSourceLine);
     }
 
     /**
      * Checks comment block indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * /* some comment *&#47; - this is ok
      * double d = 3.14;
      *     /* some comment *&#47; - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param blockComment {@link TokenTypes#BLOCK_COMMENT_BEGIN block comment begin}.
      */
     private void visitBlockComment(DetailAST blockComment) {
         final DetailAST nextStatement = blockComment.getNextSibling();
-        final DetailAST prevStatement = getPreviousStmt(blockComment);
+        final DetailAST prevStatement = getPrevStatementFromSwitchBlock(blockComment);
 
         if (nextStatement != null
             && nextStatement.getType() != TokenTypes.RCURLY
             && !isTrailingBlockComment(blockComment)
             && !areSameLevelIndented(blockComment, prevStatement, nextStatement)) {
 
             log(blockComment.getLineNo(), MSG_KEY_BLOCK, nextStatement.getLineNo(),
                 blockComment.getColumnNo(), nextStatement.getColumnNo());
         }
     }
 
     /**
      * Checks if current comment block is trailing comment, e.g.:
      * <p>
      * {@code
      * double d = 3.14; /* some comment *&#47;
      * /* some comment *&#47; double d = 18.5;
      * }
      * </p>
      * @param blockComment {@link TokenTypes#BLOCK_COMMENT_BEGIN block comment begin}.
      * @return true if current comment block is trailing comment.
      */
     private boolean isTrailingBlockComment(DetailAST blockComment) {
         final String commentLine = getLine(blockComment.getLineNo() - 1);
         final int commentColumnNo = blockComment.getColumnNo();
         return !Utils.whitespaceBefore(commentColumnNo, commentLine)
             || blockComment.getNextSibling().getLineNo() == blockComment.getLineNo();
     }
 }
