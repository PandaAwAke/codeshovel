diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
index cf5c4a478..2e62dbac3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java
@@ -28,100 +28,106 @@ import com.puppycrawl.tools.checkstyle.checks.AbstractFormatCheck;
  * expression and explicitly extending classes with names conforming to other
  * regular expression) are immutable. That is, they have only final fields.</p>
  * <p> Rationale: Exception instances should represent an error
  * condition. Having non final fields not only allows the state to be
  * modified by accident and therefore mask the original condition but
  * also allows developers to accidentally forget to initialise state
  * thereby leading to code catching the exception to draw incorrect
  * conclusions based on the state.</p>
  *
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  */
 public final class MutableExceptionCheck extends AbstractFormatCheck
 {
     /** Default value for format and extendedClassNameFormat properties. */
     private static final String DEFAULT_FORMAT = "^.*Exception$|^.*Error$|^.*Throwable$";
     /** Pattern for class name that is being extended */
     private String extendedClassNameFormat;
     /** Stack of checking information for classes. */
     private final FastStack<Boolean> checkingStack = FastStack.newInstance();
     /** Should we check current class or not. */
     private boolean checking;
 
     /** Creates new instance of the check. */
     public MutableExceptionCheck()
     {
         super(DEFAULT_FORMAT);
         setExtendedClassNameFormat(DEFAULT_FORMAT);
     }
 
     /**
      * Sets the format of extended class name to the specified regular expression.
      * @param extendedClassNameFormat a <code>String</code> value
      */
     public void setExtendedClassNameFormat(String extendedClassNameFormat)
     {
         this.extendedClassNameFormat = extendedClassNameFormat;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.CLASS_DEF, TokenTypes.VARIABLE_DEF};
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {TokenTypes.CLASS_DEF, TokenTypes.VARIABLE_DEF};
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF:
                 visitClassDef(ast);
                 break;
             case TokenTypes.VARIABLE_DEF:
                 visitVariableDef(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF:
                 leaveClassDef();
                 break;
             default:
                 // Do nothing
         }
     }
 
     /**
      * Called when we start processing class definition.
      * @param ast class definition node
      */
     private void visitClassDef(DetailAST ast)
     {
         checkingStack.push(checking ? Boolean.TRUE : Boolean.FALSE);
         checking = isNamedAsException(ast) && isExtendedClassNamedAsException(ast);
     }
 
     /** Called when we leave class definition. */
     private void leaveClassDef()
     {
         checking = checkingStack.pop();
     }
 
     /**
      * Checks variable definition.
      * @param ast variable def node for check
      */
     private void visitVariableDef(DetailAST ast)
     {
         if (checking && (ast.getParent().getType() == TokenTypes.OBJBLOCK)) {
