diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
index bfd1bbc3f..0c5f6db9e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
@@ -516,76 +516,76 @@ public class EmptyLineSeparatorCheck extends AbstractCheck {
 
     /**
      * Checks, whether there are empty lines within the specified line range. Line numbering is
      * started from 1 for parameter values
      * @param startLine number of the first line in the range
      * @param endLine number of the second line in the range
      * @return <code>true</code> if found any blank line within the range, <code>false</code>
      *         otherwise
      */
     private boolean hasEmptyLine(int startLine, int endLine) {
         // Initial value is false - blank line not found
         boolean result = false;
         if (startLine <= endLine) {
             final FileContents fileContents = getFileContents();
             for (int line = startLine; line <= endLine; line++) {
                 // Check, if the line is blank. Lines are numbered from 0, so subtract 1
                 if (fileContents.lineIsBlank(line - 1)) {
                     result = true;
                     break;
                 }
             }
         }
         return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param token token.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(DetailAST token) {
         boolean result = false;
         final int lineNo = token.getLineNo();
         if (lineNo != 1) {
             // [lineNo - 2] is the number of the previous line as the numbering starts from zero.
             final String lineBefore = getLines()[lineNo - 2];
             result = CommonUtils.isBlank(lineBefore);
         }
         return result;
     }
 
     /**
      * Check if token is preceded by javadoc comment.
      * @param token token for check.
      * @return true, if token is preceded by javadoc comment.
      */
     private static boolean isPrecededByJavadoc(DetailAST token) {
         boolean result = false;
         final DetailAST previous = token.getPreviousSibling();
         if (previous.getType() == TokenTypes.BLOCK_COMMENT_BEGIN
-                && JavadocUtils.isJavadocComment(previous)) {
+                && JavadocUtils.isJavadocComment(previous.getFirstChild().getText())) {
             result = true;
         }
         return result;
     }
 
     /**
      * Check if token is a comment.
      * @param ast ast node
      * @return true, if given ast is comment.
      */
     private static boolean isComment(DetailAST ast) {
         return ast.getType() == TokenTypes.SINGLE_LINE_COMMENT
                    || ast.getType() == TokenTypes.BLOCK_COMMENT_BEGIN;
     }
 
     /**
      * If variable definition is a type field.
      * @param variableDef variable definition.
      * @return true variable definition is a type field.
      */
     private static boolean isTypeField(DetailAST variableDef) {
         final int parentType = variableDef.getParent().getParent().getType();
         return parentType == TokenTypes.CLASS_DEF;
     }
 }
