diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
index a4d7c4f0c..c77e481b7 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
@@ -92,236 +92,236 @@ public class SuppressWarningsCheck extends AbstractFormatCheck
     /**
      * fully-qualified {@link SuppressWarnings SuppressWarnings}
      * annotation name
      */
     private static final String FQ_SUPPRESS_WARNINGS =
         "java.lang." + SUPPRESS_WARNINGS;
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED =
         "suppressed.warning.not.allowed";
 
     /**
      * Ctor that specifies the default for the format property
      * as specified in the class javadocs.
      */
     public SuppressWarningsCheck()
     {
         super("^$|^\\s+$");
     }
 
     /** {@inheritDoc} */
     @Override
     public final int[] getDefaultTokens()
     {
         return this.getAcceptableTokens();
     }
 
     /** {@inheritDoc} */
     @Override
     public final int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     /** {@inheritDoc} */
     @Override
-    public void visitToken(final DetailAST aAST)
+    public void visitToken(final DetailAST ast)
     {
-        final DetailAST annotation = this.getSuppressWarnings(aAST);
+        final DetailAST annotation = this.getSuppressWarnings(ast);
 
         if (annotation == null) {
             return;
         }
 
         final DetailAST warningHolder =
             this.findWarningsHolder(annotation);
 
         DetailAST warning = warningHolder.findFirstToken(TokenTypes.EXPR);
 
         //rare case with empty array ex: @SuppressWarnings({})
         if (warning == null) {
             //check to see if empty warnings are forbidden -- are by default
             this.logMatch(warningHolder.getLineNo(),
                 warningHolder.getColumnNo(), "");
             return;
         }
 
         while (warning != null) {
             if (warning.getType() == TokenTypes.EXPR) {
                 final DetailAST fChild = warning.getFirstChild();
                 switch (fChild.getType()) {
                 //typical case
                 case TokenTypes.STRING_LITERAL:
                     final String warningText =
                         this.removeQuotes(warning.getFirstChild().getText());
                     this.logMatch(warning.getLineNo(),
                         warning.getColumnNo(), warningText);
                     break;
                 //conditional case
                 //ex: @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")
                 case TokenTypes.QUESTION:
                     this.walkConditional(fChild);
                     break;
                 //param in constant case
                 //ex: public static final String UNCHECKED = "unchecked";
                 //@SuppressWarnings(UNCHECKED) or @SuppressWarnings(SomeClass.UNCHECKED)
                 case TokenTypes.IDENT:
                 case TokenTypes.DOT:
                     break;
                 default:
                     throw new IllegalStateException("Should never get here, type: "
                         + fChild.getType() + " text: " + fChild.getText());
                 }
             }
             warning = warning.getNextSibling();
         }
     }
 
     /**
      * Gets the {@link SuppressWarnings SuppressWarnings} annotation
      * that is annotating the AST.  If the annotation does not exist
      * this method will return {@code null}.
      *
-     * @param aAST the AST
+     * @param ast the AST
      * @return the {@link SuppressWarnings SuppressWarnings} annotation
      */
-    private DetailAST getSuppressWarnings(DetailAST aAST)
+    private DetailAST getSuppressWarnings(DetailAST ast)
     {
         final DetailAST annotation = AnnotationUtility.getAnnotation(
-            aAST, SuppressWarningsCheck.SUPPRESS_WARNINGS);
+            ast, SuppressWarningsCheck.SUPPRESS_WARNINGS);
 
         return (annotation != null) ? annotation
             : AnnotationUtility.getAnnotation(
-                aAST, SuppressWarningsCheck.FQ_SUPPRESS_WARNINGS);
+                ast, SuppressWarningsCheck.FQ_SUPPRESS_WARNINGS);
     }
 
     /**
      * This method looks for a warning that matches a configured expression.
      * If found it logs a violation at the given line and column number.
      *
-     * @param aLineNo the line number
-     * @param aColNum the column number
-     * @param aWarningText the warning.
+     * @param lineNo the line number
+     * @param colNum the column number
+     * @param warningText the warning.
      */
-    private void logMatch(final int aLineNo,
-        final int aColNum, final String aWarningText)
+    private void logMatch(final int lineNo,
+        final int colNum, final String warningText)
     {
-        final Matcher matcher = this.getRegexp().matcher(aWarningText);
+        final Matcher matcher = this.getRegexp().matcher(warningText);
         if (matcher.matches()) {
-            this.log(aLineNo, aColNum,
-                    MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED, aWarningText);
+            this.log(lineNo, colNum,
+                    MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED, warningText);
         }
     }
 
     /**
      * Find the parent (holder) of the of the warnings (Expr).
      *
-     * @param aAnnotation the annotation
+     * @param annotation the annotation
      * @return a Token representing the expr.
      */
-    private DetailAST findWarningsHolder(final DetailAST aAnnotation)
+    private DetailAST findWarningsHolder(final DetailAST annotation)
     {
         final DetailAST annValuePair =
-            aAnnotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
+            annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
         final DetailAST annArrayInit;
 
         if (annValuePair != null) {
             annArrayInit =
                 annValuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
         else {
             annArrayInit =
-                aAnnotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
+                annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
 
         if (annArrayInit != null) {
             return annArrayInit;
         }
 
-        return aAnnotation;
+        return annotation;
     }
 
     /**
      * Strips a single double quote from the front and back of a string.
      *
      * For example:
      * <br/>
      * Input String = "unchecked"
      * <br/>
      * Output String = unchecked
      *
-     * @param aWarning the warning string
+     * @param warning the warning string
      * @return the string without two quotes
      */
-    private String removeQuotes(final String aWarning)
+    private String removeQuotes(final String warning)
     {
-        assert aWarning != null : "the aWarning was null";
-        assert aWarning.charAt(0) == '"';
-        assert aWarning.charAt(aWarning.length() - 1) == '"';
+        assert warning != null : "the warning was null";
+        assert warning.charAt(0) == '"';
+        assert warning.charAt(warning.length() - 1) == '"';
 
-        return aWarning.substring(1, aWarning.length() - 1);
+        return warning.substring(1, warning.length() - 1);
     }
 
     /**
      * Recursively walks a conditional expression checking the left
      * and right sides, checking for matches and
      * logging violations.
      *
-     * @param aCond a Conditional type
+     * @param cond a Conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      */
-    private void walkConditional(final DetailAST aCond)
+    private void walkConditional(final DetailAST cond)
     {
-        if (aCond.getType() != TokenTypes.QUESTION) {
+        if (cond.getType() != TokenTypes.QUESTION) {
             final String warningText =
-                this.removeQuotes(aCond.getText());
-            this.logMatch(aCond.getLineNo(), aCond.getColumnNo(), warningText);
+                this.removeQuotes(cond.getText());
+            this.logMatch(cond.getLineNo(), cond.getColumnNo(), warningText);
             return;
         }
 
-        this.walkConditional(this.getCondLeft(aCond));
-        this.walkConditional(this.getCondRight(aCond));
+        this.walkConditional(this.getCondLeft(cond));
+        this.walkConditional(this.getCondRight(cond));
     }
 
     /**
      * Retrieves the left side of a conditional.
      *
-     * @param aCond aCond a conditional type
+     * @param cond cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      * or another conditional
      */
-    private DetailAST getCondLeft(final DetailAST aCond)
+    private DetailAST getCondLeft(final DetailAST cond)
     {
-        final DetailAST colon = aCond.findFirstToken(TokenTypes.COLON);
+        final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getPreviousSibling();
     }
 
     /**
      * Retrieves the right side of a conditional.
      *
-     * @param aCond a conditional type
+     * @param cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      * or another conditional
      */
-    private DetailAST getCondRight(final DetailAST aCond)
+    private DetailAST getCondRight(final DetailAST cond)
     {
-        final DetailAST colon = aCond.findFirstToken(TokenTypes.COLON);
+        final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getNextSibling();
     }
 }
