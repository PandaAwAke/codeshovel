diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 8520eaefb..cbe74cee9 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -123,106 +123,106 @@ public final class TreeWalker
     }
 
     /** @param tabWidth the distance between tab stops */
     public void setTabWidth(int tabWidth) {
         this.tabWidth = tabWidth;
     }
 
     /** @param fileName the cache file
      *  @throws IOException if there are some problems with file loading
      */
     public void setCacheFile(String fileName) throws IOException {
         final Configuration configuration = getConfiguration();
         cache = new PropertyCacheFile(configuration, fileName);
 
         cache.load();
     }
 
     /** @param classLoader class loader to resolve classes with. */
     public void setClassLoader(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 
     /**
      * Sets the module factory for creating child modules (Checks).
      * @param moduleFactory the factory
      */
     public void setModuleFactory(ModuleFactory moduleFactory) {
         this.moduleFactory = moduleFactory;
     }
 
     @Override
     public void finishLocalSetup() {
         final DefaultContext checkContext = new DefaultContext();
         checkContext.add("classLoader", classLoader);
         checkContext.add("messages", getMessageCollector());
         checkContext.add("severity", getSeverity());
         checkContext.add("tabWidth", String.valueOf(tabWidth));
 
         childContext = checkContext;
     }
 
     @Override
     public void setupChild(Configuration childConf)
         throws CheckstyleException {
         final String name = childConf.getName();
         final Object module = moduleFactory.createModule(name);
         if (!(module instanceof Check)) {
             throw new CheckstyleException(
                 "TreeWalker is not allowed as a parent of " + name);
         }
-        final Check c = (Check) module;
-        c.contextualize(childContext);
-        c.configure(childConf);
-        c.init();
+        final Check check = (Check) module;
+        check.contextualize(childContext);
+        check.configure(childConf);
+        check.init();
 
-        registerCheck(c);
+        registerCheck(check);
     }
 
     @Override
     protected void processFiltered(File file, List<String> lines) {
         // check if already checked and passed the file
         final String fileName = file.getPath();
         final long timestamp = file.lastModified();
         if (cache != null
                 && (cache.inCache(fileName, timestamp)
                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {
             return;
         }
 
         final String msg = "%s occurred during the analysis of file %s.";
 
         try {
             final FileText text = FileText.fromLines(file, lines);
             final FileContents contents = new FileContents(text);
             final DetailAST rootAST = TreeWalker.parse(contents);
 
             getMessageCollector().reset();
 
             walk(rootAST, contents, AstState.ORDINARY);
 
             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);
 
             walk(astWithComments, contents, AstState.WITH_COMMENTS);
         }
         catch (final TokenStreamRecognitionException tre) {
             final String exceptionMsg = String.format(msg, "TokenStreamRecognitionException",
                      fileName);
             LOG.error(exceptionMsg);
             final RecognitionException re = tre.recog;
             String message;
             message = re.getMessage();
             getMessageCollector().add(createLocalizedMessage(message));
         }
         // RecognitionException and any other (need to check if needed)
         catch (Throwable ex) {
             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);
             LOG.error(exceptionMsg, ex);
             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));
         }
 
         if (cache != null && getMessageCollector().size() == 0) {
             cache.put(fileName, timestamp);
         }
     }
 
     /**
@@ -298,224 +298,224 @@ public final class TreeWalker
      */
     private void registerCheck(String token, Check check) {
         if (check.isCommentNodesRequired()) {
             tokenToCommentChecks.put(token, check);
         }
         else if (Utils.isCommentType(token)) {
             final String message = String.format("Check '%s' waits for comment type "
                     + "token ('%s') and should override 'isCommentNodesRequred()' "
                     + "method to return 'true'", check.getClass().getName(), token);
             LOG.warn(message);
         }
         else {
             tokenToOrdinaryChecks.put(token, check);
         }
     }
 
     /**
      * Initiates the walk of an AST.
      * @param ast the root AST
      * @param contents the contents of the file the AST was generated from.
      * @param astState state of AST.
      */
     private void walk(DetailAST ast, FileContents contents,
             AstState astState) {
         notifyBegin(ast, contents, astState);
 
         // empty files are not flagged by javac, will yield ast == null
         if (ast != null) {
             processIter(ast, astState);
         }
         notifyEnd(ast, astState);
     }
 
     /**
      * Notify checks that we are about to begin walking a tree.
      * @param rootAST the root of the tree.
      * @param contents the contents of the file the AST was generated from.
      * @param astState state of AST.
      */
     private void notifyBegin(DetailAST rootAST, FileContents contents,
             AstState astState) {
         Set<Check> checks;
 
         if (astState == AstState.WITH_COMMENTS) {
             checks = commentChecks;
         }
         else {
             checks = ordinaryChecks;
         }
 
-        for (Check ch : checks) {
-            ch.setFileContents(contents);
-            ch.beginTree(rootAST);
+        for (Check check : checks) {
+            check.setFileContents(contents);
+            check.beginTree(rootAST);
         }
     }
 
     /**
      * Notify checks that we have finished walking a tree.
      * @param rootAST the root of the tree.
      * @param astState state of AST.
      */
     private void notifyEnd(DetailAST rootAST, AstState astState) {
         Set<Check> checks;
 
         if (astState == AstState.WITH_COMMENTS) {
             checks = commentChecks;
         }
         else {
             checks = ordinaryChecks;
         }
 
-        for (Check ch : checks) {
-            ch.finishTree(rootAST);
+        for (Check check : checks) {
+            check.finishTree(rootAST);
         }
     }
 
     /**
      * Notify checks that visiting a node.
      * @param ast the node to notify for.
      * @param astState state of AST.
      */
     private void notifyVisit(DetailAST ast, AstState astState) {
         Collection<Check> visitors;
         final String tokenType = Utils.getTokenName(ast.getType());
 
         if (astState == AstState.WITH_COMMENTS) {
             if (!tokenToCommentChecks.containsKey(tokenType)) {
                 return;
             }
             visitors = tokenToCommentChecks.get(tokenType);
         }
         else {
             if (!tokenToOrdinaryChecks.containsKey(tokenType)) {
                 return;
             }
             visitors = tokenToOrdinaryChecks.get(tokenType);
         }
 
-        for (Check c : visitors) {
-            c.visitToken(ast);
+        for (Check check : visitors) {
+            check.visitToken(ast);
         }
     }
 
     /**
      * Notify checks that leaving a node.
      * @param ast
      *        the node to notify for
      * @param astState state of AST.
      */
     private void notifyLeave(DetailAST ast, AstState astState) {
         Collection<Check> visitors;
         final String tokenType = Utils.getTokenName(ast.getType());
 
         if (astState == AstState.WITH_COMMENTS) {
             if (!tokenToCommentChecks.containsKey(tokenType)) {
                 return;
             }
             visitors = tokenToCommentChecks.get(tokenType);
         }
         else {
             if (!tokenToOrdinaryChecks.containsKey(tokenType)) {
                 return;
             }
             visitors = tokenToOrdinaryChecks.get(tokenType);
         }
 
-        for (Check ch : visitors) {
-            ch.leaveToken(ast);
+        for (Check check : visitors) {
+            check.leaveToken(ast);
         }
     }
 
     /**
      * Static helper method to parses a Java source file.
      *
      * @param contents
      *                contains the contents of the file
      * @return the root of the AST
      * @throws TokenStreamException
      *                 if lexing failed
      * @throws RecognitionException
      *                 if parsing failed
      */
     public static DetailAST parse(FileContents contents)
         throws RecognitionException, TokenStreamException {
         final String fullText = contents.getText().getFullText().toString();
         final Reader sr = new StringReader(fullText);
         final GeneratedJavaLexer lexer = new GeneratedJavaLexer(sr);
         lexer.setFilename(contents.getFileName());
         lexer.setCommentListener(contents);
         lexer.setTreatAssertAsKeyword(true);
         lexer.setTreatEnumAsKeyword(true);
         lexer.setTokenObjectClass("antlr.CommonHiddenStreamToken");
 
         final TokenStreamHiddenTokenFilter filter =
                 new TokenStreamHiddenTokenFilter(lexer);
         filter.hide(TokenTypes.SINGLE_LINE_COMMENT);
         filter.hide(TokenTypes.BLOCK_COMMENT_BEGIN);
 
         final GeneratedJavaRecognizer parser =
             new GeneratedJavaRecognizer(filter);
         parser.setFilename(contents.getFileName());
         parser.setASTNodeClass(DetailAST.class.getName());
         parser.compilationUnit();
 
         return (DetailAST) parser.getAST();
     }
 
     @Override
     public void destroy() {
-        for (Check c : ordinaryChecks) {
-            c.destroy();
+        for (Check check : ordinaryChecks) {
+            check.destroy();
         }
-        for (Check c : commentChecks) {
-            c.destroy();
+        for (Check check : commentChecks) {
+            check.destroy();
         }
         if (cache != null) {
             try {
                 cache.persist();
             }
             catch (IOException e) {
                 throw new IllegalStateException("Unable to persist cache file", e);
             }
         }
         super.destroy();
     }
 
     /**
      * Processes a node calling interested checks at each node.
      * Uses iterative algorithm.
      * @param root the root of tree for process
      * @param astState state of AST.
      */
     private void processIter(DetailAST root, AstState astState) {
         DetailAST curNode = root;
         while (curNode != null) {
             notifyVisit(curNode, astState);
             DetailAST toVisit = curNode.getFirstChild();
             while (curNode != null && toVisit == null) {
                 notifyLeave(curNode, astState);
                 toVisit = curNode.getNextSibling();
                 if (toVisit == null) {
                     curNode = curNode.getParent();
                 }
             }
             curNode = toVisit;
         }
     }
 
     /**
      * Appends comment nodes to existing AST.
      * It traverses each node in AST, looks for hidden comment tokens
      * and appends found comment tokens as nodes in AST.
      * @param root
      *        root of AST.
      * @return root of AST with comment nodes.
      */
     private static DetailAST appendHiddenCommentNodes(DetailAST root) {
         DetailAST result = root;
         DetailAST curNode = root;
         DetailAST lastNode = root;
 
         while (curNode != null) {
             if (isPositionGreater(curNode, lastNode)) {
                 lastNode = curNode;
