diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java
index 3c6f31956..1a6005766 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java
@@ -1,76 +1,76 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.indentation;
 
 import java.util.Arrays;
 
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
-import com.puppycrawl.tools.checkstyle.utils.Utils;
+import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * Abstract base class for all handlers.
  *
  * @author jrichard
  */
 public abstract class AbstractExpressionHandler {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ERROR = "indentation.error";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ERROR_MULTI = "indentation.error.multi";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CHILD_ERROR = "indentation.child.error";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CHILD_ERROR_MULTI = "indentation.child.error.multi";
 
     /**
      * The instance of {@code IndentationCheck} using this handler.
      */
     private final IndentationCheck indentCheck;
 
     /** The AST which is handled by this handler */
     private final DetailAST mainAst;
 
     /** Name used during output to user */
     private final String typeName;
 
     /** Containing AST handler */
     private final AbstractExpressionHandler parent;
 
     /** Indentation amount for this handler */
     private IndentLevel level;
 
     /**
@@ -325,193 +325,193 @@ public abstract class AbstractExpressionHandler {
 
     /**
      * Check the indent level for a single line.
      *
      * @param lineNum       the line number to check
      * @param indentLevel   the required indent level
      */
     private void checkSingleLine(int lineNum, IndentLevel indentLevel) {
         final String line = indentCheck.getLine(lineNum - 1);
         final int start = getLineStart(line);
         if (indentLevel.greaterThan(start)) {
             logChildError(lineNum, start, indentLevel);
         }
     }
 
     /**
      * Check the indentation for a single line.
      *
      * @param lineNum       the number of the line to check
      * @param colNum        the column number we are starting at
      * @param indentLevel   the indentation level
      * @param mustMatch     whether or not the indentation level must match
      */
 
     private void checkSingleLine(int lineNum, int colNum,
         IndentLevel indentLevel, boolean mustMatch) {
         final String line = indentCheck.getLine(lineNum - 1);
         final int start = getLineStart(line);
         // if must match is set, it is an error if the line start is not
         // at the correct indention level; otherwise, it is an only an
         // error if this statement starts the line and it is less than
         // the correct indentation level
         if (mustMatch && !indentLevel.accept(start)
                 || !mustMatch && colNum == start && indentLevel.greaterThan(start)) {
             logChildError(lineNum, start, indentLevel);
         }
     }
 
     /**
      * Get the start of the specified line.
      *
      * @param line   the specified line number
      *
      * @return the start of the specified line
      */
     protected final int getLineStart(String line) {
         int index = 0;
         while (Character.isWhitespace(line.charAt(index))) {
             index++;
         }
-        return Utils.lengthExpandedTabs(
+        return CommonUtils.lengthExpandedTabs(
             line, index, indentCheck.getIndentationTabWidth());
     }
 
     /**
      * Check the indent level of the children of the specified parent
      * expression.
      *
      * @param parentNode             the parent whose children we are checking
      * @param tokenTypes         the token types to check
      * @param startLevel         the starting indent level
      * @param firstLineMatches   whether or not the first line needs to match
      * @param allowNesting       whether or not nested children are allowed
      */
     protected final void checkChildren(DetailAST parentNode,
                                        int[] tokenTypes,
                                        IndentLevel startLevel,
                                        boolean firstLineMatches,
                                        boolean allowNesting) {
         Arrays.sort(tokenTypes);
         for (DetailAST child = parentNode.getFirstChild();
                 child != null;
                 child = child.getNextSibling()) {
             if (Arrays.binarySearch(tokenTypes, child.getType()) >= 0) {
                 checkExpressionSubtree(child, startLevel,
                     firstLineMatches, allowNesting);
             }
         }
     }
 
     /**
      * Check the indentation level for an expression subtree.
      *
      * @param tree               the expression subtree to check
      * @param indentLevel              the indentation level
      * @param firstLineMatches   whether or not the first line has to match
      * @param allowNesting       whether or not subtree nesting is allowed
      */
     protected final void checkExpressionSubtree(
         DetailAST tree,
         IndentLevel indentLevel,
         boolean firstLineMatches,
         boolean allowNesting
     ) {
         final LineSet subtreeLines = new LineSet();
         final int firstLine = getFirstLine(Integer.MAX_VALUE, tree);
         if (firstLineMatches && !allowNesting) {
             subtreeLines.addLineAndCol(firstLine,
                 getLineStart(indentCheck.getLine(firstLine - 1)));
         }
         findSubtreeLines(subtreeLines, tree, allowNesting);
 
         checkLinesIndent(subtreeLines, indentLevel, firstLineMatches, firstLine);
     }
 
     /**
      * Get the first line for a given expression.
      *
      * @param startLine   the line we are starting from
      * @param tree        the expression to find the first line for
      *
      * @return the first line of the expression
      */
     protected final int getFirstLine(int startLine, DetailAST tree) {
         int realStart = startLine;
         final int currLine = tree.getLineNo();
         if (currLine < realStart) {
             realStart = currLine;
         }
 
         // check children
         for (DetailAST node = tree.getFirstChild();
             node != null;
             node = node.getNextSibling()) {
             realStart = getFirstLine(realStart, node);
         }
 
         return realStart;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param ast   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     protected final int expandedTabsColumnNo(DetailAST ast) {
         final String line =
             indentCheck.getLine(ast.getLineNo() - 1);
 
-        return Utils.lengthExpandedTabs(line, ast.getColumnNo(),
+        return CommonUtils.lengthExpandedTabs(line, ast.getColumnNo(),
             indentCheck.getIndentationTabWidth());
     }
 
     /**
      * Find the set of lines for a given subtree.
      *
      * @param lines          the set of lines to add to
      * @param tree           the subtree to examine
      * @param allowNesting   whether or not to allow nested subtrees
      */
     protected final void findSubtreeLines(LineSet lines, DetailAST tree,
         boolean allowNesting) {
         if (indentCheck.getHandlerFactory().isHandledType(tree.getType())) {
             return;
         }
 
         final int lineNum = tree.getLineNo();
         final Integer colNum = lines.getStartColumn(lineNum);
 
         final int thisLineColumn = expandedTabsColumnNo(tree);
         if (colNum == null || thisLineColumn < colNum) {
             lines.addLineAndCol(lineNum, thisLineColumn);
         }
 
         // check children
         for (DetailAST node = tree.getFirstChild();
             node != null;
             node = node.getNextSibling()) {
             findSubtreeLines(lines, node, allowNesting);
         }
     }
 
     /**
      * Check the indentation level of modifiers.
      */
     protected void checkModifiers() {
         final DetailAST modifiers =
             mainAst.findFirstToken(TokenTypes.MODIFIERS);
         for (DetailAST modifier = modifiers.getFirstChild();
              modifier != null;
              modifier = modifier.getNextSibling()) {
             if (startsLine(modifier)
                 && !getLevel().accept(expandedTabsColumnNo(modifier))) {
                 logError(modifier, "modifier",
                     expandedTabsColumnNo(modifier));
             }
         }
     }
 
     /**
