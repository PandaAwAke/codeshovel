diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
index 955ec1e42..0fc040f7c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
@@ -41,130 +41,130 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  *
  * <p>For example:
  *
  * <pre>
  *  {@code
  *    String nullString = null;
  *    nullString.equals(&quot;My_Sweet_String&quot;);
  *  }
  * </pre>
  * should be refactored to
  *
  * <pre>
  *  {@code
  *    String nullString = null;
  *    &quot;My_Sweet_String&quot;.equals(nullString);
  *  }
  * </pre>
  *
  * @author Travis Schneeberger
  * @author Vladislav Lisetskiy
  */
 @FileStatefulCheck
 public class EqualsAvoidNullCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_EQUALS_AVOID_NULL = "equals.avoid.null";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_EQUALS_IGNORE_CASE_AVOID_NULL = "equalsIgnoreCase.avoid.null";
 
     /** Method name for comparison. */
     private static final String EQUALS = "equals";
 
     /** Type name for comparison. */
     private static final String STRING = "String";
 
     /** Whether to process equalsIgnoreCase() invocations. */
     private boolean ignoreEqualsIgnoreCase;
 
     /** Stack of sets of field names, one for each class of a set of nested classes. */
     private FieldFrame currentFrame;
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
+        return getRequiredTokens();
+    }
+
+    @Override
+    public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.METHOD_CALL,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_TRY,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.SLIST,
             TokenTypes.ENUM_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_NEW,
         };
     }
 
-    @Override
-    public int[] getRequiredTokens() {
-        return getAcceptableTokens();
-    }
-
     /**
      * Whether to ignore checking {@code String.equalsIgnoreCase(String)}.
      * @param newValue whether to ignore checking
      *    {@code String.equalsIgnoreCase(String)}.
      */
     public void setIgnoreEqualsIgnoreCase(boolean newValue) {
         ignoreEqualsIgnoreCase = newValue;
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         currentFrame = new FieldFrame(null);
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF:
             case TokenTypes.PARAMETER_DEF:
                 currentFrame.addField(ast);
                 break;
             case TokenTypes.METHOD_CALL:
                 processMethodCall(ast);
                 break;
             case TokenTypes.SLIST:
                 processSlist(ast);
                 break;
             case TokenTypes.LITERAL_NEW:
                 processLiteralNew(ast);
                 break;
             default:
                 processFrame(ast);
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         final int astType = ast.getType();
         if (astType != TokenTypes.VARIABLE_DEF
                 && astType != TokenTypes.PARAMETER_DEF
                 && astType != TokenTypes.METHOD_CALL
                 && astType != TokenTypes.SLIST
                 && astType != TokenTypes.LITERAL_NEW
                 || astType == TokenTypes.LITERAL_NEW
                     && ast.findFirstToken(TokenTypes.OBJBLOCK) != null) {
             currentFrame = currentFrame.getParent();
         }
         else if (astType == TokenTypes.SLIST) {
             leaveSlist(ast);
         }
