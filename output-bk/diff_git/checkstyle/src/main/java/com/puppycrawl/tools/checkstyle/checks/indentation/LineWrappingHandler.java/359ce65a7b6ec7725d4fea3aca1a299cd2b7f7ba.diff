diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
index c02fbb7ab..9ee72d852 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
@@ -204,101 +204,101 @@ public class LineWrappingHandler {
         }
         return nodeToVisit;
     }
 
     /**
      * Checks line wrapping into annotations.
      *
      * @param atNode at-clause node.
      * @param firstNodesOnLines map which contains
      *     first nodes as values and line numbers as keys.
      * @param indentLevel line wrapping indentation.
      */
     private void checkAnnotationIndentation(DetailAST atNode,
             NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {
         final int firstNodeIndent = getLineStart(atNode);
         final int currentIndent = firstNodeIndent + indentLevel;
         final Collection<DetailAST> values = firstNodesOnLines.values();
         final DetailAST lastAnnotationNode = atNode.getParent().getLastChild();
         final int lastAnnotationLine = lastAnnotationNode.getLineNo();
 
         final Iterator<DetailAST> itr = values.iterator();
         while (firstNodesOnLines.size() > 1) {
             final DetailAST node = itr.next();
 
             final DetailAST parentNode = node.getParent();
             final boolean isCurrentNodeCloseAnnotationAloneInLine =
                 node.getLineNo() == lastAnnotationLine
                     && isEndOfScope(lastAnnotationNode, node);
             if (isCurrentNodeCloseAnnotationAloneInLine
                     || node.getType() == TokenTypes.AT
                     && (parentNode.getParent().getType() == TokenTypes.MODIFIERS
                         || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)) {
                 logWarningMessage(node, firstNodeIndent);
             }
             else {
                 logWarningMessage(node, currentIndent);
             }
             itr.remove();
         }
     }
 
     /**
      * Checks line for end of scope.  Handles occurrences of close braces and close parenthesis on
      * the same line.
      *
      * @param lastAnnotationNode the last node of the annotation
      * @param node the node indicating where to begin checking
      * @return true if all the nodes up to the last annotation node are end of scope nodes
      *         false otherwise
      */
-    private boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {
+    private static boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {
         DetailAST checkNode = node;
         boolean endOfScope = true;
         while (endOfScope && !checkNode.equals(lastAnnotationNode)) {
             switch (checkNode.getType()) {
                 case TokenTypes.RCURLY:
                 case TokenTypes.RBRACK:
                     while (checkNode.getNextSibling() == null) {
                         checkNode = checkNode.getParent();
                     }
                     checkNode = checkNode.getNextSibling();
                     break;
                 default:
                     endOfScope = false;
 
             }
 
         }
         return endOfScope;
     }
 
     /**
      * Get the column number for the start of a given expression, expanding
      * tabs out into spaces in the process.
      *
      * @param ast   the expression to find the start of
      *
      * @return the column number for the start of the expression
      */
     private int expandedTabsColumnNo(DetailAST ast) {
         final String line =
             indentCheck.getLine(ast.getLineNo() - 1);
 
         return CommonUtils.lengthExpandedTabs(line, ast.getColumnNo(),
             indentCheck.getIndentationTabWidth());
     }
 
     /**
      * Get the start of the line for the given expression.
      *
      * @param ast   the expression to find the start of the line for
      *
      * @return the start of the line for the given expression
      */
     private int getLineStart(DetailAST ast) {
         final String line = indentCheck.getLine(ast.getLineNo() - 1);
         return getLineStart(line);
     }
 
     /**
      * Get the start of the specified line.
