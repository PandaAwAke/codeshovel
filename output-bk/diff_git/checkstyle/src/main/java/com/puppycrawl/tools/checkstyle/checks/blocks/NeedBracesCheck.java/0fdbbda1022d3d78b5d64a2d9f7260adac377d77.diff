diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java
index 06fdafdde..de566f109 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java
@@ -157,109 +157,124 @@ public class NeedBracesCheck extends AbstractCheck {
     public void setAllowSingleLineStatement(boolean allowSingleLineStatement) {
         this.allowSingleLineStatement = allowSingleLineStatement;
     }
 
     /**
      * Sets whether to allow empty loop body.
      * @param allowEmptyLoopBody Check's option for allowing loops with empty body.
      */
     public void setAllowEmptyLoopBody(boolean allowEmptyLoopBody) {
         this.allowEmptyLoopBody = allowEmptyLoopBody;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_WHILE,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_CASE,
             TokenTypes.LITERAL_DEFAULT,
             TokenTypes.LAMBDA,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST slistAST = ast.findFirstToken(TokenTypes.SLIST);
         boolean isElseIf = false;
         if (ast.getType() == TokenTypes.LITERAL_ELSE
             && ast.findFirstToken(TokenTypes.LITERAL_IF) != null) {
             isElseIf = true;
         }
-
+        final boolean isDefaultInAnnotation = isDefaultInAnnotation(ast);
         final boolean skipStatement = isSkipStatement(ast);
         final boolean skipEmptyLoopBody = allowEmptyLoopBody && isEmptyLoopBody(ast);
 
-        if (slistAST == null && !isElseIf && !skipStatement && !skipEmptyLoopBody) {
+        if (slistAST == null && !isElseIf && !isDefaultInAnnotation
+                && !skipStatement && !skipEmptyLoopBody) {
             log(ast.getLineNo(), MSG_KEY_NEED_BRACES, ast.getText());
         }
     }
 
+    /**
+     * Checks if ast is default in annotation
+     * @param ast ast to test.
+     * @return true if current ast is default and it is part of annatation.
+     */
+    private boolean isDefaultInAnnotation(DetailAST ast) {
+        boolean isDefaultInAnnotation = false;
+        if (ast.getType() == TokenTypes.LITERAL_DEFAULT
+                && ast.getParent().getType() == TokenTypes.ANNOTATION_FIELD_DEF) {
+            isDefaultInAnnotation = true;
+        }
+        return isDefaultInAnnotation;
+    }
+
     /**
      * Checks if current statement can be skipped by "need braces" warning.
      * @param statement if, for, while, do-while, lambda, else, case, default statements.
      * @return true if current statement can be skipped by Check.
      */
     private boolean isSkipStatement(DetailAST statement) {
         return allowSingleLineStatement && isSingleLineStatement(statement);
     }
 
     /**
      * Checks if current loop statement does not have body, e.g.:
      * <p>
      * {@code
      *   while (value.incrementValue() < 5);
      *   ...
      *   for(int i = 0; i < 10; value.incrementValue());
      * }
      * </p>
      * @param ast ast token.
      * @return true if current loop statement does not have body.
      */
     private static boolean isEmptyLoopBody(DetailAST ast) {
         boolean noBodyLoop = false;
 
         if (ast.getType() == TokenTypes.LITERAL_FOR
                 || ast.getType() == TokenTypes.LITERAL_WHILE) {
             DetailAST currentToken = ast.getFirstChild();
             while (currentToken.getNextSibling() != null) {
                 currentToken = currentToken.getNextSibling();
             }
             noBodyLoop = currentToken.getType() == TokenTypes.EMPTY_STAT;
         }
         return noBodyLoop;
     }
 
     /**
      * Checks if current statement is single-line statement, e.g.:
      * <p>
      * {@code
      * if (obj.isValid()) return true;
      * }
      * </p>
      * <p>
      * {@code
      * while (obj.isValid()) return true;
      * }
      * </p>
      * @param statement if, for, while, do-while, lambda, else, case, default statements.
      * @return true if current statement is single-line statement.
      */
@@ -363,108 +378,119 @@ public class NeedBracesCheck extends AbstractCheck {
      * <p>
      * {@code
      * if (obj.isValid()) return true;
      * }
      * </p>
      * @param literalIf {@link TokenTypes#LITERAL_IF if statement}.
      * @return true if current if statement is single-line statement.
      */
     private static boolean isSingleLineIf(DetailAST literalIf) {
         boolean result = false;
         final DetailAST ifCondition = literalIf.findFirstToken(TokenTypes.EXPR);
         if (literalIf.getParent().getType() == TokenTypes.SLIST) {
             final DetailAST literalIfLastChild = literalIf.getLastChild();
             final DetailAST block;
             if (literalIfLastChild.getType() == TokenTypes.LITERAL_ELSE) {
                 block = literalIfLastChild.getPreviousSibling();
             }
             else {
                 block = literalIfLastChild;
             }
             result = ifCondition.getLineNo() == block.getLineNo();
         }
         return result;
     }
 
     /**
      * Checks if current lambda statement is single-line statement, e.g.:
      * <p>
      * {@code
      * Runnable r = () -> System.out.println("Hello, world!");
      * }
      * </p>
      * @param lambda {@link TokenTypes#LAMBDA lambda statement}.
      * @return true if current lambda statement is single-line statement.
      */
     private static boolean isSingleLineLambda(DetailAST lambda) {
         boolean result = false;
         final DetailAST block = lambda.getLastChild();
         if (block.getType() != TokenTypes.SLIST) {
             result = lambda.getLineNo() == block.getLineNo();
         }
         return result;
     }
 
     /**
      * Checks if current case statement is single-line statement, e.g.:
      * <p>
      * {@code
      * case 1: doSomeStuff(); break;
      * case 2: doSomeStuff(); break;
+     * case 3: ;
      * }
      * </p>
      * @param literalCase {@link TokenTypes#LITERAL_CASE case statement}.
      * @return true if current case statement is single-line statement.
      */
     private static boolean isSingleLineCase(DetailAST literalCase) {
         boolean result = false;
         final DetailAST slist = literalCase.getNextSibling();
-        final DetailAST block = slist.getFirstChild();
-        if (block.getType() != TokenTypes.SLIST) {
-            final DetailAST caseBreak = slist.findFirstToken(TokenTypes.LITERAL_BREAK);
-            final boolean atOneLine = literalCase.getLineNo() == block.getLineNo();
-            if (caseBreak != null) {
-                result = atOneLine && block.getLineNo() == caseBreak.getLineNo();
+        if (slist == null) {
+            result = true;
+        }
+        else {
+            final DetailAST block = slist.getFirstChild();
+            if (block.getType() != TokenTypes.SLIST) {
+                final DetailAST caseBreak = slist.findFirstToken(TokenTypes.LITERAL_BREAK);
+                final boolean atOneLine = literalCase.getLineNo() == block.getLineNo();
+                if (caseBreak != null) {
+                    result = atOneLine && block.getLineNo() == caseBreak.getLineNo();
+                }
             }
         }
         return result;
     }
 
     /**
      * Checks if current default statement is single-line statement, e.g.:
      * <p>
      * {@code
      * default: doSomeStuff();
      * }
      * </p>
      * @param literalDefault {@link TokenTypes#LITERAL_DEFAULT default statement}.
      * @return true if current default statement is single-line statement.
      */
     private static boolean isSingleLineDefault(DetailAST literalDefault) {
         boolean result = false;
         final DetailAST slist = literalDefault.getNextSibling();
-        final DetailAST block = slist.getFirstChild();
-        if (block.getType() != TokenTypes.SLIST) {
-            result = literalDefault.getLineNo() == block.getLineNo();
+        if (slist == null) {
+            result = true;
+        }
+        else {
+            final DetailAST block = slist.getFirstChild();
+            if (block != null && block.getType() != TokenTypes.SLIST) {
+                result = literalDefault.getLineNo() == block.getLineNo();
+            }
         }
         return result;
     }
 
     /**
      * Checks if current else statement is single-line statement, e.g.:
      * <p>
      * {@code
      * else doSomeStuff();
      * }
      * </p>
      * @param literalElse {@link TokenTypes#LITERAL_ELSE else statement}.
      * @return true if current else statement is single-line statement.
      */
     private static boolean isSingleLineElse(DetailAST literalElse) {
         boolean result = false;
         final DetailAST block = literalElse.getFirstChild();
         if (block.getType() != TokenTypes.SLIST) {
             result = literalElse.getLineNo() == block.getLineNo();
         }
         return result;
     }
 }
