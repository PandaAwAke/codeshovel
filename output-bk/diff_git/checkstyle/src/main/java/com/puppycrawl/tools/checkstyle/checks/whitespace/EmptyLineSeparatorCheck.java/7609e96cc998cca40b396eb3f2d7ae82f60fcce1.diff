diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
index 016dd569f..bfd1bbc3f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
@@ -441,151 +441,151 @@ public class EmptyLineSeparatorCheck extends AbstractCheck {
     }
 
     /**
      * Process Variable.
      * @param ast token
      * @param nextToken next Token
      */
     private void processVariableDef(DetailAST ast, DetailAST nextToken) {
         if (isTypeField(ast) && !hasEmptyLineAfter(ast)
                 && isViolatingEmptyLineBetweenFieldsPolicy(nextToken)) {
             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,
                     nextToken.getText());
         }
     }
 
     /**
      * Checks whether token placement violates policy of empty line between fields.
      * @param detailAST token to be analyzed
      * @return true if policy is violated and warning should be raised; false otherwise
      */
     private boolean isViolatingEmptyLineBetweenFieldsPolicy(DetailAST detailAST) {
         return allowNoEmptyLineBetweenFields
                     && detailAST.getType() != TokenTypes.VARIABLE_DEF
                     && detailAST.getType() != TokenTypes.RCURLY
                 || !allowNoEmptyLineBetweenFields
                     && detailAST.getType() != TokenTypes.RCURLY;
     }
 
     /**
      * Checks if a token has empty two previous lines and multiple empty lines is not allowed.
      * @param token DetailAST token
      * @return true, if token has empty two lines before and allowMultipleEmptyLines is false
      */
     private boolean hasNotAllowedTwoEmptyLinesBefore(DetailAST token) {
         return !allowMultipleEmptyLines && hasEmptyLineBefore(token)
                 && isPrePreviousLineEmpty(token);
     }
 
     /**
      * Checks if a token has empty pre-previous line.
      * @param token DetailAST token.
      * @return true, if token has empty lines before.
      */
     private boolean isPrePreviousLineEmpty(DetailAST token) {
         boolean result = false;
         final int lineNo = token.getLineNo();
         // 3 is the number of the pre-previous line because the numbering starts from zero.
         final int number = 3;
         if (lineNo >= number) {
             final String prePreviousLine = getLines()[lineNo - number];
-            result = prePreviousLine.trim().isEmpty();
+            result = CommonUtils.isBlank(prePreviousLine);
         }
         return result;
     }
 
     /**
      * Checks if token have empty line after.
      * @param token token.
      * @return true if token have empty line after.
      */
     private boolean hasEmptyLineAfter(DetailAST token) {
         DetailAST lastToken = token.getLastChild().getLastChild();
         if (lastToken == null) {
             lastToken = token.getLastChild();
         }
         DetailAST nextToken = token.getNextSibling();
         if (isComment(nextToken)) {
             nextToken = nextToken.getNextSibling();
         }
         // Start of the next token
         final int nextBegin = nextToken.getLineNo();
         // End of current token.
         final int currentEnd = lastToken.getLineNo();
         return hasEmptyLine(currentEnd + 1, nextBegin - 1);
     }
 
     /**
      * Checks, whether there are empty lines within the specified line range. Line numbering is
      * started from 1 for parameter values
      * @param startLine number of the first line in the range
      * @param endLine number of the second line in the range
      * @return <code>true</code> if found any blank line within the range, <code>false</code>
      *         otherwise
      */
     private boolean hasEmptyLine(int startLine, int endLine) {
         // Initial value is false - blank line not found
         boolean result = false;
         if (startLine <= endLine) {
             final FileContents fileContents = getFileContents();
             for (int line = startLine; line <= endLine; line++) {
                 // Check, if the line is blank. Lines are numbered from 0, so subtract 1
                 if (fileContents.lineIsBlank(line - 1)) {
                     result = true;
                     break;
                 }
             }
         }
         return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param token token.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(DetailAST token) {
         boolean result = false;
         final int lineNo = token.getLineNo();
         if (lineNo != 1) {
             // [lineNo - 2] is the number of the previous line as the numbering starts from zero.
             final String lineBefore = getLines()[lineNo - 2];
-            result = lineBefore.trim().isEmpty();
+            result = CommonUtils.isBlank(lineBefore);
         }
         return result;
     }
 
     /**
      * Check if token is preceded by javadoc comment.
      * @param token token for check.
      * @return true, if token is preceded by javadoc comment.
      */
     private static boolean isPrecededByJavadoc(DetailAST token) {
         boolean result = false;
         final DetailAST previous = token.getPreviousSibling();
         if (previous.getType() == TokenTypes.BLOCK_COMMENT_BEGIN
                 && JavadocUtils.isJavadocComment(previous)) {
             result = true;
         }
         return result;
     }
 
     /**
      * Check if token is a comment.
      * @param ast ast node
      * @return true, if given ast is comment.
      */
     private static boolean isComment(DetailAST ast) {
         return ast.getType() == TokenTypes.SINGLE_LINE_COMMENT
                    || ast.getType() == TokenTypes.BLOCK_COMMENT_BEGIN;
     }
 
     /**
      * If variable definition is a type field.
      * @param variableDef variable definition.
      * @return true variable definition is a type field.
      */
     private static boolean isTypeField(DetailAST variableDef) {
         final int parentType = variableDef.getParent().getParent().getType();
         return parentType == TokenTypes.CLASS_DEF;
     }
 }
