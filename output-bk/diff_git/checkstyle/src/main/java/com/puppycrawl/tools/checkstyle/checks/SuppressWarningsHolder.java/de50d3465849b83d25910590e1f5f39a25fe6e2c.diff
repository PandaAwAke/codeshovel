diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
index b5eca8e8d..8dc6558e9 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
@@ -361,160 +361,164 @@ public class SuppressWarningsHolder
         final DetailAST result;
         final DetailAST parent = child.getParent();
         switch (parent.getType()) {
             case TokenTypes.ANNOTATION_DEF:
             case TokenTypes.PACKAGE_DEF:
             case TokenTypes.CLASS_DEF:
             case TokenTypes.INTERFACE_DEF:
             case TokenTypes.ENUM_DEF:
             case TokenTypes.ENUM_CONSTANT_DEF:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.PARAMETER_DEF:
             case TokenTypes.VARIABLE_DEF:
             case TokenTypes.ANNOTATION_FIELD_DEF:
             case TokenTypes.TYPE:
             case TokenTypes.LITERAL_NEW:
             case TokenTypes.LITERAL_THROWS:
             case TokenTypes.TYPE_ARGUMENT:
             case TokenTypes.IMPLEMENTS_CLAUSE:
             case TokenTypes.DOT:
                 result = parent;
                 break;
             default:
                 // it's possible case, but shouldn't be processed here
                 result = null;
         }
         return result;
     }
 
     /**
      * Returns the n'th child of an AST node.
      * @param ast the AST node to get the child of
      * @param index the index of the child to get
      * @return the n'th child of the given AST node, or {@code null} if none
      */
     private static DetailAST getNthChild(DetailAST ast, int index) {
         DetailAST child = ast.getFirstChild();
         for (int i = 0; i < index && child != null; ++i) {
             child = child.getNextSibling();
         }
         return child;
     }
 
     /**
      * Returns the Java identifier represented by an AST.
      * @param ast an AST node for an IDENT or DOT
      * @return the Java identifier represented by the given AST subtree
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getIdentifier(DetailAST ast) {
-        if (ast != null) {
-            if (ast.getType() == TokenTypes.IDENT) {
-                return ast.getText();
-            }
-            else {
-                return getIdentifier(ast.getFirstChild()) + "."
-                        + getIdentifier(ast.getLastChild());
-            }
+        if (ast == null) {
+            throw new IllegalArgumentException("Identifier AST expected, but get null.");
+        }
+        final String identifier;
+        if (ast.getType() == TokenTypes.IDENT) {
+            identifier = ast.getText();
+        }
+        else {
+            identifier = getIdentifier(ast.getFirstChild()) + "."
+                + getIdentifier(ast.getLastChild());
         }
-        throw new IllegalArgumentException("Identifier AST expected, but get null.");
+        return identifier;
     }
 
     /**
      * Returns the literal string expression represented by an AST.
      * @param ast an AST node for an EXPR
      * @return the Java string represented by the given AST expression
      *         or empty string if expression is too complex
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getStringExpr(DetailAST ast) {
         final DetailAST firstChild = ast.getFirstChild();
         String expr = "";
 
         switch (firstChild.getType()) {
             case TokenTypes.STRING_LITERAL:
                 // NOTE: escaped characters are not unescaped
                 final String quotedText = firstChild.getText();
                 expr = quotedText.substring(1, quotedText.length() - 1);
                 break;
             case TokenTypes.IDENT:
                 expr = firstChild.getText();
                 break;
             case TokenTypes.DOT:
                 expr = firstChild.getLastChild().getText();
                 break;
             default:
                 // annotations with complex expressions cannot suppress warnings
         }
         return expr;
     }
 
     /**
      * Returns the annotation values represented by an AST.
      * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT
      * @return the list of Java string represented by the given AST for an
      *         expression or annotation array initializer
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static List<String> getAnnotationValues(DetailAST ast) {
+        final List<String> annotationValues;
         switch (ast.getType()) {
             case TokenTypes.EXPR:
-                return Collections.singletonList(getStringExpr(ast));
-
+                annotationValues = Collections.singletonList(getStringExpr(ast));
+                break;
             case TokenTypes.ANNOTATION_ARRAY_INIT:
-                return findAllExpressionsInChildren(ast);
-
+                annotationValues = findAllExpressionsInChildren(ast);
+                break;
             default:
                 throw new IllegalArgumentException(
                         "Expression or annotation array initializer AST expected: " + ast);
         }
+        return annotationValues;
     }
 
     /**
      * Method looks at children and returns list of expressions in strings.
      * @param parent ast, that contains children
      * @return list of expressions in strings
      */
     private static List<String> findAllExpressionsInChildren(DetailAST parent) {
         final List<String> valueList = new LinkedList<>();
         DetailAST childAST = parent.getFirstChild();
         while (childAST != null) {
             if (childAST.getType() == TokenTypes.EXPR) {
                 valueList.add(getStringExpr(childAST));
             }
             childAST = childAST.getNextSibling();
         }
         return valueList;
     }
 
     /** Records a particular suppression for a region of a file. */
     private static class Entry {
         /** The source name of the suppressed check. */
         private final String checkName;
         /** The suppression region for the check - first line. */
         private final int firstLine;
         /** The suppression region for the check - first column. */
         private final int firstColumn;
         /** The suppression region for the check - last line. */
         private final int lastLine;
         /** The suppression region for the check - last column. */
         private final int lastColumn;
 
         /**
          * Constructs a new suppression region entry.
          * @param checkName the source name of the suppressed check
          * @param firstLine the first line of the suppression region
          * @param firstColumn the first column of the suppression region
          * @param lastLine the last line of the suppression region
          * @param lastColumn the last column of the suppression region
          */
         Entry(String checkName, int firstLine, int firstColumn,
             int lastLine, int lastColumn) {
             this.checkName = checkName;
             this.firstLine = firstLine;
             this.firstColumn = firstColumn;
             this.lastLine = lastLine;
             this.lastColumn = lastColumn;
         }
 
         /**
