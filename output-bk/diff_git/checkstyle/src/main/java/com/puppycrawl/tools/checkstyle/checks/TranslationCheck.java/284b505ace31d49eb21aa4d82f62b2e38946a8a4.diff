diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
index 60d78814a..62a1c5676 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java
@@ -14,163 +14,183 @@
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.puppycrawl.tools.checkstyle.Defn;
 import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.MessageDispatcher;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.Map.Entry;
 
 /**
  * <p>
  * The TranslationCheck class helps to ensure the correct translation of code by
  * checking property files for consistency regarding their keys.
  * Two property files describing one and the same context are consistent if they
  * contain the same keys.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="Translation"/&gt;
  * </pre>
  * @author Alexandra Bunge
  * @author lkuehne
  */
 public class TranslationCheck
     extends AbstractFileSetCheck
 {
     /** The property files to process. */
     private final List<File> mPropertyFiles = Lists.newArrayList();
 
+    /** The separator string used to separate translation files */
+    private String mBasenameSeparator;
+
     /**
      * Creates a new <code>TranslationCheck</code> instance.
      */
     public TranslationCheck()
     {
         setFileExtensions(new String[]{"properties"});
+        setBasenameSeparator("_");
     }
 
     @Override
     public void beginProcessing(String aCharset)
     {
         super.beginProcessing(aCharset);
         mPropertyFiles.clear();
     }
 
     @Override
     protected void processFiltered(File aFile, List<String> aLines)
     {
         mPropertyFiles.add(aFile);
     }
 
     @Override
     public void finishProcessing()
     {
         super.finishProcessing();
         final Map<String, Set<File>> propFilesMap =
-            arrangePropertyFiles(mPropertyFiles);
+            arrangePropertyFiles(mPropertyFiles, mBasenameSeparator);
         checkPropertyFileSets(propFilesMap);
     }
 
     /**
      * Gets the basename (the unique prefix) of a property file. For example
      * "xyz/messages" is the basename of "xyz/messages.properties",
      * "xyz/messages_de_AT.properties", "xyz/messages_en.properties", etc.
      *
      * @param aFile the file
+     * @param aBasenameSeparator the basename separator
      * @return the extracted basename
      */
-    private static String extractPropertyIdentifier(final File aFile)
+    private static String extractPropertyIdentifier(final File aFile,
+            final String aBasenameSeparator)
     {
         final String filePath = aFile.getPath();
         final int dirNameEnd = filePath.lastIndexOf(File.separatorChar);
         final int baseNameStart = dirNameEnd + 1;
-        final int underscoreIdx = filePath.indexOf('_', baseNameStart);
+        final int underscoreIdx = filePath.indexOf(aBasenameSeparator,
+            baseNameStart);
         final int dotIdx = filePath.indexOf('.', baseNameStart);
         final int cutoffIdx = (underscoreIdx != -1) ? underscoreIdx : dotIdx;
         return filePath.substring(0, cutoffIdx);
     }
 
+   /**
+    * Sets the separator used to determine the basename of a property file.
+    * This defaults to "_"
+    *
+    * @param aBasenameSeparator the basename separator
+    */
+    public void setBasenameSeparator(String aBasenameSeparator)
+    {
+        mBasenameSeparator = aBasenameSeparator;
+    }
+
     /**
      * Arranges a set of property files by their prefix.
      * The method returns a Map object. The filename prefixes
      * work as keys each mapped to a set of files.
      * @param aPropFiles the set of property files
+     * @param aBasenameSeparator the basename separator
      * @return a Map object which holds the arranged property file sets
      */
     private static Map<String, Set<File>> arrangePropertyFiles(
-        List<File> aPropFiles)
+        List<File> aPropFiles, String aBasenameSeparator)
     {
         final Map<String, Set<File>> propFileMap = Maps.newHashMap();
 
         for (final File f : aPropFiles) {
-            final String identifier = extractPropertyIdentifier(f);
+            final String identifier = extractPropertyIdentifier(f,
+                aBasenameSeparator);
 
             Set<File> fileSet = propFileMap.get(identifier);
             if (fileSet == null) {
                 fileSet = Sets.newHashSet();
                 propFileMap.put(identifier, fileSet);
             }
             fileSet.add(f);
         }
         return propFileMap;
     }
 
     /**
      * Loads the keys of the specified property file into a set.
      * @param aFile the property file
      * @return a Set object which holds the loaded keys
      */
     private Set<Object> loadKeys(File aFile)
     {
         final Set<Object> keys = Sets.newHashSet();
         InputStream inStream = null;
 
         try {
             // Load file and properties.
             inStream = new FileInputStream(aFile);
             final Properties props = new Properties();
             props.load(inStream);
 
             // Gather the keys and put them into a set
             final Enumeration<?> e = props.propertyNames();
             while (e.hasMoreElements()) {
                 keys.add(e.nextElement());
             }
         }
         catch (final IOException e) {
             logIOException(e, aFile);
         }
         finally {
             Utils.closeQuietly(inStream);
         }
         return keys;
     }
 
     /**
      * helper method to log an io exception.
      * @param aEx the exception that occured
      * @param aFile the file that could not be processed
      */
     private void logIOException(IOException aEx, File aFile)
     {
         String[] args = null;
