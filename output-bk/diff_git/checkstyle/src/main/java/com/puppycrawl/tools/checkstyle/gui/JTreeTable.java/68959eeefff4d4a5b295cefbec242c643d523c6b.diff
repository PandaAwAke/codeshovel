diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
index 2c25c2d2f..2304248d8 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
@@ -103,101 +103,101 @@ import com.puppycrawl.tools.checkstyle.api.DetailAST;
 public class JTreeTable extends JTable {
     /** For Serialisation that will never happen. */
     private static final long serialVersionUID = -8493693409423365387L;
     /** A subclass of JTree. */
     protected TreeTableCellRenderer tree;
     private JTextArea editor;
     private List<Integer> lines2position;
 
     public JTreeTable(TreeTableModel treeTableModel) {
         super();
 
         // Create the tree. It will be used as a renderer and editor.
         tree = new TreeTableCellRenderer(treeTableModel);
 
         // Install a tableModel representing the visible rows in the tree.
         setModel(new TreeTableModelAdapter(treeTableModel, tree));
 
         // Force the JTable and JTree to share their row selection models.
         final ListToTreeSelectionModelWrapper selectionWrapper = new
                 ListToTreeSelectionModelWrapper();
         tree.setSelectionModel(selectionWrapper);
         setSelectionModel(selectionWrapper.getListSelectionModel());
 
         // Install the tree editor renderer and editor.
         setDefaultRenderer(TreeTableModel.class, tree);
         setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());
 
         // No grid.
         setShowGrid(false);
 
         // No intercell spacing
         setIntercellSpacing(new Dimension(0, 0));
 
         // And update the height of the trees row to match that of
         // the table.
         if (tree.getRowHeight() < 1) {
             // Metal looks better like this.
             setRowHeight(getRowHeight());
         }
 
         final Action expand = new AbstractAction() {
                 /**
              *
              */
             private static final long serialVersionUID = -5859674518660156121L;
 
                 @Override
                 public void actionPerformed(ActionEvent e) {
                     final TreePath selected = tree.getSelectionPath();
 
-                    DetailAST ast = (DetailAST) selected.getLastPathComponent();
+                    final DetailAST ast = (DetailAST) selected.getLastPathComponent();
                     new CodeSelector(ast, editor, lines2position).select();
 
                     if (tree.isExpanded(selected)) {
                         tree.collapsePath(selected);
                     }
                     else {
                         tree.expandPath(selected);
                     }
                     tree.setSelectionPath(selected);
                 }
             };
         final KeyStroke stroke = KeyStroke.getKeyStroke("ENTER");
         final String command = "expand/collapse";
         getInputMap().put(stroke, command);
         getActionMap().put(command, expand);
     }
 
     /**
      * Overridden to message super and forward the method to the tree.
      * Since the tree is not actually in the component hierarchy it will
      * never receive this unless we forward it in this manner.
      */
     @Override
     public void updateUI() {
         super.updateUI();
         if (tree != null) {
             tree.updateUI();
         }
         // Use the tree's default foreground and background colors in the
         // table.
         LookAndFeel.installColorsAndFont(this, "Tree.background",
                 "Tree.foreground", "Tree.font");
     }
 
     /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to
      * paint the editor. The UI currently uses different techniques to
      * paint the renderers and editors and overriding setBounds() below
      * is not the right thing to do for an editor. Returning -1 for the
      * editing row in this case, ensures the editor is never painted.
      */
     @Override
     public int getEditingRow() {
         final Class<?> editingClass = getColumnClass(editingColumn);
         return editingClass == TreeTableModel.class ? -1 : editingRow;
     }
 
     /**
      * Overridden to pass the new rowHeight to the tree.
      */
     @Override
