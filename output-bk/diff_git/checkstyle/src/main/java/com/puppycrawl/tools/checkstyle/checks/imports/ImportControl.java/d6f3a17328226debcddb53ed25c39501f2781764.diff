diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControl.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControl.java
index c7dcd9e6e..c49020236 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControl.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControl.java
@@ -224,81 +224,81 @@ class ImportControl {
             result = matchesAtFrontNoRegex(pkg);
         }
         return result;
     }
 
     /**
      * Non-regex case. Ensure a trailing dot for subpackages, i.e. "com.puppy"
      * will match "com.puppy.crawl" but not "com.puppycrawl.tools".
      * @param pkg the package to compare with.
      * @return if it matches.
      */
     private boolean matchesAtFrontNoRegex(final String pkg) {
         return pkg.startsWith(fullPackage)
                 && (pkg.length() == fullPackage.length()
                     || pkg.charAt(fullPackage.length()) == '.');
     }
 
     /**
      * Returns whether a package or class is allowed to be imported.
      * The algorithm checks with the current node for a result, and if none is
      * found then calls its parent looking for a match. This will recurse
      * looking for match. If there is no clear result then
      * {@link AccessResult#UNKNOWN} is returned.
      * @param forImport the import to check on.
      * @param inPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
     public AccessResult checkAccess(final String inPkg, final String forImport) {
         final AccessResult result;
         final AccessResult returnValue = localCheckAccess(inPkg, forImport);
         if (returnValue != AccessResult.UNKNOWN) {
             result = returnValue;
         }
         else if (parent == null) {
             // we are the top, so default to not allowed.
             result = AccessResult.DISALLOWED;
         }
         else {
             result = parent.checkAccess(inPkg, forImport);
         }
         return result;
     }
 
     /**
      * Checks whether any of the rules for this node control access to
      * a specified package or class.
      * @param forImport the import to check.
      * @param inPkg the package doing the import.
      * @return an {@link AccessResult}.
      */
-    private AccessResult localCheckAccess(final String inPkg,
-        final String forImport) {
-        for (AbstractImportRule r : rules) {
+    private AccessResult localCheckAccess(final String inPkg, final String forImport) {
+        AccessResult localCheckAccessResult = AccessResult.UNKNOWN;
+        for (AbstractImportRule importRule : rules) {
             // Check if an import rule is only meant to be applied locally.
-            if (r.isLocalOnly() && !matchesExactly(inPkg)) {
-                continue;
-            }
-            final AccessResult result = r.verifyImport(forImport);
-            if (result != AccessResult.UNKNOWN) {
-                return result;
+            if (!importRule.isLocalOnly() || matchesExactly(inPkg)) {
+                final AccessResult result = importRule.verifyImport(forImport);
+                if (result != AccessResult.UNKNOWN) {
+                    localCheckAccessResult = result;
+                    break;
+                }
             }
         }
-        return AccessResult.UNKNOWN;
+        return localCheckAccessResult;
     }
 
     /**
      * Check for equality of this with pkg
      * @param pkg the package to compare with.
      * @return if it matches.
      */
     private boolean matchesExactly(final String pkg) {
         final boolean result;
         if (regex) {
             result = patternForExactMatch.matcher(pkg).matches();
         }
         else {
             result = fullPackage.equals(pkg);
         }
         return result;
     }
 }
