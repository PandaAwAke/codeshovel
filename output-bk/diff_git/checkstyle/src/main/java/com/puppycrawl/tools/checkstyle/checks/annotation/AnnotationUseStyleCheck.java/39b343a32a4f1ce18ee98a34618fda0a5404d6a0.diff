diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
index 595f06b6b..16d891f6d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
@@ -388,124 +388,120 @@ public final class AnnotationUseStyleCheck extends AbstractCheck {
             && ANNOTATION_ELEMENT_SINGLE_NAME.equals(
                 valuePair.getFirstChild().getText())) {
             log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.COMPACT);
         }
     }
 
     /**
      * Checks for compact no array style type violations.
      *
      * @param annotation the annotation token
      */
     private void checkCompactNoArrayStyle(final DetailAST annotation) {
         final DetailAST arrayInit =
             annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
 
         final int valuePairCount =
             annotation.getChildCount(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         final DetailAST valuePair =
             annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         //in compact style with one value
         if (arrayInit != null
             && arrayInit.getChildCount(TokenTypes.EXPR) == 1) {
             log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.COMPACT_NO_ARRAY);
         }
         //in expanded style with one value and the correct element name
         else if (valuePairCount == 1) {
             final DetailAST nestedArrayInit =
                 valuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
 
             if (nestedArrayInit != null
                 && ANNOTATION_ELEMENT_SINGLE_NAME.equals(
                     valuePair.getFirstChild().getText())
                     && nestedArrayInit.getChildCount(TokenTypes.EXPR) == 1) {
                 log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                     ElementStyle.COMPACT_NO_ARRAY);
             }
         }
     }
 
     /**
      * Checks to see if the trailing comma is present if required or
      * prohibited.
      *
      * @param annotation the annotation token
      */
     private void checkTrailingComma(final DetailAST annotation) {
-        if (trailingArrayComma == TrailingArrayComma.IGNORE) {
-            return;
-        }
-
-        DetailAST child = annotation.getFirstChild();
-
-        while (child != null) {
-            DetailAST arrayInit = null;
-
-            if (child.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR) {
-                arrayInit = child.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
-            }
-            else if (child.getType() == TokenTypes.ANNOTATION_ARRAY_INIT) {
-                arrayInit = child;
-            }
-
-            if (arrayInit != null) {
-                logCommaViolation(arrayInit);
+        if (trailingArrayComma != TrailingArrayComma.IGNORE) {
+            DetailAST child = annotation.getFirstChild();
+
+            while (child != null) {
+                DetailAST arrayInit = null;
+
+                if (child.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR) {
+                    arrayInit = child.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
+                }
+                else if (child.getType() == TokenTypes.ANNOTATION_ARRAY_INIT) {
+                    arrayInit = child;
+                }
+
+                if (arrayInit != null) {
+                    logCommaViolation(arrayInit);
+                }
+                child = child.getNextSibling();
             }
-            child = child.getNextSibling();
         }
     }
 
     /**
      * Logs a trailing array comma violation if one exists.
      *
      * @param ast the array init
      * {@link TokenTypes#ANNOTATION_ARRAY_INIT ANNOTATION_ARRAY_INIT}.
      */
     private void logCommaViolation(final DetailAST ast) {
         final DetailAST rCurly = ast.findFirstToken(TokenTypes.RCURLY);
 
         //comma can be null if array is empty
         final DetailAST comma = rCurly.getPreviousSibling();
 
         if (trailingArrayComma == TrailingArrayComma.ALWAYS
             && (comma == null || comma.getType() != TokenTypes.COMMA)) {
             log(rCurly.getLineNo(),
                 rCurly.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING);
         }
         else if (trailingArrayComma == TrailingArrayComma.NEVER
             && comma != null && comma.getType() == TokenTypes.COMMA) {
             log(comma.getLineNo(),
                 comma.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT);
         }
     }
 
     /**
      * Checks to see if the closing parenthesis are present if required or
      * prohibited.
      *
      * @param ast the annotation token
      */
     private void checkCheckClosingParens(final DetailAST ast) {
-        if (closingParens == ClosingParens.IGNORE) {
-            return;
-        }
-
-        final DetailAST paren = ast.getLastChild();
-        final boolean parenExists = paren.getType() == TokenTypes.RPAREN;
+        if (closingParens != ClosingParens.IGNORE) {
+            final DetailAST paren = ast.getLastChild();
+            final boolean parenExists = paren.getType() == TokenTypes.RPAREN;
 
-        if (closingParens == ClosingParens.ALWAYS
-            && !parenExists) {
-            log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_MISSING);
-        }
-        else if (closingParens == ClosingParens.NEVER
-                 && parenExists
-                 && !ast.branchContains(TokenTypes.EXPR)
-                 && !ast.branchContains(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
-                 && !ast.branchContains(TokenTypes.ANNOTATION_ARRAY_INIT)) {
-            log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_PRESENT);
+            if (closingParens == ClosingParens.ALWAYS
+                && !parenExists) {
+                log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_MISSING);
+            }
+            else if (closingParens == ClosingParens.NEVER
+                     && parenExists
+                     && !ast.branchContains(TokenTypes.EXPR)
+                     && !ast.branchContains(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
+                     && !ast.branchContains(TokenTypes.ANNOTATION_ARRAY_INIT)) {
+                log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_PRESENT);
+            }
         }
     }
 }
