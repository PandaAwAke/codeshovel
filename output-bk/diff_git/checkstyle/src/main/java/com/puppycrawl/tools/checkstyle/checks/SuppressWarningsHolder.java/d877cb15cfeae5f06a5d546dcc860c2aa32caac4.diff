diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
index 8b51b1734..1de978d83 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java
@@ -104,102 +104,102 @@ public class SuppressWarningsHolder
         return checkAlias;
     }
 
     /**
      * Registers an alias for the source name of a check.
      * @param sourceName the source name of the check (generally the class
      *        name)
      * @param checkAlias the alias used in {@link SuppressWarnings} annotations
      */
     public static void registerAlias(String sourceName, String checkAlias) {
         CHECK_ALIAS_MAP.put(sourceName, checkAlias);
     }
 
     /**
      * Registers a list of source name aliases based on a comma-separated list
      * of {@code source=alias} items, such as {@code
      * com.puppycrawl.tools.checkstyle.checks.sizes.ParameterNumberCheck=
      * paramnum}.
      * @param aliasList the list of comma-separated alias assignments
      */
     public void setAliasList(String aliasList) {
         for (String sourceAlias : aliasList.split(",")) {
             final int index = sourceAlias.indexOf('=');
             if (index > 0) {
                 registerAlias(sourceAlias.substring(0, index), sourceAlias
                     .substring(index + 1));
             }
             else if (!sourceAlias.isEmpty()) {
                 throw new ConversionException(
                     "'=' expected in alias list item: " + sourceAlias);
             }
         }
     }
 
     /**
      * Checks for a suppression of a check with the given source name and
      * location in the last file processed.
      * @param sourceName the source name of the check
      * @param line the line number of the check
      * @param column the column number of the check
      * @return whether the check with the given name is suppressed at the given
      *         source location
      */
     public static boolean isSuppressed(String sourceName, int line,
         int column) {
         final List<Entry> entries = ENTRIES.get();
         final String checkAlias = getAlias(sourceName);
         for (Entry entry : entries) {
             final boolean afterStart =
                 entry.getFirstLine() < line
-                    || entry.getFirstLine() == line && entry
-                        .getFirstColumn() <= column;
+                    || entry.getFirstLine() == line
+                            && entry.getFirstColumn() <= column;
             final boolean beforeEnd =
                 entry.getLastLine() > line
                     || entry.getLastLine() == line && entry
                         .getLastColumn() >= column;
             final boolean nameMatches =
                 entry.getCheckName().equals(checkAlias);
             if (afterStart && beforeEnd && nameMatches) {
                 return true;
             }
         }
         return false;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.ANNOTATION};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         ENTRIES.set(new LinkedList<Entry>());
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         // check whether annotation is SuppressWarnings
         // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN
         String identifier = getIdentifier(getNthChild(ast, 1));
         if (identifier.startsWith(JAVA_LANG_PREFIX)) {
             identifier = identifier.substring(JAVA_LANG_PREFIX.length());
         }
         if ("SuppressWarnings".equals(identifier)) {
 
             final List<String> values = getAllAnnotationValues(ast);
             if (isAnnotationEmpty(values)) {
                 return;
             }
 
             final DetailAST targetAST = getAnnotationTarget(ast);
 
@@ -259,136 +259,130 @@ public class SuppressWarningsHolder
      */
     private static List<String> getAllAnnotationValues(DetailAST ast) {
         // get values of annotation
         List<String> values = null;
         final DetailAST lparenAST = ast.findFirstToken(TokenTypes.LPAREN);
         if (lparenAST != null) {
             final DetailAST nextAST = lparenAST.getNextSibling();
             if (nextAST != null) {
                 final int nextType = nextAST.getType();
                 switch (nextType) {
                     case TokenTypes.EXPR:
                     case TokenTypes.ANNOTATION_ARRAY_INIT:
                         values = getAnnotationValues(nextAST);
                         break;
 
                     case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:
                         // expected children: IDENT ASSIGN ( EXPR |
                         // ANNOTATION_ARRAY_INIT )
                         values = getAnnotationValues(getNthChild(nextAST, 2));
                         break;
 
                     case TokenTypes.RPAREN:
                         // no value present (not valid Java)
                         break;
 
                     default:
                         // unknown annotation value type (new syntax?)
                 }
             }
         }
         return values;
     }
 
     /**
      * Checks that annotation is empty.
      * @param values list of values in the annotation
      * @return whether annotation is empty or contains some values
      */
     private static boolean isAnnotationEmpty(List<String> values) {
         return values == null;
     }
 
     /**
      * Get target of annotation.
      * @param ast the AST node to get the child of
      * @return get target of annotation
      */
     private static DetailAST getAnnotationTarget(DetailAST ast) {
         DetailAST targetAST = null;
         DetailAST parentAST = ast.getParent();
-        if (parentAST != null) {
-            switch (parentAST.getType()) {
-                case TokenTypes.MODIFIERS:
-                case TokenTypes.ANNOTATIONS:
-                    parentAST = parentAST.getParent();
-                    if (parentAST != null) {
-                        switch (parentAST.getType()) {
-                            case TokenTypes.ANNOTATION_DEF:
-                            case TokenTypes.PACKAGE_DEF:
-                            case TokenTypes.CLASS_DEF:
-                            case TokenTypes.INTERFACE_DEF:
-                            case TokenTypes.ENUM_DEF:
-                            case TokenTypes.ENUM_CONSTANT_DEF:
-                            case TokenTypes.CTOR_DEF:
-                            case TokenTypes.METHOD_DEF:
-                            case TokenTypes.PARAMETER_DEF:
-                            case TokenTypes.VARIABLE_DEF:
-                            case TokenTypes.ANNOTATION_FIELD_DEF:
-                            case TokenTypes.TYPE:
-                            case TokenTypes.LITERAL_NEW:
-                            case TokenTypes.LITERAL_THROWS:
-                            case TokenTypes.TYPE_ARGUMENT:
-                            case TokenTypes.IMPLEMENTS_CLAUSE:
-                            case TokenTypes.DOT:
-                                targetAST = parentAST;
-                                break;
-
-                            default:
-                                // unexpected target type
-                        }
-                    }
-                    break;
-
-                default:
-                    // unexpected container type
-            }
+        switch (parentAST.getType()) {
+            case TokenTypes.MODIFIERS:
+            case TokenTypes.ANNOTATIONS:
+                parentAST = parentAST.getParent();
+                switch (parentAST.getType()) {
+                    case TokenTypes.ANNOTATION_DEF:
+                    case TokenTypes.PACKAGE_DEF:
+                    case TokenTypes.CLASS_DEF:
+                    case TokenTypes.INTERFACE_DEF:
+                    case TokenTypes.ENUM_DEF:
+                    case TokenTypes.ENUM_CONSTANT_DEF:
+                    case TokenTypes.CTOR_DEF:
+                    case TokenTypes.METHOD_DEF:
+                    case TokenTypes.PARAMETER_DEF:
+                    case TokenTypes.VARIABLE_DEF:
+                    case TokenTypes.ANNOTATION_FIELD_DEF:
+                    case TokenTypes.TYPE:
+                    case TokenTypes.LITERAL_NEW:
+                    case TokenTypes.LITERAL_THROWS:
+                    case TokenTypes.TYPE_ARGUMENT:
+                    case TokenTypes.IMPLEMENTS_CLAUSE:
+                    case TokenTypes.DOT:
+                        targetAST = parentAST;
+                        break;
+                    default:
+                        // unexpected target type
+                }
+                break;
+            default:
+                // unexpected container type
         }
         return targetAST;
     }
 
     /**
      * Returns the n'th child of an AST node.
      * @param ast the AST node to get the child of
      * @param index the index of the child to get
      * @return the n'th child of the given AST node, or {@code null} if none
      */
     private static DetailAST getNthChild(DetailAST ast, int index) {
         DetailAST child = ast.getFirstChild();
         if (child != null) {
             for (int i = 0; i < index && child != null; ++i) {
                 child = child.getNextSibling();
             }
         }
         return child;
     }
 
     /**
      * Returns the Java identifier represented by an AST.
      * @param ast an AST node for an IDENT or DOT
      * @return the Java identifier represented by the given AST subtree
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getIdentifier(DetailAST ast) {
         if (ast != null) {
             if (ast.getType() == TokenTypes.IDENT) {
                 return ast.getText();
             }
             else if (ast.getType() == TokenTypes.DOT) {
                 return getIdentifier(ast.getFirstChild()) + "."
                     + getIdentifier(ast.getLastChild());
             }
         }
         throw new IllegalArgumentException("Identifier AST expected: " + ast);
     }
 
     /**
      * Returns the literal string expression represented by an AST.
      * @param ast an AST node for an EXPR
      * @return the Java string represented by the given AST expression
      *         or empty string if expression is too complex
      * @throws IllegalArgumentException if the AST is invalid
      */
     private static String getStringExpr(DetailAST ast) {
         if (ast != null && ast.getType() == TokenTypes.EXPR) {
             final DetailAST firstChild = ast.getFirstChild();
             String expr = "";
