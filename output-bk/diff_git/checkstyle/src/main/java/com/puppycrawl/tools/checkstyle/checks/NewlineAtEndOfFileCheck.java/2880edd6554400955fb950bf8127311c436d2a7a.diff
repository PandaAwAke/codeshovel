diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
index c52d2e877..70bda2bc6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java
@@ -32,103 +32,102 @@ import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
 
 /**
  * <p>
  * Checks that there is a newline at the end of each file.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="NewlineAtEndOfFile"/&gt;</pre>
  * <p>
  * This will check against the platform-specific default line separator.
  * </p>
  * <p>
  * It is also possible to enforce the use of a specific line-separator across
  * platforms, with the 'lineSeparator' property:
  * </p>
  * <pre>
  * &lt;module name="NewlineAtEndOfFile"&gt;
  *   &lt;property name="lineSeparator" value="lf"/&gt;
  * &lt;/module&gt;</pre>
  * <p>
  * Valid values for the 'lineSeparator' property are 'system' (system default),
  * 'crlf' (windows), 'cr' (mac), 'lf' (unix) and 'lf_cr_crlf' (lf, cr or crlf).
  * </p>
  *
  * @author Christopher Lenz
  * @author lkuehne
  */
 public class NewlineAtEndOfFileCheck
     extends AbstractFileSetCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_UNABLE_OPEN = "unable.open";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_NO_NEWLINE_EOF = "noNewlineAtEOF";
 
     /** the line separator to check against. */
     private LineSeparatorOption lineSeparator = LineSeparatorOption.SYSTEM;
 
     @Override
     protected void processFiltered(File file, List<String> lines) {
         // Cannot use lines as the line separators have been removed!
-        RandomAccessFile randomAccessFile = null;
         try {
-            randomAccessFile = new RandomAccessFile(file, "r");
+            final RandomAccessFile randomAccessFile = new RandomAccessFile(file, "r");
             boolean threw = true;
             try {
                 if (!endsWithNewline(randomAccessFile)) {
                     log(0, MSG_KEY_NO_NEWLINE_EOF, file.getPath());
                 }
                 threw = false;
             }
             finally {
                 Closeables.close(randomAccessFile, threw);
             }
         }
         catch (final IOException e) {
             log(0, MSG_KEY_UNABLE_OPEN, file.getPath());
         }
     }
 
     /**
      * Sets the line separator to one of 'crlf', 'lf','cr', 'lf_cr_crlf' or 'system'.
      *
      * @param lineSeparatorParam The line separator to set
      * @throws IllegalArgumentException If the specified line separator is not
      *         one of 'crlf', 'lf', 'cr', 'lf_cr_crlf' or 'system'
      */
     public void setLineSeparator(String lineSeparatorParam) {
         try {
             lineSeparator =
                 Enum.valueOf(LineSeparatorOption.class, lineSeparatorParam.trim()
                     .toUpperCase(Locale.ENGLISH));
         }
         catch (IllegalArgumentException iae) {
             throw new ConversionException("unable to parse " + lineSeparatorParam,
                 iae);
         }
     }
 
     /**
      * Checks whether the content provided by the Reader ends with the platform
      * specific line separator.
      * @param randomAccessFile The reader for the content to check
      * @return boolean Whether the content ends with a line separator
      * @throws IOException When an IO error occurred while reading from the
      *         provided reader
      */
     private boolean endsWithNewline(RandomAccessFile randomAccessFile)
         throws IOException {
         final int len = lineSeparator.length();
         if (randomAccessFile.length() < len) {
             return false;
         }
         randomAccessFile.seek(randomAccessFile.length() - len);
