diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 9ef4ab4cb..8247596fc 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -348,100 +348,105 @@ public class VisibilityModifierCheck
      * @param pattern
      *        pattern for public members to ignore.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object
      */
     public void setPublicMemberPattern(String pattern) {
         publicMemberPattern = Utils.createPattern(pattern);
         publicMemberFormat = pattern;
     }
 
     /**
      * @return the regexp for public members to ignore.
      */
     private Pattern getPublicMemberRegexp() {
         return publicMemberPattern;
     }
 
     /**
      * Sets whether public immutable are allowed.
      * @param allow user's value.
      */
     public void setAllowPublicImmutableFields(boolean allow) {
         allowPublicImmutableFields = allow;
     }
 
     /**
      * Set the list of immutable classes types names.
      * @param classNames array of immutable types canonical names.
      */
     public void setImmutableClassCanonicalNames(String... classNames) {
         immutableClassCanonicalNames = Arrays.asList(classNames);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.OBJBLOCK,
             TokenTypes.IMPORT,
         };
     }
 
+    @Override
+    public int[] getRequiredTokens() {
+        return getDefaultTokens();
+    }
+
     @Override
     public void beginTree(DetailAST rootAst) {
         immutableClassShortNames.clear();
         final List<String> classShortNames =
                 getClassShortNames(immutableClassCanonicalNames);
         immutableClassShortNames.addAll(classShortNames);
 
         ignoreAnnotationShortNames.clear();
         final List<String> annotationShortNames =
                 getClassShortNames(ignoreAnnotationCanonicalNames);
         ignoreAnnotationShortNames.addAll(annotationShortNames);
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF:
                 if (!isAnonymousClassVariable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + ast.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks if current variable definition is definition of an anonymous class.
      * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
      * @return true if current variable definition is definition of an anonymous class.
      */
     private static boolean isAnonymousClassVariable(DetailAST variableDef) {
         return variableDef.getParent().getType() != TokenTypes.OBJBLOCK;
     }
 
     /**
      * Checks access modifier of given variable.
      * If it is not proper according to Check - puts violation on it.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         final boolean inInterfaceOrAnnotationBlock =
                 ScopeUtils.inInterfaceOrAnnotationBlock(variableDef);
 
         if (!inInterfaceOrAnnotationBlock && !hasIgnoreAnnotation(variableDef)) {
             final DetailAST varNameAST = variableDef.findFirstToken(TokenTypes.TYPE)
