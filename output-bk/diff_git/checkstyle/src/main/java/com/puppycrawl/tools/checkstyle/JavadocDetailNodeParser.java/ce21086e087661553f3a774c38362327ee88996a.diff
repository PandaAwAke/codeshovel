diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java b/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
index a7dfb7787..cc70a7fe0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java
@@ -77,101 +77,101 @@ public class JavadocDetailNodeParser {
      */
     public static final String MSG_KEY_UNRECOGNIZED_ANTLR_ERROR =
             "javadoc.unrecognized.antlr.error";
 
     /** Symbols with which javadoc starts. */
     private static final String JAVADOC_START = "/**";
 
     /**
      * Line number of the Block comment AST that is being parsed.
      */
     private int blockCommentLineNumber;
 
     /**
      * Custom error listener.
      */
     private DescriptiveErrorListener errorListener;
 
     /**
      * Parses Javadoc comment as DetailNode tree.
      * @param javadocCommentAst
      *        DetailAST of Javadoc comment
      * @return DetailNode tree of Javadoc comment
      */
     public ParseStatus parseJavadocAsDetailNode(DetailAST javadocCommentAst) {
         blockCommentLineNumber = javadocCommentAst.getLineNo();
 
         final String javadocComment = JavadocUtils.getJavadocCommentContent(javadocCommentAst);
 
         // Use a new error listener each time to be able to use
         // one check instance for multiple files to be checked
         // without getting side effects.
         errorListener = new DescriptiveErrorListener();
 
         // Log messages should have line number in scope of file,
         // not in scope of Javadoc comment.
         // Offset is line number of beginning of Javadoc comment.
         errorListener.setOffset(javadocCommentAst.getLineNo() - 1);
 
         final ParseStatus result = new ParseStatus();
 
         try {
             final ParseTree parseTree = parseJavadocAsParseTree(javadocComment);
 
             final DetailNode tree = convertParseTreeToDetailNode(parseTree);
             // adjust first line to indent of /**
             adjustFirstLineToJavadocIndent(tree,
                         javadocCommentAst.getColumnNo()
                                 + JAVADOC_START.length());
             result.setTree(tree);
         }
-        catch (ParseCancellationException ex) {
+        catch (ParseCancellationException | IllegalArgumentException ex) {
             // If syntax error occurs then message is printed by error listener
             // and parser throws this runtime exception to stop parsing.
             // Just stop processing current Javadoc comment.
             ParseErrorMessage parseErrorMessage = errorListener.getErrorMessage();
 
             // There are cases when antlr error listener does not handle syntax error
             if (parseErrorMessage == null) {
                 parseErrorMessage = new ParseErrorMessage(javadocCommentAst.getLineNo(),
                         MSG_KEY_UNRECOGNIZED_ANTLR_ERROR,
                         javadocCommentAst.getColumnNo(), ex.getMessage());
             }
 
             result.setParseErrorMessage(parseErrorMessage);
         }
 
         return result;
     }
 
     /**
      * Parses block comment content as javadoc comment.
      * @param blockComment
      *        block comment content.
      * @return parse tree
      */
     private ParseTree parseJavadocAsParseTree(String blockComment) {
         final ANTLRInputStream input = new ANTLRInputStream(blockComment);
 
         final JavadocLexer lexer = new JavadocLexer(input);
 
         // remove default error listeners
         lexer.removeErrorListeners();
 
         // add custom error listener that logs parsing errors
         lexer.addErrorListener(errorListener);
 
         final CommonTokenStream tokens = new CommonTokenStream(lexer);
 
         final JavadocParser parser = new JavadocParser(tokens);
 
         // remove default error listeners
         parser.removeErrorListeners();
 
         // add custom error listener that logs syntax errors
         parser.addErrorListener(errorListener);
 
         // This strategy stops parsing when parser error occurs.
         // By default it uses Error Recover Strategy which is slow and useless.
         parser.setErrorHandler(new BailErrorStrategy());
 
         return parser.javadoc();
@@ -431,107 +431,107 @@ public class JavadocDetailNodeParser {
          * Javadoc comment.
          */
         private int offset;
 
         /**
          * Error message that appeared while parsing.
          */
         private ParseErrorMessage errorMessage;
 
         /**
          * Getter for error message during parsing.
          * @return Error message during parsing.
          */
         private ParseErrorMessage getErrorMessage() {
             return errorMessage;
         }
 
         /**
          * Sets offset. Offset is line number of beginning of the Javadoc
          * comment. Log messages should have line number in scope of file, not
          * in scope of Javadoc comment.
          * @param offset
          *        offset line number
          */
         public void setOffset(int offset) {
             this.offset = offset;
         }
 
         /**
          * Logs parser errors in Checkstyle manner. Parser can generate error
          * messages. There is special error that parser can generate. It is
          * missed close HTML tag. This case is special because parser prints
          * error like {@code "no viable alternative at input 'b \n *\n'"} and it
          * is not clear that error is about missed close HTML tag. Other error
          * messages are not special and logged simply as "Parse Error...".
          *
          * <p>{@inheritDoc}
          */
         @Override
         public void syntaxError(
                 Recognizer<?, ?> recognizer, Object offendingSymbol,
                 int line, int charPositionInLine,
                 String msg, RecognitionException ex) {
             final int lineNumber = offset + line;
             final Token token = (Token) offendingSymbol;
 
             if (MSG_JAVADOC_MISSED_HTML_CLOSE.equals(msg)) {
                 errorMessage = new ParseErrorMessage(lineNumber,
                         MSG_JAVADOC_MISSED_HTML_CLOSE, charPositionInLine, token.getText());
 
-                throw new ParseCancellationException(msg);
+                throw new IllegalArgumentException(msg);
             }
             else if (MSG_JAVADOC_WRONG_SINGLETON_TAG.equals(msg)) {
                 errorMessage = new ParseErrorMessage(lineNumber,
                         MSG_JAVADOC_WRONG_SINGLETON_TAG, charPositionInLine, token.getText());
 
-                throw new ParseCancellationException(msg);
+                throw new IllegalArgumentException(msg);
             }
             else {
                 final int ruleIndex = ex.getCtx().getRuleIndex();
                 final String ruleName = recognizer.getRuleNames()[ruleIndex];
                 final String upperCaseRuleName = CaseFormat.UPPER_CAMEL.to(
                         CaseFormat.UPPER_UNDERSCORE, ruleName);
 
                 errorMessage = new ParseErrorMessage(lineNumber,
                         MSG_JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, upperCaseRuleName);
             }
         }
     }
 
     /**
      * Contains result of parsing javadoc comment: DetailNode tree and parse
      * error message.
      */
     public static class ParseStatus {
         /**
          * DetailNode tree (is null if parsing fails).
          */
         private DetailNode tree;
 
         /**
          * Parse error message (is null if parsing is successful).
          */
         private ParseErrorMessage parseErrorMessage;
 
         /**
          * Getter for DetailNode tree.
          * @return DetailNode tree if parsing was successful, null otherwise.
          */
         public DetailNode getTree() {
             return tree;
         }
 
         /**
          * Sets DetailNode tree.
          * @param tree DetailNode tree.
          */
         public void setTree(DetailNode tree) {
             this.tree = tree;
         }
 
         /**
          * Getter for error message during parsing.
          * @return Error message if parsing was unsuccessful, null otherwise.
          */
         public ParseErrorMessage getParseErrorMessage() {
             return parseErrorMessage;
