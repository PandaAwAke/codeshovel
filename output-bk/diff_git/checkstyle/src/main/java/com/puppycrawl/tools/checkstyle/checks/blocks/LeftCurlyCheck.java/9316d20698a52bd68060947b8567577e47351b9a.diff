diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
index 8d9cf4778..190e1064a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
@@ -106,100 +106,101 @@ public class LeftCurlyCheck
      */
     public LeftCurlyCheck() {
         super(LeftCurlyOption.EOL, LeftCurlyOption.class);
     }
 
     /**
      * Sets the maximum line length used in calculating the placement of the
      * left curly brace.
      * @param maxLineLength the max allowed line length
      * @deprecated since 6.10 release, option is not required for the Check.
      */
     @Deprecated
     public void setMaxLineLength(int maxLineLength) {
         // do nothing, option is deprecated
     }
 
     /**
      * Sets whether check should ignore enums when left curly brace policy is EOL.
      * @param ignoreEnums check's option for ignoring enums.
      */
     public void setIgnoreEnums(boolean ignoreEnums) {
         this.ignoreEnums = ignoreEnums;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             TokenTypes.STATIC_INIT,
+            TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         DetailAST startToken;
         DetailAST brace;
 
         switch (ast.getType()) {
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 startToken = skipAnnotationOnlyLines(ast);
                 brace = ast.findFirstToken(TokenTypes.SLIST);
                 break;
             case TokenTypes.INTERFACE_DEF:
             case TokenTypes.CLASS_DEF:
             case TokenTypes.ANNOTATION_DEF:
             case TokenTypes.ENUM_DEF:
             case TokenTypes.ENUM_CONSTANT_DEF:
                 startToken = skipAnnotationOnlyLines(ast);
                 final DetailAST objBlock = ast.findFirstToken(TokenTypes.OBJBLOCK);
                 brace = objBlock;
 
                 if (objBlock != null) {
                     brace = objBlock.getFirstChild();
                 }
                 break;
             case TokenTypes.LITERAL_WHILE:
             case TokenTypes.LITERAL_CATCH:
             case TokenTypes.LITERAL_SYNCHRONIZED:
             case TokenTypes.LITERAL_FOR:
             case TokenTypes.LITERAL_TRY:
             case TokenTypes.LITERAL_FINALLY:
             case TokenTypes.LITERAL_DO:
             case TokenTypes.LITERAL_IF:
             case TokenTypes.STATIC_INIT:
                 startToken = ast;
                 brace = ast.findFirstToken(TokenTypes.SLIST);
                 break;
             case TokenTypes.LITERAL_ELSE:
                 startToken = ast;
                 final DetailAST candidate = ast.getFirstChild();
                 brace = null;
 
                 if (candidate.getType() == TokenTypes.SLIST) {
