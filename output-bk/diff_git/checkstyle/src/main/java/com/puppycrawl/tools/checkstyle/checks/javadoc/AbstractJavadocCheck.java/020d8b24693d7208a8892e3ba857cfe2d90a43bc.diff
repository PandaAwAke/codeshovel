diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
index 8103c6c6b..2bd0e8dc3 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
@@ -520,107 +520,107 @@ public abstract class AbstractJavadocCheck extends Check {
 
         /**
          * Offset is line number of beginning of the Javadoc comment. Log
          * messages should have line number in scope of file, not in scope of
          * Javadoc comment.
          */
         private int offset;
 
         /**
          * Error message that appeared while parsing.
          */
         private ParseErrorMessage errorMessage;
 
         private ParseErrorMessage getErrorMessage() {
             return errorMessage;
         }
 
         /**
          * Sets offset. Offset is line number of beginning of the Javadoc
          * comment. Log messages should have line number in scope of file, not
          * in scope of Javadoc comment.
          * @param offset
          *        offset line number
          */
         public void setOffset(int offset) {
             this.offset = offset;
         }
 
         /**
          * Logs parser errors in Checkstyle manner. Parser can generate error
          * messages. There is special error that parser can generate. It is
          * missed close HTML tag. This case is special because parser prints
          * error like {@code "no viable alternative at input 'b \n *\n'"} and it
          * is not clear that error is about missed close HTML tag. Other error
          * messages are not special and logged simply as "Parse Error...".
          * <p>
          * {@inheritDoc}
          */
         @Override
         public void syntaxError(
                 Recognizer<?, ?> recognizer, Object offendingSymbol,
                 int line, int charPositionInLine,
                 String msg, RecognitionException ex) {
             final int lineNumber = offset + line;
             final Token token = (Token) offendingSymbol;
 
             if (JAVADOC_MISSED_HTML_CLOSE.equals(msg)) {
                 errorMessage = new ParseErrorMessage(lineNumber,
                         JAVADOC_MISSED_HTML_CLOSE, charPositionInLine, token.getText());
 
-                throw new ParseCancellationException();
+                throw new ParseCancellationException(msg);
             }
             else if (JAVADOC_WRONG_SINGLETON_TAG.equals(msg)) {
                 errorMessage = new ParseErrorMessage(lineNumber,
                         JAVADOC_WRONG_SINGLETON_TAG, charPositionInLine, token.getText());
 
-                throw new ParseCancellationException();
+                throw new ParseCancellationException(msg);
             }
             else {
                 final int ruleIndex = ex.getCtx().getRuleIndex();
                 final String ruleName = recognizer.getRuleNames()[ruleIndex];
                 final String upperCaseRuleName = CaseFormat.UPPER_CAMEL.to(
                         CaseFormat.UPPER_UNDERSCORE, ruleName);
 
                 errorMessage = new ParseErrorMessage(lineNumber,
                         JAVADOC_PARSE_RULE_ERROR, charPositionInLine, msg, upperCaseRuleName);
             }
         }
     }
 
     /**
      * Contains result of parsing javadoc comment: DetailNode tree and parse
      * error message.
      */
     private static class ParseStatus {
         /**
          * DetailNode tree (is null if parsing fails)
          */
         private DetailNode tree;
 
         /**
          * Parse error message (is null if parsing is successful)
          */
         private ParseErrorMessage parseErrorMessage;
 
         public DetailNode getTree() {
             return tree;
         }
 
         public void setTree(DetailNode tree) {
             this.tree = tree;
         }
 
         public ParseErrorMessage getParseErrorMessage() {
             return parseErrorMessage;
         }
 
         public void setParseErrorMessage(ParseErrorMessage parseErrorMessage) {
             this.parseErrorMessage = parseErrorMessage;
         }
 
     }
 
     /**
      * Contains information about parse error message.
      */
     private static class ParseErrorMessage {
