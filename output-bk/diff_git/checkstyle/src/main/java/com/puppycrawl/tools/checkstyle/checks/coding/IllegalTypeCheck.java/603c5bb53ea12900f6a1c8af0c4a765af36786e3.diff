diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index 806b5b783..000dad1cf 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -173,106 +173,119 @@ public final class IllegalTypeCheck extends AbstractFormatCheck {
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_DEF:
                 if (isVerifiable(ast)) {
                     visitMethodDef(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (isVerifiable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 visitParameterDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Checks if current method's return type or variable's type is verifiable
      * according to <b>memberModifiers</b> option.
      * @param methodOrVariableDef METHOD_DEF or VARIABLE_DEF ast node.
      * @return true if member is verifiable according to <b>memberModifiers</b> option.
      */
     private boolean isVerifiable(DetailAST methodOrVariableDef) {
         boolean result = true;
         if (memberModifiers != null) {
             result = false;
             final DetailAST modifiersAst = methodOrVariableDef
                     .findFirstToken(TokenTypes.MODIFIERS);
-            if (modifiersAst.getFirstChild() != null) {
-                for (DetailAST modifier = modifiersAst.getFirstChild(); modifier != null;
-                         modifier = modifier.getNextSibling()) {
-                    if (memberModifiers.contains(modifier.getType())) {
-                        result = true;
-                    }
+            result = isContainVerifiableType(modifiersAst);
+        }
+        return result;
+    }
+
+    /**
+     * Checks is modifiers contain verifiable type
+     *
+     * @param modifiers
+     *            parent node for all modifiers
+     * @return true if mathod or variable can be verified
+     */
+    private boolean isContainVerifiableType(DetailAST modifiers) {
+        boolean result = false;
+        if (modifiers.getFirstChild() != null) {
+            for (DetailAST modifier = modifiers.getFirstChild(); modifier != null;
+                     modifier = modifier.getNextSibling()) {
+                if (memberModifiers.contains(modifier.getType())) {
+                    result = true;
                 }
             }
         }
         return result;
     }
 
     /**
      * Checks return type of a given method.
      * @param methodDef method for check.
      */
     private void visitMethodDef(DetailAST methodDef) {
         if (isCheckedMethod(methodDef)) {
             checkClassName(methodDef);
         }
     }
 
     /**
      * Checks type of parameters.
      * @param parameterDef parameter list for check.
      */
     private void visitParameterDef(DetailAST parameterDef) {
         final DetailAST grandParentAST = parameterDef.getParent().getParent();
 
         if (grandParentAST.getType() == TokenTypes.METHOD_DEF
             && isCheckedMethod(grandParentAST)) {
             checkClassName(parameterDef);
         }
     }
 
     /**
      * Checks type of given variable.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         checkClassName(variableDef);
     }
 
     /**
      * Checks imported type (as static and star imports are not supported by Check,
      *  only type is in the consideration).<br>
      * If this type is illegal due to Check's options - puts violation on it.
      * @param importAst {@link TokenTypes#IMPORT Import}
      */
     private void visitImport(DetailAST importAst) {
         if (!isStarImport(importAst)) {
             final String canonicalName = getImportedTypeCanonicalName(importAst);
             extendIllegalClassNamesWithShortName(canonicalName);
         }
     }
 
