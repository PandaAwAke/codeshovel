diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index 6ab4a98d3..bcdb895b1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -280,79 +280,79 @@ public class IllegalInstantiationCheck
      * @param className class name
      * @param pkgNameLen package name
      * @param illegal illegal value
      * @return true if type of the same package
      */
     private boolean isSamePackage(String className, int pkgNameLen, String illegal) {
         // class from same package
 
         // the top level package (pkgName == null) is covered by the
         // "illegalInstances.contains(className)" check above
 
         // the test is the "no garbage" version of
         // illegal.equals(pkgName + "." + className)
         return pkgName != null
                 && className.length() == illegal.length() - pkgNameLen - 1
                 && illegal.charAt(pkgNameLen) == '.'
                 && illegal.endsWith(className)
                 && illegal.startsWith(pkgName);
     }
 
     /**
      * Is class of the same package.
      * @param className class name
      * @return true if same package class
      */
     private boolean isSamePackage(String className) {
         boolean isSamePackage = false;
         try {
             final ClassLoader classLoader = getClassLoader();
             if (classLoader != null) {
                 final String fqName = pkgName + "." + className;
                 classLoader.loadClass(fqName);
                 // no ClassNotFoundException, fqName is a known class
                 isSamePackage = true;
             }
         }
         catch (final ClassNotFoundException ignored) {
             // not a class from the same package
             isSamePackage = false;
         }
         return isSamePackage;
     }
 
     /**
      * Is Standard Class.
      * @param className class name
      * @param illegal illegal value
      * @return true if type is standard
      */
     private boolean isStandardClass(String className, String illegal) {
-        boolean isStandardCalss = false;
+        boolean isStandardClass = false;
         // class from java.lang
         if (illegal.length() - JAVA_LANG.length() == className.length()
             && illegal.endsWith(className)
             && illegal.startsWith(JAVA_LANG)) {
             // java.lang needs no import, but a class without import might
             // also come from the same file or be in the same package.
             // E.g. if a class defines an inner class "Boolean",
             // the expression "new Boolean()" refers to that class,
             // not to java.lang.Boolean
 
             final boolean isSameFile = classNames.contains(className);
             final boolean isSamePackage = isSamePackage(className);
 
             if (!isSameFile && !isSamePackage) {
-                isStandardCalss = true;
+                isStandardClass = true;
             }
         }
-        return isStandardCalss;
+        return isStandardClass;
     }
 
     /**
      * Sets the classes that are illegal to instantiate.
      * @param names a comma separate list of class names
      */
     public void setClasses(String... names) {
         illegalClasses = Arrays.stream(names).collect(Collectors.toSet());
     }
 }
