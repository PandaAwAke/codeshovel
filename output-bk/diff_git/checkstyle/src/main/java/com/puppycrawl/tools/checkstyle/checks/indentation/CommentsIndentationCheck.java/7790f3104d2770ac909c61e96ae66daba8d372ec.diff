diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index d2fa51ec0..47646c0b1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -191,116 +191,116 @@ public class CommentsIndentationCheck extends AbstractCheck {
      * @return true if the previous statement of a comment is distributed over two or more lines.
      */
     private boolean isDistributedPreviousStatement(DetailAST comment) {
         final DetailAST previousSibling = comment.getPreviousSibling();
         return isDistributedExpression(comment)
             || isDistributedReturnStatement(previousSibling)
             || isDistributedThrowStatement(previousSibling);
     }
 
     /**
      * Checks whether the previous statement of a comment is a method call chain or
      * string concatenation statemen distributed over two ore more lines.
      * @param comment comment to check.
      * @return true if the previous statement is a distributed expression.
      */
     private boolean isDistributedExpression(DetailAST comment) {
         DetailAST previousSibling = comment.getPreviousSibling();
         while (previousSibling != null && isComment(previousSibling)) {
             previousSibling = previousSibling.getPreviousSibling();
         }
         boolean isDistributed = false;
         if (previousSibling != null) {
             if (previousSibling.getType() == TokenTypes.SEMI
                     && isOnPreviousLineIgnoringComments(comment, previousSibling)) {
                 DetailAST currentToken = previousSibling.getPreviousSibling();
                 while (currentToken.getFirstChild() != null) {
                     currentToken = currentToken.getFirstChild();
                 }
                 if (currentToken.getType() == TokenTypes.COMMENT_CONTENT) {
                     currentToken = currentToken.getParent();
                     while (isComment(currentToken)) {
                         currentToken = currentToken.getNextSibling();
                     }
                 }
                 if (previousSibling.getLineNo() != currentToken.getLineNo()) {
                     isDistributed = true;
                 }
             }
             else {
                 isDistributed = isStatementWithPossibleCurlies(previousSibling);
             }
         }
         return isDistributed;
     }
 
     /**
      * Whether the statement can have or always have curly brackets.
      * @param previousSibling the statement to check.
      * @return true if the statement can have or always have curly brackets.
      */
-    private boolean isStatementWithPossibleCurlies(DetailAST previousSibling) {
+    private static boolean isStatementWithPossibleCurlies(DetailAST previousSibling) {
         return previousSibling.getType() == TokenTypes.LITERAL_IF
             || previousSibling.getType() == TokenTypes.LITERAL_TRY
             || previousSibling.getType() == TokenTypes.LITERAL_FOR
             || previousSibling.getType() == TokenTypes.LITERAL_DO
             || previousSibling.getType() == TokenTypes.LITERAL_WHILE
             || previousSibling.getType() == TokenTypes.LITERAL_SWITCH
             || isDefinition(previousSibling);
     }
 
     /**
      * Whether the statement is a kind of definition (method, class etc.).
      * @param previousSibling the statement to check.
      * @return true if the statement is a kind of definition.
      */
-    private boolean isDefinition(DetailAST previousSibling) {
+    private static boolean isDefinition(DetailAST previousSibling) {
         return previousSibling.getType() == TokenTypes.METHOD_DEF
             || previousSibling.getType() == TokenTypes.CLASS_DEF
             || previousSibling.getType() == TokenTypes.INTERFACE_DEF
             || previousSibling.getType() == TokenTypes.ENUM_DEF
             || previousSibling.getType() == TokenTypes.ANNOTATION_DEF;
     }
 
     /**
      * Checks whether the previous statement of a comment is a destributed return statement.
      * @param commentPreviousSibling previous sibling of the comment.
      * @return true if the previous statement of a comment is a destributed return statement.
      */
     private static boolean isDistributedReturnStatement(DetailAST commentPreviousSibling) {
         boolean isDistributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.LITERAL_RETURN) {
             final DetailAST firstChild = commentPreviousSibling.getFirstChild();
             final DetailAST nextSibling = firstChild.getNextSibling();
             if (nextSibling != null) {
                 isDistributed = true;
             }
         }
         return isDistributed;
     }
 
     /**
      * Checks whether the previous statement of a comment is a destributed throw statement.
      * @param commentPreviousSibling previous sibling of the comment.
      * @return true if the previous statement of a comment is a destributed throw statement.
      */
     private static boolean isDistributedThrowStatement(DetailAST commentPreviousSibling) {
         boolean isDistributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.LITERAL_THROW) {
             final DetailAST firstChild = commentPreviousSibling.getFirstChild();
             final DetailAST nextSibling = firstChild.getNextSibling();
             if (nextSibling.getLineNo() != commentPreviousSibling.getLineNo()) {
                 isDistributed = true;
             }
         }
         return isDistributed;
     }
 
     /**
      * Returns the first token of the destributed previous statement of comment.
      * @param comment comment to check.
      * @return the first token of the destributed previous statement of comment.
      */
     private static DetailAST getDistributedPreviousStatement(DetailAST comment) {
         DetailAST currentToken = comment.getPreviousSibling();
@@ -732,101 +732,101 @@ public class CommentsIndentationCheck extends AbstractCheck {
             nextToken = checkedStatement.getFirstChild();
         }
         else {
             nextToken = checkedStatement.getNextSibling();
         }
         if (nextToken != null && isComment(nextToken) && isTrailingComment(nextToken)) {
             nextToken = nextToken.getNextSibling();
         }
         return nextToken;
     }
 
     /**
      * Count the number of empty lines between statements.
      * @param startStatement start statement.
      * @param endStatement end statement.
      * @return the number of empty lines between statements.
      */
     private int countEmptyLines(DetailAST startStatement, DetailAST endStatement) {
         int emptyLinesNumber = 0;
         final String[] lines = getLines();
         final int endLineNo = endStatement.getLineNo();
         for (int lineNo = startStatement.getLineNo(); lineNo < endLineNo; lineNo++) {
             if (CommonUtils.isBlank(lines[lineNo])) {
                 emptyLinesNumber++;
             }
         }
         return emptyLinesNumber;
     }
 
     /**
      * Logs comment which can have the same indentation level as next or previous statement.
      * @param comment comment.
      * @param nextStmt next statement.
      * @param prevStmt previous statement.
      */
     private void logMultilineIndentation(DetailAST prevStmt, DetailAST comment,
                                          DetailAST nextStmt) {
         final String multilineNoTemplate = "%d, %d";
         log(comment.getLineNo(), getMessageKey(comment),
             String.format(Locale.getDefault(), multilineNoTemplate, prevStmt.getLineNo(),
                 nextStmt.getLineNo()), comment.getColumnNo(),
             String.format(Locale.getDefault(), multilineNoTemplate,
                     getLineStart(prevStmt.getLineNo()), getLineStart(nextStmt.getLineNo())));
     }
 
     /**
      * Get a message key depending on a comment type.
      * @param comment the comment to process.
      * @return a message key.
      */
-    private String getMessageKey(DetailAST comment) {
+    private static String getMessageKey(DetailAST comment) {
         final String msgKey;
         if (comment.getType() == TokenTypes.SINGLE_LINE_COMMENT) {
             msgKey = MSG_KEY_SINGLE;
         }
         else {
             msgKey = MSG_KEY_BLOCK;
         }
         return msgKey;
     }
 
     /**
      * Gets comment's previous statement from switch block.
      * @param comment {@link TokenTypes#SINGLE_LINE_COMMENT single-line comment}.
      * @return comment's previous statement or null if previous statement is absent.
      */
     private static DetailAST getPrevStatementFromSwitchBlock(DetailAST comment) {
         final DetailAST prevStmt;
         final DetailAST parentStatement = comment.getParent();
         if (parentStatement.getType() == TokenTypes.CASE_GROUP) {
             prevStmt = getPrevStatementWhenCommentIsUnderCase(parentStatement);
         }
         else {
             prevStmt = getPrevCaseToken(parentStatement);
         }
         return prevStmt;
     }
 
     /**
      * Gets previous statement for comment which is placed immediately under case.
      * @param parentStatement comment's parent statement.
      * @return comment's previous statement or null if previous statement is absent.
      */
     private static DetailAST getPrevStatementWhenCommentIsUnderCase(DetailAST parentStatement) {
         DetailAST prevStmt = null;
         final DetailAST prevBlock = parentStatement.getPreviousSibling();
         if (prevBlock.getLastChild() != null) {
             DetailAST blockBody = prevBlock.getLastChild().getLastChild();
             if (blockBody.getType() == TokenTypes.SEMI) {
                 blockBody = blockBody.getPreviousSibling();
             }
             if (blockBody.getType() == TokenTypes.EXPR) {
                 if (isUsingOfObjectReferenceToInvokeMethod(blockBody)) {
                     prevStmt = findStartTokenOfMethodCallChain(blockBody);
                 }
                 else {
                     prevStmt = blockBody.getFirstChild().getFirstChild();
                 }
             }
             else {
                 if (blockBody.getType() == TokenTypes.SLIST) {
