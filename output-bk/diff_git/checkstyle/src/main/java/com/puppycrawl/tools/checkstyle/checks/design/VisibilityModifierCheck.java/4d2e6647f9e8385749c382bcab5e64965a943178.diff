diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 5026b08ae..f5b9c1266 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -405,101 +405,101 @@ public class VisibilityModifierCheck
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAst) {
         immutableClassShortNames.clear();
         final List<String> classShortNames =
                 getClassShortNames(immutableClassCanonicalNames);
         immutableClassShortNames.addAll(classShortNames);
 
         ignoreAnnotationShortNames.clear();
         final List<String> annotationShortNames =
                 getClassShortNames(ignoreAnnotationCanonicalNames);
         ignoreAnnotationShortNames.addAll(annotationShortNames);
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF:
                 if (!isAnonymousClassVariable(ast)) {
                     visitVariableDef(ast);
                 }
                 break;
             case TokenTypes.IMPORT:
                 visitImport(ast);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + ast.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks if current variable definition is definition of an anonymous class.
      * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
      * @return true if current variable definition is definition of an anonymous class.
      */
     private static boolean isAnonymousClassVariable(DetailAST variableDef) {
         return variableDef.getParent().getType() != TokenTypes.OBJBLOCK;
     }
 
     /**
      * Checks access modifier of given variable.
      * If it is not proper according to Check - puts violation on it.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         final boolean inInterfaceOrAnnotationBlock =
-                ScopeUtils.inInterfaceOrAnnotationBlock(variableDef);
+                ScopeUtils.isInInterfaceOrAnnotationBlock(variableDef);
 
         if (!inInterfaceOrAnnotationBlock && !hasIgnoreAnnotation(variableDef)) {
             final DetailAST varNameAST = variableDef.findFirstToken(TokenTypes.TYPE)
                 .getNextSibling();
             final String varName = varNameAST.getText();
             if (!hasProperAccessModifier(variableDef, varName)) {
                 log(varNameAST.getLineNo(), varNameAST.getColumnNo(),
                         MSG_KEY, varName);
             }
         }
     }
 
     /**
      * Checks if variable def has ignore annotation.
      * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
      * @return true if variable def has ignore annotation.
      */
     private boolean hasIgnoreAnnotation(DetailAST variableDef) {
         final DetailAST firstIgnoreAnnotation =
                  findMatchingAnnotation(variableDef);
         return firstIgnoreAnnotation != null;
     }
 
     /**
      * Checks imported type. If type's canonical name was not specified in
      * <b>immutableClassCanonicalNames</b>, but it's short name collides with one from
      * <b>immutableClassShortNames</b> - removes it from the last one.
      * @param importAst {@link TokenTypes#IMPORT Import}
      */
     private void visitImport(DetailAST importAst) {
         if (!isStarImport(importAst)) {
             final DetailAST type = importAst.getFirstChild();
             final String canonicalName = getCanonicalName(type);
             final String shortName = getClassShortName(canonicalName);
 
             // If imported canonical class name is not specified as allowed immutable class,
             // but its short name collides with one of specified class - removes the short name
             // from list to avoid names collision
             if (!immutableClassCanonicalNames.contains(canonicalName)
                      && immutableClassShortNames.contains(shortName)) {
                 immutableClassShortNames.remove(shortName);
             }
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName)) {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
