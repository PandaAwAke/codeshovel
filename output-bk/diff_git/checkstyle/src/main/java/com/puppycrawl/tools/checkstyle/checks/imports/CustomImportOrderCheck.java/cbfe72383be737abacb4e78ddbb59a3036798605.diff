diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
index a776d8a5c..9e65dff46 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java
@@ -72,205 +72,213 @@ import com.puppycrawl.tools.checkstyle.Utils;
  * SAME_PACKAGE(n), STANDARD_JAVA_PACKAGE and SPECIAL_IMPORTS.
  * </pre>
  *
  * <pre>
  * STANDARD_JAVA_PACKAGE group. This group sets ordering of standard java (java|javax) imports.
  * </pre>
  *
  * <pre>
  * SPECIAL_IMPORTS group. This group may contains some imports
  * that have particular meaning for the user.
  * </pre>
  *
  * <p>
  * NOTICE!
  * </p>
  * <p>
  * Use the separator '###' between rules.
  * </p>
  * <p>
  * To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
  * thirdPartyPackageRegExp and standardPackageRegExp options.
  * </p>
  *
  * <pre>
  * For example:
  * </pre>
  *
  * <pre>
  * <code>
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *    value=&quot;STATIC###SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE&quot;/&gt;
  *    &lt;property name=&quot;thirdPartyPackageRegExp&quot; value=&quot;com|org&quot;/&gt;
  *    &lt;property name=&quot;standardPackageRegExp&quot; value=&quot;java|javax&quot;/&gt;
  * &lt;/module&gt;
  * </code>
  * </pre>
  * <p>
  * Also, this check can be configured to force empty line separator between
  * import groups. For example
  * </p>
  *
  * <pre>
  * <code>
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * </code>
  * </pre>
  * <p>
- * By the option it is possible to force alphabetically sorting.
+ * It is possible to enforce <a href="http://en.wikipedia.org/wiki/ASCII#Order">ASCII sort order</a>
+ * of imports in groups using the following configuration:
  * </p>
- *
  * <pre>
- * <code>
- * &lt;module name=&quot;CustomImportOrder&quot;&gt;
+ * <code>&lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * </code>
  * </pre>
- *
+ * <p>
+ * Example of ASCII order:
+ * </p>
+ * <pre>
+ * <code>import java.awt.Dialog;
+ * import java.awt.Window;
+ * import java.awt.color.ColorSpace;
+ * import java.awt.Frame; // violation here - in ASCII order 'F' should go before 'c',
+ *                        // as all uppercase come before lowercase letters</code>
+ * </pre>
  * <p>
  * To force checking imports sequence such as:
  * </p>
  *
  * <pre>
  * <code>
  * package com.puppycrawl.tools.checkstyle.imports;
  *
  * import com.google.common.annotations.GwtCompatible;
  * import com.google.common.annotations.Beta;
  * import com.google.common.annotations.VisibleForTesting;
  *
  * import org.abego.treelayout.Configuration;
  *
  * import static sun.tools.util.ModifierFilter.ALL_ACCESS;
  *
  * import com.google.common.annotations.GwtCompatible; // violation here - should be in the
  *                                                     // THIRD_PARTY_PACKAGE group
  * import android.*;</code>
  * </pre>
  * configure as follows:
  * <pre>
  * <code>
  * &lt;module name=&quot;CustomImportOrder&quot;&gt;
  *    &lt;property name=&quot;customImportOrderRules&quot;
  *    value=&quot;SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STATIC###SPECIAL_IMPORTS&quot;/&gt;
  *    &lt;property name=&quot;specialImportsRegExp&quot; value=&quot;android.*&quot;/&gt;
  * &lt;/module&gt;</code>
  * </pre>
  *
  * @author maxvetrenko
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  */
 public class CustomImportOrderCheck extends Check
 {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_LINE_SEPARATOR = "custom.import.order.line.separator";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_LEX = "custom.import.order.lex";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_NONGROUP_IMPORT = "custom.import.order.nongroup.import";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_ORDER = "custom.import.order";
 
     /** STATIC group name */
     private static final String STATIC_RULE_GROUP = "STATIC";
 
     /** SAME_PACKAGE group name */
     private static final String SAME_PACKAGE_RULE_GROUP = "SAME_PACKAGE";
 
     /** THIRD_PARTY_PACKAGE group name */
     private static final String THIRD_PARTY_PACKAGE_RULE_GROUP = "THIRD_PARTY_PACKAGE";
 
     /** STANDARD_JAVA_PACKAGE group name */
     private static final String STANDARD_JAVA_PACKAGE_RULE_GROUP = "STANDARD_JAVA_PACKAGE";
 
     /** NON_GROUP group name */
     private static final String SPECIAL_IMPORTS_RULE_GROUP = "SPECIAL_IMPORTS";
 
     /** NON_GROUP group name */
     private static final String NON_GROUP_RULE_GROUP = "NON_GROUP";
 
     /** RegExp for SAME_PACKAGE group imports */
     private String samePackageDomainsRegExp = "";
 
     /** RegExp for STANDARD_JAVA_PACKAGE group imports */
     private Pattern standardPackageRegExp = Utils.getPattern("java|javax");
 
     /** RegExp for THIRDPARTY_PACKAGE group imports */
     private Pattern thirdPartyPackageRegExp = Utils.getPattern(".*");
 
     /** RegExp for SPECIAL_IMPORTS group imports */
     private Pattern specialImportsRegExp = Utils.getPattern("^$");
 
     /** Force empty line separator between import groups */
     private boolean separateLineBetweenGroups = true;
 
-    /** Force grouping alphabetically */
+    /** Force grouping alphabetically, in ASCII order */
     private boolean sortImportsInGroupAlphabetically;
 
     /** List of order declaration customizing by user */
     private final List<String> customImportOrderRules = new ArrayList<>();
 
     /** Number of first domains for SAME_PACKAGE group. */
     private int samePackageMatchingDepth = 2;
 
     /** Contains objects with import attributes */
     private List<ImportDetails> importToGroupList = new ArrayList<>();
 
     /**
      * Sets standardRegExp specified by user.
      * @param regexp
      *        user value.
      */
     public final void setStandardPackageRegExp(String regexp)
     {
         standardPackageRegExp = Utils.getPattern(regexp);
     }
 
     /**
      * Sets thirdPartyRegExp specified by user.
      * @param regexp
      *        user value.
      */
     public final void setThirdPartyPackageRegExp(String regexp)
     {
         thirdPartyPackageRegExp = Utils.getPattern(regexp);
     }
 
     /**
      * Sets specialImportsRegExp specified by user.
      * @param regexp
      *        user value.
      */
     public final void setSpecialImportsRegExp(String regexp)
     {
         specialImportsRegExp = Utils.getPattern(regexp);
     }
 
     /**
      * Sets separateLineBetweenGroups specified by user.
      * @param value
      *        user value.
      */
     public final void setSeparateLineBetweenGroups(boolean value)
     {
         separateLineBetweenGroups = value;
     }
@@ -558,101 +566,101 @@ public class CustomImportOrderCheck extends Check
      *        current group.
      * @return true, if the import is placed in the special group.
      */
     private boolean matchesSpecialImportsGroup(boolean isStatic,
         String currentImport, String currentGroup)
     {
         return !isStatic && SPECIAL_IMPORTS_RULE_GROUP.equals(currentGroup)
                 && specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks if the import is placed in the correct group.
      * @param isStatic
      *        if import is static.
      * @param currentImport
      *        import full path.
      * @param currentGroup
      *        current group.
      * @return true, if the import is placed in the third party group.
      */
     private boolean matchesThirdPartyImportGroup(boolean isStatic,
         String currentImport, String currentGroup)
     {
         return !isStatic && THIRD_PARTY_PACKAGE_RULE_GROUP.equals(currentGroup)
                 && thirdPartyPackageRegExp.matcher(currentImport).find()
                 && !standardPackageRegExp.matcher(currentImport).find()
                 && !specialImportsRegExp.matcher(currentImport).find();
     }
 
     /**
      * Checks compare two import paths.
      * @param import1
      *        current import.
      * @param import2
      *        previous import.
      * @return a negative integer, zero, or a positive integer as the
      *        specified String is greater than, equal to, or less
      *        than this String, ignoring case considerations.
      */
     private static int compareImports(String import1, String import2)
     {
         int result = 0;
         final String[] import1Tokens = import1.split("\\.");
         final String[] import2Tokens = import2.split("\\.");
         for (int i = 0; i < import1Tokens.length; i++) {
             if (i == import2Tokens.length) {
                 break;
             }
             final String import1Token = import1Tokens[i];
             final String import2Token = import2Tokens[i];
-            result = import1Token.compareToIgnoreCase(import2Token);
+            result = import1Token.compareTo(import2Token);
             if (result != 0) {
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param lineNo
      *        Line number of current import.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(int lineNo)
     {
         //  [lineNo - 2] is the number of the previous line
         //  because the numbering starts from zero.
         final String lineBefore = getLine(lineNo - 2);
         return lineBefore.trim().isEmpty();
     }
 
     /**
      * Forms import full path.
      * @param token
      *        current token.
      * @return full path or null.
      */
     private static String getFullImportIdent(DetailAST token)
     {
         return token != null ? FullIdent.createFullIdent(token.
                 findFirstToken(TokenTypes.DOT)).getText() : "";
     }
 
     /**
      * Parses ordering rule and adds it to the list with rules.
      * @param ruleStr
      *        String with rule.
      */
     private void addRuleastoList(String ruleStr)
     {
         if (STATIC_RULE_GROUP.equals(ruleStr)
                 || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                 || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr))
         {
             customImportOrderRules.add(ruleStr);
 
         }
         else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
 
