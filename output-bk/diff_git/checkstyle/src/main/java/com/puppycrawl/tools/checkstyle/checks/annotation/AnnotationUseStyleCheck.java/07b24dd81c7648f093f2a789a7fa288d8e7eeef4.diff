diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
index 4087b1333..ebd17564c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
@@ -3,134 +3,134 @@
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.annotation;
 
 import java.util.Locale;
 
 import org.apache.commons.beanutils.ConversionException;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * This check controls the style with the usage of annotations.
  *
  * <p>
  * Annotations have three element styles starting with the least verbose.
  * <ul>
  * <li>{@link ElementStyle#COMPACT_NO_ARRAY COMPACT_NO_ARRAY}</li>
  * <li>{@link ElementStyle#COMPACT COMPACT}</li>
  * <li>{@link ElementStyle#EXPANDED EXPANDED}</li>
  * </ul>
  * To not enforce an element style
  * a {@link ElementStyle#IGNORE IGNORE} type is provided.  The desired style
  * can be set through the {@code elementStyle} property.
  *
  *
  * <p>
  * Using the EXPANDED style is more verbose. The expanded version
  * is sometimes referred to as "named parameters" in other languages.
  *
  *
  * <p>
  * Using the COMPACT style is less verbose. This style can only
  * be used when there is an element called 'value' which is either
- * the sole element or all other elements have default valuess.
+ * the sole element or all other elements have default values.
  *
  *
  * <p>
  * Using the COMPACT_NO_ARRAY style is less verbose. It is similar
  * to the COMPACT style but single value arrays are flagged. With
  * annotations a single value array does not need to be placed in an
  * array initializer. This style can only be used when there is an
  * element called 'value' which is either the sole element or all other
  * elements have default values.
  *
  *
  * <p>
  * The ending parenthesis are optional when using annotations with no elements.
  * To always require ending parenthesis use the
  * {@link ClosingParens#ALWAYS ALWAYS} type.  To never have ending parenthesis
  * use the {@link ClosingParens#NEVER NEVER} type. To not enforce a
  * closing parenthesis preference a {@link ClosingParens#IGNORE IGNORE} type is
  * provided. Set this through the {@code closingParens} property.
  *
  *
  * <p>
  * Annotations also allow you to specify arrays of elements in a standard
  * format.  As with normal arrays, a trailing comma is optional. To always
  * require a trailing comma use the {@link TrailingArrayComma#ALWAYS ALWAYS}
  * type. To never have a trailing comma use the
  * {@link TrailingArrayComma#NEVER NEVER} type. To not enforce a trailing
  * array comma preference a {@link TrailingArrayComma#IGNORE IGNORE} type
  * is provided.  Set this through the {@code trailingArrayComma} property.
  *
  *
  * <p>
  * By default the ElementStyle is set to EXPANDED, the TrailingArrayComma
- * is set to NEVER, and the ClosingParans is set to ALWAYS.
+ * is set to NEVER, and the ClosingParens is set to ALWAYS.
  *
  *
  * <p>
  * According to the JLS, it is legal to include a trailing comma
  * in arrays used in annotations but Sun's Java 5 &amp; 6 compilers will not
  * compile with this syntax. This may in be a bug in Sun's compilers
  * since eclipse 3.4's built-in compiler does allow this syntax as
  * defined in the JLS. Note: this was tested with compilers included with
  * JDK versions 1.5.0.17 and 1.6.0.11 and the compiler included with eclipse
  * 3.4.1.
  *
  * See <a
  * href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7">
  * Java Language specification, &sect;9.7</a>.
  *
  *
  * <p>
  * An example shown below is set to enforce an EXPANDED style, with a
  * trailing array comma set to NEVER and always including the closing
  * parenthesis.
  *
  *
  * <pre>
  * &lt;module name=&quot;AnnotationUseStyle&quot;&gt;
  *    &lt;property name=&quot;ElementStyle&quot;
  *        value=&quot;EXPANDED&quot;/&gt;
  *    &lt;property name=&quot;TrailingArrayComma&quot;
  *        value=&quot;NEVER&quot;/&gt;
  *    &lt;property name=&quot;ClosingParens&quot;
  *        value=&quot;ALWAYS&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author Travis Schneeberger
  */
 public final class AnnotationUseStyleCheck extends Check {
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_INCORRECT_STYLE =
         "annotation.incorrect.style";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_PARENS_MISSING =
         "annotation.parens.missing";
 
@@ -161,108 +161,108 @@ public final class AnnotationUseStyleCheck extends Check {
      */
     private static final String ANNOTATION_ELEMENT_SINGLE_NAME =
             "value";
 
     //not extending AbstractOptionCheck because check
     //has more than one option type.
 
     /** @see #setElementStyle(String) */
     private ElementStyle elementStyle = ElementStyle.COMPACT_NO_ARRAY;
 
     //defaulting to NEVER because of the strange compiler behavior
     /** @see #setTrailingArrayComma(String) */
     private TrailingArrayComma trailingArrayComma = TrailingArrayComma.NEVER;
 
     /** @see #setClosingParens(String) */
     private ClosingParens closingParens = ClosingParens.NEVER;
 
     /**
      * Sets the ElementStyle from a string.
      *
      * @param style string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setElementStyle(final String style) {
         elementStyle = getOption(ElementStyle.class, style);
     }
 
     /**
      * Sets the TrailingArrayComma from a string.
      *
      * @param comma string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setTrailingArrayComma(final String comma) {
         trailingArrayComma = getOption(TrailingArrayComma.class, comma);
     }
 
     /**
      * Sets the ClosingParens from a string.
      *
      * @param parens string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setClosingParens(final String parens) {
         closingParens = getOption(ClosingParens.class, parens);
     }
 
     /**
      * Retrieves an {@link Enum Enum} type from a @{link String String}.
      * @param <T> the enum type
-     * @param enuclass the enum class
+     * @param enumClass the enum class
      * @param value the string representing the enum
      * @return the enum type
      */
-    private static <T extends Enum<T>> T getOption(final Class<T> enuclass,
+    private static <T extends Enum<T>> T getOption(final Class<T> enumClass,
         final String value) {
         try {
-            return Enum.valueOf(enuclass, value.trim().toUpperCase(Locale.ENGLISH));
+            return Enum.valueOf(enumClass, value.trim().toUpperCase(Locale.ENGLISH));
         }
         catch (final IllegalArgumentException iae) {
             throw new ConversionException("unable to parse " + value, iae);
         }
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.ANNOTATION,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         checkStyleType(ast);
         checkCheckClosingParens(ast);
         checkTrailingComma(ast);
     }
 
     /**
      * Checks to see if the
      * {@link ElementStyle AnnotationElementStyle}
      * is correct.
      *
      * @param annotation the annotation token
      */
     private void checkStyleType(final DetailAST annotation) {
 
         switch (elementStyle) {
             case COMPACT_NO_ARRAY:
                 checkCompactNoArrayStyle(annotation);
                 break;
             case COMPACT:
                 checkCompactStyle(annotation);
                 break;
             case EXPANDED:
                 checkExpandedStyle(annotation);
                 break;
             case IGNORE:
