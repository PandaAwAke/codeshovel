diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 268d333ff..c03f8c5e3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -1,88 +1,89 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import java.util.stream.Collectors;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
 import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
+import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
 
 /**
  * <p>Checks that code doesn't rely on the &quot;this&quot; default.
  * That is references to instance variables and methods of the present
  * object are explicitly of the form &quot;this.varName&quot; or
  * &quot;this.methodName(args)&quot;.
  * </p>
  * Check has the following options:
  * <p><b>checkFields</b> - whether to check references to fields. Default value is <b>true</b>.</p>
  * <p><b>checkMethods</b> - whether to check references to methods.
  * Default value is <b>true</b>.</p>
  * <p><b>validateOnlyOverlapping</b> - whether to check only overlapping by variables or
  * arguments. Default value is <b>true</b>.</p>
  *
  * <p>Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to 'false'
  * and not that actual nowadays.</p>
  *
  * <p>Examples of use:
  * <pre>
  * &lt;module name=&quot;RequireThis&quot;/&gt;
  * </pre>
  * An example of how to configure to check {@code this} qualifier for
  * methods only:
  * <pre>
  * &lt;module name=&quot;RequireThis&quot;&gt;
  *   &lt;property name=&quot;checkFields&quot; value=&quot;false&quot;/&gt;
  *   &lt;property name=&quot;checkMethods&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * <p>Rationale:</p>
  * <ol>
  *   <li>
  *     The same notation/habit for C++ and Java (C++ have global methods, so having
  *     &quot;this.&quot; do make sense in it to distinguish call of method of class
  *     instead of global).
  *   </li>
  *   <li>
  *     Non-IDE development (ease of refactoring, some clearness to distinguish
  *     static and non-static methods).
  *   </li>
  * </ol>
  *
  * <p>Limitations: Nothing is currently done about static variables
  * or catch-blocks.  Static methods invoked on a class name seem to be OK;
  * both the class name and the method name have a DOT parent.
  * Non-static methods invoked on either this or a variable name seem to be
  * OK, likewise.</p>
  *
  * @author Stephen Bloch
@@ -262,123 +263,125 @@ public class RequireThisCheck extends AbstractCheck {
                     if (frame != null) {
                         logViolation(MSG_METHOD, ast, frame);
                     }
                 }
                 break;
             default:
                 if (checkFields) {
                     final AbstractFrame frame = getFieldWithoutThis(ast, parentType);
                     if (frame != null) {
                         logViolation(MSG_VARIABLE, ast, frame);
                     }
                 }
                 break;
         }
     }
 
     /**
      * Helper method to log a LocalizedMessage.
      * @param ast a node to get line id column numbers associated with the message.
      * @param msgKey key to locale message format.
      * @param frame the class frame where the violation is found.
      */
     private void logViolation(String msgKey, DetailAST ast, AbstractFrame frame) {
         if (frame.getFrameName().equals(getNearestClassFrameName())) {
             log(ast, msgKey, ast.getText(), "");
         }
         else if (!(frame instanceof AnonymousClassFrame)) {
             log(ast, msgKey, ast.getText(), frame.getFrameName() + '.');
         }
     }
 
     /**
      * Returns the frame where the field is declared, if the given field is used without
      * 'this', and null otherwise.
      * @param ast field definition ast token.
      * @param parentType type of the parent.
      * @return the frame where the field is declared, if the given field is used without
      *         'this' and null otherwise.
      */
     private AbstractFrame getFieldWithoutThis(DetailAST ast, int parentType) {
         final boolean importOrPackage = ScopeUtils.getSurroundingScope(ast) == null;
         final boolean methodNameInMethodCall = parentType == TokenTypes.DOT
                 && ast.getPreviousSibling() != null;
         final boolean typeName = parentType == TokenTypes.TYPE
                 || parentType == TokenTypes.LITERAL_NEW;
         AbstractFrame frame = null;
 
         if (!importOrPackage
                 && !methodNameInMethodCall
                 && !typeName
-                && !isDeclarationToken(parentType)) {
+                && !isDeclarationToken(parentType)
+                && !isLambdaParameter(ast)) {
             final AbstractFrame fieldFrame = findClassFrame(ast, false);
 
             if (fieldFrame != null && ((ClassFrame) fieldFrame).hasInstanceMember(ast)) {
                 frame = getClassFrameWhereViolationIsFound(ast);
             }
         }
         return frame;
     }
 
     /**
      * Parses the next AST for declarations.
      * @param frameStack stack containing the FrameTree being built.
      * @param ast AST to parse.
      */
     private static void collectDeclarations(Deque<AbstractFrame> frameStack, DetailAST ast) {
         final AbstractFrame frame = frameStack.peek();
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF :
                 collectVariableDeclarations(ast, frame);
                 break;
             case TokenTypes.PARAMETER_DEF :
-                if (!CheckUtils.isReceiverParameter(ast)) {
+                if (!CheckUtils.isReceiverParameter(ast)
+                        && !isLambdaParameter(ast)) {
                     final DetailAST parameterIdent = ast.findFirstToken(TokenTypes.IDENT);
                     frame.addIdent(parameterIdent);
                 }
                 break;
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
                 final DetailAST classFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ClassFrame(frame, classFrameNameIdent));
                 break;
             case TokenTypes.SLIST :
                 frameStack.addFirst(new BlockFrame(frame, ast));
                 break;
             case TokenTypes.METHOD_DEF :
                 final DetailAST methodFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
                 if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {
                     ((ClassFrame) frame).addStaticMethod(methodFrameNameIdent);
                 }
                 else {
                     ((ClassFrame) frame).addInstanceMethod(methodFrameNameIdent);
                 }
                 frameStack.addFirst(new MethodFrame(frame, methodFrameNameIdent));
                 break;
             case TokenTypes.CTOR_DEF :
                 final DetailAST ctorFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ConstructorFrame(frame, ctorFrameNameIdent));
                 break;
             case TokenTypes.LITERAL_NEW:
                 if (isAnonymousClassDef(ast)) {
                     frameStack.addFirst(new AnonymousClassFrame(frame,
                             ast.getFirstChild().toString()));
                 }
                 break;
             default:
                 // do nothing
         }
     }
 
     /**
      * Collects variable declarations.
      * @param ast variable token.
      * @param frame current frame.
      */
     private static void collectVariableDeclarations(DetailAST ast, AbstractFrame frame) {
         final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);
         if (frame.getType() == FrameType.CLASS_FRAME) {
             final DetailAST mods =
                     ast.findFirstToken(TokenTypes.MODIFIERS);
@@ -845,100 +848,135 @@ public class RequireThisCheck extends AbstractCheck {
             boolean lookForMethod) {
         final AbstractFrame result;
         if (frame == null) {
             result = null;
         }
         else {
             result = frame.getIfContains(name, lookForMethod);
         }
         return result;
     }
 
     /**
      * Check that token is related to Definition tokens.
      * @param parentType token Type.
      * @return true if token is related to Definition Tokens.
      */
     private static boolean isDeclarationToken(int parentType) {
         return DECLARATION_TOKENS.contains(parentType);
     }
 
     /**
      * Check that token is related to assign tokens.
      * @param tokenType token type.
      * @return true if token is related to assign tokens.
      */
     private static boolean isAssignToken(int tokenType) {
         return ASSIGN_TOKENS.contains(tokenType);
     }
 
     /**
      * Check that token is related to compound assign tokens.
      * @param tokenType token type.
      * @return true if token is related to compound assign tokens.
      */
     private static boolean isCompoundAssignToken(int tokenType) {
         return COMPOUND_ASSIGN_TOKENS.contains(tokenType);
     }
 
     /**
      * Gets the name of the nearest parent ClassFrame.
      * @return the name of the nearest parent ClassFrame.
      */
     private String getNearestClassFrameName() {
         AbstractFrame frame = current;
         while (frame.getType() != FrameType.CLASS_FRAME) {
             frame = frame.getParent();
         }
         return frame.getFrameName();
     }
 
+    /**
+     * Checks if the token is a Lambda parameter.
+     * @param ast the {@code DetailAST} value of the token to be checked
+     * @return true if the token is a Lambda parameter
+     */
+    private static boolean isLambdaParameter(DetailAST ast) {
+        DetailAST parent;
+        for (parent = ast.getParent(); parent != null; parent = parent.getParent()) {
+            if (parent.getType() == TokenTypes.LAMBDA) {
+                break;
+            }
+        }
+        final boolean isLambdaParameter;
+        if (parent == null) {
+            isLambdaParameter = false;
+        }
+        else if (ast.getType() == TokenTypes.PARAMETER_DEF) {
+            isLambdaParameter = true;
+        }
+        else {
+            final DetailAST lambdaParameters = parent.findFirstToken(TokenTypes.PARAMETERS);
+            if (lambdaParameters == null) {
+                isLambdaParameter = parent.getFirstChild().getText().equals(ast.getText());
+            }
+            else {
+                isLambdaParameter = TokenUtils.findFirstTokenByPredicate(lambdaParameters,
+                    paramDef -> {
+                        final DetailAST param = paramDef.findFirstToken(TokenTypes.IDENT);
+                        return param != null && param.getText().equals(ast.getText());
+                    }).isPresent();
+            }
+        }
+        return isLambdaParameter;
+    }
+
     /** An AbstractFrame type. */
     private enum FrameType {
         /** Class frame type. */
         CLASS_FRAME,
         /** Constructor frame type. */
         CTOR_FRAME,
         /** Method frame type. */
         METHOD_FRAME,
         /** Block frame type. */
         BLOCK_FRAME,
     }
 
     /**
      * A declaration frame.
      * @author Stephen Bloch
      * @author Andrei Selkin
      */
     private abstract static class AbstractFrame {
         /** Set of name of variables declared in this frame. */
         private final Set<DetailAST> varIdents;
 
         /** Parent frame. */
         private final AbstractFrame parent;
 
         /** Name identifier token. */
         private final DetailAST frameNameIdent;
 
         /**
          * Constructor -- invokable only via super() from subclasses.
          * @param parent parent frame.
          * @param ident frame name ident.
          */
         protected AbstractFrame(AbstractFrame parent, DetailAST ident) {
             this.parent = parent;
             frameNameIdent = ident;
             varIdents = new HashSet<>();
         }
 
         /**
          * Get the type of the frame.
          * @return a FrameType.
          */
         protected abstract FrameType getType();
 
         /**
          * Add a name to the frame.
          * @param identToAdd the name we're adding.
          */
         private void addIdent(DetailAST identToAdd) {
             varIdents.add(identToAdd);
