diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
index 3c3cd11ca..90adad693 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
@@ -28,100 +28,106 @@ import com.puppycrawl.tools.checkstyle.api.Utils;
  * Checks that the whitespace around the Generic tokens (angle brackets)
  * "&lt;" and "&gt;" are correct to the <i>typical</i> convention.
  * The convention is not configurable.
  * </p>
  * <br>
  * <p>
  * Left angle bracket ("&lt;"):
  * </p>
  * <br>
  * <ul>
  * <li> should be preceded with whitespace only
  *   in generic methods definitions.</li>
  * <li> should not be preceded with whitespace
  *   when it is precede method name or following type name.</li>
  * <li> should not be followed with whitespace in all cases.</li>
  * </ul>
  * <br>
  * <p>
  * Right angle bracket ("&gt;"):
  * </p>
  * <br>
  * <ul>
  * <li> should not be preceded with whitespace in all cases.</li>
  * <li> should be followed with whitespace in almost all cases,
  *   except diamond operators and when preceding method name.</li></ul>
  * <br>
  * <p>
  * Examples with correct spacing:
  * </p>
  * <br>
  * <pre>
  * public void &lt;K, V extends Number&gt; boolean foo(K, V) {}  // Generic methods definitions
  * class name&lt;T1, T2, ..., Tn&gt; {}                          // Generic type definition
  * OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p;              // Generic type reference
  * boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);   // Generic preceded method name
  * Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, "apple");// Diamond operator
  * </pre>
  * @author Oliver Burn
  */
 public class GenericWhitespaceCheck extends Check
 {
     /** Used to count the depth of a Generic expression. */
     private int depth;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
+    }
+
     @Override
     public void beginTree(DetailAST rootAST)
     {
         // Reset for each tree, just incase there are errors in preceeding
         // trees.
         depth = 0;
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         if (ast.getType() == TokenTypes.GENERIC_START) {
             processStart(ast);
             depth++;
         }
         else if (ast.getType() == TokenTypes.GENERIC_END) {
             processEnd(ast);
             depth--;
         }
     }
 
     /**
      * Checks the token for the end of Generics.
      * @param ast the token to check
      */
     private void processEnd(DetailAST ast)
     {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         if ((0 <= before) && Character.isWhitespace(line.charAt(before))
                 && !Utils.whitespaceBefore(before, line))
         {
             log(ast.getLineNo(), before, "ws.preceded", ">");
         }
 
         if (after < line.length()) {
 
             // Check if the last Generic, in which case must be a whitespace
             // or a '(),[.'.
             if (1 == depth) {
                 final char charAfter = line.charAt(after);
 
                 // Need to handle a number of cases. First is:
                 //    Collections.<Object>emptySet();
                 //                        ^
                 //                        +--- whitespace not allowed
                 if ((ast.getParent().getType() == TokenTypes.TYPE_ARGUMENTS)
                     && (ast.getParent().getParent().getType()
