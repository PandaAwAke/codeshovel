diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index a86328e6c..1626c275e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -12,101 +12,102 @@
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.imports;
 
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * <ul>
  * <li>groups imports: ensures that groups of imports come in a specific order
  * (e.g., java. comes first, javax. comes second, then everything else)</li>
  * <li>adds a separation between groups : ensures that a blank line sit between
  * each group</li>
  * <li>import groups aren't separated internally: ensures that
  * each group aren't separated internally by blank line or comment</li>
  * <li>sorts imports inside each group: ensures that imports within each group
  * are in lexicographic order</li>
  * <li>sorts according to case: ensures that the comparison between import is
  * case sensitive</li>
  * <li>groups static imports: ensures that static imports are at the top (or the
  * bottom) of all the imports, or above (or under) each group, or are treated
  * like non static imports (@see {@link ImportOrderOption}</li>
  * </ul>.
  *
  * <pre>
  * Properties:
  * </pre>
  * <table summary="Properties" border="1">
  *   <tr><th>name</th><th>Description</th><th>type</th><th>default value</th></tr>
  *   <tr><td>option</td><td>policy on the relative order between regular imports and static
  *       imports</td><td>{@link ImportOrderOption}</td><td>under</td></tr>
  *   <tr><td>groups</td><td>list of imports groups (every group identified either by a common
  *       prefix string, or by a regular expression enclosed in forward slashes (e.g. /regexp/)</td>
  *       <td>list of strings</td><td>empty list</td></tr>
  *   <tr><td>ordered</td><td>whether imports within group should be sorted</td>
  *       <td>Boolean</td><td>true</td></tr>
  *   <tr><td>separated</td><td>whether imports groups should be separated by, at least,
- *       one blank line and aren't separated internally</td><td>Boolean</td><td>false</td></tr>
+ *       one blank line or comment and aren't separated internally
+ *       </td><td>Boolean</td><td>false</td></tr>
  *   <tr><td>caseSensitive</td><td>whether string comparison should be case sensitive or not.
  *       Case sensitive sorting is in ASCII sort order</td><td>Boolean</td><td>true</td></tr>
  *   <tr><td>sortStaticImportsAlphabetically</td><td>whether static imports grouped by top or
  *       bottom option are sorted alphabetically or not</td><td>Boolean</td><td>false</td></tr>
  *   <tr><td>useContainerOrderingForStatic</td><td>whether to use container ordering
  *       (Eclipse IDE term) for static imports or not</td><td>Boolean</td><td>false</td></tr>
  * </table>
  *
  * <p>
  * Example:
  * </p>
  * <p>To configure the check so that it matches default Eclipse formatter configuration
  *    (tested on Kepler, Luna and Mars):</p>
  * <ul>
  *     <li>group of static imports is on the top</li>
  *     <li>groups of non-static imports: &quot;java&quot; then &quot;javax&quot;
  *         packages first, then &quot;org&quot; and then all other imports</li>
  *     <li>imports will be sorted in the groups</li>
  *     <li>groups are separated by, at least, one blank line and aren't separated internally</li>
  * </ul>
  *
  * <pre>
  * &lt;module name=&quot;ImportOrder&quot;&gt;
  *    &lt;property name=&quot;groups&quot; value=&quot;/^javax?\./,org&quot;/&gt;
  *    &lt;property name=&quot;ordered&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;separated&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;option&quot; value=&quot;above&quot;/&gt;
  *    &lt;property name=&quot;sortStaticImportsAlphabetically&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * <p>To configure the check so that it matches default IntelliJ IDEA formatter configuration
  *    (tested on v14):</p>
  * <ul>
  *     <li>group of static imports is on the bottom</li>
  *     <li>groups of non-static imports: all imports except of &quot;javax&quot; and
  *         &quot;java&quot;, then &quot;javax&quot; and &quot;java&quot;</li>
  *     <li>imports will be sorted in the groups</li>
  *     <li>groups are separated by, at least, one blank line and aren't separated internally</li>
  * </ul>
  *
  *         <p>
  *         Note: &quot;separated&quot; option is disabled because IDEA default has blank line
  *         between &quot;java&quot; and static imports, and no blank line between
  *         &quot;javax&quot; and &quot;java&quot;
  *         </p>
  *
  * <pre>
  * &lt;module name=&quot;ImportOrder&quot;&gt;
  *     &lt;property name=&quot;groups&quot; value=&quot;*,javax,java&quot;/&gt;
@@ -402,118 +403,147 @@ public class ImportOrderCheck
         else if (option == ImportOrderOption.ABOVE) {
             // previous non-static but current is static
             doVisitToken(ident, isStatic, isStaticAndNotLastImport);
 
         }
         else if (option == ImportOrderOption.UNDER) {
             doVisitToken(ident, isStatic, isLastImportAndNonStatic);
 
         }
         else if (option == ImportOrderOption.INFLOW) {
             // "previous" argument is useless here
             doVisitToken(ident, isStatic, true);
 
         }
         else {
             throw new IllegalStateException(
                     "Unexpected option for static imports: " + option);
         }
 
         lastImportLine = ast.findFirstToken(TokenTypes.SEMI).getLineNo();
         lastImportStatic = isStatic;
         beforeFirstImport = false;
     }
 
     /**
      * Shares processing...
      *
      * @param ident the import to process.
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *                  previous static but current is non-static (under).
      */
     private void doVisitToken(FullIdent ident, boolean isStatic,
             boolean previous) {
         final String name = ident.getText();
         final int groupIdx = getGroupNumber(name);
         final int line = ident.getLineNo();
 
         if (groupIdx == lastGroup
             || !beforeFirstImport && isAlphabeticallySortableStaticImport(isStatic)) {
             doVisitTokenInSameGroup(isStatic, previous, name, line);
         }
         else if (groupIdx > lastGroup) {
             if (!beforeFirstImport && separated && line - lastImportLine < 2) {
                 log(line, MSG_SEPARATION, name);
             }
         }
         else {
             log(line, MSG_ORDERING, name);
         }
-        if (checkSeparatorInGroup(groupIdx, isStatic, line)) {
+        if (isSeparatorInGroup(groupIdx, isStatic, line)) {
             log(line, MSG_SEPARATED_IN_GROUP, name);
         }
 
         lastGroup = groupIdx;
         lastImport = name;
     }
 
     /**
      * Checks whether imports group separated internally.
      * @param groupIdx group number.
      * @param isStatic whether the token is static or not.
      * @param line the line of the current import.
      * @return true if imports group are separated internally.
      */
-    private boolean checkSeparatorInGroup(int groupIdx, boolean isStatic, int line) {
-        return !beforeFirstImport && separated && groupIdx == lastGroup
-                && isStatic == lastImportStatic && line - lastImportLine > 1;
+    private boolean isSeparatorInGroup(int groupIdx, boolean isStatic, int line) {
+        final boolean inSameGroup = isInSameGroup(groupIdx, isStatic);
+        return (!separated || inSameGroup) && isSeparatorBeforeImport(line);
+    }
+
+    /**
+     * Checks whether there is any separator before current import.
+     * @param line the line of the current import.
+     * @return true if there is separator before current import which isn't the first import.
+     */
+    private boolean isSeparatorBeforeImport(int line) {
+        return !beforeFirstImport && line - lastImportLine > 1;
+    }
+
+    /**
+     * Checks whether imports are in same group.
+     * @param groupIdx group number.
+     * @param isStatic whether the token is static or not.
+     * @return true if imports are in same group.
+     */
+    private boolean isInSameGroup(int groupIdx, boolean isStatic) {
+        final boolean isStaticImportGroupIndependent =
+            option == ImportOrderOption.TOP || option == ImportOrderOption.BOTTOM;
+        final boolean result;
+        if (isStaticImportGroupIndependent) {
+            result = isStatic && lastImportStatic
+                || groupIdx == lastGroup && isStatic == lastImportStatic;
+        }
+        else {
+            result = groupIdx == lastGroup;
+        }
+        return result;
     }
 
     /**
      * Checks whether static imports grouped by <b>top</b> or <b>bottom</b> option
      * are sorted alphabetically or not.
      * @param isStatic if current import is static.
      * @return true if static imports should be sorted alphabetically.
      */
     private boolean isAlphabeticallySortableStaticImport(boolean isStatic) {
         return isStatic && sortStaticImportsAlphabetically
                 && (option == ImportOrderOption.TOP
                     || option == ImportOrderOption.BOTTOM);
     }
 
     /**
      * Shares processing...
      *
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *     previous static but current is non-static (under).
      * @param name the name of the current import.
      * @param line the line of the current import.
      */
     private void doVisitTokenInSameGroup(boolean isStatic,
             boolean previous, String name, int line) {
         if (ordered) {
             if (option == ImportOrderOption.INFLOW) {
                 if (isWrongOrder(name, isStatic)) {
                     log(line, MSG_ORDERING, name);
                 }
             }
             else {
                 final boolean shouldFireError =
                     // previous non-static but current is static (above)
                     // or
                     // previous static but current is non-static (under)
                     previous
                         ||
                         // current and previous static or current and
                         // previous non-static
                         lastImportStatic == isStatic
                     && isWrongOrder(name, isStatic);
 
                 if (shouldFireError) {
                     log(line, MSG_ORDERING, name);
                 }
             }
         }
     }
 
