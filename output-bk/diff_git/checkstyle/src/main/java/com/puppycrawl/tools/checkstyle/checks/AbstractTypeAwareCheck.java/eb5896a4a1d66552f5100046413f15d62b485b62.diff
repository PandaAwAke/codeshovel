diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index b9b834e9a..9a7339d74 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -10,101 +10,101 @@
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks;
 
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Abstract class that endeavours to maintain type information for the Java
  * file being checked. It provides helper methods for performing type
  * information functions.
  *
  * @author Oliver Burn
  * @deprecated Checkstyle is not type aware tool and all Checks derived from this
  * class are potentially unstable.
  */
 @Deprecated
 public abstract class AbstractTypeAwareCheck extends Check {
     /** imports details **/
     private final Set<String> imports = Sets.newHashSet();
 
     /** full identifier for package of the method **/
     private FullIdent packageFullIdent;
 
     /** Name of current class. */
     private String currentClass;
 
     /** <code>ClassResolver</code> instance for current tree. */
     private ClassResolver classResolver;
 
     /** Stack of maps for type params. */
-    private final Deque<Map<String, ClassInfo>> typeParams = new ArrayDeque<>();
+    private final Deque<Map<String, AbstractClassInfo>> typeParams = new ArrayDeque<>();
 
     /**
      * Whether to log class loading errors to the checkstyle report
      * instead of throwing a RTE.
      *
      * Logging errors will avoid stopping checkstyle completely
      * because of a typo in javadoc. However, with modern IDEs that
      * support automated refactoring and generate javadoc this will
      * occur rarely, so by default we assume a configuration problem
      * in the checkstyle classpath and throw an execption.
      *
      * This configuration option was triggered by bug 1422462.
      */
     private boolean logLoadErrors = true;
 
     /**
      * Whether to show class loading errors in the checkstyle report.
      * Request ID 1491630
      */
     private boolean suppressLoadErrors;
 
     /**
      * Controls whether to log class loading errors to the checkstyle report
      * instead of throwing a RTE.
      *
      * @param logLoadErrors true if errors should be logged
      */
     public final void setLogLoadErrors(boolean logLoadErrors) {
         this.logLoadErrors = logLoadErrors;
     }
 
     /**
      * Controls whether to show class loading errors in the checkstyle report.
      *
      * @param suppressLoadErrors true if errors shouldn't be shown
      */
     public final void setSuppressLoadErrors(boolean suppressLoadErrors) {
         this.suppressLoadErrors = suppressLoadErrors;
     }
 
     /**
      * Called to process an AST when visiting it.
      * @param ast the AST to process. Guaranteed to not be PACKAGE_DEF or
      *             IMPORT tokens.
      */
     protected abstract void processAST(DetailAST ast);
 
     @Override
     public final int[] getRequiredTokens() {
         return new int[] {
@@ -268,274 +268,274 @@ public abstract class AbstractTypeAwareCheck extends Check {
      * @param columnNo column number of the problem.
      * @param msgKey message key to use.
      * @param values values to fill the message out.
      */
     protected final void logLoadErrorImpl(int lineNo, int columnNo,
                                           String msgKey, Object... values) {
         if (!logLoadErrors) {
             final LocalizedMessage msg = new LocalizedMessage(lineNo,
                                                     columnNo,
                                                     getMessageBundle(),
                                                     msgKey,
                                                     values,
                                                     getSeverityLevel(),
                                                     getId(),
                                                     this.getClass(),
                                                     null);
             throw new RuntimeException(msg.getMessage());
         }
 
         if (!suppressLoadErrors) {
             log(lineNo, columnNo, msgKey, values);
         }
     }
 
     /**
      * Collects the details of a package.
      * @param ast node containing the package details
      */
     private void processPackage(DetailAST ast) {
         final DetailAST nameAST = ast.getLastChild().getPreviousSibling();
         packageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param ast node containing the import details
      */
     private void processImport(DetailAST ast) {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
         imports.add(name.getText());
     }
 
     /**
      * Process type params (if any) for given class, enum or method.
      * @param ast class, enum or method to process.
      */
     private void processTypeParams(DetailAST ast) {
         final DetailAST params =
             ast.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
-        final Map<String, ClassInfo> paramsMap = Maps.newHashMap();
+        final Map<String, AbstractClassInfo> paramsMap = Maps.newHashMap();
         typeParams.push(paramsMap);
 
         if (params == null) {
             return;
         }
 
         for (DetailAST child = params.getFirstChild();
              child != null;
              child = child.getNextSibling()) {
             if (child.getType() == TokenTypes.TYPE_PARAMETER) {
                 final DetailAST param = child;
                 final String alias =
                     param.findFirstToken(TokenTypes.IDENT).getText();
                 final DetailAST bounds =
                     param.findFirstToken(TokenTypes.TYPE_UPPER_BOUNDS);
                 if (bounds != null) {
                     final FullIdent name =
                         FullIdent.createFullIdentBelow(bounds);
-                    final ClassInfo ci =
+                    final AbstractClassInfo ci =
                         createClassInfo(new Token(name), getCurrentClassName());
                     paramsMap.put(alias, ci);
                 }
             }
         }
     }
 
     /**
      * Processes class definition.
      * @param ast class definition to process.
      */
     private void processClass(DetailAST ast) {
         final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);
         currentClass += ("".equals(currentClass) ? "" : "$")
             + ident.getText();
 
         processTypeParams(ast);
     }
 
     /**
      * Returns current class.
      * @return name of current class.
      */
     protected final String getCurrentClassName() {
         return currentClass;
     }
 
     /**
      * Creates class info for given name.
      * @param name name of type.
      * @param surroundingClass name of surrounding class.
      * @return class infor for given name.
      */
-    protected final ClassInfo createClassInfo(final Token name,
+    protected final AbstractClassInfo createClassInfo(final Token name,
                                               final String surroundingClass) {
-        final ClassInfo ci = findClassAlias(name.getText());
+        final AbstractClassInfo ci = findClassAlias(name.getText());
         if (ci != null) {
             return new ClassAlias(name, ci);
         }
         return new RegularClass(name, surroundingClass, this);
     }
 
     /**
      * Looking if a given name is alias.
      * @param name given name
      * @return ClassInfo for alias if it exists, null otherwise
      */
-    protected final ClassInfo findClassAlias(final String name) {
-        ClassInfo ci = null;
-        final Iterator<Map<String, ClassInfo>> iterator = typeParams.descendingIterator();
+    protected final AbstractClassInfo findClassAlias(final String name) {
+        AbstractClassInfo ci = null;
+        final Iterator<Map<String, AbstractClassInfo>> iterator = typeParams.descendingIterator();
         while (iterator.hasNext()) {
-            final Map<String, ClassInfo> paramMap = iterator.next();
+            final Map<String, AbstractClassInfo> paramMap = iterator.next();
             ci = paramMap.get(name);
             if (ci != null) {
                 break;
             }
         }
         return ci;
     }
 
     /**
      * Contains class's <code>Token</code>.
      */
-    protected abstract static class ClassInfo {
+    protected abstract static class AbstractClassInfo {
         /** <code>FullIdent</code> associated with this class. */
         private final Token name;
 
         /**
          * Creates new instance of class inforamtion object.
          * @param className token which represents class name.
          */
-        protected ClassInfo(final Token className) {
+        protected AbstractClassInfo(final Token className) {
             if (className == null) {
                 throw new IllegalArgumentException(
                     "ClassInfo's name should be non-null");
             }
             name = className;
         }
 
         /** @return class name */
         public final Token getName() {
             return name;
         }
 
         /** @return <code>Class</code> associated with an object. */
         public abstract Class<?> getClazz();
     }
 
     /** Represents regular classes/enumes. */
-    private static final class RegularClass extends ClassInfo {
+    private static final class RegularClass extends AbstractClassInfo {
         /** name of surrounding class. */
         private final String surroundingClass;
         /** is class loadable. */
         private boolean loadable = true;
         /** <code>Class</code> object of this class if it's loadable. */
         private Class<?> classObj;
         /** the check we use to resolve classes. */
         private final AbstractTypeAwareCheck check;
 
         /**
          * Creates new instance of of class information object.
          * @param name <code>FullIdent</code> associated with new object.
          * @param surroundingClass name of current surrounding class.
          * @param check the check we use to load class.
          */
         public RegularClass(final Token name,
                              final String surroundingClass,
                              final AbstractTypeAwareCheck check) {
             super(name);
             this.surroundingClass = surroundingClass;
             this.check = check;
         }
         /** @return if class is loadable ot not. */
         private boolean isLoadable() {
             return loadable;
         }
 
         @Override
         public Class<?> getClazz() {
             if (isLoadable() && classObj == null) {
                 setClazz(check.tryLoadClass(getName(), surroundingClass));
             }
             return classObj;
         }
 
         /**
          * Associates <code> Class</code> with an object.
          * @param classObj <code>Class</code> to associate with.
          */
         private void setClazz(Class<?> classObj) {
             this.classObj = classObj;
             loadable = classObj != null;
         }
 
         @Override
         public String toString() {
             return "RegularClass[name=" + getName()
                 + ", in class=" + surroundingClass
                 + ", loadable=" + loadable
                 + ", class=" + classObj + "]";
         }
     }
 
     /** Represents type param which is "alias" for real type. */
-    private static class ClassAlias extends ClassInfo {
+    private static class ClassAlias extends AbstractClassInfo {
         /** Class information associated with the alias. */
-        private final ClassInfo classInfo;
+        private final AbstractClassInfo classInfo;
 
         /**
          * Creates nnew instance of the class.
          * @param name token which represents name of class alias.
          * @param classInfo class information associated with the alias.
          */
-        ClassAlias(final Token name, ClassInfo classInfo) {
+        ClassAlias(final Token name, AbstractClassInfo classInfo) {
             super(name);
             this.classInfo = classInfo;
         }
 
         @Override
         public final Class<?> getClazz() {
             return classInfo.getClazz();
         }
 
         @Override
         public String toString() {
             return "ClassAlias[alias " + getName()
                 + " for " + classInfo + "]";
         }
     }
 
     /**
      * Represents text element with location in the text.
      */
     protected static class Token {
         /** token's column number. */
         private final int column;
         /** token's line number. */
         private final int line;
         /** token's text. */
         private final String text;
 
         /**
          * Creates token.
          * @param text token's text
          * @param line token's line number
          * @param column token's column number
          */
         public Token(String text, int line, int column) {
             this.text = text;
             this.line = line;
             this.column = column;
         }
 
         /**
          * Converts FullIdent to Token.
          * @param fullIdent full ident to convert.
          */
         public Token(FullIdent fullIdent) {
             text = fullIdent.getText();
             line = fullIdent.getLineNo();
             column = fullIdent.getColumnNo();
         }
 
         /** @return line number of the token */
