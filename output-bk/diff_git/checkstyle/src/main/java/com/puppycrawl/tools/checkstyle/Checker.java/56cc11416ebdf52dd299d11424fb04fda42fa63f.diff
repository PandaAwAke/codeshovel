diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
index 396d91e14..7b50f2a55 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
@@ -224,189 +224,194 @@ public class Checker extends AutomaticBean implements MessageDispatcher, RootMod
      */
     private Set<String> getExternalResourceLocations() {
         final Set<String> externalResources = new HashSet<>();
         fileSetChecks.stream().filter(check -> check instanceof ExternalResourceHolder)
             .forEach(check -> {
                 final Set<String> locations =
                     ((ExternalResourceHolder) check).getExternalResourceLocations();
                 externalResources.addAll(locations);
             });
         filters.getFilters().stream().filter(filter -> filter instanceof ExternalResourceHolder)
             .forEach(filter -> {
                 final Set<String> locations =
                     ((ExternalResourceHolder) filter).getExternalResourceLocations();
                 externalResources.addAll(locations);
             });
         return externalResources;
     }
 
     /** Notify all listeners about the audit start. */
     private void fireAuditStarted() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditStarted(event);
         }
     }
 
     /** Notify all listeners about the audit end. */
     private void fireAuditFinished() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditFinished(event);
         }
     }
 
     /**
      * Processes a list of files with all FileSetChecks.
      * @param files a list of files to process.
      * @throws CheckstyleException if error condition within Checkstyle occurs.
      * @noinspection ProhibitedExceptionThrown
      */
     private void processFiles(List<File> files) throws CheckstyleException {
         for (final File file : files) {
             try {
                 final String fileName = file.getAbsolutePath();
                 final long timestamp = file.lastModified();
                 if (cache != null && cache.isInCache(fileName, timestamp)
                         || !CommonUtils.matchesFileExtension(file, fileExtensions)
                         || !acceptFileStarted(fileName)) {
                     continue;
                 }
+                if (cache != null) {
+                    cache.put(fileName, timestamp);
+                }
                 fireFileStarted(fileName);
                 final SortedSet<LocalizedMessage> fileMessages = processFile(file);
                 fireErrors(fileName, fileMessages);
                 fireFileFinished(fileName);
-                if (cache != null && fileMessages.isEmpty()) {
-                    cache.put(fileName, timestamp);
-                }
             }
             // -@cs[IllegalCatch] There is no other way to deliver filename that was under
             // processing. See https://github.com/checkstyle/checkstyle/issues/2285
             catch (Exception ex) {
                 // We need to catch all exceptions to put a reason failure (file name) in exception
                 throw new CheckstyleException("Exception was thrown while processing "
                         + file.getPath(), ex);
             }
             catch (Error error) {
                 // We need to catch all errors to put a reason failure (file name) in error
                 throw new Error("Error was thrown while processing " + file.getPath(), error);
             }
         }
     }
 
     /**
      * Processes a file with all FileSetChecks.
      * @param file a file to process.
      * @return a sorted set of messages to be logged.
      * @throws CheckstyleException if error condition within Checkstyle occurs.
      */
     private SortedSet<LocalizedMessage> processFile(File file) throws CheckstyleException {
         final SortedSet<LocalizedMessage> fileMessages = new TreeSet<>();
         try {
             final FileText theText = new FileText(file.getAbsoluteFile(), charset);
             for (final FileSetCheck fsc : fileSetChecks) {
                 fileMessages.addAll(fsc.process(file, theText));
             }
         }
         catch (final IOException ioe) {
             LOG.debug("IOException occurred.", ioe);
             fileMessages.add(new LocalizedMessage(0,
                     Definitions.CHECKSTYLE_BUNDLE, "general.exception",
                     new String[] {ioe.getMessage()}, null, getClass(), null));
         }
         return fileMessages;
     }
 
     /**
      * Check if all before execution file filters accept starting the file.
      *
      * @param fileName
      *            the file to be audited
      * @return {@code true} if the file is accepted.
      */
     private boolean acceptFileStarted(String fileName) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
         return beforeExecutionFileFilters.accept(stripped);
     }
 
     /**
      * Notify all listeners about the beginning of a file audit.
      *
      * @param fileName
      *            the file to be audited
      */
     @Override
     public void fireFileStarted(String fileName) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
         final AuditEvent event = new AuditEvent(this, stripped);
         for (final AuditListener listener : listeners) {
             listener.fileStarted(event);
         }
     }
 
     /**
      * Notify all listeners about the errors in a file.
      *
      * @param fileName the audited file
      * @param errors the audit errors from the file
      */
     @Override
     public void fireErrors(String fileName, SortedSet<LocalizedMessage> errors) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
+        boolean hasNonFilteredViolations = false;
         for (final LocalizedMessage element : errors) {
             final AuditEvent event = new AuditEvent(this, stripped, element);
             if (filters.accept(event)) {
+                hasNonFilteredViolations = true;
                 for (final AuditListener listener : listeners) {
                     listener.addError(event);
                 }
             }
         }
+        if (hasNonFilteredViolations && cache != null) {
+            cache.remove(fileName);
+        }
     }
 
     /**
      * Notify all listeners about the end of a file audit.
      *
      * @param fileName
      *            the audited file
      */
     @Override
     public void fireFileFinished(String fileName) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
         final AuditEvent event = new AuditEvent(this, stripped);
         for (final AuditListener listener : listeners) {
             listener.fileFinished(event);
         }
     }
 
     @Override
     public void finishLocalSetup() throws CheckstyleException {
         final Locale locale = new Locale(localeLanguage, localeCountry);
         LocalizedMessage.setLocale(locale);
 
         if (moduleFactory == null) {
 
             if (moduleClassLoader == null) {
                 throw new CheckstyleException(
                         "if no custom moduleFactory is set, "
                                 + "moduleClassLoader must be specified");
             }
 
             final Set<String> packageNames = PackageNamesLoader
                     .getPackageNames(moduleClassLoader);
             moduleFactory = new PackageObjectFactory(packageNames,
                     moduleClassLoader);
         }
 
         final DefaultContext context = new DefaultContext();
         context.add("charset", charset);
         context.add("classLoader", classLoader);
         context.add("moduleFactory", moduleFactory);
         context.add("severity", severityLevel.getName());
         context.add("basedir", basedir);
         childContext = context;
     }
 
     @Override
     protected void setupChild(Configuration childConf)
             throws CheckstyleException {
         final String name = childConf.getName();
         final Object child;
