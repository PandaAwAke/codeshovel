diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 96ec8ddc3..6af261a16 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -305,135 +305,135 @@ public class RequireThisCheck extends AbstractCheck {
                 && ast.getPreviousSibling() != null;
         final boolean typeName = parentType == TokenTypes.TYPE
                 || parentType == TokenTypes.LITERAL_NEW;
         AbstractFrame frame = null;
 
         if (!importOrPackage
                 && !methodNameInMethodCall
                 && !typeName
                 && !isDeclarationToken(parentType)
                 && !isLambdaParameter(ast)) {
             final AbstractFrame fieldFrame = findClassFrame(ast, false);
 
             if (fieldFrame != null && ((ClassFrame) fieldFrame).hasInstanceMember(ast)) {
                 frame = getClassFrameWhereViolationIsFound(ast);
             }
         }
         return frame;
     }
 
     /**
      * Parses the next AST for declarations.
      * @param frameStack stack containing the FrameTree being built.
      * @param ast AST to parse.
      */
     private static void collectDeclarations(Deque<AbstractFrame> frameStack, DetailAST ast) {
         final AbstractFrame frame = frameStack.peek();
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF :
                 collectVariableDeclarations(ast, frame);
                 break;
             case TokenTypes.PARAMETER_DEF :
                 if (!CheckUtils.isReceiverParameter(ast)
                         && !isLambdaParameter(ast)) {
                     final DetailAST parameterIdent = ast.findFirstToken(TokenTypes.IDENT);
                     frame.addIdent(parameterIdent);
                 }
                 break;
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
                 final DetailAST classFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ClassFrame(frame, classFrameNameIdent));
                 break;
             case TokenTypes.SLIST :
                 frameStack.addFirst(new BlockFrame(frame, ast));
                 break;
             case TokenTypes.METHOD_DEF :
                 final DetailAST methodFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
-                if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {
-                    ((ClassFrame) frame).addStaticMethod(methodFrameNameIdent);
+                if (mods.findFirstToken(TokenTypes.LITERAL_STATIC) == null) {
+                    ((ClassFrame) frame).addInstanceMethod(methodFrameNameIdent);
                 }
                 else {
-                    ((ClassFrame) frame).addInstanceMethod(methodFrameNameIdent);
+                    ((ClassFrame) frame).addStaticMethod(methodFrameNameIdent);
                 }
                 frameStack.addFirst(new MethodFrame(frame, methodFrameNameIdent));
                 break;
             case TokenTypes.CTOR_DEF :
                 final DetailAST ctorFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ConstructorFrame(frame, ctorFrameNameIdent));
                 break;
             case TokenTypes.LITERAL_NEW:
                 if (isAnonymousClassDef(ast)) {
                     frameStack.addFirst(new AnonymousClassFrame(frame,
                             ast.getFirstChild().toString()));
                 }
                 break;
             default:
                 // do nothing
         }
     }
 
     /**
      * Collects variable declarations.
      * @param ast variable token.
      * @param frame current frame.
      */
     private static void collectVariableDeclarations(DetailAST ast, AbstractFrame frame) {
         final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);
         if (frame.getType() == FrameType.CLASS_FRAME) {
             final DetailAST mods =
                     ast.findFirstToken(TokenTypes.MODIFIERS);
             if (ScopeUtils.isInInterfaceBlock(ast)
-                    || mods.branchContains(TokenTypes.LITERAL_STATIC)) {
+                    || mods.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
                 ((ClassFrame) frame).addStaticMember(ident);
             }
             else {
                 ((ClassFrame) frame).addInstanceMember(ident);
             }
         }
         else {
             frame.addIdent(ident);
         }
     }
 
     /**
      * Ends parsing of the AST for declarations.
      * @param frameStack Stack containing the FrameTree being built.
      * @param ast AST that was parsed.
      */
     private void endCollectingDeclarations(Queue<AbstractFrame> frameStack, DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
                 frames.put(ast, frameStack.poll());
                 break;
             case TokenTypes.LITERAL_NEW :
                 if (isAnonymousClassDef(ast)) {
                     frames.put(ast, frameStack.poll());
                 }
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Whether the AST is a definition of an anonymous class.
      * @param ast the AST to process.
      * @return true if the AST is a definition of an anonymous class.
      */
     private static boolean isAnonymousClassDef(DetailAST ast) {
         final DetailAST lastChild = ast.getLastChild();
         return lastChild != null
             && lastChild.getType() == TokenTypes.OBJBLOCK;
     }
 
     /**
      * Returns the class frame where violation is found (where the field is used without 'this')
@@ -552,101 +552,101 @@ public class RequireThisCheck extends AbstractCheck {
      * @param ident variable ident token.
      * @return true if the current variable is returned from the method.
      */
     private static boolean isReturnedVariable(AbstractFrame currentFrame, DetailAST ident) {
         final DetailAST blockFrameNameIdent = currentFrame.getFrameNameIdent();
         final DetailAST definitionToken = blockFrameNameIdent.getParent();
         final DetailAST blockStartToken = definitionToken.findFirstToken(TokenTypes.SLIST);
         final DetailAST blockEndToken = getBlockEndToken(blockFrameNameIdent, blockStartToken);
 
         final Set<DetailAST> returnsInsideBlock = getAllTokensOfType(definitionToken,
             TokenTypes.LITERAL_RETURN, blockEndToken.getLineNo());
 
         boolean returnedVariable = false;
         for (DetailAST returnToken : returnsInsideBlock) {
             returnedVariable = returnToken.findAll(ident).hasMoreNodes();
             if (returnedVariable) {
                 break;
             }
         }
         return returnedVariable;
     }
 
     /**
      * Checks whether a field can be referenced from a static context.
      * @param ident ident token.
      * @return true if field can be referenced from a static context.
      */
     private boolean canBeReferencedFromStaticContext(DetailAST ident) {
         AbstractFrame variableDeclarationFrame = findFrame(ident, false);
         boolean staticInitializationBlock = false;
         while (variableDeclarationFrame.getType() == FrameType.BLOCK_FRAME) {
             final DetailAST blockFrameNameIdent = variableDeclarationFrame.getFrameNameIdent();
             final DetailAST definitionToken = blockFrameNameIdent.getParent();
             if (definitionToken.getType() == TokenTypes.STATIC_INIT) {
                 staticInitializationBlock = true;
                 break;
             }
             variableDeclarationFrame = variableDeclarationFrame.getParent();
         }
 
         boolean staticContext = false;
         if (staticInitializationBlock) {
             staticContext = true;
         }
         else {
             if (variableDeclarationFrame.getType() == FrameType.CLASS_FRAME) {
                 final DetailAST codeBlockDefinition = getCodeBlockDefinitionToken(ident);
                 if (codeBlockDefinition != null) {
                     final DetailAST modifiers = codeBlockDefinition.getFirstChild();
                     staticContext = codeBlockDefinition.getType() == TokenTypes.STATIC_INIT
-                        || modifiers.branchContains(TokenTypes.LITERAL_STATIC);
+                        || modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;
                 }
             }
             else {
                 final DetailAST frameNameIdent = variableDeclarationFrame.getFrameNameIdent();
                 final DetailAST definitionToken = frameNameIdent.getParent();
                 staticContext = definitionToken.branchContains(TokenTypes.LITERAL_STATIC);
             }
         }
         return !staticContext;
     }
 
     /**
      * Returns code block definition token for current identifier.
      * @param ident ident token.
      * @return code block definition token for current identifier or null if code block
      *         definition was not found.
      */
     private static DetailAST getCodeBlockDefinitionToken(DetailAST ident) {
         DetailAST parent = ident.getParent();
         while (parent != null
                && parent.getType() != TokenTypes.METHOD_DEF
                && parent.getType() != TokenTypes.CTOR_DEF
                && parent.getType() != TokenTypes.STATIC_INIT) {
             parent = parent.getParent();
         }
         return parent;
     }
 
     /**
      * Checks whether a value can be assigned to a field.
      * A value can be assigned to a final field only in constructor block. If there is a method
      * block, value assignment can be performed only to non final field.
      * @param ast an identifier token.
      * @return true if a value can be assigned to a field.
      */
     private boolean canAssignValueToClassField(DetailAST ast) {
         final AbstractFrame fieldUsageFrame = findFrame(ast, false);
         final boolean fieldUsageInConstructor = isInsideConstructorFrame(fieldUsageFrame);
 
         final AbstractFrame declarationFrame = findFrame(ast, true);
         final boolean finalField = ((ClassFrame) declarationFrame).hasFinalField(ast);
 
         return fieldUsageInConstructor || !finalField;
     }
 
     /**
      * Checks whether a field usage frame is inside constructor frame.
      * @param frame frame, where field is used.
      * @return true if the field usage frame is inside constructor frame.
      */
@@ -1179,101 +1179,101 @@ public class RequireThisCheck extends AbstractCheck {
             instanceMembers.add(ident);
         }
 
         /**
          * Adds instance method's name.
          * @param ident an ident of instance method of the class.
          */
         public void addInstanceMethod(final DetailAST ident) {
             instanceMethods.add(ident);
         }
 
         /**
          * Checks if a given name is a known instance member of the class.
          * @param ident the IDENT ast of the name to check.
          * @return true is the given name is a name of a known
          *         instance member of the class.
          */
         public boolean hasInstanceMember(final DetailAST ident) {
             return containsFieldOrVariableDef(instanceMembers, ident);
         }
 
         /**
          * Checks if a given name is a known instance method of the class.
          * @param ident the IDENT ast of the method call to check.
          * @return true if the given ast is correspondent to a known
          *         instance method of the class.
          */
         public boolean hasInstanceMethod(final DetailAST ident) {
             return containsMethodDef(instanceMethods, ident);
         }
 
         /**
          * Checks if a given name is a known static method of the class.
          * @param ident the IDENT ast of the method call to check.
          * @return true is the given ast is correspondent to a known
          *         instance method of the class.
          */
         public boolean hasStaticMethod(final DetailAST ident) {
             return containsMethodDef(staticMethods, ident);
         }
 
         /**
          * Checks whether given instance member has final modifier.
          * @param instanceMember an instance member of a class.
          * @return true if given instance member has final modifier.
          */
         public boolean hasFinalField(final DetailAST instanceMember) {
             boolean result = false;
             for (DetailAST member : instanceMembers) {
                 final DetailAST mods = member.getParent().findFirstToken(TokenTypes.MODIFIERS);
-                final boolean finalMod = mods.branchContains(TokenTypes.FINAL);
+                final boolean finalMod = mods.findFirstToken(TokenTypes.FINAL) != null;
                 if (finalMod && member.equals(instanceMember)) {
                     result = true;
                     break;
                 }
             }
             return result;
         }
 
         @Override
         protected boolean containsFieldOrVariable(DetailAST nameToFind) {
             return containsFieldOrVariableDef(instanceMembers, nameToFind)
                     || containsFieldOrVariableDef(staticMembers, nameToFind);
         }
 
         @Override
         protected boolean isProperDefinition(DetailAST ident, DetailAST ast) {
             final String nameToFind = ident.getText();
             return nameToFind.equals(ast.getText());
         }
 
         @Override
         protected AbstractFrame getIfContains(DetailAST nameToFind, boolean lookForMethod) {
             AbstractFrame frame = null;
 
             if (lookForMethod && containsMethod(nameToFind)
                 || containsFieldOrVariable(nameToFind)) {
                 frame = this;
             }
             else if (getParent() != null) {
                 frame = getParent().getIfContains(nameToFind, lookForMethod);
             }
             return frame;
         }
 
         /**
          * Check whether the frame contains a given method.
          * @param methodToFind the AST of the method to find.
          * @return true, if a method with the same name and number of parameters is found.
          */
         private boolean containsMethod(DetailAST methodToFind) {
             return containsMethodDef(instanceMethods, methodToFind)
                 || containsMethodDef(staticMethods, methodToFind);
         }
 
         /**
          * Whether the set contains a method definition with the
          *     same name and number of parameters.
          * @param set the set of definitions.
          * @param ident the specified method call IDENT ast.
          * @return true if the set contains a definition with the
