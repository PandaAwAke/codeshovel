diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
index 080bb735d..3b25204fe 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
@@ -281,153 +281,155 @@ public class EmptyLineSeparatorCheck extends AbstractCheck {
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (hasMultipleLinesBefore(ast)) {
             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());
         }
         if (!allowMultipleEmptyLinesInsideClassMembers) {
             processMultipleLinesInside(ast);
         }
 
         DetailAST nextToken = ast.getNextSibling();
         while (nextToken != null && isComment(nextToken)) {
             nextToken = nextToken.getNextSibling();
         }
         if (nextToken != null) {
             final int astType = ast.getType();
             switch (astType) {
                 case TokenTypes.VARIABLE_DEF:
                     processVariableDef(ast, nextToken);
                     break;
                 case TokenTypes.IMPORT:
                     processImport(ast, nextToken, astType);
                     break;
                 case TokenTypes.PACKAGE_DEF:
                     processPackage(ast, nextToken);
                     break;
                 default:
                     if (nextToken.getType() == TokenTypes.RCURLY) {
                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {
                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());
                         }
                     }
                     else if (!hasEmptyLineAfter(ast)) {
                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,
                             nextToken.getText());
                     }
             }
         }
     }
 
     /**
      * Log violation in case there are multiple empty lines inside constructor,
      * initialization block or method.
      * @param ast the ast to check.
      */
     private void processMultipleLinesInside(DetailAST ast) {
         final int astType = ast.getType();
-        if (isClassMemberBlock(astType)) {
+        if (astType != TokenTypes.CLASS_DEF && isClassMemberBlock(astType)) {
             final List<Integer> emptyLines = getEmptyLines(ast);
             final List<Integer> emptyLinesToLog = getEmptyLinesToLog(emptyLines);
 
             for (Integer lineNo : emptyLinesToLog) {
                 // Checkstyle counts line numbers from 0 but IDE from 1
                 log(lineNo + 1, MSG_MULTIPLE_LINES_INSIDE);
             }
         }
     }
 
     /**
      * Whether the AST is a class member block.
      * @param astType the AST to check.
      * @return true if the AST is a class member block.
      */
     private static boolean isClassMemberBlock(int astType) {
         return astType == TokenTypes.STATIC_INIT
                 || astType == TokenTypes.INSTANCE_INIT
                 || astType == TokenTypes.METHOD_DEF
                 || astType == TokenTypes.CTOR_DEF;
     }
 
     /**
      * Get list of empty lines.
      * @param ast the ast to check.
      * @return list of line numbers for empty lines.
      */
     private List<Integer> getEmptyLines(DetailAST ast) {
         final DetailAST lastToken = ast.getLastChild().getLastChild();
         int lastTokenLineNo = 0;
         if (lastToken != null) {
-            lastTokenLineNo = lastToken.getLineNo();
+            // -1 as count starts from 0
+            // -2 as last token line cannot be empty, because it is a RCURLY
+            lastTokenLineNo = lastToken.getLineNo() - 2;
         }
         final List<Integer> emptyLines = new ArrayList<>();
         final FileContents fileContents = getFileContents();
 
-        for (int lineNo = ast.getLineNo(); lineNo < lastTokenLineNo; lineNo++) {
+        for (int lineNo = ast.getLineNo(); lineNo <= lastTokenLineNo; lineNo++) {
             if (fileContents.lineIsBlank(lineNo)) {
                 emptyLines.add(lineNo);
             }
         }
         return emptyLines;
     }
 
     /**
      * Get list of empty lines to log.
      * @param emptyLines list of empty lines.
      * @return list of empty lines to log.
      */
     private static List<Integer> getEmptyLinesToLog(List<Integer> emptyLines) {
         final List<Integer> emptyLinesToLog = new ArrayList<>();
-        if (emptyLines.size() > 1) {
+        if (emptyLines.size() >= 2) {
             int previousEmptyLineNo = emptyLines.get(0);
             for (int emptyLineNo : emptyLines) {
                 if (previousEmptyLineNo + 1 == emptyLineNo) {
                     emptyLinesToLog.add(emptyLineNo);
                 }
                 previousEmptyLineNo = emptyLineNo;
             }
         }
         return emptyLinesToLog;
     }
 
     /**
      * Whether the token has not allowed multiple empty lines before.
      * @param ast the ast to check.
      * @return true if the token has not allowed multiple empty lines before.
      */
     private boolean hasMultipleLinesBefore(DetailAST ast) {
         boolean result = false;
         if ((ast.getType() != TokenTypes.VARIABLE_DEF
             || isTypeField(ast))
                 && hasNotAllowedTwoEmptyLinesBefore(ast)) {
             result = true;
         }
         return result;
     }
 
     /**
      * Process Package.
      * @param ast token
      * @param nextToken next token
      */
     private void processPackage(DetailAST ast, DetailAST nextToken) {
         if (ast.getLineNo() > 1 && !hasEmptyLineBefore(ast)) {
             if (getFileContents().getFileName().endsWith("package-info.java")) {
                 if (ast.getFirstChild().getChildCount() == 0 && !isPrecededByJavadoc(ast)) {
                     log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());
                 }
             }
             else {
                 log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());
             }
         }
         if (!hasEmptyLineAfter(ast)) {
             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());
         }
     }
 
     /**
      * Process Import.
      * @param ast token
