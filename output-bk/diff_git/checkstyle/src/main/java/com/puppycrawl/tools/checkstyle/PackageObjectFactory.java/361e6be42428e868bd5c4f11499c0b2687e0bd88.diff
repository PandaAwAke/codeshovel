diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
index 644b3e0fb..ab49b2591 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
@@ -223,103 +223,103 @@ public class PackageObjectFactory implements ModuleFactory {
             throws CheckstyleException {
         final Object returnValue;
         if (fullModuleNames.size() == 1) {
             returnValue = createObject(fullModuleNames.iterator().next());
         }
         else {
             final String optionalNames = fullModuleNames.stream()
                     .sorted()
                     .collect(Collectors.joining(STRING_SEPARATOR));
             final LocalizedMessage exceptionMessage = new LocalizedMessage(0,
                     Definitions.CHECKSTYLE_BUNDLE, AMBIGUOUS_MODULE_NAME_EXCEPTION_MESSAGE,
                     new String[] {name, optionalNames}, null, getClass(), null);
             throw new CheckstyleException(exceptionMessage.getMessage());
         }
         return returnValue;
     }
 
     /**
      * Generate the map of third party Checkstyle module names to the set of their fully qualified
      * names.
      * @param loader the class loader used to load Checkstyle package names
      * @return the map of third party Checkstyle module names to the set of their fully qualified
      *      names
      */
     private Map<String, Set<String>> generateThirdPartyNameToFullModuleName(ClassLoader loader) {
         Map<String, Set<String>> returnValue;
         try {
             returnValue = ModuleReflectionUtils.getCheckstyleModules(packages, loader).stream()
                     .collect(Collectors.toMap(
                         Class::getSimpleName,
                         cls -> Collections.singleton(cls.getCanonicalName()),
                         (fullNames1, fullNames2) -> {
                             final Set<String> mergedNames = new LinkedHashSet<>(fullNames1);
                             mergedNames.addAll(fullNames2);
                             return mergedNames;
                         }));
         }
         catch (IOException ignore) {
             returnValue = new HashMap<>();
         }
         return returnValue;
     }
 
     /**
      * Creates a string by joining package names with a class name.
      * @param className name of the class for joining.
      * @param packages packages names.
      * @return a string which is obtained by joining package names with a class name.
      */
     private static String joinPackageNamesWithClassName(String className, Set<String> packages) {
-        return packages.stream()
-            .collect(Collectors.joining(
-                    className + STRING_SEPARATOR, "", PACKAGE_SEPARATOR + className));
+        return packages.stream().collect(
+            Collectors.joining(PACKAGE_SEPARATOR + className + STRING_SEPARATOR, "",
+                    PACKAGE_SEPARATOR + className));
     }
 
     /**
      * Creates a new instance of a named class.
      * @param className the name of the class to instantiate.
      * @return the {@code Object} created by loader or null.
      * @throws CheckstyleException if the class fails to instantiate.
      */
     private Object createObject(String className) throws CheckstyleException {
         Class<?> clazz = null;
 
         try {
             clazz = Class.forName(className, true, moduleClassLoader);
         }
         catch (final ReflectiveOperationException | NoClassDefFoundError ignored) {
             // ignore the exception
         }
 
         Object instance = null;
 
         if (clazz != null) {
             try {
                 final Constructor<?> declaredConstructor = clazz.getDeclaredConstructor();
                 declaredConstructor.setAccessible(true);
                 instance = declaredConstructor.newInstance();
             }
             catch (final ReflectiveOperationException ex) {
                 throw new CheckstyleException("Unable to instantiate " + className, ex);
             }
         }
 
         return instance;
     }
 
     /**
      * Fill short-to-full module names map.
      */
     private static void fillShortToFullModuleNamesMap() {
         fillChecksFromAnnotationPackage();
         fillChecksFromBlocksPackage();
         fillChecksFromCodingPackage();
         fillChecksFromDesignPackage();
         fillChecksFromHeaderPackage();
         fillChecksFromImportsPackage();
         fillChecksFromIndentationPackage();
         fillChecksFromJavadocPackage();
         fillChecksFromMetricsPackage();
         fillChecksFromModifierPackage();
         fillChecksFromNamingPackage();
         fillChecksFromRegexpPackage();
