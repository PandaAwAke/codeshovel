diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 948b35c46..b085bea4a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -505,192 +505,192 @@ public class VisibilityModifierCheck
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName))
             {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * <code>
      * import java.util.*;
      * </code>
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst)
     {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if current variable has proper access modifier according to Check's options.
      * @param variableDef Variable definition node.
      * @param variableName Variable's name.
      * @return true if variable has proper access modifier.
      */
     private boolean hasProperAccessModifier(DetailAST variableDef, String variableName)
     {
         boolean result = true;
 
         final Set<String> mods = getModifiers(variableDef);
         final String variableScope = getVisibilityScope(mods);
 
         if (!"private".equals(variableScope)) {
             final DetailAST classDef = variableDef.getParent().getParent();
             final Set<String> classModifiers = getModifiers(classDef);
 
             result =
-                (mods.contains("static") && mods.contains("final"))
-                || (isPackageAllowed() && "package".equals(variableScope))
-                || (isProtectedAllowed() && "protected".equals(variableScope))
-                || ("public".equals(variableScope)
+                mods.contains("static") && mods.contains("final")
+                || isPackageAllowed() && "package".equals(variableScope)
+                || isProtectedAllowed() && "protected".equals(variableScope)
+                || "public".equals(variableScope)
                    && getPublicMemberRegexp().matcher(variableName).find()
-                   || (allowPublicImmutableFields
-                      && classModifiers.contains("final") && isImmutableField(variableDef)));
+                   || allowPublicImmutableFields
+                      && classModifiers.contains("final") && isImmutableField(variableDef);
         }
 
         return result;
     }
 
     /**
      * Returns the variable name in a VARIABLE_DEF AST.
      * @param variableDefAST an AST where type == VARIABLE_DEF AST.
      * @return the variable name in variableDefAST
      */
     private static DetailAST getVarNameAST(DetailAST variableDefAST)
     {
         DetailAST ast = variableDefAST.getFirstChild();
         DetailAST varNameAst = null;
         while (ast != null) {
             final DetailAST nextSibling = ast.getNextSibling();
             if (ast.getType() == TokenTypes.TYPE) {
                 varNameAst = nextSibling;
                 break;
             }
             ast = nextSibling;
         }
         return varNameAst;
     }
 
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST)
     {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
 
     }
 
     /**
      * Returns the visibility scope specified with a set of modifiers.
      * @param modifiers the set of modifier Strings
      * @return one of "public", "private", "protected", "package"
      */
     private static String getVisibilityScope(Set<String> modifiers)
     {
         String accessModifier = "package";
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
      * Checks if current field is immutable:
      * has final modifier and either a primitive type or instance of class
      * known to be immutable (such as String, ImmutableCollection from Guava and etc).
      * Classes known to be immutable are listed in
      * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
      * @param variableDef Field in consideration.
      * @return true if field is immutable.
      */
     private boolean isImmutableField(DetailAST variableDef)
     {
         boolean result = false;
 
         final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);
         final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
         if (isFinal) {
             final DetailAST type = variableDef.findFirstToken(TokenTypes.TYPE);
             final boolean isCanonicalName = type.getFirstChild().getType() == TokenTypes.DOT;
             final String typeName = getTypeName(type, isCanonicalName);
 
-            result = (!isCanonicalName && isPrimitive(type))
+            result = !isCanonicalName && isPrimitive(type)
                      || immutableClassShortNames.contains(typeName)
-                     || (isCanonicalName && immutableClassCanonicalNames.contains(typeName));
+                     || isCanonicalName && immutableClassCanonicalNames.contains(typeName);
         }
         return result;
     }
 
     /**
      * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
      * If type is specified via its canonical name - canonical name will be returned,
      * else - short type's name.
      * @param type {@link TokenTypes#TYPE TYPE} node.
      * @param isCanonicalName is given name canonical.
      * @return String representation of given type's name.
      */
     private static String getTypeName(DetailAST type, boolean isCanonicalName)
     {
         String typeName = "";
         if (isCanonicalName) {
             typeName = getCanonicalName(type);
         }
         else {
             typeName = type.getFirstChild().getText();
         }
         return typeName;
     }
 
     /**
      * Checks if current type is primitive type (int, short, float, boolean, double, etc.).
      * As primitive types have special tokens for each one, such as:
      * LITERAL_INT, LITERAL_BOOLEAN, etc.
      * So, if type's identifier differs from {@link TokenTypes#IDENT IDENT} token - it's a
      * primitive type.
      * @param type Ast {@link TokenTypes#TYPE TYPE} node.
      * @return true if current type is primitive type.
      */
     private static boolean isPrimitive(DetailAST type)
     {
         return type.getFirstChild().getType() != TokenTypes.IDENT;
     }
 
     /**
      * Gets canonical type's name from given {@link TokenTypes#TYPE TYPE} node.
      * @param type DetailAST {@link TokenTypes#TYPE TYPE} node.
      * @return canonical type's name
      */
     private static String getCanonicalName(DetailAST type)
     {
         final StringBuilder canonicalNameBuilder = new StringBuilder();
         DetailAST toVisit = type.getFirstChild();
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, type);
             if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
