diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
index 3a5ef85df..01a1feb62 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
@@ -49,108 +49,108 @@ public class LineWrappingHandler {
      */
     private final DetailAST firstNode;
 
     /**
      * Last node for current expression.
      */
     private final DetailAST lastNode;
 
     /**
      * User's value of line wrapping indentation.
      */
     private final int indentLevel;
 
     /**
      * Force strict condition in line wrapping case.
      */
     private final boolean forceStrictCondition;
 
     /**
      * Sets values of class field, finds last node and calculates indentation level.
      *
      * @param instance
      *            instance of IndentationCheck.
      * @param firstNode
      *            root node for current expression.
      * @param lastNode
      *            last node for current expression.
      */
     public LineWrappingHandler(IndentationCheck instance, DetailAST firstNode, DetailAST lastNode) {
         indentCheck = instance;
         this.firstNode = firstNode;
         this.lastNode = lastNode;
         indentLevel = indentCheck.getLineWrappingIndentation();
         forceStrictCondition = indentCheck.isForceStrictCondition();
     }
 
     /**
      *  Getter for lastNode field
      *  @return lastNode field
      */
     protected final DetailAST getLastNode() {
         return lastNode;
     }
 
     /**
      * Checks line wrapping into expressions and definitions.
      */
     public void checkIndentation() {
         final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes();
 
-        final DetailAST firstNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());
-        if (firstNode.getType() == TokenTypes.AT) {
-            checkAnnotationIndentation(firstNode, firstNodesOnLines);
+        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());
+        if (firstLineNode.getType() == TokenTypes.AT) {
+            checkAnnotationIndentation(firstLineNode, firstNodesOnLines);
         }
 
         // First node should be removed because it was already checked before.
         firstNodesOnLines.remove(firstNodesOnLines.firstKey());
-        final int firstNodeIndent = getFirstNodeIndent(firstNode);
+        final int firstNodeIndent = getFirstNodeIndent(firstLineNode);
         final int currentIndent = firstNodeIndent + indentLevel;
 
         for (DetailAST node : firstNodesOnLines.values()) {
             final int currentType = node.getType();
 
             if (currentType == TokenTypes.RCURLY
                     || currentType == TokenTypes.RPAREN
                     || currentType == TokenTypes.ARRAY_INIT) {
                 logWarningMessage(node, firstNodeIndent);
             }
             else {
                 logWarningMessage(node, currentIndent);
             }
         }
     }
 
     /**
      * Calculates indentation of first node.
      *
      * @param node
      *            first node.
      * @return indentation of first node.
      */
     private static int getFirstNodeIndent(DetailAST node) {
         int indentLevel = node.getColumnNo();
 
         if (node.getType() == TokenTypes.LITERAL_IF
                 && node.getParent().getType() == TokenTypes.LITERAL_ELSE) {
             final DetailAST lcurly = node.getParent().getPreviousSibling();
             final DetailAST rcurly = lcurly.getLastChild();
 
             if (lcurly.getType() == TokenTypes.SLIST
                     && rcurly.getLineNo() == node.getLineNo()) {
                 indentLevel = rcurly.getColumnNo();
             }
             else {
                 indentLevel = node.getParent().getColumnNo();
             }
         }
         return indentLevel;
     }
 
     /**
      * Finds first nodes on line and puts them into Map.
      *
      * @return NavigableMap which contains lines numbers as a key and first
      *         nodes on lines as a values.
      */
     private NavigableMap<Integer, DetailAST> collectFirstNodes() {
         final NavigableMap<Integer, DetailAST> result = new TreeMap<>();
