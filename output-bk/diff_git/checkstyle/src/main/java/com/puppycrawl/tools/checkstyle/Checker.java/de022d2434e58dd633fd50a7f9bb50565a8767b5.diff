diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
index 6a42b7482..2059978e6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
@@ -149,137 +149,131 @@ public class Checker extends AutomaticBean implements MessageDispatcher {
         filters.clear();
         if (cache != null) {
             try {
                 cache.persist();
             }
             catch (IOException ex) {
                 throw new IllegalStateException("Unable to persist cache file.", ex);
             }
         }
     }
 
     /**
      * Removes a given listener.
      * @param listener a listener to remove
      */
     public void removeListener(AuditListener listener) {
         listeners.remove(listener);
     }
 
     /**
      * Sets base directory.
      * @param basedir the base directory to strip off in file names
      */
     public void setBasedir(String basedir) {
         this.basedir = basedir;
     }
 
     /**
      * Processes a set of files with all FileSetChecks.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param files the list of files to be audited.
      * @return the total number of errors found
      * @throws CheckstyleException if error condition within Checkstyle occurs
      * @see #destroy()
      */
     public int process(List<File> files) throws CheckstyleException {
         if (cache != null) {
             cache.putExternalResources(getExternalResourceLocations());
         }
 
         // Prepare to start
         fireAuditStarted();
         for (final FileSetCheck fsc : fileSetChecks) {
             fsc.beginProcessing(charset);
         }
 
         processFiles(files);
 
         // Finish up
-        for (final FileSetCheck fsc : fileSetChecks) {
-            // It may also log!!!
-            fsc.finishProcessing();
-        }
+        // It may also log!!!
+        fileSetChecks.forEach(FileSetCheck::finishProcessing);
 
-        for (final FileSetCheck fsc : fileSetChecks) {
-            // It may also log!!!
-            fsc.destroy();
-        }
+        // It may also log!!!
+        fileSetChecks.forEach(FileSetCheck::destroy);
 
         final int errorCount = counter.getCount();
         fireAuditFinished();
         return errorCount;
     }
 
     /**
      * Returns a set of external configuration resource locations which are used by all file set
      * checks and filters.
      * @return a set of external configuration resource locations which are used by all file set
      *         checks and filters.
      */
     private Set<String> getExternalResourceLocations() {
         final Set<String> externalResources = Sets.newHashSet();
-        for (FileSetCheck check : fileSetChecks) {
-            if (check instanceof ExternalResourceHolder) {
+        fileSetChecks.stream().filter(check -> check instanceof ExternalResourceHolder)
+            .forEach(check -> {
                 final Set<String> locations =
                     ((ExternalResourceHolder) check).getExternalResourceLocations();
                 externalResources.addAll(locations);
-            }
-        }
-        for (Filter filter : filters.getFilters()) {
-            if (filter instanceof ExternalResourceHolder) {
+            });
+        filters.getFilters().stream().filter(filter -> filter instanceof ExternalResourceHolder)
+            .forEach(filter -> {
                 final Set<String> locations =
                     ((ExternalResourceHolder) filter).getExternalResourceLocations();
                 externalResources.addAll(locations);
-            }
-        }
+            });
         return externalResources;
     }
 
     /** Notify all listeners about the audit start. */
     private void fireAuditStarted() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditStarted(event);
         }
     }
 
     /** Notify all listeners about the audit end. */
     private void fireAuditFinished() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditFinished(event);
         }
     }
 
     /**
      * Processes a list of files with all FileSetChecks.
      * @param files a list of files to process.
      * @throws CheckstyleException if error condition within Checkstyle occurs.
      * @noinspection ProhibitedExceptionThrown
      */
     private void processFiles(List<File> files) throws CheckstyleException {
         for (final File file : files) {
             try {
                 final String fileName = file.getAbsolutePath();
                 final long timestamp = file.lastModified();
                 if (cache != null && cache.isInCache(fileName, timestamp)
                         || !CommonUtils.matchesFileExtension(file, fileExtensions)) {
                     continue;
                 }
                 fireFileStarted(fileName);
                 final SortedSet<LocalizedMessage> fileMessages = processFile(file);
                 fireErrors(fileName, fileMessages);
                 fireFileFinished(fileName);
                 if (cache != null && fileMessages.isEmpty()) {
                     cache.put(fileName, timestamp);
                 }
             }
             catch (Exception ex) {
                 // We need to catch all exceptions to put a reason failure (file name) in exception
                 throw new CheckstyleException("Exception was thrown while processing "
                         + file.getPath(), ex);
             }
             catch (Error error) {
                 // We need to catch all errors to put a reason failure (file name) in error
                 throw new Error("Error was thrown while processing " + file.getPath(), error);
