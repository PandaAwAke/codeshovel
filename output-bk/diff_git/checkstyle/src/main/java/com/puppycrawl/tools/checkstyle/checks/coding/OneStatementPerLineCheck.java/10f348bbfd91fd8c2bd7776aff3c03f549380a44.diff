diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
index d613fefff..c1b991179 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java
@@ -70,101 +70,104 @@ public final class OneStatementPerLineCheck extends Check {
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "multiple.statements.line";
 
     /**
      * Hold the line-number where the last statement ended.
      */
     private int lastStatementEnd = -1;
 
     /**
      * Hold the line-number where the last 'for-loop' statement ended.
      */
     private int forStatementEnd = -1;
 
     /**
      * The for-header usually has 3 statements on one line, but THIS IS OK.
      */
     private boolean inForHeader;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.SEMI, TokenTypes.FOR_INIT,
             TokenTypes.FOR_ITERATOR,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         inForHeader = false;
         lastStatementEnd = -1;
         forStatementEnd = -1;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.SEMI:
                 DetailAST currentStatement = ast;
-                if (isMultilineStatement(currentStatement)) {
+                final boolean hasResourcesPrevSibling =
+                        currentStatement.getPreviousSibling() != null
+                        && currentStatement.getPreviousSibling().getType() == TokenTypes.RESOURCES;
+                if (!hasResourcesPrevSibling && isMultilineStatement(currentStatement)) {
                     currentStatement = ast.getPreviousSibling();
                 }
                 if (isOnTheSameLine(currentStatement, lastStatementEnd,
                         forStatementEnd) && !inForHeader) {
                     log(ast, MSG_KEY);
                 }
                 break;
             case TokenTypes.FOR_ITERATOR:
                 forStatementEnd = ast.getLineNo();
                 break;
             default:
                 inForHeader = true;
                 break;
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.SEMI:
                 lastStatementEnd = ast.getLineNo();
                 forStatementEnd = -1;
                 break;
             case TokenTypes.FOR_ITERATOR:
                 inForHeader = false;
                 break;
             default:
                 break;
         }
     }
 
     /**
      * Checks whether two statements are on the same line.
      * @param ast token for the current statement.
      * @param lastStatementEnd the line-number where the last statement ended.
      * @param forStatementEnd the line-number where the last 'for-loop'
      *                        statement ended.
      * @return true if two statements are on the same line.
      */
     private static boolean isOnTheSameLine(DetailAST ast, int lastStatementEnd,
                                            int forStatementEnd) {
         return lastStatementEnd == ast.getLineNo() && forStatementEnd != ast.getLineNo();
     }
 
     /**
      * Checks whether statement is multiline.
      * @param ast token for the current statement.
      * @return true if one statement is distributed over two or more lines.
      */
     private static boolean isMultilineStatement(DetailAST ast) {
