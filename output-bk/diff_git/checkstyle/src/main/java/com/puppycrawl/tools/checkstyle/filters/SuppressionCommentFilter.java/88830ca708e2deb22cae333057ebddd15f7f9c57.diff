diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
index 523ff5ae2..8373be989 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
@@ -293,198 +293,198 @@ public class SuppressionCommentFilter
 
     /**
      * A Tag holds a suppression comment and its location, and determines
      * whether the suppression turns checkstyle reporting on or off.
      * @author Rick Giles
      */
     public static class Tag
         implements Comparable<Tag> {
         /** The text of the tag. */
         private final String text;
 
         /** The line number of the tag. */
         private final int line;
 
         /** The column number of the tag. */
         private final int column;
 
         /** Determines whether the suppression turns checkstyle reporting on. */
         private final boolean reportingOn;
 
         /** The parsed check regexp, expanded for the text of this tag. */
         private final Pattern tagCheckRegexp;
 
         /** The parsed message regexp, expanded for the text of this tag. */
         private final Pattern tagMessageRegexp;
 
         /**
          * Constructs a tag.
          * @param line the line number.
          * @param column the column number.
          * @param text the text of the suppression.
          * @param reportingOn {@code true} if the tag turns checkstyle reporting.
          * @param filter the {@code SuppressionCommentFilter} with the context
          * @throws ConversionException if unable to parse expanded text.
          */
         public Tag(int line, int column, String text, boolean reportingOn,
                    SuppressionCommentFilter filter) {
             this.line = line;
             this.column = column;
             this.text = text;
             this.reportingOn = reportingOn;
 
             //Expand regexp for check and message
             //Does not intern Patterns with Utils.getPattern()
             String format = "";
             try {
                 if (reportingOn) {
                     format =
                         expandFromComment(text, filter.checkFormat, filter.onRegexp);
                     tagCheckRegexp = Pattern.compile(format);
-                    if (filter.messageFormat != null) {
-                        format =
-                            expandFromComment(text, filter.messageFormat, filter.onRegexp);
-                        tagMessageRegexp = Pattern.compile(format);
+                    if (filter.messageFormat == null) {
+                        tagMessageRegexp = null;
                     }
                     else {
-                        tagMessageRegexp = null;
+                        format =
+                                expandFromComment(text, filter.messageFormat, filter.onRegexp);
+                        tagMessageRegexp = Pattern.compile(format);
                     }
                 }
                 else {
                     format =
                         expandFromComment(text, filter.checkFormat, filter.offRegexp);
                     tagCheckRegexp = Pattern.compile(format);
-                    if (filter.messageFormat != null) {
-                        format =
-                            expandFromComment(
-                                    text,
-                                    filter.messageFormat,
-                                    filter.offRegexp);
-                        tagMessageRegexp = Pattern.compile(format);
+                    if (filter.messageFormat == null) {
+                        tagMessageRegexp = null;
                     }
                     else {
-                        tagMessageRegexp = null;
+                        format =
+                                expandFromComment(
+                                        text,
+                                        filter.messageFormat,
+                                        filter.offRegexp);
+                        tagMessageRegexp = Pattern.compile(format);
                     }
                 }
             }
             catch (final PatternSyntaxException e) {
                 throw new ConversionException(
                     "unable to parse expanded comment " + format,
                     e);
             }
         }
 
         /**
          * @return the line number of the tag in the source file.
          */
         public int getLine() {
             return line;
         }
 
         /**
          * Determines the column number of the tag in the source file.
          * Will be 0 for all lines of multiline comment, except the
          * first line.
          * @return the column number of the tag in the source file.
          */
         public int getColumn() {
             return column;
         }
 
         /**
          * Determines whether the suppression turns checkstyle reporting on or
          * off.
          * @return {@code true}if the suppression turns reporting on.
          */
         public boolean isReportingOn() {
             return reportingOn;
         }
 
         /**
          * Compares the position of this tag in the file
          * with the position of another tag.
          * @param object the tag to compare with this one.
          * @return a negative number if this tag is before the other tag,
          *     0 if they are at the same position, and a positive number if this
          *     tag is after the other tag.
          */
         @Override
         public int compareTo(Tag object) {
             if (line == object.line) {
                 return Integer.compare(column, object.column);
             }
 
             return Integer.compare(line, object.line);
         }
 
         @Override
         public boolean equals(Object other) {
             if (this == other) {
                 return true;
             }
             if (other == null || getClass() != other.getClass()) {
                 return false;
             }
             final Tag tag = (Tag) other;
             return Objects.equals(line, tag.line)
                     && Objects.equals(column, tag.column)
                     && Objects.equals(reportingOn, tag.reportingOn)
                     && Objects.equals(text, tag.text);
         }
 
         @Override
         public int hashCode() {
             return Objects.hash(text, line, column, reportingOn);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param event the {@code AuditEvent} to check.
          * @return true if the source of event matches the text of this tag.
          */
         public boolean isMatch(AuditEvent event) {
             boolean match = false;
             final Matcher tagMatcher = tagCheckRegexp.matcher(event.getSourceName());
             if (tagMatcher.find()) {
-                if (tagMessageRegexp != null) {
-                    final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
-                    match = messageMatcher.find();
+                if (tagMessageRegexp == null) {
+                    match = true;
                 }
                 else {
-                    match = true;
+                    final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
+                    match = messageMatcher.find();
                 }
             }
             return match;
         }
 
         /**
          * Expand based on a matching comment.
          * @param comment the comment.
          * @param stringToExpand the string to expand.
          * @param regexp the parsed expander.
          * @return the expanded string
          */
         private static String expandFromComment(
                 String comment,
                 String stringToExpand,
                 Pattern regexp) {
             final Matcher matcher = regexp.matcher(comment);
             // Match primarily for effect.
             if (!matcher.find()) {
                 return stringToExpand;
             }
             String result = stringToExpand;
             for (int i = 0; i <= matcher.groupCount(); i++) {
                 // $n expands comment match like in Pattern.subst().
                 result = result.replaceAll("\\$" + i, matcher.group(i));
             }
             return result;
         }
 
         @Override
         public final String toString() {
             return "Tag[line=" + line + "; col=" + column
                 + "; on=" + reportingOn + "; text='" + text + "']";
         }
     }
 }
