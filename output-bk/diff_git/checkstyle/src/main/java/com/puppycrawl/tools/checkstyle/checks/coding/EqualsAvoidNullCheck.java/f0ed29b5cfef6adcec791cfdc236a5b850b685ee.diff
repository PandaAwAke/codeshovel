diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
index a7ccf4c4a..955ec1e42 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
@@ -115,182 +115,182 @@ public class EqualsAvoidNullCheck extends AbstractCheck {
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     /**
      * Whether to ignore checking {@code String.equalsIgnoreCase(String)}.
      * @param newValue whether to ignore checking
      *    {@code String.equalsIgnoreCase(String)}.
      */
     public void setIgnoreEqualsIgnoreCase(boolean newValue) {
         ignoreEqualsIgnoreCase = newValue;
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         currentFrame = new FieldFrame(null);
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF:
             case TokenTypes.PARAMETER_DEF:
                 currentFrame.addField(ast);
                 break;
             case TokenTypes.METHOD_CALL:
                 processMethodCall(ast);
                 break;
             case TokenTypes.SLIST:
                 processSlist(ast);
                 break;
             case TokenTypes.LITERAL_NEW:
                 processLiteralNew(ast);
                 break;
             default:
                 processFrame(ast);
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         final int astType = ast.getType();
         if (astType != TokenTypes.VARIABLE_DEF
                 && astType != TokenTypes.PARAMETER_DEF
                 && astType != TokenTypes.METHOD_CALL
                 && astType != TokenTypes.SLIST
                 && astType != TokenTypes.LITERAL_NEW
                 || astType == TokenTypes.LITERAL_NEW
-                    && ast.branchContains(TokenTypes.LCURLY)) {
+                    && ast.findFirstToken(TokenTypes.OBJBLOCK) != null) {
             currentFrame = currentFrame.getParent();
         }
         else if (astType == TokenTypes.SLIST) {
             leaveSlist(ast);
         }
     }
 
     @Override
     public void finishTree(DetailAST ast) {
         traverseFieldFrameTree(currentFrame);
     }
 
     /**
      * Determine whether SLIST begins static or non-static block and add it as
      * a frame in this case.
      * @param ast SLIST ast.
      */
     private void processSlist(DetailAST ast) {
         final int parentType = ast.getParent().getType();
         if (parentType == TokenTypes.SLIST
                 || parentType == TokenTypes.STATIC_INIT
                 || parentType == TokenTypes.INSTANCE_INIT) {
             final FieldFrame frame = new FieldFrame(currentFrame);
             currentFrame.addChild(frame);
             currentFrame = frame;
         }
     }
 
     /**
      * Determine whether SLIST begins static or non-static block.
      * @param ast SLIST ast.
      */
     private void leaveSlist(DetailAST ast) {
         final int parentType = ast.getParent().getType();
         if (parentType == TokenTypes.SLIST
                 || parentType == TokenTypes.STATIC_INIT
                 || parentType == TokenTypes.INSTANCE_INIT) {
             currentFrame = currentFrame.getParent();
         }
     }
 
     /**
      * Process CLASS_DEF, METHOD_DEF, LITERAL_IF, LITERAL_FOR, LITERAL_WHILE, LITERAL_DO,
      * LITERAL_CATCH, LITERAL_TRY, CTOR_DEF, ENUM_DEF, ENUM_CONSTANT_DEF.
      * @param ast processed ast.
      */
     private void processFrame(DetailAST ast) {
         final FieldFrame frame = new FieldFrame(currentFrame);
         final int astType = ast.getType();
         if (astType == TokenTypes.CLASS_DEF
                 || astType == TokenTypes.ENUM_DEF
                 || astType == TokenTypes.ENUM_CONSTANT_DEF) {
             frame.setClassOrEnumOrEnumConstDef(true);
             frame.setFrameName(ast.findFirstToken(TokenTypes.IDENT).getText());
         }
         currentFrame.addChild(frame);
         currentFrame = frame;
     }
 
     /**
      * Add the method call to the current frame if it should be processed.
      * @param methodCall METHOD_CALL ast.
      */
     private void processMethodCall(DetailAST methodCall) {
         final DetailAST dot = methodCall.getFirstChild();
         if (dot.getType() == TokenTypes.DOT) {
             final String methodName = dot.getLastChild().getText();
             if (EQUALS.equals(methodName)
                     || !ignoreEqualsIgnoreCase && "equalsIgnoreCase".equals(methodName)) {
                 currentFrame.addMethodCall(methodCall);
             }
         }
     }
 
     /**
      * Determine whether LITERAL_NEW is an anonymous class definition and add it as
      * a frame in this case.
      * @param ast LITERAL_NEW ast.
      */
     private void processLiteralNew(DetailAST ast) {
-        if (ast.branchContains(TokenTypes.LCURLY)) {
+        if (ast.findFirstToken(TokenTypes.OBJBLOCK) != null) {
             final FieldFrame frame = new FieldFrame(currentFrame);
             currentFrame.addChild(frame);
             currentFrame = frame;
         }
     }
 
     /**
      * Traverse the tree of the field frames to check all equals method calls.
      * @param frame to check method calls in.
      */
     private void traverseFieldFrameTree(FieldFrame frame) {
         for (FieldFrame child: frame.getChildren()) {
             if (!child.getChildren().isEmpty()) {
                 traverseFieldFrameTree(child);
             }
             currentFrame = child;
             child.getMethodCalls().forEach(this::checkMethodCall);
         }
     }
 
     /**
      * Check whether the method call should be violated.
      * @param methodCall method call to check.
      */
     private void checkMethodCall(DetailAST methodCall) {
         DetailAST objCalledOn = methodCall.getFirstChild().getFirstChild();
         if (objCalledOn.getType() == TokenTypes.DOT) {
             objCalledOn = objCalledOn.getLastChild();
         }
         final DetailAST expr = methodCall.findFirstToken(TokenTypes.ELIST).getFirstChild();
         if (isObjectValid(objCalledOn)
                 && containsOneArgument(methodCall)
                 && containsAllSafeTokens(expr)
                 && isCalledOnStringFieldOrVariable(objCalledOn)) {
             final String methodName = methodCall.getFirstChild().getLastChild().getText();
             if (EQUALS.equals(methodName)) {
                 log(methodCall.getLineNo(), methodCall.getColumnNo(),
                     MSG_EQUALS_AVOID_NULL);
             }
             else {
                 log(methodCall.getLineNo(), methodCall.getColumnNo(),
                     MSG_EQUALS_IGNORE_CASE_AVOID_NULL);
             }
         }
     }
 
     /**
      * Check whether the object equals method is called on is not a String literal
      * and not too complex.
      * @param objCalledOn the object equals method is called on ast.
