diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 6893f89b9..8e0bd30ad 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -307,109 +307,109 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
      * @param flag a {@code Boolean} value
      */
     public void setAllowMissingJavadoc(boolean flag) {
         allowMissingJavadoc = flag;
     }
 
     /**
      * Controls whether to ignore errors when there is no javadoc for a
      * property accessor (setter/getter methods). Defaults to false.
      *
      * @param flag a {@code Boolean} value
      */
     public void setAllowMissingPropertyJavadoc(final boolean flag) {
         allowMissingPropertyJavadoc = flag;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     protected final void processAST(DetailAST ast) {
         if ((ast.getType() == TokenTypes.METHOD_DEF || ast.getType() == TokenTypes.CTOR_DEF)
             && getMethodsNumberOfLine(ast) <= minLineCount
             || hasAllowedAnnotations(ast)) {
             return;
         }
         final Scope theScope = calculateScope(ast);
         if (shouldCheck(ast, theScope)) {
             final FileContents contents = getFileContents();
-            final TextBlock cmt = contents.getJavadocBefore(ast.getLineNo());
+            final TextBlock textBlock = contents.getJavadocBefore(ast.getLineNo());
 
-            if (cmt == null) {
+            if (textBlock == null) {
                 if (!isMissingJavadocAllowed(ast)) {
                     log(ast, MSG_JAVADOC_MISSING);
                 }
             }
             else {
-                checkComment(ast, cmt);
+                checkComment(ast, textBlock);
             }
         }
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private boolean hasAllowedAnnotations(DetailAST methodDef) {
         final DetailAST modifiersNode = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         DetailAST annotationNode = modifiersNode.findFirstToken(TokenTypes.ANNOTATION);
         while (annotationNode != null && annotationNode.getType() == TokenTypes.ANNOTATION) {
             DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);
             if (identNode == null) {
                 identNode = annotationNode.findFirstToken(TokenTypes.DOT)
                     .findFirstToken(TokenTypes.IDENT);
             }
             if (allowedAnnotations.contains(identNode.getText())) {
                 return true;
             }
             annotationNode = annotationNode.getNextSibling();
         }
         return false;
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private static int getMethodsNumberOfLine(DetailAST methodDef) {
         int numberOfLines;
         final DetailAST lcurly = methodDef.getLastChild();
         final DetailAST rcurly = lcurly.getLastChild();
 
         if (lcurly.getFirstChild() == rcurly) {
             numberOfLines = 1;
         }
         else {
             numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;
         }
         return numberOfLines;
     }
 
     @Override
     protected final void logLoadError(Token ident) {
         logLoadErrorImpl(ident.getLineNo(), ident.getColumnNo(),
             MSG_CLASS_INFO,
             JavadocTagInfo.THROWS.getText(), ident.getText());
@@ -638,137 +638,137 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                 remIndex = lines.length;
                 final String lFin = multilineCont.group(1);
                 if (!lFin.equals(NEXT_TAG)
                     && !lFin.equals(END_JAVADOC)) {
                     tags.add(new JavadocTag(tagLine, column, param1, param2));
                 }
             }
             remIndex++;
         }
         return tags;
     }
 
     /**
      * Gets multiline Javadoc tags with no arguments.
      * @param noargMultilineStart javadoc tag Matcher
      * @param lines comment text lines
      * @param lineIndex line number that contains the javadoc tag
      * @param tagLine javadoc tag line number in file
      * @return javadoc tags with no arguments
      */
     private static List<JavadocTag> getMultilineNoArgTags(final Matcher noargMultilineStart,
             final String[] lines, final int lineIndex, final int tagLine) {
         final String param1 = noargMultilineStart.group(1);
         final int col = noargMultilineStart.start(1) - 1;
         final List<JavadocTag> tags = new ArrayList<>();
         int remIndex = lineIndex + 1;
         while (remIndex < lines.length) {
             final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                     .matcher(lines[remIndex]);
             multilineCont.find();
             remIndex = lines.length;
             final String lFin = multilineCont.group(1);
             if (!lFin.equals(NEXT_TAG)
                 && !lFin.equals(END_JAVADOC)) {
                 tags.add(new JavadocTag(tagLine, col, param1));
             }
             remIndex++;
         }
 
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private static List<DetailAST> getParameters(DetailAST ast) {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        final List<DetailAST> retVal = Lists.newArrayList();
+        final List<DetailAST> returnValue = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
-                retVal.add(ident);
+                returnValue.add(ident);
             }
             child = child.getNextSibling();
         }
-        return retVal;
+        return returnValue;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
-        final List<ExceptionInfo> retVal = Lists.newArrayList();
+        final List<ExceptionInfo> returnValue = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
                     final FullIdent ident = FullIdent.createFullIdent(child);
                     final ExceptionInfo exceptionInfo = new ExceptionInfo(
                             createClassInfo(new Token(ident), getCurrentClassName()));
-                    retVal.add(exceptionInfo);
+                    returnValue.add(exceptionInfo);
                 }
                 child = child.getNextSibling();
             }
         }
-        return retVal;
+        return returnValue;
     }
 
     /**
      * Checks a set of tags for matching parameters.
      *
      * @param tags the tags to check
      * @param parent the node which takes the parameters
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkParamTags(final List<JavadocTag> tags,
             final DetailAST parent, boolean reportExpectedTags) {
         final List<DetailAST> params = getParameters(parent);
         final List<DetailAST> typeParams = CheckUtils
                 .getTypeParameters(parent);
 
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             final String arg1 = tag.getFirstArg();
             boolean found = removeMatchingParam(params, arg1);
 
             if (CommonUtils.startsWithChar(arg1, '<') && CommonUtils.endsWithChar(arg1, '>')) {
                 found = searchMatchingTypeParameter(typeParams,
                         arg1.substring(1, arg1.length() - 1));
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", arg1);
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingParamTags && reportExpectedTags) {
             for (DetailAST param : params) {
                 log(param, MSG_EXPECTED_TAG,
                     JavadocTagInfo.PARAM.getText(), param.getText());
             }
