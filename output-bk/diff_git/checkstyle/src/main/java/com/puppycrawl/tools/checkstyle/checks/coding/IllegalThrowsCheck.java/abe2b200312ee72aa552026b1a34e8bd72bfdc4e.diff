diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
index 7eeffa8c6..668af8316 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
@@ -37,100 +37,106 @@ import java.util.Set;
  * <p>
  * <b>ignoredMethodNames</b> - names of methods to ignore.
  * </p>
  * <p>
  * <b>ignoreOverridenMethods</b> - ignore checking overriden methods (marked with Override
  *  or java.lang.Override annotation) default value is <b>true</b>.
  * </p>
  *
  * @author Oliver Burn
  * @author John Sirois
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  */
 public final class IllegalThrowsCheck extends AbstractIllegalCheck
 {
 
     /** Default ignored method names. */
     private static final String[] DEFAULT_IGNORED_METHOD_NAMES = {
         "finalize",
     };
 
     /** property for ignoring overriden methods. */
     private boolean ignoreOverridenMethods = true;
 
     /** methods which should be ignored. */
     private final Set<String> ignoredMethodNames = Sets.newHashSet();
 
     /** Creates new instance of the check. */
     public IllegalThrowsCheck()
     {
         super(new String[] {"Error",
                             "RuntimeException", "Throwable",
                             "java.lang.Error",
                             "java.lang.RuntimeException",
                             "java.lang.Throwable",
         });
         setIgnoredMethodNames(DEFAULT_IGNORED_METHOD_NAMES);
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.LITERAL_THROWS};
     }
 
     @Override
     public int[] getRequiredTokens()
     {
         return getDefaultTokens();
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {TokenTypes.LITERAL_THROWS};
+    }
+
     @Override
     public void visitToken(DetailAST detailAST)
     {
         final DetailAST methodDef = detailAST.getParent();
         DetailAST token = detailAST.getFirstChild();
         // Check if the method with the given name should be ignored.
         if (!isIgnorableMethod(methodDef)) {
             while (token != null) {
                 if (token.getType() != TokenTypes.COMMA) {
                     final FullIdent ident = FullIdent.createFullIdent(token);
                     if (isIllegalClassName(ident.getText())) {
                         log(token, "illegal.throw", ident.getText());
                     }
                 }
                 token = token.getNextSibling();
             }
         }
     }
 
     /**
      * Checks if current method is ignorable due to Check's properties.
      * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
      * @return true if method is ignorable.
      */
     private boolean isIgnorableMethod(DetailAST methodDef)
     {
         return shouldIgnoreMethod(methodDef.findFirstToken(TokenTypes.IDENT).getText())
             || ignoreOverridenMethods
                && (AnnotationUtility.containsAnnotation(methodDef, "Override")
                   || AnnotationUtility.containsAnnotation(methodDef, "java.lang.Override"));
     }
 
     /**
      * Check if the method is specified in the ignore method list
      * @param name the name to check
      * @return whether the method with the passed name should be ignored
      */
     private boolean shouldIgnoreMethod(String name)
     {
         return ignoredMethodNames.contains(name);
     }
 
     /**
      * Set the list of ignore method names.
      * @param methodNames array of ignored method names
      */
     public void setIgnoredMethodNames(String[] methodNames)
     {
         ignoredMethodNames.clear();
         for (String element : methodNames) {
