diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
index 05591b0d4..9f94b3b29 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
@@ -229,103 +229,99 @@ public class SuppressWarningsCheck extends AbstractFormatCheck {
      */
     private void logMatch(final int lineNo,
         final int colNum, final String warningText) {
         final Matcher matcher = this.getRegexp().matcher(warningText);
         if (matcher.matches()) {
             this.log(lineNo, colNum,
                     MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED, warningText);
         }
     }
 
     /**
      * Find the parent (holder) of the of the warnings (Expr).
      *
      * @param annotation the annotation
      * @return a Token representing the expr.
      */
     private DetailAST findWarningsHolder(final DetailAST annotation) {
         final DetailAST annValuePair =
             annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
         final DetailAST annArrayInit;
 
         if (annValuePair != null) {
             annArrayInit =
                 annValuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
         else {
             annArrayInit =
                 annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
 
         if (annArrayInit != null) {
             return annArrayInit;
         }
 
         return annotation;
     }
 
     /**
      * Strips a single double quote from the front and back of a string.
      *
      * For example:
      * <br/>
      * Input String = "unchecked"
      * <br/>
      * Output String = unchecked
      *
      * @param warning the warning string
      * @return the string without two quotes
      */
     private String removeQuotes(final String warning) {
-        assert warning != null : "the warning was null";
-        assert warning.charAt(0) == '"';
-        assert warning.charAt(warning.length() - 1) == '"';
-
         return warning.substring(1, warning.length() - 1);
     }
 
     /**
      * Recursively walks a conditional expression checking the left
      * and right sides, checking for matches and
      * logging violations.
      *
      * @param cond a Conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      */
     private void walkConditional(final DetailAST cond) {
         if (cond.getType() != TokenTypes.QUESTION) {
             final String warningText =
                 this.removeQuotes(cond.getText());
             this.logMatch(cond.getLineNo(), cond.getColumnNo(), warningText);
             return;
         }
 
         this.walkConditional(this.getCondLeft(cond));
         this.walkConditional(this.getCondRight(cond));
     }
 
     /**
      * Retrieves the left side of a conditional.
      *
      * @param cond cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      * or another conditional
      */
     private DetailAST getCondLeft(final DetailAST cond) {
         final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getPreviousSibling();
     }
 
     /**
      * Retrieves the right side of a conditional.
      *
      * @param cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      * or another conditional
      */
     private DetailAST getCondRight(final DetailAST cond) {
         final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getNextSibling();
     }
 }
