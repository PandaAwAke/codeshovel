diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
index b15a4d40f..7561b381a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java
@@ -1,75 +1,76 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.whitespace;
 
 import org.apache.commons.lang3.ArrayUtils;
 
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
+import com.puppycrawl.tools.checkstyle.api.FileContents;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Checks for empty line separators after header, package, all import declarations,
  * fields, constructors, methods, nested classes,
  * static initializers and instance initializers.
  *
  * <p> By default the check will check the following statements:
  *  {@link TokenTypes#PACKAGE_DEF PACKAGE_DEF},
  *  {@link TokenTypes#IMPORT IMPORT},
  *  {@link TokenTypes#CLASS_DEF CLASS_DEF},
  *  {@link TokenTypes#INTERFACE_DEF INTERFACE_DEF},
  *  {@link TokenTypes#STATIC_INIT STATIC_INIT},
  *  {@link TokenTypes#INSTANCE_INIT INSTANCE_INIT},
  *  {@link TokenTypes#METHOD_DEF METHOD_DEF},
  *  {@link TokenTypes#CTOR_DEF CTOR_DEF},
  *  {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}.
  * </p>
  *
  * <p>
  * Example of declarations without empty line separator:
  * </p>
  *
  * <pre>
  * ///////////////////////////////////////////////////
  * //HEADER
  * ///////////////////////////////////////////////////
  * package com.puppycrawl.tools.checkstyle.whitespace;
  * import java.io.Serializable;
  * class Foo
  * {
  *     public static final int FOO_CONST = 1;
  *     public void foo() {} //should be separated from previous statement.
  * }
  * </pre>
  *
  * <p> An example of how to configure the check with default parameters is:
  * </p>
  *
  * <pre>
  * &lt;module name="EmptyLineSeparator"/&gt;
  * </pre>
  *
  * <p>
  * Example of declarations with empty line separator
  * that is expected by the Check by default:
  * </p>
  *
  * <pre>
  * ///////////////////////////////////////////////////
@@ -282,83 +283,111 @@ public class EmptyLineSeparatorCheck extends Check {
         if (isTypeField(ast) && hasNotAllowedTwoEmptyLinesBefore(ast)) {
             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());
         }
     }
 
     /**
      * Checks whether token placement violates policy of empty line between fields.
      * @param detailAST token to be analyzed
      * @return true if policy is violated and warning should be raised; false otherwise
      */
     private boolean isViolatingEmptyLineBetweenFieldsPolicy(DetailAST detailAST) {
         return allowNoEmptyLineBetweenFields
                     && detailAST.getType() != TokenTypes.VARIABLE_DEF
                     && detailAST.getType() != TokenTypes.RCURLY
                 || !allowNoEmptyLineBetweenFields
                     && detailAST.getType() != TokenTypes.RCURLY;
     }
 
     /**
      * Checks if a token has empty two previous lines and multiple empty lines is not allowed.
      * @param token DetailAST token
      * @return true, if token has empty two lines before and allowMultipleEmptyLines is false
      */
     private boolean hasNotAllowedTwoEmptyLinesBefore(DetailAST token) {
         return !allowMultipleEmptyLines && hasEmptyLineBefore(token)
                 && isPrePreviousLineEmpty(token);
     }
 
     /**
      * Checks if a token has empty pre-previous line.
      * @param token DetailAST token.
      * @return true, if token has empty lines before.
      */
     private boolean isPrePreviousLineEmpty(DetailAST token) {
         boolean result = false;
         final int lineNo = token.getLineNo();
         // 3 is the number of the pre-previous line because the numbering starts from zero.
         final int number = 3;
         if (lineNo >= number) {
             final String prePreviousLine = getLines()[lineNo - number];
             result = prePreviousLine.trim().isEmpty();
         }
         return result;
     }
 
     /**
      * Checks if token have empty line after.
      * @param token token.
      * @return true if token have empty line after.
      */
-    private static boolean hasEmptyLineAfter(DetailAST token) {
+    private boolean hasEmptyLineAfter(DetailAST token) {
         DetailAST lastToken = token.getLastChild().getLastChild();
         if (lastToken == null) {
             lastToken = token.getLastChild();
         }
-        return token.getNextSibling().getLineNo() - lastToken.getLineNo() > 1;
+        // Start of the next token
+        final int nextBegin = token.getNextSibling().getLineNo();
+        // End of current token.
+        final int currentEnd = lastToken.getLineNo();
+        return hasEmptyLine(currentEnd + 1, nextBegin - 1);
+    }
+
+    /**
+     * Checks, whether there are empty lines within the specified line range. Line numbering is
+     * started from 1 for parameter values
+     * @param startLine number of the first line in the range
+     * @param endLine number of the second line in the range
+     * @return <code>true</code> if found any blank line within the range, <code>false</code>
+     *         otherwise
+     */
+    private boolean hasEmptyLine(int startLine, int endLine) {
+        // Initial value is false - blank line not found
+        boolean result = false;
+        if (startLine <= endLine) {
+            final FileContents fileContents = getFileContents();
+            for (int line = startLine; line <= endLine; line++) {
+                // Check, if the line is blank. Lines are numbered from 0, so subtract 1
+                if (fileContents.lineIsBlank(line - 1)) {
+                    result = true;
+                    break;
+                }
+            }
+        }
+        return result;
     }
 
     /**
      * Checks if a token has a empty line before.
      * @param token token.
      * @return true, if token have empty line before.
      */
     private boolean hasEmptyLineBefore(DetailAST token) {
         final int lineNo = token.getLineNo();
         if (lineNo == 1) {
             return false;
         }
         //  [lineNo - 2] is the number of the previous line because the numbering starts from zero.
         final String lineBefore = getLines()[lineNo - 2];
         return lineBefore.trim().isEmpty();
     }
 
     /**
      * If variable definition is a type field.
      * @param variableDef variable definition.
      * @return true variable definition is a type field.
      */
     private static boolean isTypeField(DetailAST variableDef) {
         final int parentType = variableDef.getParent().getParent().getType();
         return parentType == TokenTypes.CLASS_DEF;
     }
 }
