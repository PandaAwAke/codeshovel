diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index aa0621f51..59cc35aca 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -124,105 +124,103 @@ public class IllegalInstantiationCheck
 
     @Override
     public void visitToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.LITERAL_NEW:
                 processLiteralNew(ast);
                 break;
             case TokenTypes.PACKAGE_DEF:
                 processPackageDef(ast);
                 break;
             case TokenTypes.IMPORT:
                 processImport(ast);
                 break;
             case TokenTypes.CLASS_DEF:
                 processClassDef(ast);
                 break;
             default:
                 throw new IllegalArgumentException("Unknown type " + ast);
         }
     }
 
     @Override
     public void finishTree(DetailAST rootAST)
     {
         for (DetailAST literalNewAST : instantiations) {
             postprocessLiteralNew(literalNewAST);
         }
     }
 
     /**
      * Collects classes defined in the source file. Required
      * to avoid false alarms for local vs. java.lang classes.
      *
      * @param ast the classdef token.
      */
     private void processClassDef(DetailAST ast)
     {
         final DetailAST identToken = ast.findFirstToken(TokenTypes.IDENT);
         final String className = identToken.getText();
         classNames.add(className);
     }
 
     /**
      * Perform processing for an import token
      * @param ast the import token
      */
     private void processImport(DetailAST ast)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
-        if (name != null) {
-            // Note: different from UnusedImportsCheck.processImport(),
-            // '.*' imports are also added here
-            imports.add(name);
-        }
+        // Note: different from UnusedImportsCheck.processImport(),
+        // '.*' imports are also added here
+        imports.add(name);
     }
 
     /**
      * Perform processing for an package token
      * @param ast the package token
      */
     private void processPackageDef(DetailAST ast)
     {
         final DetailAST packageNameAST = ast.getLastChild()
                 .getPreviousSibling();
         final FullIdent packageIdent =
                 FullIdent.createFullIdent(packageNameAST);
         pkgName = packageIdent.getText();
     }
 
     /**
      * Collects a "new" token.
      * @param ast the "new" token
      */
     private void processLiteralNew(DetailAST ast)
     {
         if (ast.getParent().getType() == TokenTypes.METHOD_REF) {
             return;
         }
         instantiations.add(ast);
     }
 
     /**
      * Processes one of the collected "new" tokens when treewalking
      * has finished.
      * @param ast the "new" token.
      */
     private void postprocessLiteralNew(DetailAST ast)
     {
         final DetailAST typeNameAST = ast.getFirstChild();
         final AST nameSibling = typeNameAST.getNextSibling();
         if (nameSibling != null
                 && nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR)
         {
             // ast == "new Boolean[]"
             return;
         }
 
         final FullIdent typeIdent = FullIdent.createFullIdent(typeNameAST);
         final String typeName = typeIdent.getText();
         final int lineNo = ast.getLineNo();
         final int colNo = ast.getColumnNo();
         final String fqClassName = getIllegalInstantiation(typeName);
         if (fqClassName != null) {
             log(lineNo, colNo, MSG_KEY, fqClassName);
