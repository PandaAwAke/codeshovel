diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 5a10e95fa..79c8bbf11 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -143,103 +143,103 @@ public class DeclarationOrderCheck extends Check
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         final int parentType = ast.getParent().getType();
         ScopeState state;
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
 
             case TokenTypes.CTOR_DEF:
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
                 state = scopeStates.peek();
                 if (state.scopeState > STATE_CTOR_DEF) {
                     if (!ignoreConstructors) {
                         log(ast, MSG_CONSTRUCTOR);
                     }
                 }
                 else {
                     state.scopeState = STATE_CTOR_DEF;
                 }
                 break;
 
             case TokenTypes.METHOD_DEF:
                 state = scopeStates.peek();
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
                 if (state.scopeState > STATE_METHOD_DEF) {
                     if (!ignoreMethods) {
                         log(ast, MSG_METHOD);
                     }
                 }
                 else {
                     state.scopeState = STATE_METHOD_DEF;
                 }
                 break;
 
             case TokenTypes.MODIFIERS:
-                if ((parentType != TokenTypes.VARIABLE_DEF)
-                    || (ast.getParent().getParent().getType()
-                        != TokenTypes.OBJBLOCK))
+                if (parentType != TokenTypes.VARIABLE_DEF
+                    || ast.getParent().getParent().getType()
+                        != TokenTypes.OBJBLOCK)
                 {
                     return;
                 }
 
                 state = scopeStates.peek();
                 if (ast.findFirstToken(TokenTypes.LITERAL_STATIC) != null) {
                     if (state.scopeState > STATE_STATIC_VARIABLE_DEF) {
                         if (!ignoreModifiers
                             || state.scopeState > STATE_INSTANCE_VARIABLE_DEF)
                         {
                             log(ast, MSG_STATIC);
                         }
                     }
                     else {
                         state.scopeState = STATE_STATIC_VARIABLE_DEF;
                     }
                 }
                 else {
                     if (state.scopeState > STATE_INSTANCE_VARIABLE_DEF) {
                         log(ast, MSG_INSTANCE);
                     }
                     else if (state.scopeState == STATE_STATIC_VARIABLE_DEF) {
                         state.declarationAccess = Scope.PUBLIC;
                         state.scopeState = STATE_INSTANCE_VARIABLE_DEF;
                     }
                 }
 
                 final Scope access = ScopeUtils.getScopeFromMods(ast);
                 if (state.declarationAccess.compareTo(access) > 0) {
                     if (!ignoreModifiers) {
                         log(ast, MSG_ACCESS);
                     }
                 }
                 else {
                     state.declarationAccess = access;
                 }
                 break;
 
             default:
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.pop();
                 break;
 
