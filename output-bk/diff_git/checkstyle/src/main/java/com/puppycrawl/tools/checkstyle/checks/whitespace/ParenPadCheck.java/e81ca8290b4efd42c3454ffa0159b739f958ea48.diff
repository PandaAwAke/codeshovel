diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
index b14635f90..e39bb7b9a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
@@ -111,107 +111,107 @@ public class ParenPadCheck extends AbstractParenPadCheck {
     @Override
     public int[] getRequiredTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_CALL:
                 processLeft(ast);
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
                 processExpression(ast);
                 break;
             case TokenTypes.EXPR:
             case TokenTypes.QUESTION:
                 processExpression(ast);
                 break;
             case TokenTypes.LITERAL_FOR:
                 visitLiteralFor(ast);
                 break;
             case TokenTypes.ANNOTATION:
             case TokenTypes.ENUM_CONSTANT_DEF:
             case TokenTypes.LITERAL_NEW:
             case TokenTypes.LITERAL_SYNCHRONIZED:
                 visitNewEnumConstDefAnnotationSync(ast);
                 break;
             default:
                 processLeft(ast.findFirstToken(TokenTypes.LPAREN));
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#ENUM_CONSTANT_DEF}, {@link TokenTypes#ANNOTATION}
      * {@link TokenTypes#LITERAL_SYNCHRONIZED} and {@link TokenTypes#LITERAL_NEW}.
      * @param ast the token to check.
      */
     private void visitNewEnumConstDefAnnotationSync(DetailAST ast) {
         final DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
         if (parenAst != null) {
             processLeft(parenAst);
             processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#LITERAL_FOR}.
      * @param ast the token to check.
      */
     private void visitLiteralFor(DetailAST ast) {
-        DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
-        if (!isPrecedingEmptyForInit(parenAst)) {
-            processLeft(parenAst);
+        final DetailAST lparen = ast.findFirstToken(TokenTypes.LPAREN);
+        if (!isPrecedingEmptyForInit(lparen)) {
+            processLeft(lparen);
         }
-        parenAst = ast.findFirstToken(TokenTypes.RPAREN);
-        if (!isFollowsEmptyForIterator(parenAst)) {
-            processRight(parenAst);
+        final DetailAST rparen = ast.findFirstToken(TokenTypes.RPAREN);
+        if (!isFollowsEmptyForIterator(rparen)) {
+            processRight(rparen);
         }
     }
 
     /**
      * Checks parens inside {@link TokenTypes#EXPR}, {@link TokenTypes#QUESTION}
      * and {@link TokenTypes#METHOD_CALL}.
      * @param ast the token to check.
      */
     private void processExpression(DetailAST ast) {
         if (ast.branchContains(TokenTypes.LPAREN)) {
             DetailAST childAst = ast.getFirstChild();
             while (childAst != null) {
                 if (childAst.getType() == TokenTypes.LPAREN) {
                     processLeft(childAst);
                     processExpression(childAst);
                 }
                 else if (childAst.getType() == TokenTypes.RPAREN && !isInTypecast(childAst)) {
                     processRight(childAst);
                 }
                 else if (!isAcceptableToken(childAst)) {
                     //Traverse all subtree tokens which will never be configured
                     //to be launched in visitToken()
                     processExpression(childAst);
                 }
                 childAst = childAst.getNextSibling();
             }
         }
     }
 
     /**
      * Checks whether AcceptableTokens contains the given ast.
      * @param ast the token to check.
      * @return true if the ast is in AcceptableTokens.
      */
     private boolean isAcceptableToken(DetailAST ast) {
         boolean result = false;
         if (Arrays.binarySearch(acceptableTokens, ast.getType()) >= 0) {
             result = true;
         }
         return result;
     }
 
     /**
      * @return acceptableTokens.
      */
     private static int[] makeAcceptableTokens() {
         return new int[] {TokenTypes.ANNOTATION,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.CTOR_CALL,
             TokenTypes.CTOR_DEF,
