diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 5be87ca4f..a65710898 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -454,105 +454,102 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
         return false;
     }
 
     /**
      * Whether we should check this node.
      *
      * @param ast a given node.
      * @param nodeScope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST ast, final Scope nodeScope) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(ast);
 
         return (excludeScope == null
                 || nodeScope != excludeScope
                 && surroundingScope != excludeScope)
             && nodeScope.isIn(scope)
             && surroundingScope.isIn(scope);
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param ast the token for the method
      * @param comment the Javadoc comment
      */
     private void checkComment(DetailAST ast, TextBlock comment) {
         final List<JavadocTag> tags = getMethodTags(comment);
 
         if (!hasShortCircuitTag(ast, tags)) {
             final Iterator<JavadocTag> it = tags.iterator();
             if (ast.getType() == TokenTypes.ANNOTATION_FIELD_DEF) {
                 checkReturnTag(tags, ast.getLineNo(), true);
             }
             else {
                 // Check for inheritDoc
                 boolean hasInheritDocTag = false;
                 while (!hasInheritDocTag && it.hasNext()) {
                     hasInheritDocTag = it.next().isInheritDocTag();
                 }
                 final boolean reportExpectedTags = !hasInheritDocTag && !hasAllowedAnnotations(ast);
 
                 checkParamTags(tags, ast, reportExpectedTags);
                 checkThrowsTags(tags, getThrows(ast), reportExpectedTags);
                 if (CheckUtils.isNonVoidMethod(ast)) {
                     checkReturnTag(tags, ast.getLineNo(), reportExpectedTags);
                 }
             }
 
             // Dump out all unused tags
-            for (JavadocTag javadocTag : tags) {
-                if (!javadocTag.isSeeOrInheritDocTag()) {
-                    log(javadocTag.getLineNo(), MSG_UNUSED_TAG_GENERAL);
-                }
-            }
+            tags.stream().filter(javadocTag -> !javadocTag.isSeeOrInheritDocTag())
+                .forEach(javadocTag -> log(javadocTag.getLineNo(), MSG_UNUSED_TAG_GENERAL));
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param ast the construct being checked
      * @param tags the list of Javadoc tags associated with the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST ast,
             final List<JavadocTag> tags) {
         // Check if it contains {@inheritDoc} tag
         if (tags.size() != 1
                 || !tags.get(0).isInheritDocTag()) {
             return false;
         }
 
         // Invalid if private, a constructor, or a static method
         if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
             log(ast, MSG_INVALID_INHERIT_DOC);
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private static Scope calculateScope(final DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
 
         if (ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
             return Scope.PUBLIC;
         }
         else {
             return declaredScope;
         }
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
@@ -867,108 +864,107 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getFirstArg();
             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag
                     .getColumnNo());
             final AbstractClassInfo documentedClassInfo = createClassInfo(token,
                     getCurrentClassName());
             final boolean found = foundThrows.contains(documentedEx)
                     || isInThrows(throwsList, documentedClassInfo, foundThrows);
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedClassInfo.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());
 
                 }
             }
         }
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
-            for (ExceptionInfo exceptionInfo : throwsList) {
-                if (!exceptionInfo.isFound()) {
+            throwsList.stream().filter(exceptionInfo -> !exceptionInfo.isFound())
+                .forEach(exceptionInfo -> {
                     final Token token = exceptionInfo.getName();
                     log(token.getLineNo(), token.getColumnNo(),
-                            MSG_EXPECTED_TAG,
-                            JavadocTagInfo.THROWS.getText(), token.getText());
-                }
-            }
+                        MSG_EXPECTED_TAG,
+                        JavadocTagInfo.THROWS.getText(), token.getText());
+                });
         }
     }
 
     /**
      * Verifies that documented exception is in throws.
      *
      * @param throwsList list of throws
      * @param documentedClassInfo documented exception class info
      * @param foundThrows previously found throws
      * @return true if documented exception is in throws.
      */
     private boolean isInThrows(List<ExceptionInfo> throwsList,
             AbstractClassInfo documentedClassInfo, Set<String> foundThrows) {
         boolean found = false;
         ExceptionInfo foundException = null;
 
         // First look for matches on the exception name
         final ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();
         while (!found && throwIt.hasNext()) {
             final ExceptionInfo exceptionInfo = throwIt.next();
 
             if (exceptionInfo.getName().getText().equals(
                     documentedClassInfo.getName().getText())) {
                 found = true;
                 foundException = exceptionInfo;
             }
         }
 
         // Now match on the exception type
         final ListIterator<ExceptionInfo> exceptionInfoIt = throwsList.listIterator();
         while (!found && exceptionInfoIt.hasNext()) {
             final ExceptionInfo exceptionInfo = exceptionInfoIt.next();
 
             if (documentedClassInfo.getClazz() == exceptionInfo.getClazz()) {
                 found = true;
                 foundException = exceptionInfo;
             }
             else if (allowThrowsTagsForSubclasses) {
                 found = isSubclass(documentedClassInfo.getClazz(), exceptionInfo.getClazz());
             }
         }
 
         if (foundException != null) {
             foundException.setFound();
             foundThrows.add(documentedClassInfo.getName().getText());
         }
 
         return found;
     }
 
