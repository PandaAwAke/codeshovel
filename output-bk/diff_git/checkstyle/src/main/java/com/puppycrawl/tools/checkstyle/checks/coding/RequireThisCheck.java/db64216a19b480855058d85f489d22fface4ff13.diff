diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 674849cb8..8f0aea440 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -390,154 +390,146 @@ public class RequireThisCheck extends AbstractCheck {
                 ((ClassFrame) frame).addInstanceMember(ident);
             }
         }
         else {
             frame.addIdent(ident);
         }
     }
 
     /**
      * Ends parsing of the AST for declarations.
      * @param frameStack Stack containing the FrameTree being built.
      * @param ast AST that was parsed.
      */
     private void endCollectingDeclarations(Queue<AbstractFrame> frameStack, DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
                 frames.put(ast, frameStack.poll());
                 break;
             case TokenTypes.LITERAL_NEW :
                 if (isAnonymousClassDef(ast)) {
                     frames.put(ast, frameStack.poll());
                 }
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Whether the AST is a definition of an anonymous class.
      * @param ast the AST to process.
      * @return true if the AST is a definition of an anonymous class.
      */
     private static boolean isAnonymousClassDef(DetailAST ast) {
         final DetailAST lastChild = ast.getLastChild();
         return lastChild != null
             && lastChild.getType() == TokenTypes.OBJBLOCK;
     }
 
     /**
      * Returns the class frame where violation is found (where the field is used without 'this')
      * or null otherwise.
      * @param ast IDENT ast to check.
      * @return the class frame where violation is found or null otherwise.
+     * @noinspection IfStatementWithIdenticalBranches
      */
     // -@cs[CyclomaticComplexity] Method already invokes too many methods that fully explain
     // a logic, additional abstraction will not make logic/algorithm more readable.
     private AbstractFrame getClassFrameWhereViolationIsFound(DetailAST ast) {
         AbstractFrame frameWhereViolationIsFound = null;
         final AbstractFrame variableDeclarationFrame = findFrame(ast, false);
         final FrameType variableDeclarationFrameType = variableDeclarationFrame.getType();
         final DetailAST prevSibling = ast.getPreviousSibling();
         if (variableDeclarationFrameType == FrameType.CLASS_FRAME
                 && !validateOnlyOverlapping
                 && prevSibling == null
                 && canBeReferencedFromStaticContext(ast)) {
             frameWhereViolationIsFound = variableDeclarationFrame;
         }
         else if (variableDeclarationFrameType == FrameType.METHOD_FRAME) {
             if (isOverlappingByArgument(ast)) {
                 if (!isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
                         && !isReturnedVariable(variableDeclarationFrame, ast)
                         && canBeReferencedFromStaticContext(ast)
                         && canAssignValueToClassField(ast)) {
                     frameWhereViolationIsFound = findFrame(ast, true);
                 }
             }
             else if (!validateOnlyOverlapping
                      && prevSibling == null
                      && isAssignToken(ast.getParent().getType())
                      && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
                      && canBeReferencedFromStaticContext(ast)
                      && canAssignValueToClassField(ast)) {
                 frameWhereViolationIsFound = findFrame(ast, true);
 
             }
         }
         else if (variableDeclarationFrameType == FrameType.CTOR_FRAME
                  && isOverlappingByArgument(ast)
                  && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)) {
             frameWhereViolationIsFound = findFrame(ast, true);
         }
-        else if (variableDeclarationFrameType == FrameType.BLOCK_FRAME) {
-            if (isOverlappingByLocalVariable(ast)) {
-                if (canAssignValueToClassField(ast)
-                        && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
-                        && !isReturnedVariable(variableDeclarationFrame, ast)
-                        && canBeReferencedFromStaticContext(ast)) {
-                    frameWhereViolationIsFound = findFrame(ast, true);
-                }
-            }
-            else if (!validateOnlyOverlapping
-                     && prevSibling == null
-                     && isAssignToken(ast.getParent().getType())
-                     && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
-                     && canBeReferencedFromStaticContext(ast)) {
-                frameWhereViolationIsFound = findFrame(ast, true);
-            }
+        else if (variableDeclarationFrameType == FrameType.BLOCK_FRAME
+                    && isOverlappingByLocalVariable(ast)
+                    && canAssignValueToClassField(ast)
+                    && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
+                    && !isReturnedVariable(variableDeclarationFrame, ast)
+                    && canBeReferencedFromStaticContext(ast)) {
+            frameWhereViolationIsFound = findFrame(ast, true);
         }
         return frameWhereViolationIsFound;
     }
 
     /**
      * Checks whether user arranges 'this' for variable in method, constructor, or block on his own.
      * @param currentFrame current frame.
      * @param ident ident token.
      * @return true if user arranges 'this' for variable in method, constructor,
      *         or block on his own.
      */
     private static boolean isUserDefinedArrangementOfThis(AbstractFrame currentFrame,
                                                           DetailAST ident) {
         final DetailAST blockFrameNameIdent = currentFrame.getFrameNameIdent();
         final DetailAST definitionToken = blockFrameNameIdent.getParent();
         final DetailAST blockStartToken = definitionToken.findFirstToken(TokenTypes.SLIST);
         final DetailAST blockEndToken = getBlockEndToken(blockFrameNameIdent, blockStartToken);
 
         boolean userDefinedArrangementOfThis = false;
 
         final Set<DetailAST> variableUsagesInsideBlock =
             getAllTokensWhichAreEqualToCurrent(definitionToken, ident,
                 blockEndToken.getLineNo());
 
         for (DetailAST variableUsage : variableUsagesInsideBlock) {
             final DetailAST prevSibling = variableUsage.getPreviousSibling();
             if (prevSibling != null
                     && prevSibling.getType() == TokenTypes.LITERAL_THIS) {
                 userDefinedArrangementOfThis = true;
                 break;
             }
         }
         return userDefinedArrangementOfThis;
     }
 
     /**
      * Returns the token which ends the code block.
      * @param blockNameIdent block name identifier.
      * @param blockStartToken token which starts the block.
      * @return the token which ends the code block.
      */
     private static DetailAST getBlockEndToken(DetailAST blockNameIdent, DetailAST blockStartToken) {
         final Set<DetailAST> rcurlyTokens = getAllTokensOfType(blockNameIdent, TokenTypes.RCURLY);
         DetailAST blockEndToken = null;
         for (DetailAST currentRcurly : rcurlyTokens) {
             final DetailAST parent = currentRcurly.getParent();
             if (blockStartToken.getLineNo() == parent.getLineNo()) {
                 blockEndToken = currentRcurly;
             }
         }
