diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
index 05d5af998..fbc47a53a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java
@@ -1,158 +1,165 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.whitespace;
 
 import java.util.Arrays;
 
+import org.apache.commons.lang3.ArrayUtils;
+
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * <p>Checks the padding of parentheses; that is whether a space is required
  * after a left parenthesis and before a right parenthesis, or such spaces are
  * forbidden, with the exception that it does
  * not check for padding of the right parenthesis at an empty for iterator and
  * empty for initializer.
  * Use Check {@link EmptyForIteratorPadCheck EmptyForIteratorPad} to validate
  * empty for iterators and {@link EmptyForInitializerPadCheck EmptyForInitializerPad}
  * to validate empty for initializers. Typecasts are also not checked, as there is
  * {@link TypecastParenPadCheck TypecastParenPad} to validate them.
  * </p>
  * <p>
  * The policy to verify is specified using the {@link PadOption} class and
  * defaults to {@link PadOption#NOSPACE}.
  * </p>
  * <p> By default the check will check parentheses that occur with the following
  * tokens:
  *  {@link TokenTypes#ANNOTATION ANNOTATION},
  *  {@link TokenTypes#ANNOTATION_FIELD_DEF ANNOTATION_FIELD_DEF},
  *  {@link TokenTypes#CTOR_DEF CTOR_DEF},
  *  {@link TokenTypes#CTOR_CALL CTOR_CALL},
  *  {@link TokenTypes#ENUM_CONSTANT_DEF ENUM_CONSTANT_DEF},
  *  {@link TokenTypes#EXPR EXPR},
  *  {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH},
  *  {@link TokenTypes#LITERAL_DO LITERAL_DO},
  *  {@link TokenTypes#LITERAL_FOR LITERAL_FOR},
  *  {@link TokenTypes#LITERAL_IF LITERAL_IF},
  *  {@link TokenTypes#LITERAL_NEW LITERAL_NEW},
  *  {@link TokenTypes#LITERAL_SWITCH LITERAL_SWITCH},
  *  {@link TokenTypes#LITERAL_SYNCHRONIZED LITERAL_SYNCHRONIZED},
  *  {@link TokenTypes#LITERAL_WHILE LITERAL_WHILE},
  *  {@link TokenTypes#METHOD_CALL METHOD_CALL},
  *  {@link TokenTypes#METHOD_DEF METHOD_DEF},
  *  {@link TokenTypes#RESOURCE_SPECIFICATION RESOURCE_SPECIFICATION},
  *  {@link TokenTypes#SUPER_CTOR_CALL SUPER_CTOR_CALL},
  *  {@link TokenTypes#QUESTION QUESTION},
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="ParenPad"/&gt;
  * </pre>
  * <p>
  * An example of how to configure the check to require spaces for the
  * parentheses of constructor, method, and super constructor invocations is:
  * </p>
  * <pre>
  * &lt;module name="ParenPad"&gt;
  *     &lt;property name="tokens"
  *               value="CTOR_CALL, METHOD_CALL, SUPER_CTOR_CALL"/&gt;
  *     &lt;property name="option" value="space"/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Oliver Burn
  * @author Vladislav Lisetskiy
  */
 public class ParenPadCheck extends AbstractParenPadCheck {
 
     /**
      * The array of Acceptable Tokens.
      */
     private final int[] acceptableTokens;
 
     /**
      * Initializes and sorts acceptableTokens to make binary search over it possible.
      */
     public ParenPadCheck() {
         acceptableTokens = makeAcceptableTokens();
         Arrays.sort(acceptableTokens);
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return makeAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return makeAcceptableTokens();
     }
 
+    @Override
+    public int[] getRequiredTokens() {
+        return ArrayUtils.EMPTY_INT_ARRAY;
+    }
+
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.METHOD_CALL:
                 processLeft(ast);
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
                 processExpression(ast);
                 break;
             case TokenTypes.EXPR:
             case TokenTypes.QUESTION:
                 processExpression(ast);
                 break;
             case TokenTypes.LITERAL_FOR:
                 visitLiteralFor(ast);
                 break;
             case TokenTypes.ANNOTATION:
             case TokenTypes.ENUM_CONSTANT_DEF:
             case TokenTypes.LITERAL_NEW:
             case TokenTypes.LITERAL_SYNCHRONIZED:
                 visitNewEnumConstDefAnnotationSync(ast);
                 break;
             default:
                 processLeft(ast.findFirstToken(TokenTypes.LPAREN));
                 processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#ENUM_CONSTANT_DEF}, {@link TokenTypes#ANNOTATION}
      * {@link TokenTypes#LITERAL_SYNCHRONIZED} and {@link TokenTypes#LITERAL_NEW}.
      * @param ast the token to check.
      */
     private void visitNewEnumConstDefAnnotationSync(DetailAST ast) {
         final DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
         if (parenAst != null) {
             processLeft(parenAst);
             processRight(ast.findFirstToken(TokenTypes.RPAREN));
         }
     }
 
     /**
      * Checks parens in {@link TokenTypes#LITERAL_FOR}.
      * @param ast the token to check.
      */
     private void visitLiteralFor(DetailAST ast) {
         DetailAST parenAst = ast.findFirstToken(TokenTypes.LPAREN);
         if (!isPreceedsEmptyForInit(parenAst)) {
             processLeft(parenAst);
         }
         parenAst = ast.findFirstToken(TokenTypes.RPAREN);
