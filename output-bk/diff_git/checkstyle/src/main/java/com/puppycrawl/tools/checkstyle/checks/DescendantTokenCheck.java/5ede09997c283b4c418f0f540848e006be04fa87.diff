diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
index f5417b5b6..21bebfcd6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
@@ -117,179 +117,204 @@ import java.util.Set;
  *     &lt;property name="limitedTokens" value="LITERAL_RETURN"/&gt;
  *     &lt;property name="maximumNumber" value="3"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Too many fields within an interface --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="INTERFACE_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="VARIABLE_DEF"/&gt;
  *     &lt;property name="maximumDepth" value="2"/&gt;
  *     &lt;property name="maximumNumber" value="0"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Limit the number of exceptions a method can throw --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="LITERAL_THROWS"/&gt;
  *     &lt;property name="limitedTokens" value="IDENT"/&gt;
  *     &lt;property name="maximumNumber" value="1"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Limit the number of expressions in a method --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="METHOD_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="EXPR"/&gt;
  *     &lt;property name="maximumNumber" value="200"/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Disallow empty statements --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="EMPTY_STAT"/&gt;
  *     &lt;property name="limitedTokens" value="EMPTY_STAT"/&gt;
  *     &lt;property name="maximumNumber" value="0"/&gt;
  *     &lt;property name="maximumDepth" value="0"/&gt;
  *     &lt;property name="maximumMessage"
  *         value="Empty statement is not allowed."/&gt;
  * &lt;/module&gt;
  *
  * &lt;!-- Too many fields within a class --&gt;
  * &lt;module name="DescendantToken"&gt;
  *     &lt;property name="tokens" value="CLASS_DEF"/&gt;
  *     &lt;property name="limitedTokens" value="VARIABLE_DEF"/&gt;
  *     &lt;property name="maximumDepth" value="2"/&gt;
  *     &lt;property name="maximumNumber" value="10"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author Tim Tyler &lt;tim@tt1.org&gt;
  * @author Rick Giles
  */
 public class DescendantTokenCheck extends Check
 {
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_MIN = "descendant.token.min";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_MAX = "descendant.token.max";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_SUM_MIN = "descendant.token.sum.min";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_SUM_MAX = "descendant.token.sum.max";
+
      /** minimum  depth */
     private int minimumDepth;
     /** maximum depth */
     private int maximumDepth = Integer.MAX_VALUE;
     /** minimum number */
     private int minimumNumber;
     /** maximum number */
     private int maximumNumber = Integer.MAX_VALUE;
     /** Whether to sum the number of tokens found. */
     private boolean sumTokenCounts;
     /** limited tokens */
     private int[] limitedTokens = new int[0];
     /** error message when minimum count not reached */
     private String minimumMessage;
     /** error message when maximum count exceeded */
     private String maximumMessage;
 
     /**
      * Counts of descendant tokens.
      * Indexed by (token ID - 1) for performance.
      */
     private int[] counts = new int[0];
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[0];
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         //reset counts
         Arrays.fill(counts, 0);
         countTokens(ast, 0);
 
         // name of this token
         final String name = TokenTypes.getTokenName(ast.getType());
 
         if (sumTokenCounts) {
             int total = 0;
             for (int element : limitedTokens) {
                 total += counts[element - 1];
             }
             if (total < minimumNumber) {
                 log(ast.getLineNo(), ast.getColumnNo(),
-                        (null == minimumMessage) ? "descendant.token.sum.min"
+                        (null == minimumMessage) ? MSG_KEY_SUM_MIN
                                 : minimumMessage,
                         String.valueOf(total),
                         String.valueOf(minimumNumber), name);
             }
             if (total > maximumNumber) {
                 log(ast.getLineNo(), ast.getColumnNo(),
-                        (null == maximumMessage) ? "descendant.token.sum.max"
+                        (null == maximumMessage) ? MSG_KEY_SUM_MAX
                                 : maximumMessage,
                         String.valueOf(total),
                         String.valueOf(maximumNumber),
                         name);
             }
         }
         else {
             for (int element : limitedTokens) {
                 final int tokenCount = counts[element - 1];
                 if (tokenCount < minimumNumber) {
                     final String descendantName = TokenTypes
                             .getTokenName(element);
                     log(ast.getLineNo(), ast.getColumnNo(),
-                            (null == minimumMessage) ? "descendant.token.min"
+                            (null == minimumMessage) ? MSG_KEY_MIN
                                     : minimumMessage,
                             String.valueOf(tokenCount),
                             String.valueOf(minimumNumber),
                             name,
                             descendantName);
                 }
                 if (tokenCount > maximumNumber) {
                     final String descendantName = TokenTypes
                             .getTokenName(element);
                     log(ast.getLineNo(), ast.getColumnNo(),
-                            (null == maximumMessage) ? "descendant.token.max"
+                            (null == maximumMessage) ? MSG_KEY_MAX
                                     : maximumMessage,
                             String.valueOf(tokenCount),
                             String.valueOf(maximumNumber),
                             name,
                             descendantName);
                 }
             }
         }
     }
 
     /**
      * Counts the number of occurrences of descendant tokens.
      * @param ast the root token for descendants.
      * @param depth the maximum depth of the counted descendants.
      */
     private void countTokens(AST ast, int depth)
     {
         if (depth <= maximumDepth) {
             //update count
             if (depth >= minimumDepth) {
                 final int type = ast.getType();
                 if (type <= counts.length) {
                     counts[type - 1]++;
                 }
             }
             AST child = ast.getFirstChild();
             final int nextDepth = depth + 1;
             while (child != null) {
                 countTokens(child, nextDepth);
                 child = child.getNextSibling();
             }
         }
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         // Any tokens set by property 'tokens' are acceptable
         final Set<String> tokenNames = getTokenNames();
         final int[] result = new int[tokenNames.size()];
         int i = 0;
         for (String name : tokenNames) {
             result[i++] = TokenTypes.getTokenId(name);
         }
         return result;
     }
 
     /**
      * Sets the tokens which occurance as descendant is limited.
      * @param limitedTokensParam - list of tokens to ignore.
