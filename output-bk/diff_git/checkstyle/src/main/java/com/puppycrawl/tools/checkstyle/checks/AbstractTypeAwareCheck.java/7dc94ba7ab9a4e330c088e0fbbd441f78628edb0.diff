diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index 757eb6c5b..321041042 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -63,126 +63,128 @@ public abstract class AbstractTypeAwareCheck extends Check
      * because of a typo in javadoc. However, with modern IDEs that
      * support automated refactoring and generate javadoc this will
      * occur rarely, so by default we assume a configuration problem
      * in the checkstyle classpath and throw an execption.
      *
      * This configuration option was triggered by bug 1422462.
      */
     private boolean mLogLoadErrors = true;
 
     /**
      * Controls whether to log class loading errors to the checkstyle report
      * instead of throwing a RTE.
      *
      * @param aLogLoadErrors true if errors should be logged
      */
     public final void setLogLoadErrors(boolean aLogLoadErrors)
     {
         mLogLoadErrors = aLogLoadErrors;
     }
 
     /**
      * Whether to show class loading errors in the checkstyle report.
      * Request ID 1491630
      */
     private boolean mSuppressLoadErrors;
 
     /**
      * Controls whether to show class loading errors in the checkstyle report.
      *
      * @param aSuppressLoadErrors true if errors shouldn't be shown
      */
     public final void setSuppressLoadErrors(boolean aSuppressLoadErrors)
     {
         mSuppressLoadErrors = aSuppressLoadErrors;
     }
 
     /**
      * Called to process an AST when visiting it.
      * @param aAST the AST to process. Guaranteed to not be PACKAGE_DEF or
      *             IMPORT tokens.
      */
     protected abstract void processAST(DetailAST aAST);
 
     @Override
     public final int[] getRequiredTokens()
     {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
+            TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
         };
     }
 
     @Override
     public void beginTree(DetailAST aRootAST)
     {
         mPackageFullIdent = FullIdent.createFullIdent(null);
         mImports.clear();
         // add java.lang.* since it's always imported
         mImports.add("java.lang.*");
         mClassResolver = null;
         mCurrentClass = "";
         mTypeParams.clear();
     }
 
     @Override
     public final void visitToken(DetailAST aAST)
     {
         if (aAST.getType() == TokenTypes.PACKAGE_DEF) {
             processPackage(aAST);
         }
         else if (aAST.getType() == TokenTypes.IMPORT) {
             processImport(aAST);
         }
         else if ((aAST.getType() == TokenTypes.CLASS_DEF)
+                 || (aAST.getType() == TokenTypes.INTERFACE_DEF)
                  || (aAST.getType() == TokenTypes.ENUM_DEF))
         {
             processClass(aAST);
         }
         else {
             if (aAST.getType() == TokenTypes.METHOD_DEF) {
                 processTypeParams(aAST);
             }
             processAST(aAST);
         }
     }
 
     @Override
     public final void leaveToken(DetailAST aAST)
     {
         if ((aAST.getType() == TokenTypes.CLASS_DEF)
             || (aAST.getType() == TokenTypes.ENUM_DEF))
         {
             // perhaps it was inner class
             int dotIdx = mCurrentClass.lastIndexOf("$");
             if (dotIdx == -1) {
                 // perhaps just a class
                 dotIdx = mCurrentClass.lastIndexOf(".");
             }
             if (dotIdx == -1) {
                 // looks like a topmost class
                 mCurrentClass = "";
             }
             else {
                 mCurrentClass = mCurrentClass.substring(0, dotIdx);
             }
             mTypeParams.pop();
         }
         else if (aAST.getType() == TokenTypes.METHOD_DEF) {
             mTypeParams.pop();
         }
         else if ((aAST.getType() != TokenTypes.PACKAGE_DEF)
                  && (aAST.getType() != TokenTypes.IMPORT))
         {
             leaveAST(aAST);
         }
     }
 
     /**
      * Called when exiting an AST. A no-op by default, extending classes
      * may choose to override this to augment their processing.
      * @param aAST the AST we are departing. Guaranteed to not be PACKAGE_DEF,
      *             CLASS_DEF, or IMPORT
      */
     protected void leaveAST(DetailAST aAST)
