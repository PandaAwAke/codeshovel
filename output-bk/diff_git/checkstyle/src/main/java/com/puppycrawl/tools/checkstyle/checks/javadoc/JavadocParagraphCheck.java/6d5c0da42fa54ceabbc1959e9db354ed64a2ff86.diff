diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java
index 48f5fbe1d..aa23f058f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java
@@ -63,101 +63,101 @@ import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;
  *    *
  *    * &lt;p&gt;  Some Javadoc.
  *    *
  *    * &lt;p&gt;
  *    * &lt;pre&gt;
  *    * Some preformatted Javadoc.
  *    * &lt;/pre&gt;
  *    *
  *    *&#47;
  * </pre>
  * @author maxvetrenko
  * @author Vladislav Lisetskiy
  *
  */
 public class JavadocParagraphCheck extends AbstractJavadocCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_TAG_AFTER = "javadoc.paragraph.tag.after";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_LINE_BEFORE = "javadoc.paragraph.line.before";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_REDUNDANT_PARAGRAPH = "javadoc.paragraph.redundant.paragraph";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_MISPLACED_TAG = "javadoc.paragraph.misplaced.tag";
 
     /**
      * Whether the &lt;p&gt; tag should be placed immediately before the first word.
      */
     private boolean tagImmediatelyBeforeFirstWord = true;
 
     /**
      * Sets tagImmediatelyBeforeFirstWord.
      * @param value value to set.
      */
     public void setAllowNewlineParagraph(boolean value) {
-        this.tagImmediatelyBeforeFirstWord = value;
+        tagImmediatelyBeforeFirstWord = value;
     }
 
     @Override
     public int[] getDefaultJavadocTokens() {
         return new int[] {
             JavadocTokenTypes.NEWLINE,
             JavadocTokenTypes.HTML_ELEMENT,
         };
     }
 
     @Override
     public void visitJavadocToken(DetailNode ast) {
         if (ast.getType() == JavadocTokenTypes.NEWLINE && isEmptyLine(ast)) {
             checkEmptyLine(ast);
         }
         else if (ast.getType() == JavadocTokenTypes.HTML_ELEMENT
                 && JavadocUtils.getFirstChild(ast).getType() == JavadocTokenTypes.P_TAG_OPEN) {
             checkParagraphTag(ast);
         }
     }
 
     /**
      * Determines whether or not the next line after empty line has paragraph tag in the beginning.
      * @param newline NEWLINE node.
      */
     private void checkEmptyLine(DetailNode newline) {
         final DetailNode nearestToken = getNearestNode(newline);
         if (!isLastEmptyLine(newline) && nearestToken.getChildren().length > 1) {
             log(newline.getLineNumber(), MSG_TAG_AFTER);
         }
     }
 
     /**
      * Determines whether or not the line with paragraph tag has previous empty line.
      * @param tag html tag.
      */
     private void checkParagraphTag(DetailNode tag) {
         final DetailNode newLine = getNearestEmptyLine(tag);
         if (isFirstParagraph(tag)) {
             log(tag.getLineNumber(), MSG_REDUNDANT_PARAGRAPH);
         }
         else if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {
             log(tag.getLineNumber(), MSG_LINE_BEFORE);
         }
         if (tagImmediatelyBeforeFirstWord && isImmediatelyFollowedByText(tag)) {
             log(tag.getLineNumber(), MSG_MISPLACED_TAG);
         }
     }
 
     /**
