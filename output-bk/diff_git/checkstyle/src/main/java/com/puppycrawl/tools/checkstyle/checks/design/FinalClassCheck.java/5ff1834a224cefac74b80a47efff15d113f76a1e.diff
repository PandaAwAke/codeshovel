diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
index fa939b68d..0c14ac6b9 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
@@ -52,148 +52,148 @@ public class FinalClassCheck
     /** Keeps ClassDesc objects for stack of declared classes. */
     private final Deque<ClassDesc> classes = new ArrayDeque<>();
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[]{TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[]{TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             final boolean isFinal = modifiers != null
                     && modifiers.branchContains(TokenTypes.FINAL);
             final boolean isAbstract = modifiers != null
                     && modifiers.branchContains(TokenTypes.ABSTRACT);
             classes.push(new ClassDesc(isFinal, isAbstract));
         }
         else if (!ScopeUtils.inEnumBlock(ast)) { //ctors in enums don't matter
             final ClassDesc desc = classes.peek();
             if (modifiers != null
                 && modifiers.branchContains(TokenTypes.LITERAL_PRIVATE))
             {
                 desc.reportPrivateCtor();
             }
             else {
                 desc.reportNonPrivateCtor();
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         if (ast.getType() != TokenTypes.CLASS_DEF) {
             return;
         }
 
         final ClassDesc desc = classes.pop();
         if (!desc.isDeclaredAsFinal()
             && !desc.isDeclaredAsAbstract()
-            && desc.hasPrivateCtor()
-            && !desc.hasNonPrivateCtor())
+            && desc.isWithPrivateCtor()
+            && !desc.isWithNonPrivateCtor())
         {
             final String className =
                 ast.findFirstToken(TokenTypes.IDENT).getText();
             log(ast.getLineNo(), MSG_KEY, className);
         }
     }
 
     /** maintains information about class' ctors */
     private static final class ClassDesc
     {
         /** is class declared as final */
         private final boolean declaredAsFinal;
 
         /** is class declared as abstract */
         private final boolean declaredAsAbstract;
 
         /** does class have non-provate ctors */
-        private boolean hasNonPrivateCtor;
+        private boolean withNonPrivateCtor;
 
         /** does class have private ctors */
-        private boolean hasPrivateCtor;
+        private boolean withPrivateCtor;
 
         /**
          *  create a new ClassDesc instance.
          *  @param declaredAsFinal indicates if the
          *         class declared as final
          *  @param declaredAsAbstract indicates if the
          *         class declared as abstract
          */
         ClassDesc(boolean declaredAsFinal, boolean declaredAsAbstract)
         {
             this.declaredAsFinal = declaredAsFinal;
             this.declaredAsAbstract = declaredAsAbstract;
         }
 
         /** adds private ctor. */
         void reportPrivateCtor()
         {
-            hasPrivateCtor = true;
+            withPrivateCtor = true;
         }
 
         /** adds non-private ctor. */
         void reportNonPrivateCtor()
         {
-            hasNonPrivateCtor = true;
+            withNonPrivateCtor = true;
         }
 
         /**
          *  does class have private ctors.
          *  @return true if class has private ctors
          */
-        boolean hasPrivateCtor()
+        boolean isWithPrivateCtor()
         {
-            return hasPrivateCtor;
+            return withPrivateCtor;
         }
 
         /**
          *  does class have non-private ctors.
          *  @return true if class has non-private ctors
          */
-        boolean hasNonPrivateCtor()
+        boolean isWithNonPrivateCtor()
         {
-            return hasNonPrivateCtor;
+            return withNonPrivateCtor;
         }
 
         /**
          *  is class declared as final.
          *  @return true if class is declared as final
          */
         boolean isDeclaredAsFinal()
         {
             return declaredAsFinal;
         }
 
         /**
          *  is class declared as abstract.
          *  @return true if class is declared as final
          */
         boolean isDeclaredAsAbstract()
         {
             return declaredAsAbstract;
         }
 
         @Override
         public String toString()
         {
             return this.getClass().getName()
                 + "["
                 + "final=" + declaredAsFinal
                 + " abstract=" + declaredAsAbstract
-                + " pctor=" + hasPrivateCtor
-                + " ctor=" + hasNonPrivateCtor
+                + " pctor=" + withPrivateCtor
+                + " ctor=" + withNonPrivateCtor
                 + "]";
         }
     }
 }
