diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
index d95e79da8..cb713429c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java
@@ -86,100 +86,110 @@ import com.puppycrawl.tools.checkstyle.api.TextBlock;
  * </li>
  * </ul>
  * His comments on being hard to maintain when the size of
  * the line changes are even more important in the age of
  * automated refactorings.
  *
  * <p>
  * To configure the check so it enforces only comment on a line:
  * <pre>
  * &lt;module name=&quot;TrailingComment&quot;&gt;
  *    &lt;property name=&quot;format&quot; value=&quot;^\\s*$&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author o_sukhodolsky
  */
 public class TrailingCommentCheck extends AbstractFormatCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "trailing.comments";
 
     /** default format for allowed blank line. */
     private static final String DEFAULT_FORMAT = "^[\\s\\}\\);]*$";
 
     /** pattern for legal trailing comment. */
     private Pattern legalComment;
 
     /**
      * Creates new instance of the check.
      */
     public TrailingCommentCheck() {
         super(DEFAULT_FORMAT);
     }
 
     /**
      * Sets patter for legal trailing comments.
      * @param format format to set.
      */
     public void setLegalComment(final String format) {
         legalComment = Utils.createPattern(format);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return ArrayUtils.EMPTY_INT_ARRAY;
     }
 
+    @Override
+    public int[] getAcceptableTokens() {
+        return ArrayUtils.EMPTY_INT_ARRAY;
+    }
+
+    @Override
+    public int[] getRequiredTokens() {
+        return ArrayUtils.EMPTY_INT_ARRAY;
+    }
+
     @Override
     public void visitToken(DetailAST ast) {
         throw new IllegalStateException("visitToken() shouldn't be called.");
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         final Pattern blankLinePattern = getRegexp();
         final Map<Integer, TextBlock> cppComments = getFileContents()
                 .getCppComments();
         final Map<Integer, List<TextBlock>> cComments = getFileContents()
                 .getCComments();
         final Set<Integer> lines = Sets.newHashSet();
         lines.addAll(cppComments.keySet());
         lines.addAll(cComments.keySet());
 
         for (Integer lineNo : lines) {
             final String line = getLines()[lineNo - 1];
             String lineBefore;
             TextBlock comment;
             if (cppComments.containsKey(lineNo)) {
                 comment = cppComments.get(lineNo);
                 lineBefore = line.substring(0, comment.getStartColNo());
             }
             else {
                 final List<TextBlock> commentList = cComments.get(lineNo);
                 comment = commentList.get(commentList.size() - 1);
                 lineBefore = line.substring(0, comment.getStartColNo());
                 if (comment.getText().length == 1) {
                     final String lineAfter =
                         line.substring(comment.getEndColNo() + 1).trim();
                     if (!lineAfter.isEmpty()) {
                         // do not check comment which doesn't end line
                         continue;
                     }
                 }
             }
             if (!blankLinePattern.matcher(lineBefore).find()
                 && !isLegalComment(comment)) {
                 log(lineNo.intValue(), MSG_KEY);
             }
         }
     }
 
     /**
      * Checks if given comment is legal (single-line and matches to the
      * pattern).
      * @param comment comment to check.
      * @return true if the comment if legal.
      */
