diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 383c5b389..8a3b632de 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -73,336 +73,362 @@ import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
  * </p>
  * @author k_gibbs, r_auckenthaler
  * @author Vladislav Lisetskiy
  */
 public class FinalLocalVariableCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "final.variable";
 
     /**
      * Assign operator types.
      */
     private static final int[] ASSIGN_OPERATOR_TYPES = {
         TokenTypes.POST_INC,
         TokenTypes.POST_DEC,
         TokenTypes.ASSIGN,
         TokenTypes.PLUS_ASSIGN,
         TokenTypes.MINUS_ASSIGN,
         TokenTypes.STAR_ASSIGN,
         TokenTypes.DIV_ASSIGN,
         TokenTypes.MOD_ASSIGN,
         TokenTypes.SR_ASSIGN,
         TokenTypes.BSR_ASSIGN,
         TokenTypes.SL_ASSIGN,
         TokenTypes.BAND_ASSIGN,
         TokenTypes.BXOR_ASSIGN,
         TokenTypes.BOR_ASSIGN,
         TokenTypes.INC,
         TokenTypes.DEC,
     };
 
     /**
      * Loop types.
      */
     private static final int[] LOOP_TYPES = {
         TokenTypes.LITERAL_FOR,
         TokenTypes.LITERAL_WHILE,
         TokenTypes.LITERAL_DO,
     };
 
     /** Scope Deque. */
     private final Deque<ScopeData> scopeStack = new ArrayDeque<>();
 
     /** Uninitialized variables of previous scope. */
     private final Deque<Deque<DetailAST>> prevScopeUninitializedVariables =
             new ArrayDeque<>();
 
+    /** Assigned variables of current scope. */
+    private final Deque<Deque<DetailAST>> currentScopeAssignedVariables =
+            new ArrayDeque<>();
+
     /** Controls whether to check enhanced for-loop variable. */
     private boolean validateEnhancedForLoopVariable;
 
     static {
         // Array sorting for binary search
         Arrays.sort(ASSIGN_OPERATOR_TYPES);
         Arrays.sort(LOOP_TYPES);
     }
 
     /**
      * Whether to check enhanced for-loop variable or not.
      * @param validateEnhancedForLoopVariable whether to check for-loop variable
      */
     public final void setValidateEnhancedForLoopVariable(boolean validateEnhancedForLoopVariable) {
         this.validateEnhancedForLoopVariable = validateEnhancedForLoopVariable;
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
+            TokenTypes.LITERAL_BREAK,
         };
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
+            TokenTypes.LITERAL_BREAK,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
+            TokenTypes.LITERAL_BREAK,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
         };
     }
 
     // -@cs[CyclomaticComplexity] The only optimization which can be done here is moving CASE-block
     // expressions to separate methods, but that will not increase readability.
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.CTOR_DEF:
                 scopeStack.push(new ScopeData());
                 break;
             case TokenTypes.SLIST:
+                currentScopeAssignedVariables.push(new ArrayDeque<>());
                 if (ast.getParent().getType() != TokenTypes.CASE_GROUP
                     || ast.getParent().getParent().findFirstToken(TokenTypes.CASE_GROUP)
                     == ast.getParent()) {
                     storePrevScopeUninitializedVariableData();
                     scopeStack.push(new ScopeData());
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 if (!isInLambda(ast)
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isInAbstractOrNativeMethod(ast)
                         && !ScopeUtils.isInInterfaceBlock(ast)
                         && !isMultipleTypeCatch(ast)) {
                     insertParameter(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (ast.getParent().getType() != TokenTypes.OBJBLOCK
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isVariableInForInit(ast)
                         && shouldCheckEnhancedForLoopVariable(ast)) {
                     insertVariable(ast);
                 }
                 break;
-
             case TokenTypes.IDENT:
                 final int parentType = ast.getParent().getType();
                 if (isAssignOperator(parentType) && isFirstChild(ast)) {
                     final Optional<FinalVariableCandidate> candidate = getFinalCandidate(ast);
                     if (candidate.isPresent()) {
                         determineAssignmentConditions(ast, candidate.get());
+                        currentScopeAssignedVariables.peek().add(ast);
                     }
                     removeFinalVariableCandidateFromStack(ast);
                 }
                 break;
-
+            case TokenTypes.LITERAL_BREAK:
+                scopeStack.peek().containsBreak = true;
+                break;
             default:
                 throw new IllegalStateException("Incorrect token type");
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         Map<String, FinalVariableCandidate> scope = null;
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 scope = scopeStack.pop().scope;
                 break;
             case TokenTypes.SLIST:
                 final Deque<DetailAST> prevScopeUnitializedVariableData =
                     prevScopeUninitializedVariables.peek();
+                boolean containsBreak = false;
                 if (ast.getParent().getType() != TokenTypes.CASE_GROUP
                     || findLastChildWhichContainsSpecifiedToken(ast.getParent().getParent(),
                             TokenTypes.CASE_GROUP, TokenTypes.SLIST) == ast.getParent()) {
+                    containsBreak = scopeStack.peek().containsBreak;
                     scope = scopeStack.pop().scope;
                     prevScopeUninitializedVariables.pop();
                 }
                 final DetailAST parent = ast.getParent();
-                if (shouldUpdateUninitializedVariables(parent)) {
-                    updateUninitializedVariables(prevScopeUnitializedVariableData);
+                if (containsBreak || shouldUpdateUninitializedVariables(parent)) {
+                    updateAllUninitializedVariables(prevScopeUnitializedVariableData);
                 }
+                updateCurrentScopeAssignedVariables();
                 break;
             default:
                 // do nothing
         }
         if (scope != null) {
             for (FinalVariableCandidate candidate : scope.values()) {
                 final DetailAST ident = candidate.variableIdent;
                 log(ident.getLineNo(), ident.getColumnNo(), MSG_KEY, ident.getText());
             }
         }
     }
 
+    /**
+     * Update assigned variables in a temporary stack.
+     */
+    private void updateCurrentScopeAssignedVariables() {
+        final Deque<DetailAST> poppedScopeAssignedVariableData =
+                currentScopeAssignedVariables.pop();
+        final Deque<DetailAST> currentScopeAssignedVariableData =
+                currentScopeAssignedVariables.peek();
+        if (currentScopeAssignedVariableData != null) {
+            currentScopeAssignedVariableData.addAll(poppedScopeAssignedVariableData);
+        }
+    }
+
     /**
      * Determines identifier assignment conditions (assigned or already assigned).
      * @param ident identifier.
      * @param candidate final local variable candidate.
      */
     private static void determineAssignmentConditions(DetailAST ident,
                                                       FinalVariableCandidate candidate) {
         if (candidate.assigned) {
             if (!isInSpecificCodeBlock(ident, TokenTypes.LITERAL_ELSE)
                     && !isInSpecificCodeBlock(ident, TokenTypes.CASE_GROUP)) {
                 candidate.alreadyAssigned = true;
             }
         }
         else {
             candidate.assigned = true;
         }
     }
 
     /**
      * Checks whether the scope of a node is restricted to a specific code block.
      * @param node node.
      * @param blockType block type.
      * @return true if the scope of a node is restricted to a specific code block.
      */
     private static boolean isInSpecificCodeBlock(DetailAST node, int blockType) {
         boolean returnValue = false;
         for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {
             final int type = token.getType();
             if (type == blockType) {
                 returnValue = true;
                 break;
             }
         }
         return returnValue;
     }
 
     /**
      * Gets final variable candidate for ast.
      * @param ast ast.
      * @return Optional of {@link FinalVariableCandidate} for ast from scopeStack.
      */
     private Optional<FinalVariableCandidate> getFinalCandidate(DetailAST ast) {
         Optional<FinalVariableCandidate> result = Optional.empty();
         final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
         while (iterator.hasNext() && !result.isPresent()) {
             final ScopeData scopeData = iterator.next();
             result = scopeData.findFinalVariableCandidateForAst(ast);
         }
         return result;
     }
 
     /**
      * Store un-initialized variables in a temporary stack for future use.
      */
     private void storePrevScopeUninitializedVariableData() {
         final ScopeData scopeData = scopeStack.peek();
         final Deque<DetailAST> prevScopeUnitializedVariableData =
                 new ArrayDeque<>();
         scopeData.uninitializedVariables.forEach(prevScopeUnitializedVariableData::push);
         prevScopeUninitializedVariables.push(prevScopeUnitializedVariableData);
     }
 
     /**
-     * Update current scope data uninitialized variable according to the previous scope data.
+     * Update current scope data uninitialized variable according to the whole scope data.
      * @param prevScopeUnitializedVariableData variable for previous stack of uninitialized
      *     variables
      */
     // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation.
-    private void updateUninitializedVariables(Deque<DetailAST> prevScopeUnitializedVariableData) {
+    private void updateAllUninitializedVariables(
+            Deque<DetailAST> prevScopeUnitializedVariableData) {
         // Check for only previous scope
-        for (DetailAST variable : prevScopeUnitializedVariableData) {
-            for (ScopeData scopeData : scopeStack) {
-                final FinalVariableCandidate candidate = scopeData.scope.get(variable.getText());
-                DetailAST storedVariable = null;
-                if (candidate != null) {
-                    storedVariable = candidate.variableIdent;
-                }
-                if (storedVariable != null && isSameVariables(storedVariable, variable)
-                        && !scopeData.uninitializedVariables.contains(storedVariable)) {
-                    scopeData.uninitializedVariables.push(variable);
-                }
-            }
-        }
+        updateUninitializedVariables(prevScopeUnitializedVariableData);
         // Check for rest of the scope
-        for (Deque<DetailAST> unitializedVariableData : prevScopeUninitializedVariables) {
-            for (DetailAST variable : unitializedVariableData) {
+        prevScopeUninitializedVariables.forEach(this::updateUninitializedVariables);
+    }
+
+    /**
+     * Update current scope data uninitialized variable according to the specific scope data.
+     * @param scopeUnitializedVariableData variable for specific stack of uninitialized variables
+     */
+    private void updateUninitializedVariables(Deque<DetailAST> scopeUnitializedVariableData) {
+        final Iterator<DetailAST> iterator = currentScopeAssignedVariables.peek().iterator();
+        while (iterator.hasNext()) {
+            final DetailAST assignedVariable = iterator.next();
+            for (DetailAST variable : scopeUnitializedVariableData) {
                 for (ScopeData scopeData : scopeStack) {
                     final FinalVariableCandidate candidate =
                         scopeData.scope.get(variable.getText());
                     DetailAST storedVariable = null;
                     if (candidate != null) {
                         storedVariable = candidate.variableIdent;
                     }
                     if (storedVariable != null
                             && isSameVariables(storedVariable, variable)
-                            && !scopeData.uninitializedVariables.contains(storedVariable)) {
+                            && isSameVariables(assignedVariable, variable)) {
                         scopeData.uninitializedVariables.push(variable);
+                        iterator.remove();
                     }
                 }
             }
         }
     }
 
     /**
      * If token is LITERAL_IF and there is an {@code else} following or token is CASE_GROUP and
      * there is another {@code case} following, then update the uninitialized variables.
      * @param ast token to be checked
      * @return true if should be updated, else false
      */
     private static boolean shouldUpdateUninitializedVariables(DetailAST ast) {
         return isIfTokenWithAnElseFollowing(ast) || isCaseTokenWithAnotherCaseFollowing(ast);
     }
 
     /**
      * If token is LITERAL_IF and there is an {@code else} following.
      * @param ast token to be checked
      * @return true if token is LITERAL_IF and there is an {@code else} following, else false
      */
     private static boolean isIfTokenWithAnElseFollowing(DetailAST ast) {
         return ast.getType() == TokenTypes.LITERAL_IF
                 && ast.getLastChild().getType() == TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * If token is CASE_GROUP and there is another {@code case} following.
      * @param ast token to be checked
      * @return true if token is CASE_GROUP and there is another {@code case} following, else false
      */
     private static boolean isCaseTokenWithAnotherCaseFollowing(DetailAST ast) {
         return ast.getType() == TokenTypes.CASE_GROUP
                 && findLastChildWhichContainsSpecifiedToken(
                         ast.getParent(), TokenTypes.CASE_GROUP, TokenTypes.SLIST) != ast;
     }
 
     /**
      * Returns the last child token that makes a specified type and contains containType in
      * its branch.
      * @param ast token to be tested
      * @param childType the token type to match
      * @param containType the token type which has to be present in the branch
      * @return the matching token, or null if no match
      */
     private static DetailAST findLastChildWhichContainsSpecifiedToken(DetailAST ast, int childType,
                                                               int containType) {
         DetailAST returnValue = null;
         for (DetailAST astIterator = ast.getFirstChild(); astIterator != null;
                 astIterator = astIterator.getNextSibling()) {
@@ -580,128 +606,131 @@ public class FinalLocalVariableCheck extends AbstractCheck {
         DetailAST parent = ast.getParent();
         while (parent != null && !abstractOrNative) {
             if (parent.getType() == TokenTypes.METHOD_DEF) {
                 final DetailAST modifiers =
                     parent.findFirstToken(TokenTypes.MODIFIERS);
                 abstractOrNative = modifiers.branchContains(TokenTypes.ABSTRACT)
                         || modifiers.branchContains(TokenTypes.LITERAL_NATIVE);
             }
             parent = parent.getParent();
         }
         return abstractOrNative;
     }
 
     /**
      * Check if current param is lambda's param.
      * @param paramDef {@link TokenTypes#PARAMETER_DEF parameter def}.
      * @return true if current param is lambda's param.
      */
     private static boolean isInLambda(DetailAST paramDef) {
         return paramDef.getParent().getParent().getType() == TokenTypes.LAMBDA;
     }
 
     /**
      * Find the Class, Constructor, Enum, Method, or Field in which it is defined.
      * @param ast Variable for which we want to find the scope in which it is defined
      * @return ast The Class or Constructor or Method in which it is defined.
      */
     private static DetailAST findFirstUpperNamedBlock(DetailAST ast) {
         DetailAST astTraverse = ast;
         while (astTraverse.getType() != TokenTypes.METHOD_DEF
                 && astTraverse.getType() != TokenTypes.CLASS_DEF
                 && astTraverse.getType() != TokenTypes.ENUM_DEF
                 && astTraverse.getType() != TokenTypes.CTOR_DEF
                 && !ScopeUtils.isClassFieldDef(astTraverse)) {
             astTraverse = astTraverse.getParent();
         }
         return astTraverse;
     }
 
     /**
      * Check if both the Variables are same.
      * @param ast1 Variable to compare
      * @param ast2 Variable to compare
      * @return true if both the variables are same, otherwise false
      */
     private static boolean isSameVariables(DetailAST ast1, DetailAST ast2) {
         final DetailAST classOrMethodOfAst1 =
             findFirstUpperNamedBlock(ast1);
         final DetailAST classOrMethodOfAst2 =
             findFirstUpperNamedBlock(ast2);
-        return classOrMethodOfAst1 == classOrMethodOfAst2;
+        return classOrMethodOfAst1 == classOrMethodOfAst2 && ast1.getText().equals(ast2.getText());
     }
 
     /**
      * Check if both the variables are in the same loop.
      * @param ast1 variable to compare.
      * @param ast2 variable to compare.
      * @return true if both the variables are in the same loop.
      */
     private static boolean isInTheSameLoop(DetailAST ast1, DetailAST ast2) {
         DetailAST loop1 = ast1.getParent();
         while (loop1 != null && !isLoopAst(loop1.getType())) {
             loop1 = loop1.getParent();
         }
         DetailAST loop2 = ast2.getParent();
         while (loop2 != null && !isLoopAst(loop2.getType())) {
             loop2 = loop2.getParent();
         }
         return loop1 != null && loop1 == loop2;
     }
 
     /**
      * Checks whether the ast is a loop.
      * @param ast the ast to check.
      * @return true if the ast is a loop.
      */
     private static boolean isLoopAst(int ast) {
         return Arrays.binarySearch(LOOP_TYPES, ast) >= 0;
     }
 
     /**
      * Holder for the scope data.
      */
     private static class ScopeData {
         /** Contains variable definitions. */
         private final Map<String, FinalVariableCandidate> scope = new HashMap<>();
 
         /** Contains definitions of uninitialized variables. */
         private final Deque<DetailAST> uninitializedVariables = new ArrayDeque<>();
 
+        /** Whether there is a {@code break} in the scope. */
+        private boolean containsBreak;
+
         /**
          * Searches for final local variable candidate for ast in the scope.
          * @param ast ast.
          * @return Optional of {@link FinalVariableCandidate}.
          */
         public Optional<FinalVariableCandidate> findFinalVariableCandidateForAst(DetailAST ast) {
             Optional<FinalVariableCandidate> result = Optional.empty();
             DetailAST storedVariable = null;
             final Optional<FinalVariableCandidate> candidate =
                 Optional.ofNullable(scope.get(ast.getText()));
             if (candidate.isPresent()) {
                 storedVariable = candidate.get().variableIdent;
             }
             if (storedVariable != null && isSameVariables(storedVariable, ast)) {
                 result = candidate;
             }
             return result;
         }
     }
 
     /**Represents information about final local variable candidate. */
     private static class FinalVariableCandidate {
         /** Identifier token. */
         private final DetailAST variableIdent;
         /** Whether the variable is assigned. */
         private boolean assigned;
         /** Whether the variable is already assigned. */
         private boolean alreadyAssigned;
 
         /**
          * Creates new instance.
          * @param variableIdent variable identifier.
          */
         FinalVariableCandidate(DetailAST variableIdent) {
             this.variableIdent = variableIdent;
         }
     }
 }
