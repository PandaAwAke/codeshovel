diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java b/src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java
index c7f88d5d4..5a9409232 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java
@@ -71,101 +71,101 @@ public class DefaultLogger
     /**
      * Creates a new <code>DefaultLogger</code> instance.
      *
      * @param infoStream the <code>OutputStream</code> for info messages
      * @param closeInfoAfterUse auditFinished should close infoStream
      * @param errorStream the <code>OutputStream</code> for error messages
      * @param closeErrorAfterUse auditFinished should close errorStream
      * @exception UnsupportedEncodingException if there is a problem to use UTF-8 encoding
      */
     public DefaultLogger(OutputStream infoStream,
                          boolean closeInfoAfterUse,
                          OutputStream errorStream,
                          boolean closeErrorAfterUse) throws UnsupportedEncodingException {
         closeInfo = closeInfoAfterUse;
         closeError = closeErrorAfterUse;
         final Writer infoStreamWriter = new OutputStreamWriter(infoStream, "UTF-8");
         final Writer errorStreamWriter = new OutputStreamWriter(errorStream, "UTF-8");
         infoWriter = new PrintWriter(infoStreamWriter);
         errorWriter = infoStream == errorStream
             ? infoWriter
             : new PrintWriter(errorStreamWriter);
     }
 
     /**
      * Print an Emacs compliant line on the error stream.
      * If the column number is non zero, then also display it.
      * @param evt {@inheritDoc}
      * @see AuditListener
      **/
     @Override
     public void addError(AuditEvent evt) {
         final SeverityLevel severityLevel = evt.getSeverityLevel();
         if (severityLevel != SeverityLevel.IGNORE) {
 
             final String fileName = evt.getFileName();
             final String message = evt.getMessage();
 
             // avoid StringBuffer.expandCapacity
             final int bufLen = fileName.length() + message.length()
                 + BUFFER_CUSHION;
             final StringBuilder sb = new StringBuilder(bufLen);
 
             sb.append(fileName).append(':').append(evt.getLine());
             if (evt.getColumn() > 0) {
                 sb.append(':').append(evt.getColumn());
             }
             if (severityLevel == SeverityLevel.WARNING) {
                 sb.append(": warning");
             }
             sb.append(": ").append(message);
-            errorWriter.println(sb.toString());
+            errorWriter.println(sb);
         }
     }
 
     /** {@inheritDoc} */
     @Override
     public void addException(AuditEvent evt, Throwable throwable) {
         synchronized (errorWriter) {
             errorWriter.println("Error auditing " + evt.getFileName());
             throwable.printStackTrace(errorWriter);
         }
     }
 
     /** {@inheritDoc} */
     @Override
     public void auditStarted(AuditEvent evt) {
         infoWriter.println("Starting audit...");
     }
 
     /** {@inheritDoc} */
     @Override
     public void fileFinished(AuditEvent evt) {
         // No need to implement this method in this class
     }
 
     /** {@inheritDoc} */
     @Override
     public void fileStarted(AuditEvent evt) {
         // No need to implement this method in this class
     }
 
     /** {@inheritDoc} */
     @Override
     public void auditFinished(AuditEvent evt) {
         infoWriter.println("Audit done.");
         closeStreams();
     }
 
     /**
      * Flushes the output streams and closes them if needed.
      */
     protected void closeStreams() {
         infoWriter.flush();
         if (closeInfo) {
             infoWriter.close();
         }
 
         errorWriter.flush();
         if (closeError) {
             errorWriter.close();
         }
