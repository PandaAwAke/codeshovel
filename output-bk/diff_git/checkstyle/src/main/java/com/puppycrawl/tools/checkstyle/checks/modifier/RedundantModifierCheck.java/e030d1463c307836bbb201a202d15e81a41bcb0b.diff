diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java
index 0dee2d28e..5e90df163 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java
@@ -38,153 +38,169 @@ public class RedundantModifierCheck
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "redundantModifier";
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.INTERFACE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {};
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.INTERFACE_DEF,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (TokenTypes.INTERFACE_DEF == ast.getType()) {
             final DetailAST modifiers =
                 ast.findFirstToken(TokenTypes.MODIFIERS);
             if (null != modifiers) {
                 for (final int tokenType : new int[] {
                     TokenTypes.LITERAL_STATIC,
                     TokenTypes.ABSTRACT, }) {
                     final DetailAST modifier =
                             modifiers.findFirstToken(tokenType);
                     if (null != modifier) {
                         log(modifier.getLineNo(), modifier.getColumnNo(),
                                 MSG_KEY, modifier.getText());
                     }
                 }
             }
         }
         else if (isInterfaceOrAnnotationMember(ast)) {
-            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
-            DetailAST modifier = modifiers.getFirstChild();
-            while (modifier != null) {
+            processInterfaceOrAnnotation(ast);
+        }
+        else if (ast.getType() == TokenTypes.METHOD_DEF) {
+            processMethods(ast);
+        }
+    }
 
-                // javac does not allow final or static in interface methods
-                // order annotation fields hence no need to check that this
-                // is not a method or annotation field
+    /**
+     * do validation of interface of annotation
+     * @param ast token AST
+     */
+    private void processInterfaceOrAnnotation(DetailAST ast) {
+        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
+        DetailAST modifier = modifiers.getFirstChild();
+        while (modifier != null) {
 
+            // javac does not allow final or static in interface methods
+            // order annotation fields hence no need to check that this
+            // is not a method or annotation field
+
+            final int type = modifier.getType();
+            if (type == TokenTypes.LITERAL_PUBLIC
+                || type == TokenTypes.LITERAL_STATIC
+                        && ast.getType() != TokenTypes.METHOD_DEF
+                || type == TokenTypes.ABSTRACT
+                || type == TokenTypes.FINAL) {
+                log(modifier.getLineNo(), modifier.getColumnNo(),
+                        MSG_KEY, modifier.getText());
+                break;
+            }
+
+            modifier = modifier.getNextSibling();
+        }
+    }
+
+    /**
+     * process validation ofMethods
+     * @param ast method AST
+     */
+    private void processMethods(DetailAST ast) {
+        final DetailAST modifiers =
+                        ast.findFirstToken(TokenTypes.MODIFIERS);
+        // private method?
+        boolean checkFinal =
+            modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);
+        // declared in a final class?
+        DetailAST parent = ast.getParent();
+        while (parent != null) {
+            if (parent.getType() == TokenTypes.CLASS_DEF) {
+                final DetailAST classModifiers =
+                    parent.findFirstToken(TokenTypes.MODIFIERS);
+                checkFinal |=
+                    classModifiers.branchContains(TokenTypes.FINAL);
+                break;
+            }
+            parent = parent.getParent();
+        }
+        if (checkFinal && !isAnnotatedWithSafeVarargs(ast)) {
+            DetailAST modifier = modifiers.getFirstChild();
+            while (modifier != null) {
                 final int type = modifier.getType();
-                if (type == TokenTypes.LITERAL_PUBLIC
-                    || type == TokenTypes.LITERAL_STATIC
-                            && ast.getType() != TokenTypes.METHOD_DEF
-                    || type == TokenTypes.ABSTRACT
-                    || type == TokenTypes.FINAL) {
+                if (type == TokenTypes.FINAL) {
                     log(modifier.getLineNo(), modifier.getColumnNo(),
                             MSG_KEY, modifier.getText());
                     break;
                 }
-
                 modifier = modifier.getNextSibling();
             }
         }
-        else if (ast.getType() == TokenTypes.METHOD_DEF) {
-            final DetailAST modifiers =
-                            ast.findFirstToken(TokenTypes.MODIFIERS);
-            // private method?
-            boolean checkFinal =
-                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);
-            // declared in a final class?
-            DetailAST parent = ast.getParent();
-            while (parent != null) {
-                if (parent.getType() == TokenTypes.CLASS_DEF) {
-                    final DetailAST classModifiers =
-                        parent.findFirstToken(TokenTypes.MODIFIERS);
-                    checkFinal |=
-                        classModifiers.branchContains(TokenTypes.FINAL);
-                    break;
-                }
-                parent = parent.getParent();
-            }
-            if (checkFinal && !isAnnotatedWithSafeVarargs(ast)) {
-                DetailAST modifier = modifiers.getFirstChild();
-                while (modifier != null) {
-                    final int type = modifier.getType();
-                    if (type == TokenTypes.FINAL) {
-                        log(modifier.getLineNo(), modifier.getColumnNo(),
-                                MSG_KEY, modifier.getText());
-                        break;
-                    }
-                    modifier = modifier.getNextSibling();
-                }
-            }
-        }
     }
 
     /**
      * Checks if current AST node is member of Interface or Annotation, not of their subnodes.
      * @param ast AST node
      * @return true or false
      */
     private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {
         final DetailAST parentTypeDef = ast.getParent().getParent();
         return parentTypeDef.getType() == TokenTypes.INTERFACE_DEF
                || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF;
     }
 
     /**
      * Checks if method definition is annotated with
      * <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html">
      * SafeVarargs</a> annotation
      * @param methodDef method definition node
      * @return true or false
      */
     private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {
         boolean result = false;
         final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);
         for (DetailAST annotationNode : methodAnnotationsList) {
             if ("SafeVarargs".equals(annotationNode.getLastChild().getText())) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Gets the list of annotations on method definition
      * @param methodDef method definition node
      * @return List of annotations
      */
     private static List<DetailAST> getMethodAnnotationsList(DetailAST methodDef) {
         final List<DetailAST> annotationsList = new ArrayList<>();
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         DetailAST modifier = modifiers.getFirstChild();
         while (modifier != null) {
             if (modifier.getType() == TokenTypes.ANNOTATION) {
                 annotationsList.add(modifier);
             }
             modifier = modifier.getNextSibling();
         }
         return annotationsList;
     }
 }
