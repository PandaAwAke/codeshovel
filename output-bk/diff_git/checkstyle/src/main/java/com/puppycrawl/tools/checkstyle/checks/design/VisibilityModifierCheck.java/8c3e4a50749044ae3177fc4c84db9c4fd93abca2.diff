diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 823be3487..ae694653c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -223,102 +223,124 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * String customAnnotated1; // No warning
  * }
  * {@code @mypackage.annotation.CustomAnnotation
  * String customAnnotatedAnotherPackage; // another package but short name matches
  *                                       // so no violation
  * }
  * </pre>
  *
  *
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  */
 public class VisibilityModifierCheck
     extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "variable.notPrivate";
 
     /** Default immutable types canonical names. */
     private static final List<String> DEFAULT_IMMUTABLE_TYPES = ImmutableList.of(
         "java.lang.String",
         "java.lang.Integer",
         "java.lang.Byte",
         "java.lang.Character",
         "java.lang.Short",
         "java.lang.Boolean",
         "java.lang.Long",
         "java.lang.Double",
         "java.lang.Float",
         "java.lang.StackTraceElement",
         "java.math.BigInteger",
         "java.math.BigDecimal",
         "java.io.File",
         "java.util.Locale",
         "java.util.UUID",
         "java.net.URL",
         "java.net.URI",
         "java.net.Inet4Address",
         "java.net.Inet6Address",
         "java.net.InetSocketAddress"
     );
 
     /** Default ignore annotations canonical names. */
     private static final List<String> DEFAULT_IGNORE_ANNOTATIONS = ImmutableList.of(
         "org.junit.Rule",
         "com.google.common.annotations.VisibleForTesting"
     );
 
+    /** Name for 'public' access modifier. */
+    private static final String PUBLIC_ACCESS_MODIFIER = "public";
+
+    /** Name for 'private' access modifier. */
+    private static final String PRIVATE_ACCESS_MODIFIER = "private";
+
+    /** Name for 'protected' access modifier. */
+    private static final String PROTECTED_ACCESS_MODIFIER = "protected";
+
+    /** Name for implicit 'package' access modifier. */
+    private static final String PACKAGE_ACCESS_MODIFIER = "package";
+
+    /** Name for 'static' keyword. */
+    private static final String STATIC_KEYWORD = "static";
+
+    /** Name for 'final' keyword. */
+    private static final String FINAL_KEYWORD = "final";
+
     /** Contains explicit access modifiers. */
-    private static final String[] EXPLICIT_MODS = {"public", "private", "protected"};
+    private static final String[] EXPLICIT_MODS = {
+        PUBLIC_ACCESS_MODIFIER,
+        PRIVATE_ACCESS_MODIFIER,
+        PROTECTED_ACCESS_MODIFIER,
+    };
 
     /** Whether protected members are allowed */
     private boolean protectedAllowed;
 
     /** Whether package visible members are allowed */
     private boolean packageAllowed;
 
     /**
      * Pattern for public members that should be ignored.  Note:
      * Earlier versions of checkstyle used ^f[A-Z][a-zA-Z0-9]*$ as the
      * default to allow CMP for EJB 1.1 with the default settings.
      * With EJB 2.0 it is not longer necessary to have public access
      * for persistent fields.
      */
     private String publicMemberFormat = "^serialVersionUID$";
 
     /** Regexp for public members that should be ignored */
     private Pattern publicMemberPattern = Pattern.compile(publicMemberFormat);
 
     /** List of ignore annotations canonical names. */
     private List<String> ignoreAnnotationCanonicalNames =
             new ArrayList<>(DEFAULT_IGNORE_ANNOTATIONS);
 
     /** List of ignore annotations short names. */
     private final List<String> ignoreAnnotationShortNames =
             getClassShortNames(DEFAULT_IGNORE_ANNOTATIONS);
 
     /** Allows immutable fields to be declared as public. */
     private boolean allowPublicImmutableFields = true;
 
     /** List of immutable classes canonical names. */
     private List<String> immutableClassCanonicalNames = new ArrayList<>(DEFAULT_IMMUTABLE_TYPES);
 
     /** List of immutable classes short names. */
     private final List<String> immutableClassShortNames =
             getClassShortNames(DEFAULT_IMMUTABLE_TYPES);
 
     /**
      * Set the list of ignore annotations.
      * @param annotationNames array of ignore annotations canonical names.
      */
     public void setIgnoreAnnotationCanonicalNames(String... annotationNames) {
         ignoreAnnotationCanonicalNames = Arrays.asList(annotationNames);
     }
 
     /**
      * Set whether protected members are allowed.
      * @param protectedAllowed whether protected members are allowed
      */
     public void setProtectedAllowed(boolean protectedAllowed) {
@@ -466,172 +488,173 @@ public class VisibilityModifierCheck
             final String shortName = getClassShortName(canonicalName);
 
             // If imported canonical class name is not specified as allowed immutable class,
             // but its short name collides with one of specified class - removes the short name
             // from list to avoid names collision
             if (!immutableClassCanonicalNames.contains(canonicalName)
                      && immutableClassShortNames.contains(shortName)) {
                 immutableClassShortNames.remove(shortName);
             }
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName)) {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * {@code
      * import java.util.*;
      * }
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if current variable has proper access modifier according to Check's options.
      * @param variableDef Variable definition node.
      * @param variableName Variable's name.
      * @return true if variable has proper access modifier.
      */
     private boolean hasProperAccessModifier(DetailAST variableDef, String variableName) {
         boolean result = true;
 
         final String variableScope = getVisibilityScope(variableDef);
 
-        if (!"private".equals(variableScope)) {
+        if (!PRIVATE_ACCESS_MODIFIER.equals(variableScope)) {
             result =
                 isStaticFinalVariable(variableDef)
-                || packageAllowed && "package".equals(variableScope)
-                || protectedAllowed && "protected".equals(variableScope)
+                || packageAllowed && PACKAGE_ACCESS_MODIFIER.equals(variableScope)
+                || protectedAllowed && PROTECTED_ACCESS_MODIFIER.equals(variableScope)
                 || isIgnoredPublicMember(variableName, variableScope)
                    || allowPublicImmutableFields
                       && isImmutableFieldDefinedInFinalClass(variableDef);
         }
 
         return result;
     }
 
     /**
      * Checks whether variable has static final modifiers.
      * @param variableDef Variable definition node.
      * @return true of variable has static final modifiers.
      */
     private static boolean isStaticFinalVariable(DetailAST variableDef) {
         final Set<String> modifiers = getModifiers(variableDef);
-        return modifiers.contains("static") && modifiers.contains("final");
+        return modifiers.contains(STATIC_KEYWORD)
+                && modifiers.contains(FINAL_KEYWORD);
     }
 
     /**
      * Checks whether variable belongs to public members that should be ignored.
      * @param variableName Variable's name.
      * @param variableScope Variable's scope.
      * @return true if variable belongs to public members that should be ignored.
      */
     private boolean isIgnoredPublicMember(String variableName, String variableScope) {
-        return "public".equals(variableScope)
+        return PUBLIC_ACCESS_MODIFIER.equals(variableScope)
             && publicMemberPattern.matcher(variableName).find();
     }
 
     /**
      * Checks whether immutable field is defined in final class.
      * @param variableDef Variable definition node.
      * @return true if immutable field is defined in final class.
      */
     private boolean isImmutableFieldDefinedInFinalClass(DetailAST variableDef) {
         final DetailAST classDef = variableDef.getParent().getParent();
         final Set<String> classModifiers = getModifiers(classDef);
-        return classModifiers.contains("final") && isImmutableField(variableDef);
+        return classModifiers.contains(FINAL_KEYWORD) && isImmutableField(variableDef);
     }
 
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST) {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
 
     }
 
     /**
      * Returns the visibility scope for the variable.
      * @param variableDef Variable definition node.
      * @return one of "public", "private", "protected", "package"
      */
     private static String getVisibilityScope(DetailAST variableDef) {
         final Set<String> modifiers = getModifiers(variableDef);
-        String accessModifier = "package";
+        String accessModifier = PACKAGE_ACCESS_MODIFIER;
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
      * Checks if current field is immutable:
      * has final modifier and either a primitive type or instance of class
      * known to be immutable (such as String, ImmutableCollection from Guava and etc).
      * Classes known to be immutable are listed in
      * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
      * @param variableDef Field in consideration.
      * @return true if field is immutable.
      */
     private boolean isImmutableField(DetailAST variableDef) {
         boolean result = false;
 
         final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);
         final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
         if (isFinal) {
             final DetailAST type = variableDef.findFirstToken(TokenTypes.TYPE);
             final boolean isCanonicalName = type.getFirstChild().getType() == TokenTypes.DOT;
             final String typeName = getTypeName(type, isCanonicalName);
 
             result = !isCanonicalName && isPrimitive(type)
                      || immutableClassShortNames.contains(typeName)
                      || isCanonicalName && immutableClassCanonicalNames.contains(typeName);
         }
         return result;
     }
 
     /**
      * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
      * If type is specified via its canonical name - canonical name will be returned,
      * else - short type's name.
      * @param type {@link TokenTypes#TYPE TYPE} node.
      * @param isCanonicalName is given name canonical.
      * @return String representation of given type's name.
      */
     private static String getTypeName(DetailAST type, boolean isCanonicalName) {
         String typeName;
         if (isCanonicalName) {
             typeName = getCanonicalName(type);
         }
         else {
             typeName = type.getFirstChild().getText();
