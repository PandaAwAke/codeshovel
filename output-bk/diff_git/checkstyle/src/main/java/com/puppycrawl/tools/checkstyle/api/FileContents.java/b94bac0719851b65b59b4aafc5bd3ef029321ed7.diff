diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java
index 250d1b59a..0061966b4 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java
@@ -1,338 +1,338 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2014  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.api;
 
 import com.google.common.collect.ImmutableMap;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.puppycrawl.tools.checkstyle.grammars.CommentListener;
 import java.io.File;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Pattern;
 
 /**
  * Represents the contents of a file.
  *
  * @author Oliver Burn
  * @version 1.0
  */
 public final class FileContents implements CommentListener
 {
     /**
      * the pattern to match a single line comment containing only the comment
      * itself -- no code.
      */
     private static final String MATCH_SINGLELINE_COMMENT_PAT = "^\\s*//.*$";
     /** compiled regexp to match a single-line comment line */
     private static final Pattern MATCH_SINGLELINE_COMMENT = Pattern
             .compile(MATCH_SINGLELINE_COMMENT_PAT);
 
     /** the file name */
-    private final String mFilename;
+    private final String filename;
 
     /** the text */
-    private final FileText mText;
+    private final FileText text;
 
     /** map of the Javadoc comments indexed on the last line of the comment.
      * The hack is it assumes that there is only one Javadoc comment per line.
      */
-    private final Map<Integer, TextBlock> mJavadocComments = Maps.newHashMap();
+    private final Map<Integer, TextBlock> javadocComments = Maps.newHashMap();
     /** map of the C++ comments indexed on the first line of the comment. */
-    private final Map<Integer, TextBlock> mCPlusPlusComments =
+    private final Map<Integer, TextBlock> cPlusPlusComments =
         Maps.newHashMap();
 
     /**
      * map of the C comments indexed on the first line of the comment to a list
      * of comments on that line
      */
-    private final Map<Integer, List<TextBlock>> mCComments = Maps.newHashMap();
+    private final Map<Integer, List<TextBlock>> cComments = Maps.newHashMap();
 
     /**
      * Creates a new <code>FileContents</code> instance.
      *
-     * @param aFilename name of the file
-     * @param aLines the contents of the file
+     * @param filename name of the file
+     * @param lines the contents of the file
      * @deprecated Use {@link #FileContents(FileText)} instead
      *   in order to preserve the original line breaks where possible.
      */
-    @Deprecated public FileContents(String aFilename, String[] aLines)
+    @Deprecated public FileContents(String filename, String[] lines)
     {
-        mFilename = aFilename;
-        mText = FileText.fromLines(new File(aFilename), Arrays.asList(aLines));
+        this.filename = filename;
+        text = FileText.fromLines(new File(filename), Arrays.asList(lines));
     }
 
     /**
      * Creates a new <code>FileContents</code> instance.
      *
-     * @param aText the contents of the file
+     * @param text the contents of the file
      */
-    public FileContents(FileText aText)
+    public FileContents(FileText text)
     {
-        mFilename = aText.getFile().toString();
-        mText = aText;
+        filename = text.getFile().toString();
+        this.text = text;
     }
 
     /** {@inheritDoc} */
     @Override
-    public void reportSingleLineComment(String aType, int aStartLineNo,
-            int aStartColNo)
+    public void reportSingleLineComment(String type, int startLineNo,
+            int startColNo)
     {
-        reportCppComment(aStartLineNo, aStartColNo);
+        reportCppComment(startLineNo, startColNo);
     }
 
     /** {@inheritDoc} */
     @Override
-    public void reportBlockComment(String aType, int aStartLineNo,
-            int aStartColNo, int aEndLineNo, int aEndColNo)
+    public void reportBlockComment(String type, int startLineNo,
+            int startColNo, int endLineNo, int endColNo)
     {
-        reportCComment(aStartLineNo, aStartColNo, aEndLineNo, aEndColNo);
+        reportCComment(startLineNo, startColNo, endLineNo, endColNo);
     }
 
     /**
      * Report the location of a C++ style comment.
-     * @param aStartLineNo the starting line number
-     * @param aStartColNo the starting column number
+     * @param startLineNo the starting line number
+     * @param startColNo the starting column number
      **/
-    public void reportCppComment(int aStartLineNo, int aStartColNo)
+    public void reportCppComment(int startLineNo, int startColNo)
     {
-        final String line = line(aStartLineNo - 1);
-        final String[] txt = new String[] {line.substring(aStartColNo)};
-        final Comment comment = new Comment(txt, aStartColNo, aStartLineNo,
+        final String line = line(startLineNo - 1);
+        final String[] txt = new String[] {line.substring(startColNo)};
+        final Comment comment = new Comment(txt, startColNo, startLineNo,
                 line.length() - 1);
-        mCPlusPlusComments.put(aStartLineNo, comment);
+        cPlusPlusComments.put(startLineNo, comment);
     }
 
     /**
      * Returns a map of all the C++ style comments. The key is a line number,
      * the value is the comment {@link TextBlock} at the line.
      * @return the Map of comments
      */
     public ImmutableMap<Integer, TextBlock> getCppComments()
     {
-        return ImmutableMap.copyOf(mCPlusPlusComments);
+        return ImmutableMap.copyOf(cPlusPlusComments);
     }
 
     /**
      * Report the location of a C-style comment.
-     * @param aStartLineNo the starting line number
-     * @param aStartColNo the starting column number
-     * @param aEndLineNo the ending line number
-     * @param aEndColNo the ending column number
+     * @param startLineNo the starting line number
+     * @param startColNo the starting column number
+     * @param endLineNo the ending line number
+     * @param endColNo the ending column number
      **/
-    public void reportCComment(int aStartLineNo, int aStartColNo,
-            int aEndLineNo, int aEndColNo)
+    public void reportCComment(int startLineNo, int startColNo,
+            int endLineNo, int endColNo)
     {
-        final String[] cc = extractCComment(aStartLineNo, aStartColNo,
-                aEndLineNo, aEndColNo);
-        final Comment comment = new Comment(cc, aStartColNo, aEndLineNo,
-                aEndColNo);
+        final String[] cc = extractCComment(startLineNo, startColNo,
+                endLineNo, endColNo);
+        final Comment comment = new Comment(cc, startColNo, endLineNo,
+                endColNo);
 
         // save the comment
-        if (mCComments.containsKey(aStartLineNo)) {
-            final List<TextBlock> entries = mCComments.get(aStartLineNo);
+        if (cComments.containsKey(startLineNo)) {
+            final List<TextBlock> entries = cComments.get(startLineNo);
             entries.add(comment);
         }
         else {
             final List<TextBlock> entries = Lists.newArrayList();
             entries.add(comment);
-            mCComments.put(aStartLineNo, entries);
+            cComments.put(startLineNo, entries);
         }
 
         // Remember if possible Javadoc comment
-        if (line(aStartLineNo - 1).indexOf("/**", aStartColNo) != -1) {
-            mJavadocComments.put(aEndLineNo - 1, comment);
+        if (line(startLineNo - 1).indexOf("/**", startColNo) != -1) {
+            javadocComments.put(endLineNo - 1, comment);
         }
     }
 
     /**
      * Returns a map of all C style comments. The key is the line number, the
      * value is a {@link List} of C style comment {@link TextBlock}s
      * that start at that line.
      * @return the map of comments
      */
     public ImmutableMap<Integer, List<TextBlock>> getCComments()
     {
-        return ImmutableMap.copyOf(mCComments);
+        return ImmutableMap.copyOf(cComments);
     }
 
     /**
      * Returns the specified C comment as a String array.
      * @return C comment as a array
-     * @param aStartLineNo the starting line number
-     * @param aStartColNo the starting column number
-     * @param aEndLineNo the ending line number
-     * @param aEndColNo the ending column number
+     * @param startLineNo the starting line number
+     * @param startColNo the starting column number
+     * @param endLineNo the ending line number
+     * @param endColNo the ending column number
      **/
-    private String[] extractCComment(int aStartLineNo, int aStartColNo,
-            int aEndLineNo, int aEndColNo)
+    private String[] extractCComment(int startLineNo, int startColNo,
+            int endLineNo, int endColNo)
     {
         String[] retVal;
-        if (aStartLineNo == aEndLineNo) {
+        if (startLineNo == endLineNo) {
             retVal = new String[1];
-            retVal[0] = line(aStartLineNo - 1).substring(aStartColNo,
-                    aEndColNo + 1);
+            retVal[0] = line(startLineNo - 1).substring(startColNo,
+                    endColNo + 1);
         }
         else {
-            retVal = new String[aEndLineNo - aStartLineNo + 1];
-            retVal[0] = line(aStartLineNo - 1).substring(aStartColNo);
-            for (int i = aStartLineNo; i < aEndLineNo; i++) {
-                retVal[i - aStartLineNo + 1] = line(i);
+            retVal = new String[endLineNo - startLineNo + 1];
+            retVal[0] = line(startLineNo - 1).substring(startColNo);
+            for (int i = startLineNo; i < endLineNo; i++) {
+                retVal[i - startLineNo + 1] = line(i);
             }
-            retVal[retVal.length - 1] = line(aEndLineNo - 1).substring(0,
-                    aEndColNo + 1);
+            retVal[retVal.length - 1] = line(endLineNo - 1).substring(0,
+                    endColNo + 1);
         }
         return retVal;
     }
 
     /**
      * Returns the Javadoc comment before the specified line.
      * A return value of <code>null</code> means there is no such comment.
      * @return the Javadoc comment, or <code>null</code> if none
-     * @param aLineNo the line number to check before
+     * @param lineNo the line number to check before
      **/
-    public TextBlock getJavadocBefore(int aLineNo)
+    public TextBlock getJavadocBefore(int lineNoBefore)
     {
         // Lines start at 1 to the callers perspective, so need to take off 2
-        int lineNo = aLineNo - 2;
+        int lineNo = lineNoBefore - 2;
 
         // skip blank lines
         while ((lineNo > 0) && (lineIsBlank(lineNo) || lineIsComment(lineNo))) {
             lineNo--;
         }
 
-        return mJavadocComments.get(lineNo);
+        return javadocComments.get(lineNo);
     }
 
     /**
      * Get a single line.
      * For internal use only, as getText().get(lineNo) is just as
      * suitable for external use and avoids method duplication.
-     * @param aLineNo the number of the line to get
+     * @param lineNo the number of the line to get
      * @return the corresponding line, without terminator
      * @throws IndexOutOfBoundsException if lineNo is invalid
      */
-    private String line(int aLineNo)
+    private String line(int lineNo)
     {
-        return mText.get(aLineNo);
+        return text.get(lineNo);
     }
 
     /**
      * Get the full text of the file.
      * @return an object containing the full text of the file
      */
     public FileText getText()
     {
-        return mText;
+        return text;
     }
 
     /** @return the lines in the file */
     public String[] getLines()
     {
-        return mText.toLinesArray();
+        return text.toLinesArray();
     }
 
     /**
      * Get the line from text of the file.
-     * @param aIndex index of the line
+     * @param index index of the line
      * @return line from text of the file
      */
-    public String getLine(int aIndex)
+    public String getLine(int index)
     {
-        return mText.get(aIndex);
+        return text.get(index);
     }
 
     /** @return the name of the file */
     public String getFilename()
     {
-        return mFilename;
+        return filename;
     }
 
     /**
      * Checks if the specified line is blank.
-     * @param aLineNo the line number to check
+     * @param lineNo the line number to check
      * @return if the specified line consists only of tabs and spaces.
      **/
-    public boolean lineIsBlank(int aLineNo)
+    public boolean lineIsBlank(int lineNo)
     {
         // possible improvement: avoid garbage creation in trim()
-        return "".equals(line(aLineNo).trim());
+        return "".equals(line(lineNo).trim());
     }
 
     /**
      * Checks if the specified line is a single-line comment without code.
-     * @param aLineNo  the line number to check
+     * @param lineNo  the line number to check
      * @return if the specified line consists of only a single line comment
      *         without code.
      **/
-    public boolean lineIsComment(int aLineNo)
+    public boolean lineIsComment(int lineNo)
     {
-        return MATCH_SINGLELINE_COMMENT.matcher(line(aLineNo)).matches();
+        return MATCH_SINGLELINE_COMMENT.matcher(line(lineNo)).matches();
     }
 
     /**
      * Checks if the specified position intersects with a comment.
-     * @param aStartLineNo the starting line number
-     * @param aStartColNo the starting column number
-     * @param aEndLineNo the ending line number
-     * @param aEndColNo the ending column number
+     * @param startLineNo the starting line number
+     * @param startColNo the starting column number
+     * @param endLineNo the ending line number
+     * @param endColNo the ending column number
      * @return true if the positions intersects with a comment.
      **/
-    public boolean hasIntersectionWithComment(int aStartLineNo,
-            int aStartColNo, int aEndLineNo, int aEndColNo)
+    public boolean hasIntersectionWithComment(int startLineNo,
+            int startColNo, int endLineNo, int endColNo)
     {
         // Check C comments (all comments should be checked)
-        final Collection<List<TextBlock>> values = mCComments.values();
+        final Collection<List<TextBlock>> values = cComments.values();
         for (final List<TextBlock> row : values) {
             for (final TextBlock comment : row) {
-                if (comment.intersects(aStartLineNo, aStartColNo, aEndLineNo,
-                        aEndColNo))
+                if (comment.intersects(startLineNo, startColNo, endLineNo,
+                        endColNo))
                 {
                     return true;
                 }
             }
         }
 
         // Check CPP comments (line searching is possible)
-        for (int lineNumber = aStartLineNo; lineNumber <= aEndLineNo;
+        for (int lineNumber = startLineNo; lineNumber <= endLineNo;
              lineNumber++)
         {
-            final TextBlock comment = mCPlusPlusComments.get(lineNumber);
+            final TextBlock comment = cPlusPlusComments.get(lineNumber);
             if ((comment != null)
-                    && comment.intersects(aStartLineNo, aStartColNo,
-                            aEndLineNo, aEndColNo))
+                    && comment.intersects(startLineNo, startColNo,
+                            endLineNo, endColNo))
             {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Checks if the current file is a package-info.java file.
      * @return true if the package file.
      */
     public boolean inPackageInfo()
     {
         return this.getFilename().endsWith("package-info.java");
     }
 }
