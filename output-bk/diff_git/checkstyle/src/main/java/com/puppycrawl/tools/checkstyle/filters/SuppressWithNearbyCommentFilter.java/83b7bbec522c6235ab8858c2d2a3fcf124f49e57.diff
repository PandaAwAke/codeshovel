diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
index 68523ac1a..e3c6af713 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
@@ -161,106 +161,108 @@ public class SuppressWithNearbyCommentFilter
      * @param format a {@code String} value
      */
     public final void setInfluenceFormat(String format) {
         influenceFormat = format;
     }
 
     /**
      * Set whether to look in C++ comments.
      * @param checkCpp {@code true} if C++ comments are checked.
      */
     // -@cs[AbbreviationAsWordInName] We can not change it as,
     // check's property is a part of API (used in configurations).
     public void setCheckCPP(boolean checkCpp) {
         checkCPP = checkCpp;
     }
 
     /**
      * Set whether to look in C comments.
      * @param checkC {@code true} if C comments are checked.
      */
     public void setCheckC(boolean checkC) {
         this.checkC = checkC;
     }
 
     @Override
     public boolean accept(AuditEvent event) {
         boolean accepted = true;
 
         if (event.getLocalizedMessage() != null) {
             // Lazy update. If the first event for the current file, update file
             // contents and tag suppressions
             final FileContents currentContents = FileContentsHolder.getCurrentFileContents();
 
             if (getFileContents() != currentContents) {
                 setFileContents(currentContents);
                 tagSuppressions();
             }
             if (matchesTag(event)) {
                 accepted = false;
             }
         }
         return accepted;
     }
 
     /**
      * Whether current event matches any tag from {@link #tags}.
      * @param event AuditEvent to test match on {@link #tags}.
      * @return true if event matches any tag from {@link #tags}, false otherwise.
      */
     private boolean matchesTag(AuditEvent event) {
+        boolean result = false;
         for (final Tag tag : tags) {
             if (tag.isMatch(event)) {
-                return true;
+                result = true;
+                break;
             }
         }
-        return false;
+        return result;
     }
 
     /**
      * Collects all the suppression tags for all comments into a list and
      * sorts the list.
      */
     private void tagSuppressions() {
         tags.clear();
         final FileContents contents = getFileContents();
         if (checkCPP) {
             tagSuppressions(contents.getSingleLineComments().values());
         }
         if (checkC) {
             final Collection<List<TextBlock>> cComments =
                 contents.getBlockComments().values();
             cComments.forEach(this::tagSuppressions);
         }
         Collections.sort(tags);
     }
 
     /**
      * Appends the suppressions in a collection of comments to the full
      * set of suppression tags.
      * @param comments the set of comments.
      */
     private void tagSuppressions(Collection<TextBlock> comments) {
         for (final TextBlock comment : comments) {
             final int startLineNo = comment.getStartLineNo();
             final String[] text = comment.getText();
             tagCommentLine(text[0], startLineNo);
             for (int i = 1; i < text.length; i++) {
                 tagCommentLine(text[i], startLineNo + i);
             }
         }
     }
 
     /**
      * Tags a string if it matches the format for turning
      * checkstyle reporting on or the format for turning reporting off.
      * @param text the string to tag.
      * @param line the line number of text.
      */
     private void tagCommentLine(String text, int line) {
         final Matcher matcher = commentFormat.matcher(text);
         if (matcher.find()) {
             addTag(matcher.group(0), line);
         }
     }
 
     /**
@@ -308,105 +310,108 @@ public class SuppressWithNearbyCommentFilter
             try {
                 format = CommonUtils.fillTemplateWithStringsByRegexp(
                         filter.checkFormat, text, filter.commentFormat);
                 tagCheckRegexp = Pattern.compile(format);
                 if (filter.messageFormat == null) {
                     tagMessageRegexp = null;
                 }
                 else {
                     format = CommonUtils.fillTemplateWithStringsByRegexp(
                             filter.messageFormat, text, filter.commentFormat);
                     tagMessageRegexp = Pattern.compile(format);
                 }
                 format = CommonUtils.fillTemplateWithStringsByRegexp(
                         filter.influenceFormat, text, filter.commentFormat);
                 final int influence;
                 try {
                     if (CommonUtils.startsWithChar(format, '+')) {
                         format = format.substring(1);
                     }
                     influence = Integer.parseInt(format);
                 }
                 catch (final NumberFormatException ex) {
                     throw new IllegalArgumentException("unable to parse influence from '" + text
                             + "' using " + filter.influenceFormat, ex);
                 }
                 if (influence >= 0) {
                     firstLine = line;
                     lastLine = line + influence;
                 }
                 else {
                     firstLine = line + influence;
                     lastLine = line;
                 }
             }
             catch (final PatternSyntaxException ex) {
                 throw new IllegalArgumentException(
                     "unable to parse expanded comment " + format, ex);
             }
         }
 
         /**
          * Compares the position of this tag in the file
          * with the position of another tag.
          * @param other the tag to compare with this one.
          * @return a negative number if this tag is before the other tag,
          *     0 if they are at the same position, and a positive number if this
          *     tag is after the other tag.
          */
         @Override
         public int compareTo(Tag other) {
+            final int result;
             if (firstLine == other.firstLine) {
-                return Integer.compare(lastLine, other.lastLine);
+                result = Integer.compare(lastLine, other.lastLine);
             }
-
-            return Integer.compare(firstLine, other.firstLine);
+            else {
+                result = Integer.compare(firstLine, other.firstLine);
+            }
+            return result;
         }
 
         @Override
         public boolean equals(Object other) {
             if (this == other) {
                 return true;
             }
             if (other == null || getClass() != other.getClass()) {
                 return false;
             }
             final Tag tag = (Tag) other;
             return Objects.equals(firstLine, tag.firstLine)
                     && Objects.equals(lastLine, tag.lastLine)
                     && Objects.equals(text, tag.text)
                     && Objects.equals(tagCheckRegexp, tag.tagCheckRegexp)
                     && Objects.equals(tagMessageRegexp, tag.tagMessageRegexp);
         }
 
         @Override
         public int hashCode() {
             return Objects.hash(text, firstLine, lastLine, tagCheckRegexp, tagMessageRegexp);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param event the {@code AuditEvent} to check.
          * @return true if the source of event matches the text of this tag.
          */
         public boolean isMatch(AuditEvent event) {
             final int line = event.getLine();
             boolean match = false;
 
             if (line >= firstLine && line <= lastLine) {
                 final Matcher tagMatcher = tagCheckRegexp.matcher(event.getSourceName());
 
                 if (tagMatcher.find()) {
                     match = true;
                 }
                 else if (tagMessageRegexp == null) {
                     if (event.getModuleId() != null) {
                         final Matcher idMatcher = tagCheckRegexp.matcher(event.getModuleId());
                         match = idMatcher.find();
                     }
                 }
                 else {
                     final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
                     match = messageMatcher.find();
                 }
             }
