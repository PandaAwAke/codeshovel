diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 7b2ee2dbc..6893f89b9 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -582,188 +582,188 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),
                         javadocArgMatcher.group(2)));
             }
             else if (javadocNoargMatcher.find()) {
                 final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);
                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));
             }
             else if (noargCurlyMatcher.find()) {
                 final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);
                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));
             }
             else if (argMultilineStart.find()) {
                 final int col = calculateTagColumn(argMultilineStart, i, startColumnNumber);
                 tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));
             }
             else if (noargMultilineStart.find()) {
                 tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));
             }
         }
         return tags;
     }
 
     /**
      * Calculates column number using Javadoc tag matcher.
      * @param javadocTagMatcher found javadoc tag matcher
      * @param lineNumber line number of Javadoc tag in comment
      * @param startColumnNumber column number of Javadoc comment beginning
      * @return column number
      */
     private static int calculateTagColumn(Matcher javadocTagMatcher,
             int lineNumber, int startColumnNumber) {
         int col = javadocTagMatcher.start(1) - 1;
         if (lineNumber == 0) {
             col += startColumnNumber;
         }
         return col;
     }
 
     /**
      * Gets multiline Javadoc tags with arguments.
      * @param argMultilineStart javadoc tag Matcher
      * @param column column number of Javadoc tag
      * @param lines comment text lines
      * @param lineIndex line number that contains the javadoc tag
      * @param tagLine javadoc tag line number in file
      * @return javadoc tags with arguments
      */
     private static List<JavadocTag> getMultilineArgTags(final Matcher argMultilineStart,
             final int column, final String[] lines, final int lineIndex, final int tagLine) {
         final List<JavadocTag> tags = new ArrayList<>();
-        final String p1 = argMultilineStart.group(1);
-        final String p2 = argMultilineStart.group(2);
+        final String param1 = argMultilineStart.group(1);
+        final String param2 = argMultilineStart.group(2);
         int remIndex = lineIndex + 1;
         while (remIndex < lines.length) {
             final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);
             if (multilineCont.find()) {
                 remIndex = lines.length;
                 final String lFin = multilineCont.group(1);
                 if (!lFin.equals(NEXT_TAG)
                     && !lFin.equals(END_JAVADOC)) {
-                    tags.add(new JavadocTag(tagLine, column, p1, p2));
+                    tags.add(new JavadocTag(tagLine, column, param1, param2));
                 }
             }
             remIndex++;
         }
         return tags;
     }
 
     /**
      * Gets multiline Javadoc tags with no arguments.
      * @param noargMultilineStart javadoc tag Matcher
      * @param lines comment text lines
      * @param lineIndex line number that contains the javadoc tag
      * @param tagLine javadoc tag line number in file
      * @return javadoc tags with no arguments
      */
     private static List<JavadocTag> getMultilineNoArgTags(final Matcher noargMultilineStart,
             final String[] lines, final int lineIndex, final int tagLine) {
-        final String p1 = noargMultilineStart.group(1);
+        final String param1 = noargMultilineStart.group(1);
         final int col = noargMultilineStart.start(1) - 1;
         final List<JavadocTag> tags = new ArrayList<>();
         int remIndex = lineIndex + 1;
         while (remIndex < lines.length) {
             final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
                     .matcher(lines[remIndex]);
             multilineCont.find();
             remIndex = lines.length;
             final String lFin = multilineCont.group(1);
             if (!lFin.equals(NEXT_TAG)
                 && !lFin.equals(END_JAVADOC)) {
-                tags.add(new JavadocTag(tagLine, col, p1));
+                tags.add(new JavadocTag(tagLine, col, param1));
             }
             remIndex++;
         }
 
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private static List<DetailAST> getParameters(DetailAST ast) {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
         final List<DetailAST> retVal = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = child.getNextSibling();
         }
         return retVal;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
         final List<ExceptionInfo> retVal = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
-                    final FullIdent fi = FullIdent.createFullIdent(child);
-                    final ExceptionInfo ei = new ExceptionInfo(createClassInfo(new Token(fi),
-                            getCurrentClassName()));
-                    retVal.add(ei);
+                    final FullIdent ident = FullIdent.createFullIdent(child);
+                    final ExceptionInfo exceptionInfo = new ExceptionInfo(
+                            createClassInfo(new Token(ident), getCurrentClassName()));
+                    retVal.add(exceptionInfo);
                 }
                 child = child.getNextSibling();
             }
         }
         return retVal;
     }
 
     /**
      * Checks a set of tags for matching parameters.
      *
      * @param tags the tags to check
      * @param parent the node which takes the parameters
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkParamTags(final List<JavadocTag> tags,
             final DetailAST parent, boolean reportExpectedTags) {
         final List<DetailAST> params = getParameters(parent);
         final List<DetailAST> typeParams = CheckUtils
                 .getTypeParameters(parent);
 
         // Loop over the tags, checking to see they exist in the params.
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isParamTag()) {
                 continue;
             }
 
             tagIt.remove();
 
             final String arg1 = tag.getFirstArg();
             boolean found = removeMatchingParam(params, arg1);
 
             if (CommonUtils.startsWithChar(arg1, '<') && CommonUtils.endsWithChar(arg1, '>')) {
                 found = searchMatchingTypeParameter(typeParams,
                         arg1.substring(1, arg1.length() - 1));
 
             }
 
             // Handle extra JavadocTag
             if (!found) {
                 log(tag.getLineNo(), tag.getColumnNo(), MSG_UNUSED_TAG,
                         "@param", arg1);
             }
         }
 
         // Now dump out all type parameters/parameters without tags :- unless
         // the user has chosen to suppress these problems
@@ -796,215 +796,215 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
         final Iterator<DetailAST> typeParamsIt = typeParams.iterator();
         boolean found = false;
         while (typeParamsIt.hasNext()) {
             final DetailAST typeParam = typeParamsIt.next();
             if (typeParam.findFirstToken(TokenTypes.IDENT).getText()
                     .equals(requiredTypeName)) {
                 found = true;
                 typeParamsIt.remove();
                 break;
             }
         }
         return found;
     }
 
     /**
      * Remove parameter from params collection by name.
      * @param params collection of DetailAST parameters
      * @param paramName name of parameter
      * @return true if parameter found and removed
      */
     private static boolean removeMatchingParam(List<DetailAST> params, String paramName) {
         boolean found = false;
         final Iterator<DetailAST> paramIt = params.iterator();
         while (paramIt.hasNext()) {
             final DetailAST param = paramIt.next();
             if (param.getText().equals(paramName)) {
                 found = true;
                 paramIt.remove();
                 break;
             }
         }
         return found;
     }
 
     /**
      * Checks for only one return tag. All return tags will be removed from the
      * supplied list.
      *
      * @param tags the tags to check
      * @param lineNo the line number of the expected tag
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkReturnTag(List<JavadocTag> tags, int lineNo,
         boolean reportExpectedTags) {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator<JavadocTag> it = tags.listIterator();
         while (it.hasNext()) {
-            final JavadocTag jt = it.next();
-            if (jt.isReturnTag()) {
+            final JavadocTag javadocTag = it.next();
+            if (javadocTag.isReturnTag()) {
                 if (found) {
-                    log(jt.getLineNo(), jt.getColumnNo(),
-                        MSG_DUPLICATE_TAG,
-                        JavadocTagInfo.RETURN.getText());
+                    log(javadocTag.getLineNo(), javadocTag.getColumnNo(),
+                            MSG_DUPLICATE_TAG,
+                            JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !allowMissingReturnTag && reportExpectedTags) {
             log(lineNo, MSG_RETURN_EXPECTED);
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getFirstArg();
             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag
                     .getColumnNo());
             final AbstractClassInfo documentedCI = createClassInfo(token,
                     getCurrentClassName());
             final boolean found = foundThrows.contains(documentedEx)
                     || isInThrows(throwsList, documentedCI, foundThrows);
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedCI.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());
 
                 }
             }
         }
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
             for (ExceptionInfo ei : throwsList) {
                 if (!ei.isFound()) {
-                    final Token fi = ei.getName();
-                    log(fi.getLineNo(), fi.getColumnNo(),
+                    final Token token = ei.getName();
+                    log(token.getLineNo(), token.getColumnNo(),
                             MSG_EXPECTED_TAG,
-                        JavadocTagInfo.THROWS.getText(), fi.getText());
+                            JavadocTagInfo.THROWS.getText(), token.getText());
                 }
             }
         }
     }
 
     /**
      * Verifies that documented exception is in throws.
      *
      * @param throwsList list of throws
      * @param documentedCI documented exception class info
      * @param foundThrows previously found throws
      * @return true if documented exception is in throws.
      */
     private boolean isInThrows(List<ExceptionInfo> throwsList,
             AbstractClassInfo documentedCI, Set<String> foundThrows) {
         boolean found = false;
         ExceptionInfo foundException = null;
 
         // First look for matches on the exception name
         final ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();
         while (!found && throwIt.hasNext()) {
-            final ExceptionInfo ei = throwIt.next();
+            final ExceptionInfo exceptionInfo = throwIt.next();
 
-            if (ei.getName().getText().equals(
+            if (exceptionInfo.getName().getText().equals(
                     documentedCI.getName().getText())) {
                 found = true;
-                foundException = ei;
+                foundException = exceptionInfo;
             }
         }
 
         // Now match on the exception type
         final ListIterator<ExceptionInfo> exceptionInfoIt = throwsList.listIterator();
         while (!found && exceptionInfoIt.hasNext()) {
-            final ExceptionInfo ei = exceptionInfoIt.next();
+            final ExceptionInfo exceptionInfo = exceptionInfoIt.next();
 
-            if (documentedCI.getClazz() == ei.getClazz()) {
+            if (documentedCI.getClazz() == exceptionInfo.getClazz()) {
                 found = true;
-                foundException = ei;
+                foundException = exceptionInfo;
             }
             else if (allowThrowsTagsForSubclasses) {
-                found = isSubclass(documentedCI.getClazz(), ei.getClazz());
+                found = isSubclass(documentedCI.getClazz(), exceptionInfo.getClazz());
             }
         }
 
         if (foundException != null) {
             foundException.setFound();
             foundThrows.add(documentedCI.getName().getText());
         }
 
         return found;
     }
 
     /** Stores useful information about declared exception. */
     private static class ExceptionInfo {
         /** Does the exception have throws tag associated with. */
         private boolean found;
         /** Class information associated with this exception. */
         private final AbstractClassInfo classInfo;
 
         /**
          * Creates new instance for {@code FullIdent}.
          *
          * @param classInfo class info
          */
         ExceptionInfo(AbstractClassInfo classInfo) {
             this.classInfo = classInfo;
         }
 
         /** Mark that the exception has associated throws tag. */
         final void setFound() {
             found = true;
         }
 
         /**
          * Checks that the exception has throws tag associated with it.
          * @return whether the exception has throws tag associated with
          */
         final boolean isFound() {
             return found;
         }
 
         /**
          * Gets exception name.
          * @return exception's name
          */
         final Token getName() {
             return classInfo.getName();
         }
 
         /**
          * Gets exception class.
