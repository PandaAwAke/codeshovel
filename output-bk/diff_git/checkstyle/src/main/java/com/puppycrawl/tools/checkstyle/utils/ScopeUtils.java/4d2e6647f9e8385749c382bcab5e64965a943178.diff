diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtils.java
index da1185151..986d818eb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtils.java
@@ -52,203 +52,203 @@ public final class ScopeUtils {
             }
             else if ("protected".equals(token.getText())) {
                 retVal = Scope.PROTECTED;
             }
             else if ("private".equals(token.getText())) {
                 retVal = Scope.PRIVATE;
             }
         }
         return retVal;
     }
 
     /**
      * Returns the scope of the surrounding "block".
      * @param aAST the node to return the scope for
      * @return the Scope of the surrounding block
      */
     public static Scope getSurroundingScope(DetailAST aAST) {
         Scope retVal = null;
         for (DetailAST token = aAST.getParent();
              token != null;
              token = token.getParent()) {
             final int type = token.getType();
             if (type == TokenTypes.CLASS_DEF
                 || type == TokenTypes.INTERFACE_DEF
                 || type == TokenTypes.ANNOTATION_DEF
                 || type == TokenTypes.ENUM_DEF) {
                 final DetailAST mods =
                     token.findFirstToken(TokenTypes.MODIFIERS);
                 final Scope modScope = getScopeFromMods(mods);
                 if (retVal == null || retVal.isIn(modScope)) {
                     retVal = modScope;
                 }
             }
             else if (type == TokenTypes.LITERAL_NEW) {
                 retVal = Scope.ANONINNER;
                 // because Scope.ANONINNER is not in any other Scope
                 break;
             }
         }
 
         return retVal;
     }
 
     /**
      * Returns whether a node is directly contained within an interface block.
      *
      * @param aAST the node to check if directly contained within an interface
      * block
      * @return a {@code boolean} value
      */
-    public static boolean inInterfaceBlock(DetailAST aAST) {
+    public static boolean isInInterfaceBlock(DetailAST aAST) {
         boolean retVal = false;
 
         // Loop up looking for a containing interface block
         for (DetailAST token = aAST.getParent();
              token != null && !retVal;
              token = token.getParent()) {
 
             final int type = token.getType();
 
             if (type == TokenTypes.INTERFACE_DEF) {
                 retVal = true;
             }
             else if (type == TokenTypes.CLASS_DEF
                 || type == TokenTypes.ENUM_DEF
                 || type == TokenTypes.ANNOTATION_DEF
                 || type == TokenTypes.LITERAL_NEW) {
                 break;
             }
         }
 
         return retVal;
     }
 
     /**
      * Returns whether a node is directly contained within an annotation block.
      *
      * @param aAST the node to check if directly contained within an annotation
      * block
      * @return a {@code boolean} value
      */
-    public static boolean inAnnotationBlock(DetailAST aAST) {
+    public static boolean isInAnnotationBlock(DetailAST aAST) {
         boolean retVal = false;
 
         // Loop up looking for a containing interface block
         for (DetailAST token = aAST.getParent();
              token != null && !retVal;
              token = token.getParent()) {
             final int type = token.getType();
             if (type == TokenTypes.ANNOTATION_DEF) {
                 retVal = true;
             }
             else if (type == TokenTypes.CLASS_DEF
                 || type == TokenTypes.ENUM_DEF
                 || type == TokenTypes.INTERFACE_DEF
                 || type == TokenTypes.LITERAL_NEW) {
                 break;
             }
 
         }
 
         return retVal;
     }
 
     /**
      * Returns whether a node is directly contained within an interface or
      * annotation block.
      *
      * @param aAST the node to check if directly contained within an interface
      * or annotation block
      * @return a {@code boolean} value
      */
-    public static boolean inInterfaceOrAnnotationBlock(DetailAST aAST) {
-        return inInterfaceBlock(aAST) || inAnnotationBlock(aAST);
+    public static boolean isInInterfaceOrAnnotationBlock(DetailAST aAST) {
+        return isInInterfaceBlock(aAST) || isInAnnotationBlock(aAST);
     }
 
     /**
      * Returns whether a node is directly contained within an enum block.
      *
      * @param aAST the node to check if directly contained within an enum
      * block
      * @return a {@code boolean} value
      */
-    public static boolean inEnumBlock(DetailAST aAST) {
+    public static boolean isInEnumBlock(DetailAST aAST) {
         boolean retVal = false;
 
         // Loop up looking for a containing interface block
         for (DetailAST token = aAST.getParent();
              token != null && !retVal;
              token = token.getParent()) {
             final int type = token.getType();
             if (type == TokenTypes.ENUM_DEF) {
                 retVal = true;
             }
             else if (type == TokenTypes.INTERFACE_DEF
                 || type == TokenTypes.ANNOTATION_DEF
                 || type == TokenTypes.CLASS_DEF
                 || type == TokenTypes.LITERAL_NEW) {
                 break;
             }
         }
 
         return retVal;
     }
 
     /**
      * Returns whether the scope of a node is restricted to a code block.
      * A code block is a method or constructor body, or a initialiser block.
      *
      * @param aAST the node to check
      * @return a {@code boolean} value
      */
-    public static boolean inCodeBlock(DetailAST aAST) {
+    public static boolean isInCodeBlock(DetailAST aAST) {
         boolean retVal = false;
 
         // Loop up looking for a containing code block
         for (DetailAST token = aAST.getParent();
              token != null;
              token = token.getParent()) {
             final int type = token.getType();
             if (type == TokenTypes.METHOD_DEF
                 || type == TokenTypes.CTOR_DEF
                 || type == TokenTypes.INSTANCE_INIT
                 || type == TokenTypes.STATIC_INIT) {
                 retVal = true;
                 break;
             }
         }
 
         return retVal;
     }
 
     /**
      * Returns whether a node is contained in the outer most type block.
      *
      * @param aAST the node to check
      * @return a {@code boolean} value
      */
     public static boolean isOuterMostType(DetailAST aAST) {
         boolean retVal = true;
         for (DetailAST parent = aAST.getParent();
              parent != null;
              parent = parent.getParent()) {
             if (parent.getType() == TokenTypes.CLASS_DEF
                 || parent.getType() == TokenTypes.INTERFACE_DEF
                 || parent.getType() == TokenTypes.ANNOTATION_DEF
                 || parent.getType() == TokenTypes.ENUM_DEF) {
                 retVal = false;
                 break;
             }
         }
 
         return retVal;
     }
 
     /**
      * Determines whether a node is a local variable definition.
      * I.e. if it is declared in a code block, a for initializer,
      * or a catch parameter.
      * @param aAST the node to check.
      * @return whether aAST is a local variable definition.
      */
     public static boolean isLocalVariableDef(DetailAST aAST) {
