diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index f24313601..6ca38808d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -337,369 +337,369 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
                         final String instanceName =
                             getInstanceName(methodCallAst);
                         // method is called without instance
                         if (instanceName.isEmpty()) {
                             result = false;
                         }
                         // differs from previous instance
                         else if (!instanceName.equals(initInstanceName)) {
                             if (!initInstanceName.isEmpty()) {
                                 result = false;
                             }
                             else {
                                 initInstanceName = instanceName;
                             }
                         }
                     }
                     else { // is not method call
                         result = false;
                     }
                     break;
 
                 case TokenTypes.VARIABLE_DEF:
                     final String currentVariableName = currentSiblingAst
                         .findFirstToken(TokenTypes.IDENT).getText();
                     isUsedVariableDeclarationFound = variableName.equals(currentVariableName);
                     break;
 
                 case TokenTypes.SEMI:
                     break;
 
                 default:
                     result = false;
             }
 
             currentSiblingAst = currentSiblingAst.getPreviousSibling();
         }
 
         return result;
     }
 
     /**
      * Calculates distance between declaration of variable and its first usage
      * in single scope.
      * @param semicolonAst
      *        Regular node of Ast which is checked for content of checking
      *        variable.
      * @param variableIdentAst
      *        Variable which distance is calculated for.
      * @return entry which contains expression with variable usage and distance.
      */
-    private Entry<DetailAST, Integer> calculateDistanceInSingleScope(
+    private static Entry<DetailAST, Integer> calculateDistanceInSingleScope(
             DetailAST semicolonAst, DetailAST variableIdentAst) {
         int dist = 0;
         boolean firstUsageFound = false;
         DetailAST currentAst = semicolonAst;
         DetailAST variableUsageAst = null;
 
         while (!firstUsageFound && currentAst != null
                 && currentAst.getType() != TokenTypes.RCURLY) {
             if (currentAst.getFirstChild() != null) {
 
                 if (isChild(currentAst, variableIdentAst)) {
 
                     switch (currentAst.getType()) {
                         case TokenTypes.VARIABLE_DEF:
                             dist++;
                             break;
                         case TokenTypes.SLIST:
                             dist = 0;
                             break;
                         case TokenTypes.LITERAL_FOR:
                         case TokenTypes.LITERAL_WHILE:
                         case TokenTypes.LITERAL_DO:
                         case TokenTypes.LITERAL_IF:
                         case TokenTypes.LITERAL_SWITCH:
                             if (isVariableInOperatorExpr(currentAst, variableIdentAst)) {
                                 dist++;
                             }
                             else { // variable usage is in inner scope
                                 // reset counters, because we can't determine distance
                                 dist = 0;
                             }
                             break;
                         default:
                             if (currentAst.branchContains(TokenTypes.SLIST)) {
                                 dist = 0;
                             }
                             else {
                                 dist++;
                             }
                     }
                     variableUsageAst = currentAst;
                     firstUsageFound = true;
                 }
                 else if (currentAst.getType() != TokenTypes.VARIABLE_DEF) {
                     dist++;
                 }
             }
             currentAst = currentAst.getNextSibling();
         }
 
         // If variable wasn't used after its declaration, distance is 0.
         if (!firstUsageFound) {
             dist = 0;
         }
 
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Calculates distance between declaration of variable and its first usage
      * in multiple scopes.
      * @param ast
      *        Regular node of Ast which is checked for content of checking
      *        variable.
      * @param variable
      *        Variable which distance is calculated for.
      * @return entry which contains expression with variable usage and distance.
      */
-    private Entry<DetailAST, Integer> calculateDistanceBetweenScopes(
+    private static Entry<DetailAST, Integer> calculateDistanceBetweenScopes(
             DetailAST ast, DetailAST variable) {
         int dist = 0;
         DetailAST currentScopeAst = ast;
         DetailAST variableUsageAst = null;
         while (currentScopeAst != null) {
             final List<DetailAST> variableUsageExpressions = new ArrayList<>();
             DetailAST currentStatementAst = currentScopeAst;
             currentScopeAst = null;
             while (currentStatementAst != null
                     && currentStatementAst.getType() != TokenTypes.RCURLY) {
                 if (currentStatementAst.getFirstChild() != null) {
                     if (isChild(currentStatementAst, variable)) {
                         variableUsageExpressions.add(currentStatementAst);
                     }
                     // If expression doesn't contain variable and this variable
                     // hasn't been met yet, than distance + 1.
                     else if (variableUsageExpressions.isEmpty()
                             && currentStatementAst.getType() != TokenTypes.VARIABLE_DEF) {
                         dist++;
                     }
                 }
                 currentStatementAst = currentStatementAst.getNextSibling();
             }
             // If variable usage exists in a single scope, then look into
             // this scope and count distance until variable usage.
             if (variableUsageExpressions.size() == 1) {
                 final DetailAST blockWithVariableUsage = variableUsageExpressions
                         .get(0);
                 DetailAST exprWithVariableUsage = null;
                 switch (blockWithVariableUsage.getType()) {
                     case TokenTypes.VARIABLE_DEF:
                     case TokenTypes.EXPR:
                         dist++;
                         break;
                     case TokenTypes.LITERAL_FOR:
                     case TokenTypes.LITERAL_WHILE:
                     case TokenTypes.LITERAL_DO:
                         exprWithVariableUsage = getFirstNodeInsideForWhileDoWhileBlocks(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_IF:
                         exprWithVariableUsage = getFirstNodeInsideIfBlock(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_SWITCH:
                         exprWithVariableUsage = getFirstNodeInsideSwitchBlock(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_TRY:
                         exprWithVariableUsage =
                             getFirstNodeInsideTryCatchFinallyBlocks(blockWithVariableUsage,
                                 variable);
                         break;
                     default:
                         exprWithVariableUsage = blockWithVariableUsage.getFirstChild();
                 }
                 currentScopeAst = exprWithVariableUsage;
                 if (exprWithVariableUsage != null) {
                     variableUsageAst = exprWithVariableUsage;
                 }
                 else {
                     variableUsageAst = blockWithVariableUsage;
                 }
             }
             // If variable usage exists in different scopes, then distance =
             // distance until variable first usage.
             else if (variableUsageExpressions.size() > 1) {
                 dist++;
                 variableUsageAst = variableUsageExpressions.get(0);
             }
             // If there's no any variable usage, then distance = 0.
             else {
                 variableUsageAst = null;
             }
         }
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Gets first Ast node inside FOR, WHILE or DO-WHILE blocks if variable
      * usage is met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents FOR, WHILE or DO-WHILE block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
-    private DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
+    private static DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = null;
 
             // Find currentNode for DO-WHILE block.
             if (block.getType() == TokenTypes.LITERAL_DO) {
                 currentNode = block.getFirstChild();
             }
             // Find currentNode for FOR or WHILE block.
             else {
                 // Looking for RPAREN ( ')' ) token to mark the end of operator
                 // expression.
                 currentNode = block.findFirstToken(TokenTypes.RPAREN);
                 if (currentNode != null) {
                     currentNode = currentNode.getNextSibling();
                 }
             }
 
             if (currentNode != null) {
                 final int currentNodeType = currentNode.getType();
 
                 if (currentNodeType == TokenTypes.SLIST) {
                     firstNodeInsideBlock = currentNode.getFirstChild();
                 }
                 else if (currentNodeType != TokenTypes.VARIABLE_DEF
                         && currentNodeType != TokenTypes.EXPR) {
                     firstNodeInsideBlock = currentNode;
                 }
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside IF block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents IF block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
-    private DetailAST getFirstNodeInsideIfBlock(
+    private static DetailAST getFirstNodeInsideIfBlock(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = block.getLastChild();
             final List<DetailAST> variableUsageExpressions =
                     new ArrayList<>();
 
             while (currentNode != null
                     && currentNode.getType() == TokenTypes.LITERAL_ELSE) {
                 final DetailAST previousNode =
                         currentNode.getPreviousSibling();
 
                 // Checking variable usage inside IF block.
                 if (isChild(previousNode, variable)) {
                     variableUsageExpressions.add(previousNode);
                 }
 
                 // Looking into ELSE block, get its first child and analyze it.
                 currentNode = currentNode.getFirstChild();
 
                 if (currentNode.getType() == TokenTypes.LITERAL_IF) {
                     currentNode = currentNode.getLastChild();
                 }
                 else if (isChild(currentNode, variable)) {
                     variableUsageExpressions.add(currentNode);
                     currentNode = null;
                 }
             }
 
             // If IF block doesn't include ELSE than analyze variable usage
             // only inside IF block.
             if (currentNode != null
                     && isChild(currentNode, variable)) {
                 variableUsageExpressions.add(currentNode);
             }
 
             // If variable usage exists in several related blocks, then
             // firstNodeInsideBlock = null, otherwise if variable usage exists
             // only inside one block, then get node from
             // variableUsageExpressions.
             if (variableUsageExpressions.size() == 1) {
                 firstNodeInsideBlock = variableUsageExpressions.get(0);
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside SWITCH block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents SWITCH block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
-    private DetailAST getFirstNodeInsideSwitchBlock(
+    private static DetailAST getFirstNodeInsideSwitchBlock(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = block
                     .findFirstToken(TokenTypes.CASE_GROUP);
             final List<DetailAST> variableUsageExpressions =
                     new ArrayList<>();
 
             // Checking variable usage inside all CASE blocks.
             while (currentNode != null
                     && currentNode.getType() == TokenTypes.CASE_GROUP) {
                 final DetailAST lastNodeInCaseGroup =
                         currentNode.getLastChild();
 
                 if (isChild(lastNodeInCaseGroup, variable)) {
                     variableUsageExpressions.add(lastNodeInCaseGroup);
                 }
                 currentNode = currentNode.getNextSibling();
             }
 
             // If variable usage exists in several related blocks, then
             // firstNodeInsideBlock = null, otherwise if variable usage exists
             // only inside one block, then get node from
             // variableUsageExpressions.
             if (variableUsageExpressions.size() == 1) {
                 firstNodeInsideBlock = variableUsageExpressions.get(0);
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside TRY-CATCH-FINALLY blocks if variable usage is
      * met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents TRY-CATCH-FINALLY block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideTryCatchFinallyBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST currentNode = block.getFirstChild();
         final List<DetailAST> variableUsageExpressions =
                 new ArrayList<>();
 
@@ -711,101 +711,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
         // Switch on CATCH block.
         currentNode = currentNode.getNextSibling();
 
         // Checking variable usage inside all CATCH blocks.
         while (currentNode != null
                 && currentNode.getType() == TokenTypes.LITERAL_CATCH) {
             final DetailAST catchBlock = currentNode.getLastChild();
 
             if (isChild(catchBlock, variable)) {
                 variableUsageExpressions.add(catchBlock);
             }
             currentNode = currentNode.getNextSibling();
         }
 
         // Checking variable usage inside FINALLY block.
         if (currentNode != null) {
             final DetailAST finalBlock = currentNode.getLastChild();
 
             if (isChild(finalBlock, variable)) {
                 variableUsageExpressions.add(finalBlock);
             }
         }
 
         DetailAST variableUsageNode = null;
 
         // If variable usage exists in several related blocks, then
         // firstNodeInsideBlock = null, otherwise if variable usage exists
         // only inside one block, then get node from
         // variableUsageExpressions.
         if (variableUsageExpressions.size() == 1) {
             variableUsageNode = variableUsageExpressions.get(0).getFirstChild();
         }
 
         return variableUsageNode;
     }
 
     /**
      * Checks if variable is in operator declaration. For instance:
      * <pre>
      * boolean b = true;
      * if (b) {...}
      * </pre>
      * Variable 'b' is in declaration of operator IF.
      * @param operator
      *        Ast node which represents operator.
      * @param variable
      *        Variable which is checked for content in operator.
      * @return true if operator contains variable in its declaration, otherwise
      *         - false.
      */
-    private boolean isVariableInOperatorExpr(
+    private static boolean isVariableInOperatorExpr(
             DetailAST operator, DetailAST variable) {
         boolean isVarInOperatorDeclr = false;
         final DetailAST openingBracket =
                 operator.findFirstToken(TokenTypes.LPAREN);
 
         if (openingBracket != null) {
             // Get EXPR between brackets
             DetailAST exprBetweenBrackets = openingBracket
                     .getNextSibling();
 
             // Look if variable is in operator expression
             while (exprBetweenBrackets.getType() != TokenTypes.RPAREN) {
 
                 if (isChild(exprBetweenBrackets, variable)) {
                     isVarInOperatorDeclr = true;
                     break;
                 }
                 exprBetweenBrackets = exprBetweenBrackets.getNextSibling();
             }
 
             // Variable may be met in ELSE declaration or in CASE declaration.
             // So, check variable usage in these declarations.
             if (!isVarInOperatorDeclr) {
                 switch (operator.getType()) {
                     case TokenTypes.LITERAL_IF:
                         final DetailAST elseBlock = operator.getLastChild();
 
                         if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
                             // Get IF followed by ELSE
                             final DetailAST firstNodeInsideElseBlock = elseBlock
                                 .getFirstChild();
 
                             if (firstNodeInsideElseBlock.getType()
                                 == TokenTypes.LITERAL_IF) {
                                 isVarInOperatorDeclr |=
                                     isVariableInOperatorExpr(
                                         firstNodeInsideElseBlock,
                                             variable);
                             }
                         }
                         break;
 
                     case TokenTypes.LITERAL_SWITCH:
                         DetailAST currentCaseBlock = operator
                             .findFirstToken(TokenTypes.CASE_GROUP);
 
                         while (currentCaseBlock != null
                             && currentCaseBlock.getType()
                             == TokenTypes.CASE_GROUP) {
                             final DetailAST firstNodeInsideCaseBlock =
