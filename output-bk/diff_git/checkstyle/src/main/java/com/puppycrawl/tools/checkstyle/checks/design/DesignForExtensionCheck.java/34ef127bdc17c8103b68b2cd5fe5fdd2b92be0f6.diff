diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
index fdb7b34b5..b74a61454 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java
@@ -137,156 +137,159 @@ public class DesignForExtensionCheck extends AbstractCheck {
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (!hasJavadocComment(ast)
                 && (isNativeMethod(ast)
                     || !hasEmptyImplementation(ast))
                 && canBeOverridden(ast)
                 && !hasIgnoredAnnotation(ast, ignoredAnnotations)) {
 
             final DetailAST classDef = getNearestClassOrEnumDefinition(ast);
             if (canBeSubclassed(classDef)) {
                 final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();
                 final String methodName = ast.findFirstToken(TokenTypes.IDENT).getText();
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY, className, methodName);
             }
         }
     }
 
     /**
      * Checks whether a method has a javadoc comment.
      * @param methodDef method definition token.
      * @return true if a method has a javadoc comment.
      */
     private boolean hasJavadocComment(DetailAST methodDef) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         return modifiers.branchContains(TokenTypes.BLOCK_COMMENT_BEGIN);
     }
 
     /**
      * Checks whether a methods is native.
      * @param ast method definition token.
      * @return true if a methods is native.
      */
     private boolean isNativeMethod(DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         return mods.branchContains(TokenTypes.LITERAL_NATIVE);
     }
 
     /**
      * Checks whether a method has only comments in the body (has an empty implementation).
      * Method is OK if its implementation is empty.
      * @param ast method definition token.
      * @return true if a method has only comments in the body.
      */
     private static boolean hasEmptyImplementation(DetailAST ast) {
         boolean hasEmptyBody = true;
         final DetailAST methodImplOpenBrace = ast.findFirstToken(TokenTypes.SLIST);
         if (methodImplOpenBrace != null) {
             final DetailAST methodImplCloseBrace = methodImplOpenBrace.getLastChild();
-            final Predicate<DetailAST> predicate = currentNode ->
-                currentNode != null
+            final Predicate<DetailAST> predicate = currentNode -> {
+                return currentNode != null
                     && currentNode != methodImplCloseBrace
                     && currentNode.getLineNo() <= methodImplCloseBrace.getLineNo()
                     && !TokenUtils.isCommentType(currentNode.getType());
+            };
             final Optional<DetailAST> methodBody =
                 TokenUtils.findFirstTokenByPredicate(methodImplOpenBrace, predicate);
             if (methodBody.isPresent()) {
                 hasEmptyBody = false;
             }
         }
         return hasEmptyBody;
     }
 
     /**
      * Checks whether a method can be overridden.
      * Method can be overridden if it is not private, abstract, final or static.
      * Note that the check has nothing to do for interfaces.
      * @param methodDef method definition token.
      * @return true if a method can be overridden in a subclass.
      */
     private boolean canBeOverridden(DetailAST methodDef) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         return ScopeUtils.getSurroundingScope(methodDef).isIn(Scope.PROTECTED)
             && !ScopeUtils.isInInterfaceOrAnnotationBlock(methodDef)
             && !modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)
             && !modifiers.branchContains(TokenTypes.ABSTRACT)
             && !modifiers.branchContains(TokenTypes.FINAL)
             && !modifiers.branchContains(TokenTypes.LITERAL_STATIC);
     }
 
     /**
      * Checks whether a method has any of ignored annotations.
      * @param methodDef method definition token.
      * @param annotations a set of ignored annotations.
      * @return true if a method has any of ignored annotations.
      */
     private static boolean hasIgnoredAnnotation(DetailAST methodDef, Set<String> annotations) {
         return annotations.stream().filter(annotation -> hasAnnotation(methodDef, annotation))
             .findAny().isPresent();
     }
 
     /**
      * Check if a method has specific annotation.
      * @param methodDef method definition token.
      * @param annotationName annotation name.
      * @return true, if a method has a specific annotation.
      */
     private static boolean hasAnnotation(DetailAST methodDef, String annotationName) {
         final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         boolean containsAnnotation = false;
         if (modifiers.branchContains(TokenTypes.ANNOTATION)) {
             final Optional<DetailAST> annotation = TokenUtils.findFirstTokenByPredicate(modifiers,
-                currentToken -> currentToken != null
-                    && currentToken.getType() == TokenTypes.ANNOTATION
-                    && annotationName.equals(getAnnotationName(currentToken)));
+                currentToken -> {
+                    return currentToken != null
+                        && currentToken.getType() == TokenTypes.ANNOTATION
+                        && annotationName.equals(getAnnotationName(currentToken));
+                });
             if (annotation.isPresent()) {
                 containsAnnotation = true;
             }
         }
         return containsAnnotation;
     }
 
     /**
      * Gets the name of the annotation.
      * @param annotation to get name of.
      * @return the name of the annotation.
      */
     private static String getAnnotationName(DetailAST annotation) {
         final DetailAST dotAst = annotation.findFirstToken(TokenTypes.DOT);
         final String name;
         if (dotAst == null) {
             name = annotation.findFirstToken(TokenTypes.IDENT).getText();
         }
         else {
             name = dotAst.findFirstToken(TokenTypes.IDENT).getText();
         }
         return name;
     }
 
     /**
      * Returns CLASS_DEF or ENUM_DEF token which is the nearest to the given ast node.
      * Searches the tree towards the root until it finds a CLASS_DEF or ENUM_DEF node.
      * @param ast the start node for searching.
      * @return the CLASS_DEF or ENUM_DEF token.
      */
     private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {
         DetailAST searchAST = ast;
         while (searchAST.getType() != TokenTypes.CLASS_DEF
                && searchAST.getType() != TokenTypes.ENUM_DEF) {
             searchAST = searchAST.getParent();
         }
         return searchAST;
     }
 
     /**
      * Checks if the given class (given CLASS_DEF node) can be subclassed.
      * @param classDef class definition token.
      * @return true if the containing class can be subclassed.
      */
     private static boolean canBeSubclassed(DetailAST classDef) {
         final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);
         return classDef.getType() != TokenTypes.ENUM_DEF
             && !modifiers.branchContains(TokenTypes.FINAL)
             && hasDefaultOrExplicitNonPrivateCtor(classDef);
     }
