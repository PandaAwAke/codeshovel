diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java
index 931e9c577..0b6bc61d3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java
@@ -60,111 +60,111 @@ import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
  * <pre>
  * &lt;module name="ParameterName"&gt;
  *    &lt;property name="ignoreOverridden" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author Oliver Burn
  * @author Andrei Selkin
  */
 public class ParameterNameCheck extends AbstractNameCheck {
 
     /**
      * Allows to skip methods with Override annotation from validation.
      */
     private boolean ignoreOverridden;
 
     /** Access modifiers of methods which should be checked. */
     private AccessModifier[] accessModifiers = {
         AccessModifier.PUBLIC,
         AccessModifier.PROTECTED,
         AccessModifier.PACKAGE,
         AccessModifier.PRIVATE,
     };
 
     /**
      * Creates a new {@code ParameterNameCheck} instance.
      */
     public ParameterNameCheck() {
         super("^[a-z][a-zA-Z0-9]*$");
     }
 
     /**
      * Sets whether to skip methods with Override annotation from validation.
      * @param ignoreOverridden Flag for skipping methods with Override annotation.
      */
     public void setIgnoreOverridden(boolean ignoreOverridden) {
         this.ignoreOverridden = ignoreOverridden;
     }
 
     /**
      * Sets access modifiers of methods which should be checked.
      * @param accessModifiers access modifiers of methods which should be checked.
      */
     public void setAccessModifiers(AccessModifier... accessModifiers) {
         this.accessModifiers =
             Arrays.copyOf(accessModifiers, accessModifiers.length);
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {TokenTypes.PARAMETER_DEF};
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getAcceptableTokens();
+        return new int[] {TokenTypes.PARAMETER_DEF};
     }
 
     @Override
     protected boolean mustCheckName(DetailAST ast) {
         boolean checkName = true;
         if (ignoreOverridden && isOverriddenMethod(ast)
                 || ast.getParent().getType() == TokenTypes.LITERAL_CATCH
                 || CheckUtils.isReceiverParameter(ast)
                 || !matchAccessModifiers(getAccessModifier(ast))) {
             checkName = false;
         }
         return checkName;
     }
 
     /**
      * Returns the access modifier of the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the access modifier is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor.
      * @return the access modifier of the method/constructor.
      */
     private static AccessModifier getAccessModifier(final DetailAST ast) {
         final DetailAST params = ast.getParent();
         final DetailAST meth = params.getParent();
         AccessModifier accessModifier = AccessModifier.PRIVATE;
 
         if (meth.getType() == TokenTypes.METHOD_DEF
                 || meth.getType() == TokenTypes.CTOR_DEF) {
             if (ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
                 accessModifier = AccessModifier.PUBLIC;
             }
             else {
                 final DetailAST modsToken = meth.findFirstToken(TokenTypes.MODIFIERS);
                 accessModifier = CheckUtils.getAccessModifierFromModifiersToken(modsToken);
             }
         }
 
         return accessModifier;
     }
 
     /**
      * Checks whether a method has the correct access modifier to be checked.
      * @param accessModifier the access modifier of the method.
      * @return whether the method matches the expected access modifier.
      */
     private boolean matchAccessModifiers(final AccessModifier accessModifier) {
         return Arrays.stream(accessModifiers).anyMatch(el -> el == accessModifier);
     }
 
