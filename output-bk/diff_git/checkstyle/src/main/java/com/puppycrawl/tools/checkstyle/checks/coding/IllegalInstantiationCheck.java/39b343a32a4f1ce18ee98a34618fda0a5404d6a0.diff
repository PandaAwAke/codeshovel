diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index 31b4aa2a4..1ed9118d0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -153,112 +153,110 @@ public class IllegalInstantiationCheck
      *
      * @param ast the class def token.
      */
     private void processClassDef(DetailAST ast) {
         final DetailAST identToken = ast.findFirstToken(TokenTypes.IDENT);
         final String className = identToken.getText();
         classNames.add(className);
     }
 
     /**
      * Perform processing for an import token.
      * @param ast the import token
      */
     private void processImport(DetailAST ast) {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
         // Note: different from UnusedImportsCheck.processImport(),
         // '.*' imports are also added here
         imports.add(name);
     }
 
     /**
      * Perform processing for an package token.
      * @param ast the package token
      */
     private void processPackageDef(DetailAST ast) {
         final DetailAST packageNameAST = ast.getLastChild()
                 .getPreviousSibling();
         final FullIdent packageIdent =
                 FullIdent.createFullIdent(packageNameAST);
         pkgName = packageIdent.getText();
     }
 
     /**
      * Collects a "new" token.
      * @param ast the "new" token
      */
     private void processLiteralNew(DetailAST ast) {
         if (ast.getParent().getType() != TokenTypes.METHOD_REF) {
             instantiations.add(ast);
         }
     }
 
     /**
      * Processes one of the collected "new" tokens when walking tree
      * has finished.
      * @param newTokenAst the "new" token.
      */
     private void postProcessLiteralNew(DetailAST newTokenAst) {
         final DetailAST typeNameAst = newTokenAst.getFirstChild();
         final AST nameSibling = typeNameAst.getNextSibling();
-        if (nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR) {
-            // ast == "new Boolean[]"
-            return;
-        }
-
-        final FullIdent typeIdent = FullIdent.createFullIdent(typeNameAst);
-        final String typeName = typeIdent.getText();
-        final int lineNo = newTokenAst.getLineNo();
-        final int colNo = newTokenAst.getColumnNo();
-        final String fqClassName = getIllegalInstantiation(typeName);
-        if (fqClassName != null) {
-            log(lineNo, colNo, MSG_KEY, fqClassName);
+        if (nameSibling.getType() != TokenTypes.ARRAY_DECLARATOR) {
+            // ast != "new Boolean[]"
+            final FullIdent typeIdent = FullIdent.createFullIdent(typeNameAst);
+            final String typeName = typeIdent.getText();
+            final int lineNo = newTokenAst.getLineNo();
+            final int colNo = newTokenAst.getColumnNo();
+            final String fqClassName = getIllegalInstantiation(typeName);
+            if (fqClassName != null) {
+                log(lineNo, colNo, MSG_KEY, fqClassName);
+            }
         }
     }
 
     /**
      * Checks illegal instantiations.
      * @param className instantiated class, may or may not be qualified
      * @return the fully qualified class name of className
      *     or null if instantiation of className is OK
      */
     private String getIllegalInstantiation(String className) {
         String fullClassName = null;
 
         if (illegalClasses.contains(className)) {
             fullClassName = className;
         }
         else {
             final int pkgNameLen;
 
             if (pkgName == null) {
                 pkgNameLen = 0;
             }
             else {
                 pkgNameLen = pkgName.length();
             }
 
             for (String illegal : illegalClasses) {
                 if (isStandardClass(className, illegal)
                         || isSamePackage(className, pkgNameLen, illegal)) {
                     fullClassName = illegal;
                 }
                 else {
                     fullClassName = checkImportStatements(className);
                 }
 
                 if (fullClassName != null) {
                     break;
                 }
             }
         }
         return fullClassName;
     }
 
     /**
      * Check import statements.
      * @param className name of the class
      * @return value of illegal instantiated type
      * @noinspection StringContatenationInLoop
      */
     private String checkImportStatements(String className) {
         String illegalType = null;
