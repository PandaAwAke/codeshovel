diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
index ee5ff4a6c..52ae6dcc2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java
@@ -104,101 +104,101 @@ public class LeftCurlyCheck
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.INTERFACE_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_FOR,
             // TODO: need to handle....
             //TokenTypes.STATIC_INIT,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST startToken;
         final DetailAST brace;
 
         switch (aAST.getType()) {
         case TokenTypes.CTOR_DEF :
         case TokenTypes.METHOD_DEF :
             startToken = skipAnnotationOnlyLines(aAST);
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.INTERFACE_DEF :
         case TokenTypes.CLASS_DEF :
         case TokenTypes.ANNOTATION_DEF :
         case TokenTypes.ENUM_DEF :
         case TokenTypes.ENUM_CONSTANT_DEF :
             startToken = skipAnnotationOnlyLines(aAST);
             final DetailAST objBlock = aAST.findFirstToken(TokenTypes.OBJBLOCK);
             brace = (objBlock == null)
                 ? null
-                : (DetailAST) objBlock.getFirstChild();
+                : objBlock.getFirstChild();
             break;
 
         case TokenTypes.LITERAL_WHILE:
         case TokenTypes.LITERAL_CATCH:
         case TokenTypes.LITERAL_SYNCHRONIZED:
         case TokenTypes.LITERAL_FOR:
         case TokenTypes.LITERAL_TRY:
         case TokenTypes.LITERAL_FINALLY:
         case TokenTypes.LITERAL_DO:
         case TokenTypes.LITERAL_IF :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.SLIST);
             break;
 
         case TokenTypes.LITERAL_ELSE :
             startToken = aAST;
             final DetailAST candidate = aAST.getFirstChild();
             brace =
                 (candidate.getType() == TokenTypes.SLIST)
                 ? candidate
                 : null; // silently ignore
             break;
 
         case TokenTypes.LITERAL_SWITCH :
             startToken = aAST;
             brace = aAST.findFirstToken(TokenTypes.LCURLY);
             break;
 
         default :
             startToken = null;
             brace = null;
         }
 
         if ((brace != null) && (startToken != null)) {
             verifyBrace(brace, startToken);
         }
     }
 
     /**
      * Skip lines that only contain <code>TokenTypes.ANNOTATION</code>s.
      * If the received <code>DetailAST</code>
      * has annotations within its modifiers then first token on the line
      * of the first token afer all annotations is return. This might be
      * an annotation.
      * Otherwise, the received <code>DetailAST</code> is returned.
      * @param aAST <code>DetailAST</code>.
      * @return <code>DetailAST</code>.
      */
     private DetailAST skipAnnotationOnlyLines(DetailAST aAST)
     {
