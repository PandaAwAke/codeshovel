diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
index 8f10a1609..b829df522 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java
@@ -65,183 +65,195 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * </pre>
  *
  * <p>Use following configuration:
  * <pre>
  * &lt;module name=&quot;AnnotationLocation&quot;&gt;
  *    &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;false&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineSingleParameterlessAnnotation&quot;
  *    value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineParametrizedAnnotation&quot; value=&quot;false&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  * <br/>
  * <p>
  * Example to allow multiple parameterized annotations on the same line:
  * </p>
  * <pre>
  * &#64;SuppressWarnings("deprecation") &#64;Mock DataLoader loader;
  * </pre>
  *
  * <p>Use following configuration:
  * <pre>
  * &lt;module name=&quot;AnnotationLocation&quot;&gt;
  *    &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineSingleParameterlessAnnotation&quot;
  *    value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineParametrizedAnnotation&quot; value=&quot;true&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  * <br/>
  * <p>
  * Example to allow multiple parameterless annotations on the same line:
  * </p>
  * <pre>
  * &#64;Partial &#64;Mock DataLoader loader;
  * </pre>
  *
  * <p>Use following configuration:
  * <pre>
  * &lt;module name=&quot;AnnotationLocation&quot;&gt;
  *    &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineSingleParameterlessAnnotation&quot;
  *    value=&quot;true&quot;/&gt;
  *    &lt;property name=&quot;allowSamelineParametrizedAnnotation&quot; value=&quot;false&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author maxvetrenko
  */
 public class AnnotationLocationCheck extends Check
 {
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_LOCATION_ALONE = "annotation.location.alone";
+
+    /**
+     * A key is pointing to the warning message text in "messages.properties"
+     * file.
+     */
+    public static final String MSG_KEY_ANNOTATION_LOCATION = "annotation.location";
+
     /**
      * Some javadoc.
      */
     private boolean mAllowSamelineSingleParameterlessAnnotation = true;
 
     /**
      * Some javadoc.
      */
     private boolean mAllowSamelineParametrizedAnnotation;
 
     /**
      * Some javadoc.
      */
     private boolean mAllowSamelineMultipleAnnotations;
 
     /**
      * Some javadoc.
      * @param aAllow Some javadoc.
      */
     public final void setAllowSamelineSingleParameterlessAnnotation(boolean aAllow)
     {
         mAllowSamelineSingleParameterlessAnnotation = aAllow;
     }
 
     /**
      * Some javadoc.
      * @param aAllow Some javadoc.
      */
     public final void setAllowSamelineParametrizedAnnotation(boolean aAllow)
     {
         mAllowSamelineParametrizedAnnotation = aAllow;
     }
 
     /**
      * Some javadoc.
      * @param aAllow Some javadoc.
      */
     public final void setAllowSamelineMultipleAnnotations(boolean aAllow)
     {
         mAllowSamelineMultipleAnnotations = aAllow;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final DetailAST modifiersNode = aAST.findFirstToken(TokenTypes.MODIFIERS);
 
         if (hasAnnotations(modifiersNode)) {
             checkAnnotations(modifiersNode, getAnnotationLevel(modifiersNode));
         }
     }
 
     /**
      * Some javadoc.
      * @param aModifierNode Some javadoc.
      * @param aCorrectLevel Some javadoc.
      */
     private void checkAnnotations(DetailAST aModifierNode, int aCorrectLevel)
     {
         DetailAST annotation = aModifierNode.getFirstChild();
 
         while (annotation != null && annotation.getType() == TokenTypes.ANNOTATION) {
             final boolean hasParameters = isParameterized(annotation);
 
             if (!isCorrectLocation(annotation, hasParameters)) {
                 log(annotation.getLineNo(),
-                    "annotation.location.alone", getAnnotationName(annotation));
+                        MSG_KEY_ANNOTATION_LOCATION_ALONE, getAnnotationName(annotation));
             }
             else if (annotation.getColumnNo() != aCorrectLevel && !hasNodeBefore(annotation)) {
-                log(annotation.getLineNo(), "annotation.location",
+                log(annotation.getLineNo(), MSG_KEY_ANNOTATION_LOCATION,
                     getAnnotationName(annotation), annotation.getColumnNo(), aCorrectLevel);
             }
             annotation = annotation.getNextSibling();
         }
     }
 
     /**
      * Some javadoc.
      * @param aAnnotation Some javadoc.
      * @param aHasParams Some javadoc.
      * @return Some javadoc.
      */
     private boolean isCorrectLocation(DetailAST aAnnotation, boolean aHasParams)
     {
         final boolean allowingCondition = aHasParams ? mAllowSamelineParametrizedAnnotation
             : mAllowSamelineSingleParameterlessAnnotation;
         return allowingCondition && !hasNodeBefore(aAnnotation)
             || !allowingCondition && !hasNodeBeside(aAnnotation)
             || mAllowSamelineMultipleAnnotations;
     }
 
     /**
      * Some javadoc.
      * @param aAnnotation Some javadoc.
      * @return Some javadoc.
      */
     private static String getAnnotationName(DetailAST aAnnotation)
     {
         DetailAST idenNode = aAnnotation.findFirstToken(TokenTypes.IDENT);
         if (idenNode == null) {
             idenNode = aAnnotation.findFirstToken(TokenTypes.DOT).findFirstToken(TokenTypes.IDENT);
         }
         return idenNode.getText();
     }
 
     /**
      * Some javadoc.
      * @param aAnnotation Some javadoc.
      * @return Some javadoc.
      */
     private static boolean hasNodeAfter(DetailAST aAnnotation)
     {
         final int annotationLineNo = aAnnotation.getLineNo();
         DetailAST nextNode = aAnnotation.getNextSibling();
 
         if (nextNode == null) {
             nextNode = aAnnotation.getParent().getNextSibling();
         }
 
         return nextNode != null && annotationLineNo == nextNode.getLineNo();
