diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
index 1736e0a41..acbd8c5b9 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
@@ -141,101 +141,101 @@ public class ClassResolver {
     }
 
     /**
      * See if inner class of this class.
      * @param name name of the search Class to search
      * @param currentClass class where search in
      * @return class if found , or null if not resolved
      * @throws ClassNotFoundException  if an error occurs
      */
     private Class<?> resolveInnerClass(String name, String currentClass)
             throws ClassNotFoundException {
         Class<?> clazz = null;
         if (!currentClass.isEmpty()) {
             String innerClass = currentClass + DOLLAR_SIGN + name;
 
             if (!pkg.isEmpty()) {
                 innerClass = pkg + PERIOD + innerClass;
             }
 
             if (isLoadable(innerClass)) {
                 clazz = safeLoad(innerClass);
             }
         }
         return clazz;
     }
 
     /**
      * Try star imports.
      * @param name name of the Class to search
      * @return  class if found , or null if not resolved
      */
     private Class<?> resolveByStarImports(String name) {
         Class<?> clazz = null;
         for (String imp : imports) {
             if (imp.endsWith(".*")) {
                 final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1) + name;
                 clazz = resolveQualifiedName(fqn);
                 if (clazz != null) {
                     break;
                 }
             }
         }
         return clazz;
     }
 
     /**
      * @param name name of the class to check
      * @return whether a specified class is loadable with safeLoad().
      */
     public boolean isLoadable(String name) {
-        boolean result = false;
+        boolean result;
         try {
             safeLoad(name);
             result = true;
         }
         catch (final ClassNotFoundException | NoClassDefFoundError ignored) {
             result = false;
         }
         return result;
     }
 
     /**
      * Will load a specified class is such a way that it will NOT be
      * initialised.
      * @param name name of the class to load
      * @return the {@code Class} for the specified class
      * @throws ClassNotFoundException if an error occurs
      * @throws NoClassDefFoundError if an error occurs
      */
     // -@cs[ForbidWildcardAsReturnType] The class is deprecated and will be removed soon.
     private Class<?> safeLoad(String name) throws ClassNotFoundException, NoClassDefFoundError {
         // The next line will load the class using the specified class
         // loader. The magic is having the "false" parameter. This means the
         // class will not be initialised. Very, very important.
         return Class.forName(name, false, loader);
     }
 
     /**
      * Tries to resolve a class for fully-specified name.
      * @param name a given name of class.
      * @return Class object for the given name or null.
      */
     private Class<?> resolveQualifiedName(final String name) {
         Class<?> classObj = null;
         try {
             if (isLoadable(name)) {
                 classObj = safeLoad(name);
             }
             else {
                 //Perhaps it's fully-qualified inner class
                 final int dot = name.lastIndexOf('.');
                 if (dot != -1) {
                     final String innerName =
                         name.substring(0, dot) + DOLLAR_SIGN + name.substring(dot + 1);
                     classObj = resolveQualifiedName(innerName);
                 }
             }
         }
         catch (final ClassNotFoundException ex) {
             // we shouldn't get this exception here,
             // so this is unexpected runtime exception
