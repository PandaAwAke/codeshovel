diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java
index 8143fbd19..e091181fa 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java
@@ -37,105 +37,107 @@ import java.util.List;
 
 import com.google.common.io.Closeables;
 import org.apache.commons.beanutils.ConversionException;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import org.apache.commons.lang3.StringUtils;
 
 /**
  * Abstract super class for header checks.
  * Provides support for header and headerFile properties.
  * @author o_sukhosolsky
  */
 public abstract class AbstractHeaderCheck extends AbstractFileSetCheck {
     /** The file that contains the header to check against. */
     private String filename;
 
     /** Name of a charset to use for loading the header from a file. */
     private String charset = System.getProperty("file.encoding", "UTF-8");
 
     /** the lines of the header file. */
     private final List<String> readerLines = Lists.newArrayList();
 
 
     /**
      * Return the header lines to check against.
      * @return the header lines to check against.
      */
     protected ImmutableList<String> getHeaderLines() {
         return ImmutableList.copyOf(readerLines);
     }
 
     /**
      * Set the charset to use for loading the header from a file.
      * @param charset the charset to use for loading the header from a file
      * @throws UnsupportedEncodingException if charset is unsupported
      */
     public void setCharset(String charset) throws UnsupportedEncodingException {
         if (!Charset.isSupported(charset)) {
             final String message = "unsupported charset: '" + charset + "'";
             throw new UnsupportedEncodingException(message);
         }
         this.charset = charset;
     }
 
     /**
      * Set the header file to check against.
      * @param fileName the file that contains the header to check against.
+     * @throws CheckstyleException if fileName is empty.
      */
-    public void setHeaderFile(String fileName) {
-        // Handle empty param
+    public void setHeaderFile(String fileName) throws CheckstyleException {
         if (StringUtils.isBlank(fileName)) {
-            return;
+            throw new CheckstyleException(
+                "property 'headerFile' is missing or invalid in module "
+                    + getConfiguration().getName());
         }
 
         filename = fileName;
     }
 
     /**
      * Load the header from a file.
      * @throws CheckstyleException if the file cannot be loaded
      */
     private void loadHeaderFile() throws CheckstyleException {
         checkHeaderNotInitialized();
         Reader headerReader = null;
         try {
             final URI uri = resolveHeaderFile();
             headerReader = new InputStreamReader(new BufferedInputStream(
                     uri.toURL().openStream()), charset);
             loadHeader(headerReader);
         }
         catch (final IOException ex) {
             throw new CheckstyleException(
                     "unable to load header file " + filename, ex);
         }
         finally {
             Closeables.closeQuietly(headerReader);
         }
     }
 
     /**
      * Resolve the specified filename param to a URI.
      * @return resolved header file URI
      * @throws IOException on failure
      */
     private URI resolveHeaderFile() throws IOException {
         // figure out if this is a File or a URL
         URI uri;
         try {
             final URL url = new URL(filename);
             uri = url.toURI();
         }
         catch (final MalformedURLException ex) {
             uri = null;
         }
         catch (final URISyntaxException ex) {
             // URL violating RFC 2396
             uri = null;
         }
         if (uri == null) {
             final File file = new File(filename);
             if (file.exists()) {
                 uri = file.toURI();
@@ -182,56 +184,54 @@ public abstract class AbstractHeaderCheck extends AbstractFileSetCheck {
         }
 
         checkHeaderNotInitialized();
 
         final String headerExpandedNewLines = header.replaceAll("\\\\n", "\n");
 
         final Reader headerReader = new StringReader(headerExpandedNewLines);
         try {
             loadHeader(headerReader);
         }
         catch (final IOException ex) {
             throw new ConversionException("unable to load header", ex);
         }
         finally {
             Closeables.closeQuietly(headerReader);
         }
     }
 
     /**
      * Load header to check against from a Reader into readerLines.
      * @param headerReader delivers the header to check against
      * @throws IOException if
      */
     private void loadHeader(final Reader headerReader) throws IOException {
         final LineNumberReader lnr = new LineNumberReader(headerReader);
         readerLines.clear();
         while (true) {
             final String l = lnr.readLine();
             if (l == null) {
                 break;
             }
             readerLines.add(l);
         }
         postprocessHeaderLines();
     }
 
     /**
      * Hook method for post processing header lines.
      * This implementation does nothing.
      */
     protected void postprocessHeaderLines() {
         // No code by default
     }
 
     @Override
     protected final void finishLocalSetup() throws CheckstyleException {
         if (filename != null) {
             loadHeaderFile();
         }
         if (readerLines.isEmpty()) {
-            throw new CheckstyleException(
-                    "property 'headerFile' is missing or invalid in module "
-                    + getConfiguration().getName());
+            setHeader(null);
         }
     }
 }
