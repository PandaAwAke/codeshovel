diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
index 51a3ea1e6..b35922ee2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
@@ -60,113 +60,109 @@ import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
  * For example:
  * {@code @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")}.
  * According to the above example, the "unused" warning is being suppressed
  * not the "unchecked" or "foo" warnings.  All of these warnings will be
  * considered and matched against regardless of what the conditional
  * evaluates to.
  * <br>
  * The check also does not support code like {@code @SuppressWarnings("un" + "used")},
  * {@code @SuppressWarnings((String) "unused")} or
  * {@code @SuppressWarnings({('u' + (char)'n') + (""+("used" + (String)"")),})}.
  * </p>
  *
  * <p>This check can be configured so that the "unchecked"
  * and "unused" warnings cannot be suppressed on
  * anything but variable and parameter declarations.
  * See below of an example.
  * </p>
  *
  * <pre>
  * &lt;module name=&quot;SuppressWarnings&quot;&gt;
  *    &lt;property name=&quot;format&quot;
  *        value=&quot;^unchecked$|^unused$&quot;/&gt;
  *    &lt;property name=&quot;tokens&quot;
  *        value=&quot;
  *        CLASS_DEF,INTERFACE_DEF,ENUM_DEF,
  *        ANNOTATION_DEF,ANNOTATION_FIELD_DEF,
  *        ENUM_CONSTANT_DEF,METHOD_DEF,CTOR_DEF
  *        &quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  * @author Travis Schneeberger
  */
 public class SuppressWarningsCheck extends AbstractCheck {
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED =
         "suppressed.warning.not.allowed";
 
     /** {@link SuppressWarnings SuppressWarnings} annotation name. */
     private static final String SUPPRESS_WARNINGS = "SuppressWarnings";
 
     /**
      * Fully-qualified {@link SuppressWarnings SuppressWarnings}
      * annotation name.
      */
     private static final String FQ_SUPPRESS_WARNINGS =
         "java.lang." + SUPPRESS_WARNINGS;
 
-    /** The format string of the regexp. */
-    private String format = "^$|^\\s+$";
-
     /** The regexp to match against. */
-    private Pattern regexp = Pattern.compile(format);
+    private Pattern format = Pattern.compile("^$|^\\s+$");
 
     /**
      * Set the format for the specified regular expression.
      * @param pattern the new pattern
      */
     public final void setFormat(Pattern pattern) {
-        format = pattern.pattern();
-        regexp = pattern;
+        format = pattern;
     }
 
     @Override
     public final int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public final int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         final DetailAST annotation = getSuppressWarnings(ast);
 
         if (annotation != null) {
             final DetailAST warningHolder =
                 findWarningsHolder(annotation);
 
             final DetailAST token =
                     warningHolder.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
             DetailAST warning;
 
             if (token == null) {
                 warning = warningHolder.findFirstToken(TokenTypes.EXPR);
             }
             else {
                 // case like '@SuppressWarnings(value = UNUSED)'
                 warning = token.findFirstToken(TokenTypes.EXPR);
             }
 
             //rare case with empty array ex: @SuppressWarnings({})
             if (warning == null) {
@@ -195,101 +191,101 @@ public class SuppressWarningsCheck extends AbstractCheck {
                             // param in constant case
                             // ex: public static final String UNCHECKED = "unchecked";
                             // @SuppressWarnings(UNCHECKED)
                             // or
                             // @SuppressWarnings(SomeClass.UNCHECKED)
                             case TokenTypes.IDENT:
                             case TokenTypes.DOT:
                                 break;
                             default:
                                 // Known limitation: cases like @SuppressWarnings("un" + "used") or
                                 // @SuppressWarnings((String) "unused") are not properly supported,
                                 // but they should not cause exceptions.
                         }
                     }
                     warning = warning.getNextSibling();
                 }
             }
         }
     }
 
     /**
      * Gets the {@link SuppressWarnings SuppressWarnings} annotation
      * that is annotating the AST.  If the annotation does not exist
      * this method will return {@code null}.
      *
      * @param ast the AST
      * @return the {@link SuppressWarnings SuppressWarnings} annotation
      */
     private static DetailAST getSuppressWarnings(DetailAST ast) {
         final DetailAST annotation = AnnotationUtility.getAnnotation(
             ast, SUPPRESS_WARNINGS);
 
         if (annotation == null) {
             return AnnotationUtility.getAnnotation(ast, FQ_SUPPRESS_WARNINGS);
         }
         else {
             return annotation;
         }
     }
 
     /**
      * This method looks for a warning that matches a configured expression.
      * If found it logs a violation at the given line and column number.
      *
      * @param lineNo the line number
      * @param colNum the column number
      * @param warningText the warning.
      */
     private void logMatch(final int lineNo,
         final int colNum, final String warningText) {
-        final Matcher matcher = regexp.matcher(warningText);
+        final Matcher matcher = format.matcher(warningText);
         if (matcher.matches()) {
             log(lineNo, colNum,
                     MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED, warningText);
         }
     }
 
     /**
      * Find the parent (holder) of the of the warnings (Expr).
      *
      * @param annotation the annotation
      * @return a Token representing the expr.
      */
     private static DetailAST findWarningsHolder(final DetailAST annotation) {
         final DetailAST annValuePair =
             annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
         final DetailAST annArrayInit;
 
         if (annValuePair == null) {
             annArrayInit =
                     annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
         else {
             annArrayInit =
                     annValuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
 
         if (annArrayInit != null) {
             return annArrayInit;
         }
 
         return annotation;
     }
 
     /**
      * Strips a single double quote from the front and back of a string.
      *
      * <p>For example:
      * <br/>
      * Input String = "unchecked"
      * <br/>
      * Output String = unchecked
      *
      * @param warning the warning string
      * @return the string without two quotes
      */
     private static String removeQuotes(final String warning) {
         return warning.substring(1, warning.length() - 1);
     }
 
     /**
