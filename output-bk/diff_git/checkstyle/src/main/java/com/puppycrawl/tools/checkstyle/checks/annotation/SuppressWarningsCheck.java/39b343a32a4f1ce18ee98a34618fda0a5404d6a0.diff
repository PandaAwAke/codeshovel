diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
index 0ef6b09f2..1338b2a3a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java
@@ -106,235 +106,236 @@ public class SuppressWarningsCheck extends AbstractCheck {
      */
     private static final String FQ_SUPPRESS_WARNINGS =
         "java.lang." + SUPPRESS_WARNINGS;
 
     /** The format string of the regexp. */
     private String format = "^$|^\\s+$";
 
     /** The regexp to match against. */
     private Pattern regexp = Pattern.compile(format);
 
     /**
      * Set the format to the specified regular expression.
      * @param format a {@code String} value
      * @throws org.apache.commons.beanutils.ConversionException unable to parse format
      */
     public final void setFormat(String format) {
         this.format = format;
         regexp = CommonUtils.createPattern(format);
     }
 
     @Override
     public final int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public final int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         final DetailAST annotation = getSuppressWarnings(ast);
 
-        if (annotation == null) {
-            return;
-        }
-
-        final DetailAST warningHolder =
-            findWarningsHolder(annotation);
-
-        final DetailAST token =
-                warningHolder.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
-        DetailAST warning;
+        if (annotation != null) {
+            final DetailAST warningHolder =
+                findWarningsHolder(annotation);
 
-        if (token == null) {
-            warning = warningHolder.findFirstToken(TokenTypes.EXPR);
-        }
-        else {
-            // case like '@SuppressWarnings(value = UNUSED)'
-            warning = token.findFirstToken(TokenTypes.EXPR);
-        }
+            final DetailAST token =
+                    warningHolder.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
+            DetailAST warning;
 
-        //rare case with empty array ex: @SuppressWarnings({})
-        if (warning == null) {
-            //check to see if empty warnings are forbidden -- are by default
-            logMatch(warningHolder.getLineNo(),
-                warningHolder.getColumnNo(), "");
-            return;
-        }
+            if (token == null) {
+                warning = warningHolder.findFirstToken(TokenTypes.EXPR);
+            }
+            else {
+                // case like '@SuppressWarnings(value = UNUSED)'
+                warning = token.findFirstToken(TokenTypes.EXPR);
+            }
 
-        while (warning != null) {
-            if (warning.getType() == TokenTypes.EXPR) {
-                final DetailAST fChild = warning.getFirstChild();
-                switch (fChild.getType()) {
-                    //typical case
-                    case TokenTypes.STRING_LITERAL:
-                        final String warningText =
-                            removeQuotes(warning.getFirstChild().getText());
-                        logMatch(warning.getLineNo(),
-                                warning.getColumnNo(), warningText);
-                        break;
-                    // conditional case
-                    // ex: @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")
-                    case TokenTypes.QUESTION:
-                        walkConditional(fChild);
-                        break;
-                    // param in constant case
-                    // ex: public static final String UNCHECKED = "unchecked";
-                    // @SuppressWarnings(UNCHECKED) or @SuppressWarnings(SomeClass.UNCHECKED)
-                    case TokenTypes.IDENT:
-                    case TokenTypes.DOT:
-                        break;
-                    default:
-                        // Known limitation: cases like @SuppressWarnings("un" + "used") or
-                        // @SuppressWarnings((String) "unused") are not properly supported,
-                        // but they should not cause exceptions.
+            //rare case with empty array ex: @SuppressWarnings({})
+            if (warning == null) {
+                //check to see if empty warnings are forbidden -- are by default
+                logMatch(warningHolder.getLineNo(),
+                    warningHolder.getColumnNo(), "");
+            }
+            else {
+                while (warning != null) {
+                    if (warning.getType() == TokenTypes.EXPR) {
+                        final DetailAST fChild = warning.getFirstChild();
+                        switch (fChild.getType()) {
+                            //typical case
+                            case TokenTypes.STRING_LITERAL:
+                                final String warningText =
+                                    removeQuotes(warning.getFirstChild().getText());
+                                logMatch(warning.getLineNo(),
+                                        warning.getColumnNo(), warningText);
+                                break;
+                            // conditional case
+                            // ex:
+                            // @SuppressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")
+                            case TokenTypes.QUESTION:
+                                walkConditional(fChild);
+                                break;
+                            // param in constant case
+                            // ex: public static final String UNCHECKED = "unchecked";
+                            // @SuppressWarnings(UNCHECKED)
+                            // or
+                            // @SuppressWarnings(SomeClass.UNCHECKED)
+                            case TokenTypes.IDENT:
+                            case TokenTypes.DOT:
+                                break;
+                            default:
+                                // Known limitation: cases like @SuppressWarnings("un" + "used") or
+                                // @SuppressWarnings((String) "unused") are not properly supported,
+                                // but they should not cause exceptions.
+                        }
+                    }
+                    warning = warning.getNextSibling();
                 }
             }
-            warning = warning.getNextSibling();
         }
     }
 
     /**
      * Gets the {@link SuppressWarnings SuppressWarnings} annotation
      * that is annotating the AST.  If the annotation does not exist
      * this method will return {@code null}.
      *
      * @param ast the AST
      * @return the {@link SuppressWarnings SuppressWarnings} annotation
      */
     private static DetailAST getSuppressWarnings(DetailAST ast) {
         final DetailAST annotation = AnnotationUtility.getAnnotation(
             ast, SUPPRESS_WARNINGS);
 
         if (annotation == null) {
             return AnnotationUtility.getAnnotation(ast, FQ_SUPPRESS_WARNINGS);
         }
         else {
             return annotation;
         }
     }
 
     /**
      * This method looks for a warning that matches a configured expression.
      * If found it logs a violation at the given line and column number.
      *
      * @param lineNo the line number
      * @param colNum the column number
      * @param warningText the warning.
      */
     private void logMatch(final int lineNo,
         final int colNum, final String warningText) {
         final Matcher matcher = regexp.matcher(warningText);
         if (matcher.matches()) {
             log(lineNo, colNum,
                     MSG_KEY_SUPPRESSED_WARNING_NOT_ALLOWED, warningText);
         }
     }
 
     /**
      * Find the parent (holder) of the of the warnings (Expr).
      *
      * @param annotation the annotation
      * @return a Token representing the expr.
      */
     private static DetailAST findWarningsHolder(final DetailAST annotation) {
         final DetailAST annValuePair =
             annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
         final DetailAST annArrayInit;
 
         if (annValuePair == null) {
             annArrayInit =
                     annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
         else {
             annArrayInit =
                     annValuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
         }
 
         if (annArrayInit != null) {
             return annArrayInit;
         }
 
         return annotation;
     }
 
     /**
      * Strips a single double quote from the front and back of a string.
      *
      * <p>For example:
      * <br/>
      * Input String = "unchecked"
      * <br/>
      * Output String = unchecked
      *
      * @param warning the warning string
      * @return the string without two quotes
      */
     private static String removeQuotes(final String warning) {
         return warning.substring(1, warning.length() - 1);
     }
 
     /**
      * Recursively walks a conditional expression checking the left
      * and right sides, checking for matches and
      * logging violations.
      *
      * @param cond a Conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      */
     private void walkConditional(final DetailAST cond) {
-        if (cond.getType() != TokenTypes.QUESTION) {
+        if (cond.getType() == TokenTypes.QUESTION) {
+            walkConditional(getCondLeft(cond));
+            walkConditional(getCondRight(cond));
+        }
+        else {
             final String warningText =
-                removeQuotes(cond.getText());
+                    removeQuotes(cond.getText());
             logMatch(cond.getLineNo(), cond.getColumnNo(), warningText);
-            return;
         }
-
-        walkConditional(getCondLeft(cond));
-        walkConditional(getCondRight(cond));
     }
 
     /**
      * Retrieves the left side of a conditional.
      *
      * @param cond cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      *     or another conditional
      */
     private static DetailAST getCondLeft(final DetailAST cond) {
         final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getPreviousSibling();
     }
 
     /**
      * Retrieves the right side of a conditional.
      *
      * @param cond a conditional type
      * {@link TokenTypes#QUESTION QUESTION}
      * @return either the value
      *     or another conditional
      */
     private static DetailAST getCondRight(final DetailAST cond) {
         final DetailAST colon = cond.findFirstToken(TokenTypes.COLON);
         return colon.getNextSibling();
     }
 }
