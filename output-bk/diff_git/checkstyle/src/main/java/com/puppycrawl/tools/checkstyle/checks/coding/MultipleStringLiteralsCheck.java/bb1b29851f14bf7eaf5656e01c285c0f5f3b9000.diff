diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
index 8356ecf1a..0e3dcd490 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
@@ -1,223 +1,223 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2014  Oliver Burn
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.puppycrawl.tools.checkstyle.api.Check;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.api.Utils;
 import java.util.BitSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 /**
  * Checks for multiple occurrences of the same string literal within a
  * single file.
  *
  * @author Daniel Grenner
  */
 public class MultipleStringLiteralsCheck extends Check
 {
     /**
      * The found strings and their positions.
      * {@code <String, ArrayList>}, with the ArrayList containing StringInfo
      * objects.
      */
-    private final Map<String, List<StringInfo>> mStringMap = Maps.newHashMap();
+    private final Map<String, List<StringInfo>> stringMap = Maps.newHashMap();
 
     /**
      * Marks the TokenTypes where duplicate strings should be ignored.
      */
-    private final BitSet mIgnoreOccurrenceContext = new BitSet();
+    private final BitSet ignoreOccurrenceContext = new BitSet();
 
     /**
      * The allowed number of string duplicates in a file before an error is
      * generated.
      */
-    private int mAllowedDuplicates = 1;
+    private int allowedDuplicates = 1;
 
     /**
      * Sets the maximum allowed duplicates of a string.
-     * @param aAllowedDuplicates The maximum number of duplicates.
+     * @param allowedDuplicates The maximum number of duplicates.
      */
-    public void setAllowedDuplicates(int aAllowedDuplicates)
+    public void setAllowedDuplicates(int allowedDuplicates)
     {
-        mAllowedDuplicates = aAllowedDuplicates;
+        this.allowedDuplicates = allowedDuplicates;
     }
 
     /**
      * Pattern for matching ignored strings.
      */
-    private Pattern mPattern;
+    private Pattern pattern;
 
     /**
      * Construct an instance with default values.
      */
     public MultipleStringLiteralsCheck()
     {
         setIgnoreStringsRegexp("^\"\"$");
-        mIgnoreOccurrenceContext.set(TokenTypes.ANNOTATION);
+        ignoreOccurrenceContext.set(TokenTypes.ANNOTATION);
     }
 
     /**
      * Sets regexp pattern for ignored strings.
-     * @param aIgnoreStringsRegexp regexp pattern for ignored strings
+     * @param ignoreStringsRegexp regexp pattern for ignored strings
      */
-    public void setIgnoreStringsRegexp(String aIgnoreStringsRegexp)
+    public void setIgnoreStringsRegexp(String ignoreStringsRegexp)
     {
-        if ((aIgnoreStringsRegexp != null)
-            && (aIgnoreStringsRegexp.length() > 0))
+        if ((ignoreStringsRegexp != null)
+            && (ignoreStringsRegexp.length() > 0))
         {
-            mPattern = Utils.getPattern(aIgnoreStringsRegexp);
+            pattern = Utils.getPattern(ignoreStringsRegexp);
         }
         else {
-            mPattern = null;
+            pattern = null;
         }
     }
 
     /**
      * Adds a set of tokens the check is interested in.
-     * @param aStrRep the string representation of the tokens interested in
+     * @param strRep the string representation of the tokens interested in
      */
-    public final void setIgnoreOccurrenceContext(String[] aStrRep)
+    public final void setIgnoreOccurrenceContext(String[] strRep)
     {
-        mIgnoreOccurrenceContext.clear();
-        for (final String s : aStrRep) {
+        ignoreOccurrenceContext.clear();
+        for (final String s : strRep) {
             final int type = TokenTypes.getTokenId(s);
-            mIgnoreOccurrenceContext.set(type);
+            ignoreOccurrenceContext.set(type);
         }
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     @Override
-    public void visitToken(DetailAST aAST)
+    public void visitToken(DetailAST ast)
     {
-        if (isInIgnoreOccurrenceContext(aAST)) {
+        if (isInIgnoreOccurrenceContext(ast)) {
             return;
         }
-        final String currentString = aAST.getText();
-        if ((mPattern == null) || !mPattern.matcher(currentString).find()) {
-            List<StringInfo> hitList = mStringMap.get(currentString);
+        final String currentString = ast.getText();
+        if ((pattern == null) || !pattern.matcher(currentString).find()) {
+            List<StringInfo> hitList = stringMap.get(currentString);
             if (hitList == null) {
                 hitList = Lists.newArrayList();
-                mStringMap.put(currentString, hitList);
+                stringMap.put(currentString, hitList);
             }
-            final int line = aAST.getLineNo();
-            final int col = aAST.getColumnNo();
+            final int line = ast.getLineNo();
+            final int col = ast.getColumnNo();
             hitList.add(new StringInfo(line, col));
         }
     }
 
     /**
      * Analyses the path from the AST root to a given AST for occurrences
-     * of the token types in {@link #mIgnoreOccurrenceContext}.
+     * of the token types in {@link #ignoreOccurrenceContext}.
      *
-     * @param aAST the node from where to start searching towards the root node
-     * @return whether the path from the root node to aAST contains one of the
-     * token type in {@link #mIgnoreOccurrenceContext}.
+     * @param ast the node from where to start searching towards the root node
+     * @return whether the path from the root node to ast contains one of the
+     * token type in {@link #ignoreOccurrenceContext}.
      */
-    private boolean isInIgnoreOccurrenceContext(DetailAST aAST)
+    private boolean isInIgnoreOccurrenceContext(DetailAST ast)
     {
-        for (DetailAST token = aAST;
+        for (DetailAST token = ast;
              token.getParent() != null;
              token = token.getParent())
         {
             final int type = token.getType();
-            if (mIgnoreOccurrenceContext.get(type)) {
+            if (ignoreOccurrenceContext.get(type)) {
                 return true;
             }
         }
         return false;
     }
 
     @Override
-    public void beginTree(DetailAST aRootAST)
+    public void beginTree(DetailAST rootAST)
     {
-        super.beginTree(aRootAST);
-        mStringMap.clear();
+        super.beginTree(rootAST);
+        stringMap.clear();
     }
 
     @Override
-    public void finishTree(DetailAST aRootAST)
+    public void finishTree(DetailAST rootAST)
     {
-        final Set<String> keys = mStringMap.keySet();
+        final Set<String> keys = stringMap.keySet();
         for (String key : keys) {
-            final List<StringInfo> hits = mStringMap.get(key);
-            if (hits.size() > mAllowedDuplicates) {
+            final List<StringInfo> hits = stringMap.get(key);
+            if (hits.size() > allowedDuplicates) {
                 final StringInfo firstFinding = hits.get(0);
                 final int line = firstFinding.getLine();
                 final int col = firstFinding.getCol();
                 log(line, col, "multiple.string.literal", key, hits.size());
             }
         }
     }
 
     /**
      * This class contains information about where a string was found.
      */
     private static final class StringInfo
     {
         /**
          * Line of finding
          */
-        private final int mLine;
+        private final int line;
         /**
          * Column of finding
          */
-        private final int mCol;
+        private final int col;
         /**
          * Creates information about a string position.
-         * @param aLine int
-         * @param aCol int
+         * @param line int
+         * @param col int
          */
-        private StringInfo(int aLine, int aCol)
+        private StringInfo(int line, int col)
         {
-            mLine = aLine;
-            mCol = aCol;
+            this.line = line;
+            this.col = col;
         }
 
         /**
          * The line where a string was found.
          * @return int Line of the string.
          */
         private int getLine()
         {
-            return mLine;
+            return line;
         }
 
         /**
          * The column where a string was found.
          * @return int Column of the string.
          */
         private int getCol()
         {
-            return mCol;
+            return col;
         }
     }
 
 }
