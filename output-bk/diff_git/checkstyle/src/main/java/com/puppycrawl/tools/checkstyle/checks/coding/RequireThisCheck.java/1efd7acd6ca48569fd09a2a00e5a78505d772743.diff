diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index bb534ec7a..96ec8ddc3 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -756,105 +756,107 @@ public class RequireThisCheck extends AbstractCheck {
                 if (vertex.getNextSibling() != null) {
                     stack.push(vertex.getNextSibling());
                 }
                 vertex = vertex.getFirstChild();
             }
         }
         return result;
     }
 
     /**
      * Collects all tokens which are equal to current token starting with the current ast node and
      * which line number is lower or equal to the end line number.
      * @param ast ast node.
      * @param token token.
      * @param endLineNumber end line number.
      * @return a set of tokens which are equal to current token starting with the current ast node
      *         and which line number is lower or equal to the end line number.
      */
     private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,
                                                                      int endLineNumber) {
         DetailAST vertex = ast;
         final Set<DetailAST> result = new HashSet<>();
         final Deque<DetailAST> stack = new ArrayDeque<>();
         while (vertex != null || !stack.isEmpty()) {
             if (!stack.isEmpty()) {
                 vertex = stack.pop();
             }
             while (vertex != null) {
                 if (token.equals(vertex)
                         && vertex.getLineNo() <= endLineNumber) {
                     result.add(vertex);
                 }
                 if (vertex.getNextSibling() != null) {
                     stack.push(vertex.getNextSibling());
                 }
                 vertex = vertex.getFirstChild();
             }
         }
         return result;
     }
 
     /**
      * Returns the frame where the method is declared, if the given method is used without
      * 'this' and null otherwise.
      * @param ast the IDENT ast of the name to check.
      * @return the frame where the method is declared, if the given method is used without
      *         'this' and null otherwise.
      */
     private AbstractFrame getMethodWithoutThis(DetailAST ast) {
         AbstractFrame result = null;
-        final AbstractFrame frame = findFrame(ast, true);
-        if (!validateOnlyOverlapping
-                && ((ClassFrame) frame).hasInstanceMethod(ast)
-                && !((ClassFrame) frame).hasStaticMethod(ast)) {
-            result = frame;
+        if (!validateOnlyOverlapping) {
+            final AbstractFrame frame = findFrame(ast, true);
+            if (frame != null
+                    && ((ClassFrame) frame).hasInstanceMethod(ast)
+                    && !((ClassFrame) frame).hasStaticMethod(ast)) {
+                result = frame;
+            }
         }
         return result;
     }
 
     /**
      * Find the class frame containing declaration.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private AbstractFrame findClassFrame(DetailAST name, boolean lookForMethod) {
         AbstractFrame frame = current;
 
         while (true) {
             frame = findFrame(frame, name, lookForMethod);
 
             if (frame == null || frame instanceof ClassFrame) {
                 break;
             }
 
             frame = frame.getParent();
         }
 
         return frame;
     }
 
     /**
      * Find frame containing declaration.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private AbstractFrame findFrame(DetailAST name, boolean lookForMethod) {
         return findFrame(current, name, lookForMethod);
     }
 
     /**
      * Find frame containing declaration.
      * @param frame The parent frame to searching in.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private static AbstractFrame findFrame(AbstractFrame frame, DetailAST name,
             boolean lookForMethod) {
         final AbstractFrame result;
         if (frame == null) {
             result = null;
         }
         else {
