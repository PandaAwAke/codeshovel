diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
index 1e78b89fe..3cdb03bea 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
@@ -45,208 +45,213 @@ import com.puppycrawl.tools.checkstyle.utils.JavadocUtils;
  * <p>To ensure that summary do not contain phrase like "This method returns",
  *  use following config:
  *
  * <pre>
  * &lt;module name=&quot;SummaryJavadocCheck&quot;&gt;
  *     &lt;property name=&quot;forbiddenSummaryFragments&quot;
  *     value=&quot;^This method returns.*&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>
  * To specify period symbol at the end of first javadoc sentence - use following config:
  * </p>
  * <pre>
  * &lt;module name=&quot;SummaryJavadocCheck&quot;&gt;
  *     &lt;property name=&quot;period&quot;
  *     value=&quot;period&quot;/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  *
  * @author max
  * @author <a href="mailto:nesterenko-aleksey@list.ru">Aleksey Nesterenko</a>
  */
 public class SummaryJavadocCheck extends AbstractJavadocCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_SUMMARY_FIRST_SENTENCE = "summary.first.sentence";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_SUMMARY_JAVADOC = "summary.javaDoc";
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_SUMMARY_JAVADOC_MISSING = "summary.javaDoc.missing";
     /**
      * This regexp is used to convert multiline javadoc to single line without stars.
      */
     private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =
             Pattern.compile("\n[ ]+(\\*)|^[ ]+(\\*)");
 
     /** Period literal. */
     private static final String PERIOD = ".";
 
-    /** Inherit doc literal. */
-    private static final String INHERIT_DOC = "{@inheritDoc}";
-
     /** Set of allowed Tokens tags in summary java doc. */
     private static final Set<Integer> ALLOWED_TYPES = Collections.unmodifiableSet(
             new HashSet<>(Arrays.asList(JavadocTokenTypes.TEXT,
                     JavadocTokenTypes.WS))
     );
 
     /** Regular expression for forbidden summary fragments. */
     private Pattern forbiddenSummaryFragments = CommonUtils.createPattern("^$");
 
     /** Period symbol at the end of first javadoc sentence. */
     private String period = PERIOD;
 
     /**
      * Sets custom value of regular expression for forbidden summary fragments.
      * @param pattern a pattern.
      */
     public void setForbiddenSummaryFragments(Pattern pattern) {
         forbiddenSummaryFragments = pattern;
     }
 
     /**
      * Sets value of period symbol at the end of first javadoc sentence.
      * @param period period's value.
      */
     public void setPeriod(String period) {
         this.period = period;
     }
 
     @Override
     public int[] getDefaultJavadocTokens() {
         return new int[] {
             JavadocTokenTypes.JAVADOC,
         };
     }
 
     @Override
     public int[] getRequiredJavadocTokens() {
         return getAcceptableJavadocTokens();
     }
 
     @Override
     public void visitJavadocToken(DetailNode ast) {
-        String firstSentence = getFirstSentence(ast);
-        final int endOfSentence = firstSentence.lastIndexOf(period);
-        final String summaryDoc = getSummarySentence(ast);
-        if (summaryDoc.isEmpty()) {
-            log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);
-        }
-        else if (!period.isEmpty()
-                && !summaryDoc.contains(period)
-                && !summaryDoc.equals(INHERIT_DOC)) {
-            log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);
+        if (!startsWithInheritDoc(ast)) {
+            String firstSentence = getFirstSentence(ast);
+            final int endOfSentence = firstSentence.lastIndexOf(period);
+            final String summaryDoc = getSummarySentence(ast);
+            if (summaryDoc.isEmpty()) {
+                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);
+            }
+            else if (!period.isEmpty()
+                    && !summaryDoc.contains(period)) {
+                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);
+            }
+            if (endOfSentence != -1) {
+                firstSentence = firstSentence.substring(0, endOfSentence);
+                if (containsForbiddenFragment(firstSentence)) {
+                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);
+                }
+            }
         }
-        if (endOfSentence != -1) {
-            firstSentence = firstSentence.substring(0, endOfSentence);
-            if (containsForbiddenFragment(firstSentence)) {
-                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);
+    }
+
+    /**
+     * Checks if the node starts with an {&#64;inheritDoc}.
+     * @param root The root node to examine.
+     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.
+     */
+    private static boolean startsWithInheritDoc(DetailNode root) {
+        boolean found = false;
+        final DetailNode[] children = root.getChildren();
+
+        for (int i = 0; !found && i < children.length - 1; i++) {
+            final DetailNode child = children[i];
+            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG
+                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {
+                found = true;
+            }
+            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK
+                    && !CommonUtils.isBlank(child.getText())) {
+                break;
             }
         }
+
+        return found;
     }
 
     /**
      * Checks if period is at the end of sentence.
      * @param ast Javadoc root node.
      * @return error string
      */
     private static String getSummarySentence(DetailNode ast) {
         boolean flag = true;
         final StringBuilder result = new StringBuilder(256);
         for (DetailNode child : ast.getChildren()) {
             if (ALLOWED_TYPES.contains(child.getType())) {
                 result.append(child.getText());
             }
-            else if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG
-                    && getContentOfChild(child).equals(INHERIT_DOC)) {
-                result.append(INHERIT_DOC);
-            }
             else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT
                     && CommonUtils.isBlank(result.toString().trim())) {
                 result.append(getStringInsideTag(result.toString(),
                         child.getChildren()[0].getChildren()[0]));
             }
             else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {
                 flag = false;
             }
             if (!flag) {
                 break;
             }
         }
         return result.toString().trim();
     }
 
-    /**
-     * Returns content when token type is javadoc inline tag.
-     * @param child javadoc inline tag ast.
-     * @return content of child nodes as string.
-     */
-    private static String getContentOfChild(DetailNode child) {
-        final StringBuilder contents = new StringBuilder(256);
-        for (DetailNode node : child.getChildren()) {
-            contents.append(node.getText().trim());
-        }
-        return contents.toString();
-    }
-
     /**
      * Concatenates string within text of html tags.
      * @param result javadoc string
      * @param detailNode javadoc tag node
      * @return java doc tag content appended in result
      */
     private static String getStringInsideTag(String result, DetailNode detailNode) {
         final StringBuilder contents = new StringBuilder(result);
         DetailNode tempNode = detailNode;
         while (tempNode != null) {
             if (tempNode.getType() == JavadocTokenTypes.TEXT) {
                 contents.append(tempNode.getText());
             }
             tempNode = JavadocUtils.getNextSibling(tempNode);
         }
         return contents.toString();
     }
 
     /**
      * Finds and returns first sentence.
      * @param ast Javadoc root node.
      * @return first sentence.
      */
     private static String getFirstSentence(DetailNode ast) {
         final StringBuilder result = new StringBuilder(256);
         final String periodSuffix = PERIOD + ' ';
         for (DetailNode child : ast.getChildren()) {
             final String text;
             if (child.getChildren().length == 0) {
                 text = child.getText();
             }
             else {
                 text = getFirstSentence(child);
             }
 
             if (child.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG
                 && text.contains(periodSuffix)) {
                 result.append(text.substring(0, text.indexOf(periodSuffix) + 1));
                 break;
             }
             else {
                 result.append(text);
             }
         }
         return result.toString();
     }
 
     /**
      * Tests if first sentence contains forbidden summary fragment.
      * @param firstSentence String with first sentence.
