diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 708710119..b3da34413 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -218,130 +218,132 @@ public final class TreeWalker
             LOG.error(exceptionMsg, ex);
             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));
         }
 
         if (cache != null && getMessageCollector().size() == 0) {
             cache.put(fileName, timestamp);
         }
     }
 
     /**
      * Creates {@link LocalizedMessage} object using default attributes.
      * @param message
      *        message that will be used for created object
      * @return instance of created object
      */
     private LocalizedMessage createLocalizedMessage(String message) {
         return new LocalizedMessage(
                 0,
                 Definitions.CHECKSTYLE_BUNDLE,
                 "general.exception",
                 new String[] {message },
                 getId(),
                 getClass(), null);
     }
 
     /**
      * Register a check for a given configuration.
      * @param check the check to register
      * @throws CheckstyleException if an error occurs
      */
     private void registerCheck(Check check)
         throws CheckstyleException {
         validateDefaultTokens(check);
         final int[] tokens;
         final Set<String> checkTokens = check.getTokenNames();
         if (checkTokens.isEmpty()) {
             tokens = check.getDefaultTokens();
         }
         else {
             tokens = check.getRequiredTokens();
 
             //register configured tokens
             final int[] acceptableTokens = check.getAcceptableTokens();
             Arrays.sort(acceptableTokens);
             for (String token : checkTokens) {
                 final int tokenId = Utils.getTokenId(token);
                 if (Arrays.binarySearch(acceptableTokens, tokenId) >= 0) {
                     registerCheck(token, check);
                 }
                 else {
-                    throw new CheckstyleException("Token \""
-                        + token + "\" was not found in Acceptable tokens list"
-                                + " in check " + check.getClass().getName());
+                    final String message = String.format("Token \"%s\" was not found in "
+                            + "Acceptable tokens list in check %s",
+                            token, check.getClass().getName());
+                    throw new CheckstyleException(message);
                 }
             }
         }
         for (int element : tokens) {
             registerCheck(element, check);
         }
         if (check.isCommentNodesRequired()) {
             commentChecks.add(check);
         }
         else {
             ordinaryChecks.add(check);
         }
     }
 
     /**
      * Validates that check's required tokens are subset of default tokens.
      * @param check to validate
      * @throws CheckstyleException when validation of default tokens fails
      */
     private static void validateDefaultTokens(Check check) throws CheckstyleException {
         final int[] defaultTokens = check.getDefaultTokens();
         if (check.getRequiredTokens().length != 0) {
             Arrays.sort(defaultTokens);
             for (final int token : check.getRequiredTokens()) {
                 if (Arrays.binarySearch(defaultTokens, token) < 0) {
-                    throw new CheckstyleException("Token \"" + token + "\" from required tokens was"
-                        + " not found in default tokens list in check " + check);
+                    final String message = String.format("Token \"%s\" from required tokens was"
+                            + " not found in default tokens list in check %s", token, check);
+                    throw new CheckstyleException(message);
                 }
             }
         }
     }
 
     /**
      * Register a check for a specified token id.
      * @param tokenID the id of the token
      * @param check the check to register
      */
     private void registerCheck(int tokenID, Check check) {
         registerCheck(Utils.getTokenName(tokenID), check);
     }
 
     /**
      * Register a check for a specified token name
      * @param token the name of the token
      * @param check the check to register
      */
     private void registerCheck(String token, Check check) {
         if (check.isCommentNodesRequired()) {
             tokenToCommentChecks.put(token, check);
         }
         else if (Utils.isCommentType(token)) {
             final String message = String.format("Check '%s' waits for comment type "
                     + "token ('%s') and should override 'isCommentNodesRequred()' "
                     + "method to return 'true'", check.getClass().getName(), token);
             LOG.warn(message);
         }
         else {
             tokenToOrdinaryChecks.put(token, check);
         }
     }
 
     /**
      * Initiates the walk of an AST.
      * @param ast the root AST
      * @param contents the contents of the file the AST was generated from.
      * @param astState state of AST.
      */
     private void walk(DetailAST ast, FileContents contents,
             AstState astState) {
         notifyBegin(ast, contents, astState);
 
         // empty files are not flagged by javac, will yield ast == null
         if (ast != null) {
             processIter(ast, astState);
         }
         notifyEnd(ast, astState);
     }
