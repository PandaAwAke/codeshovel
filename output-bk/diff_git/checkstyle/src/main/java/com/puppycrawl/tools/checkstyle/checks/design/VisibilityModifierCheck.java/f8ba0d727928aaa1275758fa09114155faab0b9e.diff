diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 0045d61b9..63bb344b5 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -473,145 +473,174 @@ public class VisibilityModifierCheck
             final DetailAST type = importAst.getFirstChild();
             final String canonicalName = getCanonicalName(type);
             final String shortName = getClassShortName(canonicalName);
 
             // If imported canonical class name is not specified as allowed immutable class,
             // but its short name collides with one of specified class - removes the short name
             // from list to avoid names collision
             if (!immutableClassCanonicalNames.contains(canonicalName)
                      && immutableClassShortNames.contains(shortName)) {
                 immutableClassShortNames.remove(shortName);
             }
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName)) {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * <code>
      * import java.util.*;
      * </code>
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if current variable has proper access modifier according to Check's options.
      * @param variableDef Variable definition node.
      * @param variableName Variable's name.
      * @return true if variable has proper access modifier.
      */
     private boolean hasProperAccessModifier(DetailAST variableDef, String variableName) {
         boolean result = true;
 
-        final Set<String> mods = getModifiers(variableDef);
-        final String variableScope = getVisibilityScope(mods);
 
-        if (!"private".equals(variableScope)) {
-            final DetailAST classDef = variableDef.getParent().getParent();
-            final Set<String> classModifiers = getModifiers(classDef);
+        final String variableScope = getVisibilityScope(variableDef);
 
+        if (!"private".equals(variableScope)) {
             result =
-                mods.contains("static") && mods.contains("final")
+                isStaticFinalVariable(variableDef)
                 || isPackageAllowed() && "package".equals(variableScope)
                 || isProtectedAllowed() && "protected".equals(variableScope)
-                || "public".equals(variableScope)
-                   && getPublicMemberRegexp().matcher(variableName).find()
+                || isIgnoredPublicMember(variableName, variableScope)
                    || allowPublicImmutableFields
-                      && classModifiers.contains("final") && isImmutableField(variableDef);
+                      && isImmutableFieldDefinedInFinalClass(variableDef);
         }
 
         return result;
     }
 
+    /**
+     * Checks whether variable has static final modifiers.
+     * @param variableDef Variable definition node.
+     * @return true of variable has static final modifiers.
+     */
+    private static boolean isStaticFinalVariable(DetailAST variableDef) {
+        final Set<String> modifiers = getModifiers(variableDef);
+        return modifiers.contains("static") && modifiers.contains("final");
+    }
+
+    /**
+     * Checks whether variable belongs to public members that should be ignored.
+     * @param variableName Variable's name.
+     * @param variableScope Variable's scope.
+     * @return true if variable belongs to public members that should be ignored.
+     */
+    private boolean isIgnoredPublicMember(String variableName, String variableScope) {
+        return "public".equals(variableScope)
+            && getPublicMemberRegexp().matcher(variableName).find();
+    }
+
+    /**
+     * Checks whether immutable field is defined in final class.
+     * @param variableDef Variable definition node.
+     * @return true if immutable field is defined in final class.
+     */
+    private boolean isImmutableFieldDefinedInFinalClass(DetailAST variableDef) {
+        final DetailAST classDef = variableDef.getParent().getParent();
+        final Set<String> classModifiers = getModifiers(classDef);
+        return classModifiers.contains("final") && isImmutableField(variableDef);
+    }
+
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST) {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
 
     }
 
     /**
-     * Returns the visibility scope specified with a set of modifiers.
-     * @param modifiers the set of modifier Strings
+     * Returns the visibility scope for the variable.
+     * @param variableDef Variable definition node.
      * @return one of "public", "private", "protected", "package"
      */
-    private static String getVisibilityScope(Set<String> modifiers) {
+    private static String getVisibilityScope(DetailAST variableDef) {
+        final Set<String> modifiers = getModifiers(variableDef);
         String accessModifier = "package";
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
      * Checks if current field is immutable:
      * has final modifier and either a primitive type or instance of class
      * known to be immutable (such as String, ImmutableCollection from Guava and etc).
      * Classes known to be immutable are listed in
      * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
      * @param variableDef Field in consideration.
      * @return true if field is immutable.
      */
     private boolean isImmutableField(DetailAST variableDef) {
         boolean result = false;
 
         final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);
         final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
         if (isFinal) {
             final DetailAST type = variableDef.findFirstToken(TokenTypes.TYPE);
             final boolean isCanonicalName = type.getFirstChild().getType() == TokenTypes.DOT;
             final String typeName = getTypeName(type, isCanonicalName);
 
             result = !isCanonicalName && isPrimitive(type)
                      || immutableClassShortNames.contains(typeName)
                      || isCanonicalName && immutableClassCanonicalNames.contains(typeName);
         }
         return result;
     }
 
     /**
      * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
      * If type is specified via its canonical name - canonical name will be returned,
      * else - short type's name.
      * @param type {@link TokenTypes#TYPE TYPE} node.
      * @param isCanonicalName is given name canonical.
      * @return String representation of given type's name.
      */
     private static String getTypeName(DetailAST type, boolean isCanonicalName) {
         String typeName = "";
         if (isCanonicalName) {
             typeName = getCanonicalName(type);
         }
         else {
