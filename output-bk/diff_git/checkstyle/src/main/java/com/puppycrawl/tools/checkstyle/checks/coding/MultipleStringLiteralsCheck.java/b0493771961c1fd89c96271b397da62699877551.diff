diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
index 6812b374d..6c0be80fc 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
@@ -120,101 +120,100 @@ public class MultipleStringLiteralsCheck extends AbstractCheck {
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (!isInIgnoreOccurrenceContext(ast)) {
             final String currentString = ast.getText();
             if (ignoreStringsRegexp == null || !ignoreStringsRegexp.matcher(currentString).find()) {
                 List<StringInfo> hitList = stringMap.get(currentString);
                 if (hitList == null) {
                     hitList = new ArrayList<>();
                     stringMap.put(currentString, hitList);
                 }
                 final int line = ast.getLineNo();
                 final int col = ast.getColumnNo();
                 hitList.add(new StringInfo(line, col));
             }
         }
     }
 
     /**
      * Analyses the path from the AST root to a given AST for occurrences
      * of the token types in {@link #ignoreOccurrenceContext}.
      *
      * @param ast the node from where to start searching towards the root node
      * @return whether the path from the root node to ast contains one of the
      *     token type in {@link #ignoreOccurrenceContext}.
      */
     private boolean isInIgnoreOccurrenceContext(DetailAST ast) {
         boolean isInIgnoreOccurrenceContext = false;
         for (DetailAST token = ast;
              token.getParent() != null;
              token = token.getParent()) {
             final int type = token.getType();
             if (ignoreOccurrenceContext.get(type)) {
                 isInIgnoreOccurrenceContext = true;
                 break;
             }
         }
         return isInIgnoreOccurrenceContext;
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
-        super.beginTree(rootAST);
         stringMap.clear();
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
         for (Map.Entry<String, List<StringInfo>> stringListEntry : stringMap.entrySet()) {
             final List<StringInfo> hits = stringListEntry.getValue();
             if (hits.size() > allowedDuplicates) {
                 final StringInfo firstFinding = hits.get(0);
                 final int line = firstFinding.getLine();
                 final int col = firstFinding.getCol();
                 log(line, col, MSG_KEY, stringListEntry.getKey(), hits.size());
             }
         }
     }
 
     /**
      * This class contains information about where a string was found.
      */
     private static final class StringInfo {
         /**
          * Line of finding.
          */
         private final int line;
         /**
          * Column of finding.
          */
         private final int col;
 
         /**
          * Creates information about a string position.
          * @param line int
          * @param col int
          */
         StringInfo(int line, int col) {
             this.line = line;
             this.col = col;
         }
 
         /**
          * The line where a string was found.
          * @return int Line of the string.
          */
         private int getLine() {
             return line;
         }
 
         /**
          * The column where a string was found.
          * @return int Column of the string.
