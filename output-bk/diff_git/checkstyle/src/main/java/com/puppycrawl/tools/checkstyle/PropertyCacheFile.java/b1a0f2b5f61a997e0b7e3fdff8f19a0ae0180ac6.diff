diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index 5c38a4826..b0bdf25fc 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -173,127 +173,136 @@ final class PropertyCacheFile {
             Flushables.flush(stream, false);
         }
         Closeables.close(stream, false);
     }
 
     /**
      * Checks that file is in cache.
      * @param uncheckedFileName the file to check
      * @param timestamp the timestamp of the file to check
      * @return whether the specified file has already been checked ok
      */
     public boolean isInCache(String uncheckedFileName, long timestamp) {
         final String lastChecked = details.getProperty(uncheckedFileName);
         return lastChecked != null
             && lastChecked.equals(Long.toString(timestamp));
     }
 
     /**
      * Records that a file checked ok.
      * @param checkedFileName name of the file that checked ok
      * @param timestamp the timestamp of the file
      */
     public void put(String checkedFileName, long timestamp) {
         details.setProperty(checkedFileName, Long.toString(timestamp));
     }
 
     /**
      * Retrieves the hash of a specific file.
      * @param name The name of the file to retrieve.
      * @return The has of the file or {@code null}.
      */
     public String get(String name) {
         return details.getProperty(name);
     }
 
     /**
      * Removed a specific file from the cache.
      * @param checkedFileName The name of the file to remove.
      */
     public void remove(String checkedFileName) {
         details.remove(checkedFileName);
     }
 
     /**
      * Calculates the hashcode for the serializable object based on its content.
      * @param object serializable object.
      * @return the hashcode for serializable object.
      */
     private static String getHashCodeBasedOnObjectContent(Serializable object) {
         try {
-            // im-memory serialization of Configuration
-
             final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-            ObjectOutputStream oos = null;
-            try {
-                oos = new ObjectOutputStream(outputStream);
-                oos.writeObject(object);
-            }
-            finally {
-                flushAndCloseOutStream(oos);
-            }
-
+            // in-memory serialization of Configuration
+            serialize(object, outputStream);
             // Instead of hexEncoding outputStream.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             final MessageDigest digest = MessageDigest.getInstance("SHA-1");
             digest.update(outputStream.toByteArray());
 
             return DatatypeConverter.printHexBinary(digest.digest());
         }
         catch (final IOException | NoSuchAlgorithmException ex) {
             // rethrow as unchecked exception
             throw new IllegalStateException("Unable to calculate hashcode.", ex);
         }
     }
 
+    /**
+     * Serializes object to output stream.
+     * @param object object to be erialized
+     * @param outputStream serialization stream
+     * @throws IOException if an error occurs
+     */
+    private static void serialize(Serializable object,
+                                  OutputStream outputStream) throws IOException {
+        ObjectOutputStream oos = null;
+        try {
+            oos = new ObjectOutputStream(outputStream);
+            oos.writeObject(object);
+        }
+        finally {
+            flushAndCloseOutStream(oos);
+        }
+    }
+
     /**
      * Puts external resources in cache.
      * If at least one external resource changed, clears the cache.
      * @param locations locations of external resources.
      */
     public void putExternalResources(Set<String> locations) {
         final Set<ExternalResource> resources = loadExternalResources(locations);
         if (areExternalResourcesChanged(resources)) {
             reset();
         }
         fillCacheWithExternalResources(resources);
     }
 
     /**
      * Loads a set of {@link ExternalResource} based on their locations.
      * @param resourceLocations locations of external configuration resources.
      * @return a set of {@link ExternalResource}.
      */
     private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {
         final Set<ExternalResource> resources = new HashSet<>();
         for (String location : resourceLocations) {
             String contentHashSum = null;
             try {
                 final byte[] content = loadExternalResource(location);
                 contentHashSum = getHashCodeBasedOnObjectContent(content);
             }
             catch (CheckstyleException ex) {
                 // if exception happened (configuration resource was not found, connection is not
                 // available, resource is broken, etc), we need to calculate hash sum based on
                 // exception object content in order to check whether problem is resolved later
                 // and/or the configuration is changed.
                 contentHashSum = getHashCodeBasedOnObjectContent(ex);
             }
             finally {
                 resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,
                         contentHashSum));
             }
         }
         return resources;
     }
 
     /**
      * Loads the content of external resource.
      * @param location external resource location.
      * @return array of bytes which represents the content of external resource in binary form.
      * @throws CheckstyleException if error while loading occurs.
      */
     private static byte[] loadExternalResource(String location) throws CheckstyleException {
         final byte[] content;
         final URI uri = CommonUtils.getUriByFilename(location);
