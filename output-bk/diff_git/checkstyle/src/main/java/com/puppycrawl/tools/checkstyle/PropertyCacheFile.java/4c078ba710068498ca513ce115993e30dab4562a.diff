diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index 53b8173ba..dfb6e9931 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -87,141 +87,141 @@ final class PropertyCacheFile {
      */
     PropertyCacheFile(Configuration currentConfig, String fileName) {
         boolean setInActive = true;
         if (fileName != null) {
             FileInputStream inStream = null;
             // get the current config so if the file isn't found
             // the first time the hash will be added to output file
             final String currentConfigHash = getConfigHashCode(currentConfig);
             try {
                 inStream = new FileInputStream(fileName);
                 details.load(inStream);
                 final String cachedConfigHash =
                     details.getProperty(CONFIG_HASH_KEY);
                 setInActive = false;
                 if (cachedConfigHash == null
                     || !cachedConfigHash.equals(currentConfigHash)) {
                     // Detected configuration change - clear cache
                     details.clear();
                     details.put(CONFIG_HASH_KEY, currentConfigHash);
                 }
             }
             catch (final FileNotFoundException e) {
                 // Ignore, the cache does not exist
                 setInActive = false;
                 // put the hash in the file if the file is going to be created
                 details.put(CONFIG_HASH_KEY, currentConfigHash);
             }
             catch (final IOException e) {
                 LOG.debug("Unable to open cache file, ignoring.", e);
             }
             finally {
                 Closeables.closeQuietly(inStream);
             }
         }
         detailsFile = setInActive ? null : fileName;
     }
 
     /** Cleans up the object and updates the cache file. **/
     void destroy() {
         if (detailsFile != null) {
             FileOutputStream out = null;
             try {
                 out = new FileOutputStream(detailsFile);
                 details.store(out, null);
             }
             catch (final IOException e) {
                 LOG.debug("Unable to save cache file.", e);
             }
             finally {
                 if (out != null) {
-                    this.flushAndCloseOutStream(out);
+                    flushAndCloseOutStream(out);
                 }
             }
         }
     }
 
     /**
      * Flushes and closes output stream.
      * @param stream the output stream
      */
-    private void flushAndCloseOutStream(OutputStream stream) {
+    private static void flushAndCloseOutStream(OutputStream stream) {
         try {
             Flushables.flush(stream, false);
             Closeables.close(stream, false);
         }
         catch (final IOException ex) {
             LOG.debug("Unable to flush and close output stream.", ex);
         }
     }
 
     /**
      * @param fileName the file to check
      * @param timestamp the timestamp of the file to check
      * @return whether the specified file has already been checked ok
      */
     boolean alreadyChecked(String fileName, long timestamp) {
         final String lastChecked = details.getProperty(fileName);
         return lastChecked != null
             && lastChecked.equals(Long.toString(timestamp));
     }
 
     /**
      * Records that a file checked ok.
      * @param fileName name of the file that checked ok
      * @param timestamp the timestamp of the file
      */
     void checkedOk(String fileName, long timestamp) {
         details.put(fileName, Long.toString(timestamp));
     }
 
     /**
      * Calculates the hashcode for a GlobalProperties.
      *
      * @param configuration the GlobalProperties
      * @return the hashcode for <code>configuration</code>
      */
-    private String getConfigHashCode(Serializable configuration) {
+    private static String getConfigHashCode(Serializable configuration) {
         try {
             // im-memory serialization of Configuration
 
             final ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = null;
             try {
                 oos = new ObjectOutputStream(baos);
                 oos.writeObject(configuration);
             }
             finally {
-                this.flushAndCloseOutStream(oos);
+                flushAndCloseOutStream(oos);
             }
 
             // Instead of hexEncoding baos.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             final MessageDigest md = MessageDigest.getInstance("SHA-1");
             md.update(baos.toByteArray());
 
             return hexEncode(md.digest());
         }
         catch (final IOException | NoSuchAlgorithmException ex) {
             // rethrow as unchecked exception
             throw new IllegalStateException("Unable to calculate hashcode.", ex);
         }
     }
 
     /**
      * Hex-encodes a byte array.
      * @param byteArray the byte array
      * @return hex encoding of <code>byteArray</code>
      */
     private static String hexEncode(byte... byteArray) {
         final StringBuilder buf = new StringBuilder(2 * byteArray.length);
         for (final byte b : byteArray) {
             final int low = b & MASK_0X0F;
             final int high = b >> SHIFT_4 & MASK_0X0F;
             buf.append(HEX_CHARS[high]);
             buf.append(HEX_CHARS[low]);
         }
         return buf.toString();
     }
 }
