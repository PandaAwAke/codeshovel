diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
index da0e81085..8a76f7d4e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
@@ -50,115 +50,115 @@ public class FinalClassCheck
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "final.class";
 
     /**
      * Character separate package names in qualified name of java class.
      */
     private static final String PACKAGE_SEPARATOR = ".";
 
     /** Keeps ClassDesc objects for stack of declared classes. */
     private Deque<ClassDesc> classes;
 
     /** Full qualified name of the package. */
     private String packageName;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF, TokenTypes.PACKAGE_DEF};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         classes = new ArrayDeque<>();
         packageName = "";
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         switch (ast.getType()) {
 
             case TokenTypes.PACKAGE_DEF:
                 packageName = extractQualifiedName(ast);
                 break;
 
             case TokenTypes.CLASS_DEF:
                 registerNestedSubclassToOuterSuperClasses(ast);
 
-                final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
-                final boolean isAbstract = modifiers.branchContains(TokenTypes.ABSTRACT);
+                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;
+                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;
 
                 final String qualifiedClassName = getQualifiedClassName(ast);
                 classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));
                 break;
 
             case TokenTypes.CTOR_DEF:
                 if (!ScopeUtils.isInEnumBlock(ast)) {
                     final ClassDesc desc = classes.peek();
-                    if (modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)) {
-                        desc.registerPrivateCtor();
+                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {
+                        desc.registerNonPrivateCtor();
                     }
                     else {
-                        desc.registerNonPrivateCtor();
+                        desc.registerPrivateCtor();
                     }
                 }
                 break;
 
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             final ClassDesc desc = classes.pop();
             if (desc.isWithPrivateCtor()
                 && !desc.isDeclaredAsAbstract()
                 && !desc.isDeclaredAsFinal()
                 && !desc.isWithNonPrivateCtor()
                 && !desc.isWithNestedSubclass()
                 && !ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
                 final String qualifiedName = desc.getQualifiedName();
                 final String className = getClassNameFromQualifiedName(qualifiedName);
                 log(ast.getLineNo(), MSG_KEY, className);
             }
         }
     }
 
     /**
      * Get name of class(with qualified package if specified) in extend clause.
      * @param classExtend extend clause to extract class name
      * @return super class name
      */
     private static String extractQualifiedName(DetailAST classExtend) {
         final String className;
 
         if (classExtend.findFirstToken(TokenTypes.IDENT) == null) {
             // Name specified with packages, have to traverse DOT
             final DetailAST firstChild = classExtend.findFirstToken(TokenTypes.DOT);
             final List<String> qualifiedNameParts = new LinkedList<>();
 
             qualifiedNameParts.add(0, firstChild.findFirstToken(TokenTypes.IDENT).getText());
             DetailAST traverse = firstChild.findFirstToken(TokenTypes.DOT);
             while (traverse != null) {
                 qualifiedNameParts.add(0, traverse.findFirstToken(TokenTypes.IDENT).getText());
                 traverse = traverse.findFirstToken(TokenTypes.DOT);
             }
             className = String.join(PACKAGE_SEPARATOR, qualifiedNameParts);
         }
         else {
             className = classExtend.findFirstToken(TokenTypes.IDENT).getText();
         }
