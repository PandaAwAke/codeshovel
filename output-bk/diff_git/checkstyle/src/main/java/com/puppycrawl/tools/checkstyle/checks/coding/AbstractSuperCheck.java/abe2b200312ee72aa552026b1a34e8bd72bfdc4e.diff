diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java
index 43dd980c4..d0f11f232 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java
@@ -54,100 +54,109 @@ public abstract class AbstractSuperCheck
          * Constructs a stack node for a method definition.
          * @param ast AST for the method definition.
          */
         public MethodNode(DetailAST ast)
         {
             method = ast;
             callsSuper = false;
         }
 
         /**
          * Records that the overriding method has a call to the super method.
          */
         public void setCallsSuper()
         {
             callsSuper = true;
         }
 
         /**
          * Determines whether the overriding method has a call to the super
          * method.
          * @return true if the overriding method has a call to the super
          * method.
          */
         public boolean getCallsSuper()
         {
             return callsSuper;
         }
 
         /**
          * Returns the overriding method definition AST.
          * @return the overriding method definition AST.
          */
         public DetailAST getMethod()
         {
             return method;
         }
     }
 
     /** stack of methods */
     private final LinkedList<MethodNode> methodStack = Lists.newLinkedList();
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.LITERAL_SUPER,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.METHOD_DEF,
+            TokenTypes.LITERAL_SUPER,
+        };
+    }
+
     /**
      * Returns the name of the overriding method.
      * @return the name of the overriding method.
      */
     protected abstract String getMethodName();
 
     @Override
     public void beginTree(DetailAST rootAST)
     {
         methodStack.clear();
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         if (isOverridingMethod(ast)) {
             methodStack.add(new MethodNode(ast));
         }
         else if (isSuperCall(ast)) {
             final MethodNode methodNode = methodStack.getLast();
             methodNode.setCallsSuper();
         }
     }
 
     /**
      *  Determines whether a 'super' literal is a call to the super method
      * for this check.
      * @param ast the AST node of a 'super' literal.
      * @return true if ast is a call to the super method
      * for this check.
      */
     private boolean isSuperCall(DetailAST ast)
     {
         if (ast.getType() != TokenTypes.LITERAL_SUPER) {
             return false;
         }
         // dot operator?
         DetailAST parent = ast.getParent();
         if ((parent == null) || (parent.getType() != TokenTypes.DOT)) {
             return false;
         }
 
         // same name of method
         AST sibling = ast.getNextSibling();
         // ignore type parameters
         if ((sibling != null)
             && (sibling.getType() == TokenTypes.TYPE_ARGUMENTS))
         {
             sibling = sibling.getNextSibling();
         }
