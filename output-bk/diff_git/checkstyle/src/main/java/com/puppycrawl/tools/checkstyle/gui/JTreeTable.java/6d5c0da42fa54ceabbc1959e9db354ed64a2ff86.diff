diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
index b8392c30a..1ad576598 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/JTreeTable.java
@@ -166,101 +166,101 @@ public class JTreeTable extends JTable {
     }
 
     /**
      * Overridden to message super and forward the method to the tree.
      * Since the tree is not actually in the component hierarchy it will
      * never receive this unless we forward it in this manner.
      */
     @Override
     public void updateUI() {
         super.updateUI();
         if (tree != null) {
             tree.updateUI();
         }
         // Use the tree's default foreground and background colors in the
         // table.
         LookAndFeel.installColorsAndFont(this, "Tree.background",
                 "Tree.foreground", "Tree.font");
     }
 
     /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to
      * paint the editor. The UI currently uses different techniques to
      * paint the renderers and editors and overriding setBounds() below
      * is not the right thing to do for an editor. Returning -1 for the
      * editing row in this case, ensures the editor is never painted.
      */
     @Override
     public int getEditingRow() {
         final Class<?> editingClass = getColumnClass(editingColumn);
         return editingClass == TreeTableModel.class ? -1 : editingRow;
     }
 
     /**
      * Overridden to pass the new rowHeight to the tree.
      */
     @Override
     public final void setRowHeight(int newRowHeight) {
         super.setRowHeight(newRowHeight);
         if (tree != null && tree.getRowHeight() != newRowHeight) {
             tree.setRowHeight(getRowHeight());
         }
     }
 
     /**
      * @return the tree that is being shared between the model.
      */
     public JTree getTree() {
         return tree;
     }
 
     public void setEditor(JTextArea mJTextArea) {
-        this.editor = mJTextArea;
+        editor = mJTextArea;
     }
 
     public void setLinePositionMap(List<Integer> lines2position) {
         this.lines2position = ImmutableList.copyOf(lines2position);
     }
 
     /**
      * A TreeCellRenderer that displays a JTree.
      */
     class TreeTableCellRenderer extends JTree implements
             TableCellRenderer {
         /**
          *
          */
         private static final long serialVersionUID = 4324031590789321581L;
         /** Last table/tree row asked to renderer. */
         protected int visibleRow;
 
         /** creates a new instance */
         public TreeTableCellRenderer(TreeModel model) {
             super(model);
         }
 
         /**
          * updateUI is overridden to set the colors of the Tree's renderer
          * to match that of the table.
          */
         @Override
         public void updateUI() {
             super.updateUI();
             // Make the tree's cell renderer use the table's cell selection
             // colors.
             final TreeCellRenderer tcr = getCellRenderer();
             if (tcr instanceof DefaultTreeCellRenderer) {
                 final DefaultTreeCellRenderer dtcr = (DefaultTreeCellRenderer) tcr;
                 // For 1.1 uncomment this, 1.2 has a bug that will cause an
                 // exception to be thrown if the border selection color is
                 // null.
                 // dtcr.setBorderSelectionColor(null);
                 dtcr.setTextSelectionColor(UIManager.getColor("Table.selectionForeground"));
                 dtcr.setBackgroundSelectionColor(UIManager.getColor("Table.selectionBackground"));
             }
         }
 
         /**
          * Sets the row height of the tree, and forwards the row height to
          * the table.
          */
         @Override
         public void setRowHeight(int newRowHeight) {
