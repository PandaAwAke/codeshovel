diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
index d97891498..b13554833 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
@@ -161,119 +161,119 @@ public final class BooleanExpressionComplexityCheck extends Check
 
     /**
      * Checks if {@link TokenTypes#BOR binary OR} is applied to exceptions
      * in
      * <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20">
      * multi-catch</a> (pipe-syntax).
      * @param binaryOr {@link TokenTypes#BOR binary or}
      * @return true if binary or is applied to exceptions in multi-catch.
      */
     private static boolean isPipeOperator(DetailAST binaryOr)
     {
         return binaryOr.getParent().getType() == TokenTypes.TYPE;
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 leaveMethodDef();
                 break;
             case TokenTypes.EXPR:
                 leaveExpr(ast);
                 break;
             default:
                 // Do nothing
         }
     }
 
     /**
      * Creates new context for a given method.
      * @param ast a method we start to check.
      */
     private void visitMethodDef(DetailAST ast)
     {
         contextStack.push(context);
         context = new Context(!CheckUtils.isEqualsMethod(ast));
     }
 
     /** Removes old context. */
     private void leaveMethodDef()
     {
         context = contextStack.pop();
     }
 
     /** Creates and pushes new context. */
     private void visitExpr()
     {
         contextStack.push(context);
-        context = new Context((context == null) || context.isChecking());
+        context = new Context(context == null || context.isChecking());
     }
 
     /**
      * Restores previous context.
      * @param ast expression we leave.
      */
     private void leaveExpr(DetailAST ast)
     {
         context.checkCount(ast);
         context = contextStack.pop();
     }
 
     /**
      * Represents context (method/expression) in which we check complexity.
      *
      * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
      * @author o_sukhodolsky
      */
     private class Context
     {
         /**
          * Should we perform check in current context or not.
          * Usually false if we are inside equals() method.
          */
         private final boolean checking;
         /** Count of boolean operators. */
         private int count;
 
         /**
          * Creates new instance.
          * @param checking should we check in current context or not.
          */
         public Context(boolean checking)
         {
             this.checking = checking;
             count = 0;
         }
 
         /**
          * Getter for checking property.
          * @return should we check in current context or not.
          */
         public boolean isChecking()
         {
             return checking;
         }
 
         /** Increases operator counter. */
         public void visitBooleanOperator()
         {
             ++count;
         }
 
         /**
          * Checks if we violates maximum allowed complexity.
          * @param ast a node we check now.
          */
         public void checkCount(DetailAST ast)
         {
-            if (checking && (count > getMax())) {
+            if (checking && count > getMax()) {
                 final DetailAST parentAST = ast.getParent();
 
                 log(parentAST.getLineNo(), parentAST.getColumnNo(),
                     MSG_KEY, count, getMax());
             }
         }
     }
 }
