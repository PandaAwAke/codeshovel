diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
index 141a0a7ab..3a73890ff 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java
@@ -57,100 +57,111 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 public class DeclarationOrderCheck extends Check
 {
     /** State for the VARIABLE_DEF */
     private static final int STATE_STATIC_VARIABLE_DEF = 1;
 
     /** State for the VARIABLE_DEF */
     private static final int STATE_INSTANCE_VARIABLE_DEF = 2;
 
     /** State for the CTOR_DEF */
     private static final int STATE_CTOR_DEF = 3;
 
     /** State for the METHOD_DEF */
     private static final int STATE_METHOD_DEF = 4;
 
     /**
      * List of Declaration States. This is necessary due to
      * inner classes that have their own state
      */
     private final FastStack<ScopeState> scopeStates = FastStack.newInstance();
 
     /**
      * private class to encapsulate the state
      */
     private static class ScopeState
     {
         /** The state the check is in */
         private int scopeState = STATE_STATIC_VARIABLE_DEF;
 
         /** The sub-state the check is in */
         private Scope declarationAccess = Scope.PUBLIC;
     }
 
     /** If true, ignores the check to constructors. */
     private boolean ignoreConstructors;
     /** If true, ignore the check to methods. */
     private boolean ignoreMethods;
     /** If true, ignore the check to modifiers (fields, ...). */
     private boolean ignoreModifiers;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.MODIFIERS,
             TokenTypes.OBJBLOCK,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.CTOR_DEF,
+            TokenTypes.METHOD_DEF,
+            TokenTypes.MODIFIERS,
+            TokenTypes.OBJBLOCK,
+        };
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         final int parentType = ast.getParent().getType();
         ScopeState state;
 
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
                 scopeStates.push(new ScopeState());
                 break;
 
             case TokenTypes.CTOR_DEF:
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
                 state = scopeStates.peek();
                 if (state.scopeState > STATE_CTOR_DEF) {
                     if (!ignoreConstructors) {
                         log(ast, "declaration.order.constructor");
                     }
                 }
                 else {
                     state.scopeState = STATE_CTOR_DEF;
                 }
                 break;
 
             case TokenTypes.METHOD_DEF:
                 state = scopeStates.peek();
                 if (parentType != TokenTypes.OBJBLOCK) {
                     return;
                 }
 
                 if (state.scopeState > STATE_METHOD_DEF) {
                     if (!ignoreMethods) {
                         log(ast, "declaration.order.method");
                     }
                 }
                 else {
                     state.scopeState = STATE_METHOD_DEF;
                 }
                 break;
 
             case TokenTypes.MODIFIERS:
                 if ((parentType != TokenTypes.VARIABLE_DEF)
                     || (ast.getParent().getParent().getType()
                         != TokenTypes.OBJBLOCK))
                 {
                     return;
                 }
