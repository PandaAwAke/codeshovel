diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java
index b83a284e5..6ff7cb188 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java
@@ -216,103 +216,102 @@ public class AbbreviationAsWordInNameCheck extends Check
                 // field declarations in interface are static/final
                 result = true;
             }
             else {
                 result = (mIgnoreFinal
                           && modifiers.branchContains(TokenTypes.FINAL))
                     || (mIgnoreStatic
                         && modifiers.branchContains(TokenTypes.LITERAL_STATIC));
             }
         }
         else if (aAst.getType() == TokenTypes.METHOD_DEF) {
             result = mIgnoreOverriddenMethods
                     && hasOverrideAnnotation(modifiers);
         }
         return result;
     }
 
     /**
      * Check that variable definition in interface definition.
      * @param aVariableDefAst variable definition.
      * @return true if variable definition(aVaribaleDefAst) is in interface
      * definition.
      */
     private static boolean isInterfaceDeclaration(DetailAST aVariableDefAst)
     {
         boolean result = false;
         final DetailAST astBlock = aVariableDefAst.getParent();
         if (astBlock != null) {
             final DetailAST astParent2 = astBlock.getParent();
             if (astParent2 != null
                     && astParent2.getType() == TokenTypes.INTERFACE_DEF)
             {
                 result = true;
             }
         }
         return result;
     }
 
     /**
      * Checks that the method has "@Override" annotation.
      * @param aMethodModifiersAST
      *        A DetailAST nod is related to the given method modifiers
      *        (MODIFIERS type).
      * @return true if method has "@Override" annotation.
      */
     private static boolean hasOverrideAnnotation(DetailAST aMethodModifiersAST)
     {
         boolean result = false;
         for (DetailAST child : getChildren(aMethodModifiersAST)) {
             if (child.getType() == TokenTypes.ANNOTATION) {
-                final String annotationText =
-                        child.findFirstToken(TokenTypes.IDENT).getText();
-                if ("Override".equals(annotationText)) {
+                final DetailAST annotationIdent = child.findFirstToken(TokenTypes.IDENT);
+                if (annotationIdent != null && "Override".equals(annotationIdent.getText())) {
                     result = true;
                     break;
                 }
             }
         }
         return result;
     }
 
     /**
      * Gets the disallowed abbreviation contained in given String.
      * @param aString
      *        the given String.
      * @return the disallowed abbreviation contained in given String as a
      *         separate String.
      */
     private String getDisallowedAbbreviation(String aString)
     {
         int beginIndex = 0;
         boolean abbrStarted = false;
         String result = null;
 
         for (int index = 0; index < aString.length(); index++) {
             final char symbol = aString.charAt(index);
 
             if (Character.isUpperCase(symbol)) {
                 if (!abbrStarted) {
                     abbrStarted = true;
                     beginIndex = index;
                 }
             }
             else {
                 if (abbrStarted) {
                     abbrStarted = false;
 
                     // -1 as a first capital is usually beginning of next word
                     final int endIndex = index - 1;
                     final int abbrLength = endIndex - beginIndex;
                     if (abbrLength > mAllowedAbbreviationLength) {
                         result = aString.substring(beginIndex, endIndex);
                         if (!mAllowedAbbreviations.contains(result)) {
                             break;
                         }
                         else {
                             result = null;
                         }
                     }
                     beginIndex = -1;
                 }
             }
         }
