diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index adeae49bd..d2fa51ec0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -85,122 +85,137 @@ public class CommentsIndentationCheck extends AbstractCheck {
             TokenTypes.SINGLE_LINE_COMMENT,
             TokenTypes.BLOCK_COMMENT_BEGIN,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.SINGLE_LINE_COMMENT,
             TokenTypes.BLOCK_COMMENT_BEGIN,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST commentAst) {
         switch (commentAst.getType()) {
             case TokenTypes.SINGLE_LINE_COMMENT:
             case TokenTypes.BLOCK_COMMENT_BEGIN:
                 visitComment(commentAst);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + commentAst.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks comment indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * // some comment - this is ok
      * double d = 3.14;
      *     // some comment - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param comment comment to check.
      */
     private void visitComment(DetailAST comment) {
         final DetailAST prevStmt = getPreviousStatement(comment);
-        final DetailAST nextStmt = comment.getNextSibling();
+        final DetailAST nextStmt = getNextStmt(comment);
 
         if (!isTrailingComment(comment)) {
             if (isInEmptyCaseBlock(prevStmt, nextStmt)) {
                 handleCommentInEmptyCaseBlock(prevStmt, comment, nextStmt);
             }
             else if (isFallThroughComment(prevStmt, nextStmt)) {
                 handleFallThroughtComment(prevStmt, comment, nextStmt);
             }
             else if (isInEmptyCodeBlock(prevStmt, nextStmt)) {
                 handleCommentInEmptyCodeBlock(comment, nextStmt);
             }
             else if (isCommentAtTheEndOfTheCodeBlock(nextStmt)) {
                 handleCommentAtTheEndOfTheCodeBlock(prevStmt, comment, nextStmt);
             }
             else if (nextStmt != null && !areSameLevelIndented(comment, nextStmt, nextStmt)) {
                 log(comment.getLineNo(), getMessageKey(comment), nextStmt.getLineNo(),
                     comment.getColumnNo(), nextStmt.getColumnNo());
             }
         }
     }
 
+    /**
+     * Returns the next statement of a comment.
+     * @param comment comment.
+     * @return the next statement of a comment.
+     */
+    private static DetailAST getNextStmt(DetailAST comment) {
+        DetailAST nextStmt = comment.getNextSibling();
+        while (nextStmt != null
+                && isComment(nextStmt)
+                && comment.getColumnNo() != nextStmt.getColumnNo()) {
+            nextStmt = nextStmt.getNextSibling();
+        }
+        return nextStmt;
+    }
+
     /**
      * Returns the previous statement of a comment.
      * @param comment comment.
      * @return the previous statement of a comment.
      */
     private DetailAST getPreviousStatement(DetailAST comment) {
         final DetailAST prevStatement;
         if (isDistributedPreviousStatement(comment)) {
             prevStatement = getDistributedPreviousStatement(comment);
         }
         else {
             prevStatement = getOneLinePreviousStatement(comment);
         }
         return prevStatement;
     }
 
     /**
      * Checks whether the previous statement of a comment is distributed over two or more lines.
      * @param comment comment to check.
      * @return true if the previous statement of a comment is distributed over two or more lines.
      */
     private boolean isDistributedPreviousStatement(DetailAST comment) {
         final DetailAST previousSibling = comment.getPreviousSibling();
         return isDistributedExpression(comment)
             || isDistributedReturnStatement(previousSibling)
             || isDistributedThrowStatement(previousSibling);
     }
 
     /**
      * Checks whether the previous statement of a comment is a method call chain or
      * string concatenation statemen distributed over two ore more lines.
      * @param comment comment to check.
      * @return true if the previous statement is a distributed expression.
      */
     private boolean isDistributedExpression(DetailAST comment) {
         DetailAST previousSibling = comment.getPreviousSibling();
         while (previousSibling != null && isComment(previousSibling)) {
             previousSibling = previousSibling.getPreviousSibling();
         }
         boolean isDistributed = false;
         if (previousSibling != null) {
             if (previousSibling.getType() == TokenTypes.SEMI
                     && isOnPreviousLineIgnoringComments(comment, previousSibling)) {
                 DetailAST currentToken = previousSibling.getPreviousSibling();
                 while (currentToken.getFirstChild() != null) {
                     currentToken = currentToken.getFirstChild();
                 }
                 if (currentToken.getType() == TokenTypes.COMMENT_CONTENT) {
                     currentToken = currentToken.getParent();
                     while (isComment(currentToken)) {
