diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 9de035b32..4fc35fa6b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -318,286 +318,290 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
         };
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     protected final void processAST(DetailAST ast) {
         final Scope theScope = calculateScope(ast);
         if (shouldCheck(ast, theScope)) {
             final FileContents contents = getFileContents();
             final TextBlock textBlock = contents.getJavadocBefore(ast.getLineNo());
 
             if (textBlock == null) {
                 if (!isMissingJavadocAllowed(ast)) {
                     log(ast, MSG_JAVADOC_MISSING);
                 }
             }
             else {
                 checkComment(ast, textBlock);
             }
         }
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private boolean hasAllowedAnnotations(DetailAST methodDef) {
+        boolean result = false;
         final DetailAST modifiersNode = methodDef.findFirstToken(TokenTypes.MODIFIERS);
         DetailAST annotationNode = modifiersNode.findFirstToken(TokenTypes.ANNOTATION);
         while (annotationNode != null && annotationNode.getType() == TokenTypes.ANNOTATION) {
             DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);
             if (identNode == null) {
                 identNode = annotationNode.findFirstToken(TokenTypes.DOT)
                     .findFirstToken(TokenTypes.IDENT);
             }
             if (allowedAnnotations.contains(identNode.getText())) {
-                return true;
+                result = true;
+                break;
             }
             annotationNode = annotationNode.getNextSibling();
         }
-        return false;
+        return result;
     }
 
     /**
      * Some javadoc.
      * @param methodDef Some javadoc.
      * @return Some javadoc.
      */
     private static int getMethodsNumberOfLine(DetailAST methodDef) {
         final int numberOfLines;
         final DetailAST lcurly = methodDef.getLastChild();
         final DetailAST rcurly = lcurly.getLastChild();
 
         if (lcurly.getFirstChild() == rcurly) {
             numberOfLines = 1;
         }
         else {
             numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;
         }
         return numberOfLines;
     }
 
     @Override
     protected final void logLoadError(Token ident) {
         logLoadErrorImpl(ident.getLineNo(), ident.getColumnNo(),
             MSG_CLASS_INFO,
             JavadocTagInfo.THROWS.getText(), ident.getText());
     }
 
     /**
      * The JavadocMethodCheck is about to report a missing Javadoc.
      * This hook can be used by derived classes to allow a missing javadoc
      * in some situations.  The default implementation checks
      * {@code allowMissingJavadoc} and
      * {@code allowMissingPropertyJavadoc} properties, do not forget
      * to call {@code super.isMissingJavadocAllowed(ast)} in case
      * you want to keep this logic.
      * @param ast the tree node for the method or constructor.
      * @return True if this method or constructor doesn't need Javadoc.
      */
     protected boolean isMissingJavadocAllowed(final DetailAST ast) {
         return allowMissingJavadoc
             || allowMissingPropertyJavadoc
                 && (CheckUtils.isSetterMethod(ast) || CheckUtils.isGetterMethod(ast))
             || matchesSkipRegex(ast)
             || isContentsAllowMissingJavadoc(ast);
     }
 
     /**
      * Checks if the Javadoc can be missing if the method or constructor is
      * below the minimum line count or has a special annotation.
      *
      * @param ast the tree node for the method or constructor.
      * @return True if this method or constructor doesn't need Javadoc.
      */
     private boolean isContentsAllowMissingJavadoc(DetailAST ast) {
         return (ast.getType() == TokenTypes.METHOD_DEF || ast.getType() == TokenTypes.CTOR_DEF)
                 && (getMethodsNumberOfLine(ast) <= minLineCount || hasAllowedAnnotations(ast));
     }
 
     /**
      * Checks if the given method name matches the regex. In that case
      * we skip enforcement of javadoc for this method
      * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
      * @return true if given method name matches the regex.
      */
     private boolean matchesSkipRegex(DetailAST methodDef) {
+        boolean result = false;
         if (ignoreMethodNamesRegex != null) {
             final DetailAST ident = methodDef.findFirstToken(TokenTypes.IDENT);
             final String methodName = ident.getText();
 
             final Matcher matcher = ignoreMethodNamesRegex.matcher(methodName);
             if (matcher.matches()) {
-                return true;
+                result = true;
             }
         }
-        return false;
+        return result;
     }
 
     /**
      * Whether we should check this node.
      *
      * @param ast a given node.
      * @param nodeScope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST ast, final Scope nodeScope) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(ast);
 
         return (excludeScope == null
                 || nodeScope != excludeScope
                 && surroundingScope != excludeScope)
             && nodeScope.isIn(scope)
             && surroundingScope.isIn(scope);
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param ast the token for the method
      * @param comment the Javadoc comment
      */
     private void checkComment(DetailAST ast, TextBlock comment) {
         final List<JavadocTag> tags = getMethodTags(comment);
 
         if (!hasShortCircuitTag(ast, tags)) {
             final Iterator<JavadocTag> it = tags.iterator();
             if (ast.getType() == TokenTypes.ANNOTATION_FIELD_DEF) {
                 checkReturnTag(tags, ast.getLineNo(), true);
             }
             else {
                 // Check for inheritDoc
                 boolean hasInheritDocTag = false;
                 while (!hasInheritDocTag && it.hasNext()) {
                     hasInheritDocTag = it.next().isInheritDocTag();
                 }
                 final boolean reportExpectedTags = !hasInheritDocTag && !hasAllowedAnnotations(ast);
 
                 checkParamTags(tags, ast, reportExpectedTags);
                 checkThrowsTags(tags, getThrows(ast), reportExpectedTags);
                 if (CheckUtils.isNonVoidMethod(ast)) {
                     checkReturnTag(tags, ast.getLineNo(), reportExpectedTags);
                 }
             }
 
             // Dump out all unused tags
             tags.stream().filter(javadocTag -> !javadocTag.isSeeOrInheritDocTag())
                 .forEach(javadocTag -> log(javadocTag.getLineNo(), MSG_UNUSED_TAG_GENERAL));
         }
     }
 
     /**
      * Validates whether the Javadoc has a short circuit tag. Currently this is
      * the inheritTag. Any errors are logged.
      *
      * @param ast the construct being checked
      * @param tags the list of Javadoc tags associated with the construct
      * @return true if the construct has a short circuit tag.
      */
-    private boolean hasShortCircuitTag(final DetailAST ast,
-            final List<JavadocTag> tags) {
+    private boolean hasShortCircuitTag(final DetailAST ast, final List<JavadocTag> tags) {
+        boolean result = true;
         // Check if it contains {@inheritDoc} tag
-        if (tags.size() != 1
-                || !tags.get(0).isInheritDocTag()) {
-            return false;
+        if (tags.size() == 1
+                && tags.get(0).isInheritDocTag()) {
+            // Invalid if private, a constructor, or a static method
+            if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
+                log(ast, MSG_INVALID_INHERIT_DOC);
+            }
         }
-
-        // Invalid if private, a constructor, or a static method
-        if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
-            log(ast, MSG_INVALID_INHERIT_DOC);
+        else {
+            result = false;
         }
-
-        return true;
+        return result;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private static Scope calculateScope(final DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
-        final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
+        final Scope scope;
 
         if (ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
-            return Scope.PUBLIC;
+            scope = Scope.PUBLIC;
         }
         else {
-            return declaredScope;
+            scope = ScopeUtils.getScopeFromMods(mods);
         }
+        return scope;
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      *
      * @param comment the Javadoc comment
      * @return the tags found
      */
     private static List<JavadocTag> getMethodTags(TextBlock comment) {
         final String[] lines = comment.getText();
         final List<JavadocTag> tags = new ArrayList<>();
         int currentLine = comment.getStartLineNo() - 1;
         final int startColumnNumber = comment.getStartColNo();
 
         for (int i = 0; i < lines.length; i++) {
             currentLine++;
             final Matcher javadocArgMatcher =
                 MATCH_JAVADOC_ARG.matcher(lines[i]);
             final Matcher javadocNoargMatcher =
                 MATCH_JAVADOC_NOARG.matcher(lines[i]);
             final Matcher noargCurlyMatcher =
                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);
             final Matcher argMultilineStart =
                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);
             final Matcher noargMultilineStart =
                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);
 
             if (javadocArgMatcher.find()) {
                 final int col = calculateTagColumn(javadocArgMatcher, i, startColumnNumber);
                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),
                         javadocArgMatcher.group(2)));
             }
             else if (javadocNoargMatcher.find()) {
                 final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);
                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));
             }
             else if (noargCurlyMatcher.find()) {
                 final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);
                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));
             }
             else if (argMultilineStart.find()) {
                 final int col = calculateTagColumn(argMultilineStart, i, startColumnNumber);
                 tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));
             }
             else if (noargMultilineStart.find()) {
                 tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));
             }
         }
         return tags;
