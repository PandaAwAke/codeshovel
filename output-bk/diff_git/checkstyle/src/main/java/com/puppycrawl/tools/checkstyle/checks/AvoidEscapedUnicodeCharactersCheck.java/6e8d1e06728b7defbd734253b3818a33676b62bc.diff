diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
index 14465b6cb..4ed74d1b0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
@@ -173,153 +173,153 @@ public class AvoidEscapedUnicodeCharactersCheck
 
     /**
      * Set allowIfAllCharactersEscaped.
      * @param allow user's value.
      */
     public final void setAllowEscapesForControlCharacters(boolean allow) {
         allowEscapesForControlCharacters = allow;
     }
 
     /**
      * Set allowByTailComment.
      * @param allow user's value.
      */
     public final void setAllowByTailComment(boolean allow) {
         allowByTailComment = allow;
     }
 
     /**
      * Set allowIfAllCharactersEscaped.
      * @param allow user's value.
      */
     public final void setAllowIfAllCharactersEscaped(boolean allow) {
         allowIfAllCharactersEscaped = allow;
     }
 
     /**
      * Set allowSpaceEscapes.
      * @param allow user's value.
      */
     public final void setAllowNonPrintableEscapes(boolean allow) {
         allowNonPrintableEscapes = allow;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.STRING_LITERAL, TokenTypes.CHAR_LITERAL};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
-        singlelineComments = getFileContents().getCppComments();
-        blockComments = getFileContents().getCComments();
+        singlelineComments = getFileContents().getSingleLineComments();
+        blockComments = getFileContents().getBlockComments();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
 
         final String literal = ast.getText();
 
         if (hasUnicodeChar(literal) && !(allowByTailComment && hasTrailComment(ast)
                 || isAllCharactersEscaped(literal)
                 || allowEscapesForControlCharacters
                         && isOnlyUnicodeValidChars(literal, UNICODE_CONTROL)
                 || allowNonPrintableEscapes
                         && isOnlyUnicodeValidChars(literal, NON_PRINTABLE_CHARS))) {
             log(ast.getLineNo(), MSG_KEY);
         }
     }
 
     /**
      * Checks if literal has Unicode chars.
      * @param literal String literal.
      * @return true if literal has Unicode chars.
      */
     private static boolean hasUnicodeChar(String literal) {
         final String literalWithoutEscapedBackslashes =
                 ESCAPED_BACKSLASH.matcher(literal).replaceAll("");
         return UNICODE_REGEXP.matcher(literalWithoutEscapedBackslashes).find();
     }
 
     /**
      * Check if String literal contains Unicode control chars.
      * @param literal String literal.
      * @param pattern RegExp for valid characters.
      * @return true, if String literal contains Unicode control chars.
      */
     private static boolean isOnlyUnicodeValidChars(String literal, Pattern pattern) {
         final int unicodeMatchesCounter =
                 countMatches(UNICODE_REGEXP, literal);
         final int unicodeValidMatchesCounter =
                 countMatches(pattern, literal);
         return unicodeMatchesCounter - unicodeValidMatchesCounter == 0;
     }
 
     /**
      * Check if trail comment is present after ast token.
      * @param ast current token.
      * @return true if trail comment is present after ast token.
      */
     private boolean hasTrailComment(DetailAST ast) {
         boolean result = false;
         final int lineNo = ast.getLineNo();
         if (singlelineComments.containsKey(lineNo)) {
             result = true;
         }
         else {
             final String line = getLines()[lineNo - 1];
             final List<TextBlock> commentList = blockComments.get(lineNo);
             if (commentList != null) {
                 final TextBlock comment = commentList.get(commentList.size() - 1);
-                result = isTrailingCComent(comment, line);
+                result = isTrailingBlockComment(comment, line);
             }
         }
         return result;
     }
 
     /**
      * Whether the C style comment is trailing.
      * @param comment the comment to check.
      * @param line the line where the comment starts.
      * @return true if the comment is trailing.
      */
-    private static boolean isTrailingCComent(TextBlock comment, String line) {
+    private static boolean isTrailingBlockComment(TextBlock comment, String line) {
         return comment.getText().length != 1
             || line.substring(comment.getEndColNo() + 1).trim().isEmpty();
     }
 
     /**
      * Count regexp matches into String literal.
      * @param pattern pattern.
      * @param target String literal.
      * @return count of regexp matches.
      */
     private static int countMatches(Pattern pattern, String target) {
         int matcherCounter = 0;
         final Matcher matcher = pattern.matcher(target);
         while (matcher.find()) {
             matcherCounter++;
         }
         return matcherCounter;
     }
 
     /**
      * Checks if all characters in String literal is escaped.
      * @param literal current literal.
      * @return true if all characters in String literal is escaped.
      */
     private boolean isAllCharactersEscaped(String literal) {
         return allowIfAllCharactersEscaped
                 && ALL_ESCAPED_CHARS.matcher(literal.substring(1,
                         literal.length() - 1)).find();
     }
 }
