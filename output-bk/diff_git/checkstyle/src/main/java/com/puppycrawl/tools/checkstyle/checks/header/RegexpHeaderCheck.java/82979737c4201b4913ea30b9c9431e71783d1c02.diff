diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java
index c659aace8..e69749b72 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java
@@ -1,131 +1,133 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.header;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
+import com.puppycrawl.tools.checkstyle.api.FileText;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * Checks the header of the source against a header file that contains a
  * {@link Pattern regular expression}
  * for each line of the source header. In default configuration,
  * if header is not specified, the default value of header is set to null
  * and the check does not rise any violations.
  *
  * @author Lars KÃ¼hne
  * @author o_sukhodolsky
  */
 public class RegexpHeaderCheck extends AbstractHeaderCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_HEADER_MISSING = "header.missing";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_HEADER_MISMATCH = "header.mismatch";
 
     /** Empty array to avoid instantiations. */
     private static final int[] EMPTY_INT_ARRAY = new int[0];
 
     /** The compiled regular expressions. */
     private final List<Pattern> headerRegexps = new ArrayList<>();
 
     /** The header lines to repeat (0 or more) in the check, sorted. */
     private int[] multiLines = EMPTY_INT_ARRAY;
 
     /**
      * Set the lines numbers to repeat in the header check.
      * @param list comma separated list of line numbers to repeat in header.
      */
     public void setMultiLines(int... list) {
         if (list.length == 0) {
             multiLines = EMPTY_INT_ARRAY;
         }
         else {
             multiLines = new int[list.length];
             System.arraycopy(list, 0, multiLines, 0, list.length);
             Arrays.sort(multiLines);
         }
     }
 
     @Override
-    protected void processFiltered(File file, List<String> lines) {
+    protected void processFiltered(File file, FileText fileText) {
         final int headerSize = getHeaderLines().size();
+        final List<String> lines = fileText.getLines();
         final int fileSize = lines.size();
 
         if (headerSize - multiLines.length > fileSize) {
             log(1, MSG_HEADER_MISSING);
         }
         else {
             int headerLineNo = 0;
             int index;
             for (index = 0; headerLineNo < headerSize && index < fileSize; index++) {
                 final String line = lines.get(index);
                 boolean isMatch = isMatch(line, headerLineNo);
                 while (!isMatch && isMultiLine(headerLineNo)) {
                     headerLineNo++;
                     isMatch = headerLineNo == headerSize
                             || isMatch(line, headerLineNo);
                 }
                 if (!isMatch) {
                     log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(
                             headerLineNo));
                     break;
                 }
                 if (!isMultiLine(headerLineNo)) {
                     headerLineNo++;
                 }
             }
             if (index == fileSize) {
                 // if file finished, but we have at least one non-multi-line
                 // header isn't completed
                 logFirstSinglelineLine(headerLineNo, headerSize);
             }
         }
     }
 
     /**
      * Logs warning if any non-multiline lines left in header regexp.
      * @param startHeaderLine header line number to start from
      * @param headerSize whole header size
      */
     private void logFirstSinglelineLine(int startHeaderLine, int headerSize) {
         for (int lineNum = startHeaderLine; lineNum < headerSize; lineNum++) {
             if (!isMultiLine(lineNum)) {
                 log(1, MSG_HEADER_MISSING);
                 break;
             }
         }
     }
 
     /**
      * Checks if a code line matches the required header line.
      * @param line the code line
