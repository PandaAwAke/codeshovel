diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index 95a0b673f..4ef9bbad6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -331,100 +331,101 @@ public class CommentsIndentationCheck extends AbstractCheck {
      *        int someVariable = 1;
      *        // fall through
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if a comment is a 'fall through' comment.
      */
     private static boolean isFallThroughComment(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && prevStmt.getType() != TokenTypes.LITERAL_CASE
             && (nextStmt.getType() == TokenTypes.LITERAL_CASE
                 || nextStmt.getType() == TokenTypes.LITERAL_DEFAULT);
     }
 
     /**
      * Checks whether a comment is placed at the end of the code block.
      * @param nextStmt next statement.
      * @return true if a comment is placed at the end of the block.
      */
     private static boolean isCommentAtTheEndOfTheCodeBlock(DetailAST nextStmt) {
         return nextStmt != null
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Checks whether comment is placed in the empty code block.
      * For example:
      * <p>
      * ...
      * {@code
      *  // empty code block
      * }
      * ...
      * </p>
      * Note, the method does not treat empty case blocks.
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if comment is placed in the empty code block.
      */
     private static boolean isInEmptyCodeBlock(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && (prevStmt.getType() == TokenTypes.SLIST
                 || prevStmt.getType() == TokenTypes.LCURLY
+                || prevStmt.getType() == TokenTypes.ARRAY_INIT
                 || prevStmt.getType() == TokenTypes.OBJBLOCK)
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Handles a comment which is plased within empty case block.
      * Note, if comment is placed at the end of the empty case block, we have Checkstyle's
      * limitations to clearly detect user intention of explanation target - above or below. The
      * only case we can assume as a violation is when a single line comment within the empty case
      * block has indentation level that is lower than the indentation level of the next case
      * token. For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      * // violation
      *    case OPTION_TWO:
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment single line comment.
      * @param nextStmt next statement.
      */
     private void handleCommentInEmptyCaseBlock(DetailAST prevStmt, DetailAST comment,
                                                DetailAST nextStmt) {
 
         if (comment.getColumnNo() < prevStmt.getColumnNo()
                 || comment.getColumnNo() < nextStmt.getColumnNo()) {
             logMultilineIndentation(prevStmt, comment, nextStmt);
         }
     }
 
     /**
      * Handles 'fall through' single line comment.
      * Note, 'fall through' and similar comments can have indentation level as next or previous
      * statement.
      * For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *        // fall through - OK
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
@@ -523,100 +524,101 @@ public class CommentsIndentationCheck extends AbstractCheck {
      */
     private DetailAST getOneLinePreviousStatement(DetailAST comment) {
         DetailAST root = comment.getParent();
         while (root != null && !isBlockStart(root)) {
             root = root.getParent();
         }
 
         final Deque<DetailAST> stack = new ArrayDeque<>();
         DetailAST previousStatement = null;
         while (root != null || !stack.isEmpty()) {
             if (!stack.isEmpty()) {
                 root = stack.pop();
             }
             while (root != null) {
                 previousStatement = findPreviousStatement(comment, root);
                 if (previousStatement != null) {
                     root = null;
                     stack.clear();
                     break;
                 }
                 if (root.getNextSibling() != null) {
                     stack.push(root.getNextSibling());
                 }
                 root = root.getFirstChild();
             }
         }
         return previousStatement;
     }
 
     /**
      * Whether the ast is a comment.
      * @param ast the ast to check.
      * @return true if the ast is a comment.
      */
     private static boolean isComment(DetailAST ast) {
         final int astType = ast.getType();
         return astType == TokenTypes.SINGLE_LINE_COMMENT
             || astType == TokenTypes.BLOCK_COMMENT_BEGIN
             || astType == TokenTypes.COMMENT_CONTENT
             || astType == TokenTypes.BLOCK_COMMENT_END;
     }
 
     /**
      * Whether the AST node starts a block.
      * @param root the AST node to check.
      * @return true if the AST node starts a block.
      */
     private static boolean isBlockStart(DetailAST root) {
         return root.getType() == TokenTypes.SLIST
                 || root.getType() == TokenTypes.OBJBLOCK
+                || root.getType() == TokenTypes.ARRAY_INIT
                 || root.getType() == TokenTypes.CASE_GROUP;
     }
 
     /**
      * Finds a previous statement of the comment.
      * Uses root token of the line while searching.
      * @param comment comment.
      * @param root root token of the line.
      * @return previous statement of the comment or null if previous statement was not found.
      */
     private DetailAST findPreviousStatement(DetailAST comment, DetailAST root) {
         DetailAST previousStatement = null;
         if (root.getLineNo() >= comment.getLineNo()) {
             // ATTENTION: parent of the comment is below the comment in case block
             // See https://github.com/checkstyle/checkstyle/issues/851
             previousStatement = getPrevStatementFromSwitchBlock(comment);
         }
         final DetailAST tokenWhichBeginsTheLine;
         if (root.getType() == TokenTypes.EXPR
                 && root.getFirstChild().getFirstChild() != null) {
             if (root.getFirstChild().getType() == TokenTypes.LITERAL_NEW) {
                 tokenWhichBeginsTheLine = root.getFirstChild();
             }
             else {
                 tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine(root);
             }
         }
         else if (root.getType() == TokenTypes.PLUS) {
             tokenWhichBeginsTheLine = root.getFirstChild();
         }
         else {
             tokenWhichBeginsTheLine = root;
         }
         if (tokenWhichBeginsTheLine != null
                 && !isComment(tokenWhichBeginsTheLine)
                 && isOnPreviousLineIgnoringComments(comment, tokenWhichBeginsTheLine)) {
             previousStatement = tokenWhichBeginsTheLine;
         }
         return previousStatement;
     }
 
     /**
      * Finds a token which begins the line.
      * @param root root token of the line.
      * @return token which begins the line.
      */
     private static DetailAST findTokenWhichBeginsTheLine(DetailAST root) {
         final DetailAST tokenWhichBeginsTheLine;
         if (isUsingOfObjectReferenceToInvokeMethod(root)) {
             tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain(root);
@@ -641,100 +643,101 @@ public class CommentsIndentationCheck extends AbstractCheck {
      * Finds the start token of method call chain.
      * @param root root token of the line.
      * @return the start token of method call chain.
      */
     private static DetailAST findStartTokenOfMethodCallChain(DetailAST root) {
         DetailAST startOfMethodCallChain = root;
         while (startOfMethodCallChain.getFirstChild() != null
                 && startOfMethodCallChain.getFirstChild().getLineNo() == root.getLineNo()) {
             startOfMethodCallChain = startOfMethodCallChain.getFirstChild();
         }
         if (startOfMethodCallChain.getFirstChild() != null) {
             startOfMethodCallChain = startOfMethodCallChain.getFirstChild().getNextSibling();
         }
         return startOfMethodCallChain;
     }
 
     /**
      * Checks whether the checked statement is on the previous line ignoring empty lines
      * and lines which contain only comments.
      * @param currentStatement current statement.
      * @param checkedStatement checked statement.
      * @return true if checked statement is on the line which is previous to current statement
      *     ignoring empty lines and lines which contain only comments.
      */
     private boolean isOnPreviousLineIgnoringComments(DetailAST currentStatement,
                                                      DetailAST checkedStatement) {
         DetailAST nextToken = getNextToken(checkedStatement);
         int distanceAim = 1;
         if (nextToken != null && isComment(nextToken)) {
             distanceAim += countEmptyLines(checkedStatement, currentStatement);
         }
 
         while (nextToken != null && nextToken != currentStatement && isComment(nextToken)) {
             if (nextToken.getType() == TokenTypes.BLOCK_COMMENT_BEGIN) {
                 distanceAim += nextToken.getLastChild().getLineNo() - nextToken.getLineNo();
             }
             distanceAim++;
             nextToken = nextToken.getNextSibling();
         }
         return currentStatement.getLineNo() - checkedStatement.getLineNo() == distanceAim;
     }
 
     /**
      * Get the token to start counting the number of lines to add to the distance aim from.
      * @param checkedStatement the checked statement.
      * @return the token to start counting the number of lines to add to the distance aim from.
      */
     private DetailAST getNextToken(DetailAST checkedStatement) {
         DetailAST nextToken;
         if (checkedStatement.getType() == TokenTypes.SLIST
+                || checkedStatement.getType() == TokenTypes.ARRAY_INIT
                 || checkedStatement.getType() == TokenTypes.CASE_GROUP) {
             nextToken = checkedStatement.getFirstChild();
         }
         else {
             nextToken = checkedStatement.getNextSibling();
         }
         if (nextToken != null && isComment(nextToken) && isTrailingComment(nextToken)) {
             nextToken = nextToken.getNextSibling();
         }
         return nextToken;
     }
 
     /**
      * Count the number of empty lines between statements.
      * @param startStatement start statement.
      * @param endStatement end statement.
      * @return the number of empty lines between statements.
      */
     private int countEmptyLines(DetailAST startStatement, DetailAST endStatement) {
         int emptyLinesNumber = 0;
         final String[] lines = getLines();
         final int endLineNo = endStatement.getLineNo();
         for (int lineNo = startStatement.getLineNo(); lineNo < endLineNo; lineNo++) {
             if (CommonUtils.isBlank(lines[lineNo])) {
                 emptyLinesNumber++;
             }
         }
         return emptyLinesNumber;
     }
 
     /**
      * Logs comment which can have the same indentation level as next or previous statement.
      * @param comment comment.
      * @param nextStmt next statement.
      * @param prevStmt previous statement.
      */
     private void logMultilineIndentation(DetailAST prevStmt, DetailAST comment,
                                          DetailAST nextStmt) {
         final String multilineNoTemplate = "%d, %d";
         log(comment.getLineNo(), getMessageKey(comment),
             String.format(Locale.getDefault(), multilineNoTemplate, prevStmt.getLineNo(),
                 nextStmt.getLineNo()), comment.getColumnNo(),
             String.format(Locale.getDefault(), multilineNoTemplate,
                     getLineStart(prevStmt.getLineNo()), getLineStart(nextStmt.getLineNo())));
     }
 
     /**
      * Get a message key depending on a comment type.
      * @param comment the comment to process.
      * @return a message key.
