diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
index 19c3c48d7..16b41658d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java
@@ -78,112 +78,129 @@ public final class BooleanExpressionComplexityCheck extends Check
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.EXPR,
         };
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.EXPR,
             TokenTypes.LAND,
             TokenTypes.BAND,
             TokenTypes.LOR,
             TokenTypes.BOR,
             TokenTypes.BXOR,
         };
     }
 
     /**
      * Getter for maximum allowed complexity.
      * @return value of maximum allowed complexity.
      */
     public int getMax()
     {
         return max;
     }
 
     /**
      * Setter for maximum allowed complexity.
      * @param max new maximum allowed complexity.
      */
     public void setMax(int max)
     {
         this.max = max;
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 visitMethodDef(ast);
                 break;
             case TokenTypes.EXPR:
                 visitExpr();
                 break;
+            case TokenTypes.BOR:
+                if (!isPipeOperator(ast)) {
+                    context.visitBooleanOperator();
+                }
+                break;
             case TokenTypes.LAND:
             case TokenTypes.BAND:
             case TokenTypes.LOR:
-            case TokenTypes.BOR:
             case TokenTypes.BXOR:
                 context.visitBooleanOperator();
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
+    /**
+     * Checks if {@link TokenTypes#BOR binary OR} is applied to exceptions
+     * in
+     * <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20">
+     * multi-catch</a> (pipe-syntax).
+     * @param binaryOr {@link TokenTypes#BOR binary or}
+     * @return true if binary or is applied to exceptions in multi-catch.
+     */
+    private static boolean isPipeOperator(DetailAST binaryOr)
+    {
+        return binaryOr.getParent().getType() == TokenTypes.TYPE;
+    }
+
     @Override
     public void leaveToken(DetailAST ast)
     {
         switch (ast.getType()) {
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 leaveMethodDef();
                 break;
             case TokenTypes.EXPR:
                 leaveExpr(ast);
                 break;
             default:
                 // Do nothing
         }
     }
 
     /**
      * Creates new context for a given method.
      * @param ast a method we start to check.
      */
     private void visitMethodDef(DetailAST ast)
     {
         contextStack.push(context);
         context = new Context(!CheckUtils.isEqualsMethod(ast));
     }
 
     /** Removes old context. */
     private void leaveMethodDef()
     {
         context = contextStack.pop();
     }
 
     /** Creates and pushes new context. */
     private void visitExpr()
     {
         contextStack.push(context);
         context = new Context((context == null) || context.isChecking());
     }
 
     /**
      * Restores previous context.
      * @param ast expression we leave.
      */
     private void leaveExpr(DetailAST ast)
     {
         context.checkCount(ast);
         context = contextStack.pop();
     }
 
     /**
