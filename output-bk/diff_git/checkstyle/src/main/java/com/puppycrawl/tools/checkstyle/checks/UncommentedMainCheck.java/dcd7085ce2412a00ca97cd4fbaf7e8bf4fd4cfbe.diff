diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
index 852af0f22..b5390d49a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java
@@ -68,100 +68,101 @@ public class UncommentedMainCheck
      * @throws ConversionException if unable to create Pattern object
      */
     public void setExcludedClasses(String excludedClasses)
         throws ConversionException {
         this.excludedClasses = excludedClasses;
         excludedClassesPattern = Utils.createPattern(excludedClasses);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.METHOD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.PACKAGE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         packageName = FullIdent.createFullIdent(null);
         currentClass = null;
         classDepth = 0;
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             if (classDepth == 1) {
                 currentClass = null;
             }
             classDepth--;
         }
     }
 
     @Override
     public void visitToken(DetailAST ast) {
+
         switch (ast.getType()) {
             case TokenTypes.PACKAGE_DEF:
                 visitPackageDef(ast);
                 break;
             case TokenTypes.CLASS_DEF:
                 visitClassDef(ast);
                 break;
             case TokenTypes.METHOD_DEF:
                 visitMethodDef(ast);
                 break;
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Sets current package.
      * @param packageDef node for package definition
      */
     private void visitPackageDef(DetailAST packageDef) {
         packageName = FullIdent.createFullIdent(packageDef.getLastChild()
                 .getPreviousSibling());
     }
 
     /**
      * If not inner class then change current class name.
      * @param classDef node for class definition
      */
     private void visitClassDef(DetailAST classDef) {
         // we are not use inner classes because they can not
         // have static methods
         if (classDepth == 0) {
             final DetailAST ident = classDef.findFirstToken(TokenTypes.IDENT);
             currentClass = packageName.getText() + "." + ident.getText();
             classDepth++;
         }
     }
 
     /**
      * Checks method definition if this is
      * <code>public static void main(String[])</code>.
      * @param method method definition node
      */
     private void visitMethodDef(DetailAST method) {
         if (classDepth != 1) {
             // method in inner class or in interface definition
             return;
         }
 
         if (checkClassName()
@@ -188,60 +189,55 @@ public class UncommentedMainCheck
      */
     private static boolean checkName(DetailAST method) {
         final DetailAST ident = method.findFirstToken(TokenTypes.IDENT);
         return "main".equals(ident.getText());
     }
 
     /**
      * Checks that method has final and static modifiers.
      * @param method the METHOD_DEF node
      * @return true if check passed, false otherwise
      */
     private static boolean checkModifiers(DetailAST method) {
         final DetailAST modifiers =
             method.findFirstToken(TokenTypes.MODIFIERS);
 
         return modifiers.branchContains(TokenTypes.LITERAL_PUBLIC)
             && modifiers.branchContains(TokenTypes.LITERAL_STATIC);
     }
 
     /**
      * Checks that return type is <code>void</code>.
      * @param method the METHOD_DEF node
      * @return true if check passed, false otherwise
      */
     private static boolean checkType(DetailAST method) {
         final DetailAST type =
             method.findFirstToken(TokenTypes.TYPE).getFirstChild();
         return type.getType() == TokenTypes.LITERAL_VOID;
     }
 
     /**
      * Checks that method has only <code>String[]</code> param
      * @param method the METHOD_DEF node
      * @return true if check passed, false otherwise
      */
     private static boolean checkParams(DetailAST method) {
         final DetailAST params = method.findFirstToken(TokenTypes.PARAMETERS);
         if (params.getChildCount() != 1) {
             return false;
         }
         final DetailAST paratype = params.getFirstChild()
             .findFirstToken(TokenTypes.TYPE);
         final DetailAST arrayDecl =
             paratype.findFirstToken(TokenTypes.ARRAY_DECLARATOR);
         if (arrayDecl == null) {
             return false;
         }
 
         final DetailAST arrayType = arrayDecl.getFirstChild();
 
-        if (arrayType.getType() == TokenTypes.IDENT
-            || arrayType.getType() == TokenTypes.DOT) {
-            final FullIdent type = FullIdent.createFullIdent(arrayType);
-            return "String".equals(type.getText())
-                    || "java.lang.String".equals(type.getText());
-        }
-
-        return false;
+        final FullIdent type = FullIdent.createFullIdent(arrayType);
+        return "String".equals(type.getText())
+                || "java.lang.String".equals(type.getText());
     }
 }
