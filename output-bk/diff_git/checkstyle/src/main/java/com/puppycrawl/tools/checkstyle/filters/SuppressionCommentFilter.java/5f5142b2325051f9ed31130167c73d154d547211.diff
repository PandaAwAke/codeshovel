diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
index 33cfbeba7..523ff5ae2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java
@@ -149,341 +149,342 @@ public class SuppressionCommentFilter
         fileContentsReference = new WeakReference<>(fileContents);
     }
 
     /**
      * Set the format for a check.
      * @param format a {@code String} value
      */
     public final void setCheckFormat(String format) {
         checkFormat = format;
     }
 
     /**
      * Set the format for a message.
      * @param format a {@code String} value
      */
     public void setMessageFormat(String format) {
         messageFormat = format;
     }
 
     /**
      * Set whether to look in C++ comments.
      * @param checkCPP {@code true} if C++ comments are checked.
      */
     public void setCheckCPP(boolean checkCPP) {
         this.checkCPP = checkCPP;
     }
 
     /**
      * Set whether to look in C comments.
      * @param checkC {@code true} if C comments are checked.
      */
     public void setCheckC(boolean checkC) {
         this.checkC = checkC;
     }
 
     @Override
     public boolean accept(AuditEvent event) {
         boolean accepted = true;
 
         if (event.getLocalizedMessage() != null) {
             // Lazy update. If the first event for the current file, update file
             // contents and tag suppressions
             final FileContents currentContents = FileContentsHolder.getContents();
 
             if (currentContents != null) {
                 if (getFileContents() != currentContents) {
                     setFileContents(currentContents);
                     tagSuppressions();
                 }
                 final Tag matchTag = findNearestMatch(event);
-                accepted = matchTag == null || matchTag.isOn();
+                accepted = matchTag == null || matchTag.isReportingOn();
             }
         }
         return accepted;
     }
 
     /**
      * Finds the nearest comment text tag that matches an audit event.
      * The nearest tag is before the line and column of the event.
      * @param event the {@code AuditEvent} to match.
      * @return The {@code Tag} nearest event.
      */
     private Tag findNearestMatch(AuditEvent event) {
         Tag result = null;
         for (Tag tag : tags) {
             if (tag.getLine() > event.getLine()
                 || tag.getLine() == event.getLine()
                     && tag.getColumn() > event.getColumn()) {
                 break;
             }
             if (tag.isMatch(event)) {
                 result = tag;
             }
         }
         return result;
     }
 
     /**
      * Collects all the suppression tags for all comments into a list and
      * sorts the list.
      */
     private void tagSuppressions() {
         tags.clear();
         final FileContents contents = getFileContents();
         if (checkCPP) {
             tagSuppressions(contents.getCppComments().values());
         }
         if (checkC) {
             final Collection<List<TextBlock>> cComments = contents
                     .getCComments().values();
             for (List<TextBlock> element : cComments) {
                 tagSuppressions(element);
             }
         }
         Collections.sort(tags);
     }
 
     /**
      * Appends the suppressions in a collection of comments to the full
      * set of suppression tags.
      * @param comments the set of comments.
      */
     private void tagSuppressions(Collection<TextBlock> comments) {
         for (TextBlock comment : comments) {
             final int startLineNo = comment.getStartLineNo();
             final String[] text = comment.getText();
             tagCommentLine(text[0], startLineNo, comment.getStartColNo());
             for (int i = 1; i < text.length; i++) {
                 tagCommentLine(text[i], startLineNo + i, 0);
             }
         }
     }
 
     /**
      * Tags a string if it matches the format for turning
      * checkstyle reporting on or the format for turning reporting off.
      * @param text the string to tag.
      * @param line the line number of text.
      * @param column the column number of text.
      */
     private void tagCommentLine(String text, int line, int column) {
         final Matcher offMatcher = offRegexp.matcher(text);
         if (offMatcher.find()) {
             addTag(offMatcher.group(0), line, column, false);
         }
         else {
             final Matcher onMatcher = onRegexp.matcher(text);
             if (onMatcher.find()) {
                 addTag(onMatcher.group(0), line, column, true);
             }
         }
     }
 
     /**
      * Adds a {@code Tag} to the list of all tags.
      * @param text the text of the tag.
      * @param line the line number of the tag.
      * @param column the column number of the tag.
-     * @param on {@code true} if the tag turns checkstyle reporting on.
+     * @param reportingOn {@code true} if the tag turns checkstyle reporting on.
      */
-    private void addTag(String text, int line, int column, boolean on) {
-        final Tag tag = new Tag(line, column, text, on, this);
+    private void addTag(String text, int line, int column, boolean reportingOn) {
+        final Tag tag = new Tag(line, column, text, reportingOn, this);
         tags.add(tag);
     }
 
     /**
      * A Tag holds a suppression comment and its location, and determines
      * whether the suppression turns checkstyle reporting on or off.
      * @author Rick Giles
      */
     public static class Tag
         implements Comparable<Tag> {
         /** The text of the tag. */
         private final String text;
 
         /** The line number of the tag. */
         private final int line;
 
         /** The column number of the tag. */
         private final int column;
 
         /** Determines whether the suppression turns checkstyle reporting on. */
-        private final boolean on;
+        private final boolean reportingOn;
 
         /** The parsed check regexp, expanded for the text of this tag. */
         private final Pattern tagCheckRegexp;
 
         /** The parsed message regexp, expanded for the text of this tag. */
         private final Pattern tagMessageRegexp;
 
         /**
          * Constructs a tag.
          * @param line the line number.
          * @param column the column number.
          * @param text the text of the suppression.
-         * @param on {@code true} if the tag turns checkstyle reporting.
+         * @param reportingOn {@code true} if the tag turns checkstyle reporting.
          * @param filter the {@code SuppressionCommentFilter} with the context
          * @throws ConversionException if unable to parse expanded text.
          */
-        public Tag(int line, int column, String text, boolean on, SuppressionCommentFilter filter) {
+        public Tag(int line, int column, String text, boolean reportingOn,
+                   SuppressionCommentFilter filter) {
             this.line = line;
             this.column = column;
             this.text = text;
-            this.on = on;
+            this.reportingOn = reportingOn;
 
             //Expand regexp for check and message
             //Does not intern Patterns with Utils.getPattern()
             String format = "";
             try {
-                if (on) {
+                if (reportingOn) {
                     format =
                         expandFromComment(text, filter.checkFormat, filter.onRegexp);
                     tagCheckRegexp = Pattern.compile(format);
                     if (filter.messageFormat != null) {
                         format =
                             expandFromComment(text, filter.messageFormat, filter.onRegexp);
                         tagMessageRegexp = Pattern.compile(format);
                     }
                     else {
                         tagMessageRegexp = null;
                     }
                 }
                 else {
                     format =
                         expandFromComment(text, filter.checkFormat, filter.offRegexp);
                     tagCheckRegexp = Pattern.compile(format);
                     if (filter.messageFormat != null) {
                         format =
                             expandFromComment(
                                     text,
                                     filter.messageFormat,
                                     filter.offRegexp);
                         tagMessageRegexp = Pattern.compile(format);
                     }
                     else {
                         tagMessageRegexp = null;
                     }
                 }
             }
             catch (final PatternSyntaxException e) {
                 throw new ConversionException(
                     "unable to parse expanded comment " + format,
                     e);
             }
         }
 
         /**
          * @return the line number of the tag in the source file.
          */
         public int getLine() {
             return line;
         }
 
         /**
          * Determines the column number of the tag in the source file.
          * Will be 0 for all lines of multiline comment, except the
          * first line.
          * @return the column number of the tag in the source file.
          */
         public int getColumn() {
             return column;
         }
 
         /**
          * Determines whether the suppression turns checkstyle reporting on or
          * off.
          * @return {@code true}if the suppression turns reporting on.
          */
-        public boolean isOn() {
-            return on;
+        public boolean isReportingOn() {
+            return reportingOn;
         }
 
         /**
          * Compares the position of this tag in the file
          * with the position of another tag.
          * @param object the tag to compare with this one.
          * @return a negative number if this tag is before the other tag,
          *     0 if they are at the same position, and a positive number if this
          *     tag is after the other tag.
          */
         @Override
         public int compareTo(Tag object) {
             if (line == object.line) {
                 return Integer.compare(column, object.column);
             }
 
             return Integer.compare(line, object.line);
         }
 
         @Override
-        public boolean equals(Object o) {
-            if (this == o) {
+        public boolean equals(Object other) {
+            if (this == other) {
                 return true;
             }
-            if (o == null || getClass() != o.getClass()) {
+            if (other == null || getClass() != other.getClass()) {
                 return false;
             }
-            final Tag tag = (Tag) o;
+            final Tag tag = (Tag) other;
             return Objects.equals(line, tag.line)
                     && Objects.equals(column, tag.column)
-                    && Objects.equals(on, tag.on)
+                    && Objects.equals(reportingOn, tag.reportingOn)
                     && Objects.equals(text, tag.text);
         }
 
         @Override
         public int hashCode() {
-            return Objects.hash(text, line, column, on);
+            return Objects.hash(text, line, column, reportingOn);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param event the {@code AuditEvent} to check.
          * @return true if the source of event matches the text of this tag.
          */
         public boolean isMatch(AuditEvent event) {
             boolean match = false;
             final Matcher tagMatcher = tagCheckRegexp.matcher(event.getSourceName());
             if (tagMatcher.find()) {
                 if (tagMessageRegexp != null) {
                     final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
                     match = messageMatcher.find();
                 }
                 else {
                     match = true;
                 }
             }
             return match;
         }
 
         /**
          * Expand based on a matching comment.
          * @param comment the comment.
          * @param stringToExpand the string to expand.
          * @param regexp the parsed expander.
          * @return the expanded string
          */
         private static String expandFromComment(
                 String comment,
                 String stringToExpand,
                 Pattern regexp) {
             final Matcher matcher = regexp.matcher(comment);
             // Match primarily for effect.
             if (!matcher.find()) {
                 return stringToExpand;
             }
             String result = stringToExpand;
             for (int i = 0; i <= matcher.groupCount(); i++) {
                 // $n expands comment match like in Pattern.subst().
                 result = result.replaceAll("\\$" + i, matcher.group(i));
             }
             return result;
         }
 
         @Override
         public final String toString() {
             return "Tag[line=" + line + "; col=" + column
-                + "; on=" + on + "; text='" + text + "']";
+                + "; on=" + reportingOn + "; text='" + text + "']";
         }
     }
 }
