diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index 4aded473f..df97e5c13 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -603,251 +603,230 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
                 if (isChild(previousNode, variable)) {
                     variableUsageExpressions.add(previousNode);
                 }
 
                 // Looking into ELSE block, get its first child and analyze it.
                 currentNode = currentNode.getFirstChild();
 
                 if (currentNode.getType() == TokenTypes.LITERAL_IF) {
                     currentNode = currentNode.getLastChild();
                 }
                 else if (isChild(currentNode, variable)) {
                     variableUsageExpressions.add(currentNode);
                     currentNode = null;
                 }
             }
 
             // If IF block doesn't include ELSE than analyze variable usage
             // only inside IF block.
             if (currentNode != null
                     && isChild(currentNode, variable)) {
                 variableUsageExpressions.add(currentNode);
             }
 
             // If variable usage exists in several related blocks, then
             // firstNodeInsideBlock = null, otherwise if variable usage exists
             // only inside one block, then get node from
             // variableUsageExpressions.
             if (variableUsageExpressions.size() == 1) {
                 firstNodeInsideBlock = variableUsageExpressions.get(0);
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside SWITCH block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents SWITCH block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideSwitchBlock(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
-        if (!isVariableInOperatorExpr(block, variable)) {
-            DetailAST currentNode = block
-                    .findFirstToken(TokenTypes.CASE_GROUP);
-            final List<DetailAST> variableUsageExpressions =
-                    new ArrayList<>();
+        DetailAST currentNode = block
+                .findFirstToken(TokenTypes.CASE_GROUP);
+        final List<DetailAST> variableUsageExpressions =
+                new ArrayList<>();
 
-            // Checking variable usage inside all CASE blocks.
-            while (currentNode != null
-                    && currentNode.getType() == TokenTypes.CASE_GROUP) {
-                final DetailAST lastNodeInCaseGroup =
-                        currentNode.getLastChild();
+        // Checking variable usage inside all CASE blocks.
+        while (currentNode.getType() == TokenTypes.CASE_GROUP) {
+            final DetailAST lastNodeInCaseGroup =
+                    currentNode.getLastChild();
 
-                if (isChild(lastNodeInCaseGroup, variable)) {
-                    variableUsageExpressions.add(lastNodeInCaseGroup);
-                }
-                currentNode = currentNode.getNextSibling();
+            if (isChild(lastNodeInCaseGroup, variable)) {
+                variableUsageExpressions.add(lastNodeInCaseGroup);
             }
+            currentNode = currentNode.getNextSibling();
+        }
 
-            // If variable usage exists in several related blocks, then
-            // firstNodeInsideBlock = null, otherwise if variable usage exists
-            // only inside one block, then get node from
-            // variableUsageExpressions.
-            if (variableUsageExpressions.size() == 1) {
-                firstNodeInsideBlock = variableUsageExpressions.get(0);
-            }
+        // If variable usage exists in several related blocks, then
+        // firstNodeInsideBlock = null, otherwise if variable usage exists
+        // only inside one block, then get node from
+        // variableUsageExpressions.
+        if (variableUsageExpressions.size() == 1) {
+            firstNodeInsideBlock = variableUsageExpressions.get(0);
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside TRY-CATCH-FINALLY blocks if variable usage is
      * met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents TRY-CATCH-FINALLY block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideTryCatchFinallyBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST currentNode = block.getFirstChild();
         final List<DetailAST> variableUsageExpressions =
                 new ArrayList<>();
 
         // Checking variable usage inside TRY block.
         if (isChild(currentNode, variable)) {
             variableUsageExpressions.add(currentNode);
         }
 
         // Switch on CATCH block.
         currentNode = currentNode.getNextSibling();
 
         // Checking variable usage inside all CATCH blocks.
         while (currentNode != null
                 && currentNode.getType() == TokenTypes.LITERAL_CATCH) {
             final DetailAST catchBlock = currentNode.getLastChild();
 
             if (isChild(catchBlock, variable)) {
                 variableUsageExpressions.add(catchBlock);
             }
             currentNode = currentNode.getNextSibling();
         }
 
         // Checking variable usage inside FINALLY block.
         if (currentNode != null) {
             final DetailAST finalBlock = currentNode.getLastChild();
 
             if (isChild(finalBlock, variable)) {
                 variableUsageExpressions.add(finalBlock);
             }
         }
 
         DetailAST variableUsageNode = null;
 
         // If variable usage exists in several related blocks, then
         // firstNodeInsideBlock = null, otherwise if variable usage exists
         // only inside one block, then get node from
         // variableUsageExpressions.
         if (variableUsageExpressions.size() == 1) {
             variableUsageNode = variableUsageExpressions.get(0).getFirstChild();
         }
 
         return variableUsageNode;
     }
 
     /**
      * Checks if variable is in operator declaration. For instance:
      * <pre>
      * boolean b = true;
      * if (b) {...}
      * </pre>
      * Variable 'b' is in declaration of operator IF.
      * @param operator
      *        Ast node which represents operator.
      * @param variable
      *        Variable which is checked for content in operator.
      * @return true if operator contains variable in its declaration, otherwise
      *         - false.
      */
     private static boolean isVariableInOperatorExpr(
             DetailAST operator, DetailAST variable) {
         boolean isVarInOperatorDeclr = false;
         final DetailAST openingBracket =
                 operator.findFirstToken(TokenTypes.LPAREN);
 
         // Get EXPR between brackets
         DetailAST exprBetweenBrackets = openingBracket.getNextSibling();
 
         // Look if variable is in operator expression
         while (exprBetweenBrackets.getType() != TokenTypes.RPAREN) {
 
             if (isChild(exprBetweenBrackets, variable)) {
                 isVarInOperatorDeclr = true;
                 break;
             }
             exprBetweenBrackets = exprBetweenBrackets.getNextSibling();
         }
 
-        // Variable may be met in ELSE declaration or in CASE declaration.
+        // Variable may be met in ELSE declaration
         // So, check variable usage in these declarations.
-        if (!isVarInOperatorDeclr) {
-            switch (operator.getType()) {
-            case TokenTypes.LITERAL_IF:
-                final DetailAST elseBlock = operator.getLastChild();
-
-                if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
-                    // Get IF followed by ELSE
-                    final DetailAST firstNodeInsideElseBlock = elseBlock.getFirstChild();
-
-                    if (firstNodeInsideElseBlock.getType() == TokenTypes.LITERAL_IF) {
-                        isVarInOperatorDeclr |= isVariableInOperatorExpr(firstNodeInsideElseBlock, variable);
-                        }
-                }
-                break;
-
-            case TokenTypes.LITERAL_SWITCH:
-                DetailAST currentCaseBlock = operator.findFirstToken(TokenTypes.CASE_GROUP);
-
-                while (currentCaseBlock != null && currentCaseBlock.getType() == TokenTypes.CASE_GROUP) {
-                    final DetailAST firstNodeInsideCaseBlock = currentCaseBlock.getFirstChild();
-
-                    if (isChild(firstNodeInsideCaseBlock, variable)) {
-                        isVarInOperatorDeclr = true;
-                        break;
-                        }
-                    currentCaseBlock = currentCaseBlock.getNextSibling();
+        if (!isVarInOperatorDeclr && operator.getType() == TokenTypes.LITERAL_IF) {
+            final DetailAST elseBlock = operator.getLastChild();
+
+            if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
+                // Get IF followed by ELSE
+                final DetailAST firstNodeInsideElseBlock = elseBlock.getFirstChild();
+
+                if (firstNodeInsideElseBlock.getType() == TokenTypes.LITERAL_IF) {
+                    isVarInOperatorDeclr |=
+                            isVariableInOperatorExpr(
+                                firstNodeInsideElseBlock,
+                                    variable);
                 }
-                break;
-
-            default:
-                // no code
             }
         }
 
         return isVarInOperatorDeclr;
     }
 
     /**
      * Checks if Ast node contains given element.
      * @param parent
      *        Node of AST.
      * @param ast
      *        Ast element which is checked for content in Ast node.
      * @return true if Ast element was found in Ast node, otherwise - false.
      */
     private static boolean isChild(DetailAST parent, DetailAST ast) {
         boolean isChild = false;
         final ASTEnumeration astList = parent.findAllPartial(ast);
 
         while (astList.hasMoreNodes()) {
             final DetailAST astNode = (DetailAST) astList.nextNode();
             DetailAST astParent = astNode.getParent();
 
             while (astParent != null) {
 
                 if (astParent.equals(parent)
                         && astParent.getLineNo() == parent.getLineNo()) {
                     isChild = true;
                     break;
                 }
                 astParent = astParent.getParent();
             }
         }
 
         return isChild;
     }
 
     /**
      * Checks if entrance variable is contained in ignored pattern.
      * @param variable
      *        Variable which is checked for content in ignored pattern.
      * @return true if variable was found, otherwise - false.
      */
     private boolean isVariableMatchesIgnorePattern(String variable) {
         final Matcher matcher = ignoreVariablePattern.matcher(variable);
         return matcher.matches();
     }
 }
