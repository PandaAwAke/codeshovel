diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
index f32a00507..a6584a19f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java
@@ -143,100 +143,103 @@ public class IllegalInstantiationCheck
             postprocessLiteralNew(literalNewAST);
         }
     }
 
     /**
      * Collects classes defined in the source file. Required
      * to avoid false alarms for local vs. java.lang classes.
      *
      * @param aAST the classdef token.
      */
     private void processClassDef(DetailAST aAST)
     {
         final DetailAST identToken = aAST.findFirstToken(TokenTypes.IDENT);
         final String className = identToken.getText();
         mClassNames.add(className);
     }
 
     /**
      * Perform processing for an import token
      * @param aAST the import token
      */
     private void processImport(DetailAST aAST)
     {
         final FullIdent name = FullIdent.createFullIdentBelow(aAST);
         if (name != null) {
             // Note: different from UnusedImportsCheck.processImport(),
             // '.*' imports are also added here
             mImports.add(name);
         }
     }
 
     /**
      * Perform processing for an package token
      * @param aAST the package token
      */
     private void processPackageDef(DetailAST aAST)
     {
         final DetailAST packageNameAST = aAST.getLastChild()
                 .getPreviousSibling();
         final FullIdent packageIdent =
                 FullIdent.createFullIdent(packageNameAST);
         mPkgName = packageIdent.getText();
     }
 
     /**
      * Collects a "new" token.
      * @param aAST the "new" token
      */
     private void processLiteralNew(DetailAST aAST)
     {
+        if (aAST.getParent().getType() == TokenTypes.METHOD_REF) {
+            return;
+        }
         mInstantiations.add(aAST);
     }
 
     /**
      * Processes one of the collected "new" tokens when treewalking
      * has finished.
      * @param aAST the "new" token.
      */
     private void postprocessLiteralNew(DetailAST aAST)
     {
         final DetailAST typeNameAST = aAST.getFirstChild();
         final AST nameSibling = typeNameAST.getNextSibling();
         if ((nameSibling != null)
                 && (nameSibling.getType() == TokenTypes.ARRAY_DECLARATOR))
         {
             // aAST == "new Boolean[]"
             return;
         }
 
         final FullIdent typeIdent = FullIdent.createFullIdent(typeNameAST);
         final String typeName = typeIdent.getText();
         final int lineNo = aAST.getLineNo();
         final int colNo = aAST.getColumnNo();
         final String fqClassName = getIllegalInstantiation(typeName);
         if (fqClassName != null) {
             log(lineNo, colNo, "instantiation.avoid", fqClassName);
         }
     }
 
     /**
      * Checks illegal instantiations.
      * @param aClassName instantiated class, may or may not be qualified
      * @return the fully qualified class name of aClassName
      * or null if instantiation of aClassName is OK
      */
     private String getIllegalInstantiation(String aClassName)
     {
         final String javaLang = "java.lang.";
 
         if (mIllegalClasses.contains(aClassName)) {
             return aClassName;
         }
 
         final int clsNameLen = aClassName.length();
         final int pkgNameLen = (mPkgName == null) ? 0 : mPkgName.length();
 
         for (String illegal : mIllegalClasses) {
             final int illegalLen = illegal.length();
 
             // class from java.lang
