diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
index 7f4599596..a2d217054 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
@@ -98,101 +98,101 @@ public class NoWhitespaceAfterCheck extends Check {
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.ARRAY_INIT,
             TokenTypes.INC,
             TokenTypes.DEC,
             TokenTypes.UNARY_MINUS,
             TokenTypes.UNARY_PLUS,
             TokenTypes.BNOT,
             TokenTypes.LNOT,
             TokenTypes.DOT,
             TokenTypes.TYPECAST,
             TokenTypes.ARRAY_DECLARATOR,
             TokenTypes.INDEX_OP,
         };
     }
 
     /**
      * Control whether whitespace is flagged at linebreaks.
      * @param allowLineBreaks whether whitespace should be
      *     flagged at linebreaks.
      */
     public void setAllowLineBreaks(boolean allowLineBreaks) {
         this.allowLineBreaks = allowLineBreaks;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST whitespaceFollowedAst = getWhitespaceFollowedNode(ast);
 
         final int whitespaceColumnNo = getPositionAfter(whitespaceFollowedAst);
         final int whitespaceLineNo = whitespaceFollowedAst.getLineNo();
 
         if (hasTrailingWhitespace(ast, whitespaceColumnNo, whitespaceLineNo)) {
             log(whitespaceLineNo, whitespaceColumnNo,
                 MSG_KEY, whitespaceFollowedAst.getText());
         }
     }
 
     /**
      * For a visited ast node returns node that should be checked
      * for not being followed by whitespace.
      * @param ast
      *        , visited node.
      * @return node before ast.
      */
     private static DetailAST getWhitespaceFollowedNode(DetailAST ast) {
-        DetailAST whitespaceFollowedAst;
+        final DetailAST whitespaceFollowedAst;
         switch (ast.getType()) {
             case TokenTypes.TYPECAST:
                 whitespaceFollowedAst = ast.findFirstToken(TokenTypes.RPAREN);
                 break;
             case TokenTypes.ARRAY_DECLARATOR:
                 whitespaceFollowedAst = getArrayDeclaratorPreviousElement(ast);
                 break;
             case TokenTypes.INDEX_OP:
                 whitespaceFollowedAst = getIndexOpPreviousElement(ast);
                 break;
             default:
                 whitespaceFollowedAst = ast;
         }
         return whitespaceFollowedAst;
     }
 
     /**
      * Gets position after token (place of possible redundant whitespace).
      * @param ast Node representing token.
      * @return position after token.
      */
     private static int getPositionAfter(DetailAST ast) {
         final int after;
         //If target of possible redundant whitespace is in method definition.
         if (ast.getType() == TokenTypes.IDENT
                 && ast.getNextSibling() != null
                 && ast.getNextSibling().getType() == TokenTypes.LPAREN) {
             final DetailAST methodDef = ast.getParent();
             final DetailAST endOfParams = methodDef.findFirstToken(TokenTypes.RPAREN);
             after = endOfParams.getColumnNo() + 1;
         }
         else {
             after = ast.getColumnNo() + ast.getText().length();
         }
         return after;
     }
 
     /**
      * Checks if there is unwanted whitespace after the visited node.
      * @param ast
      *        , visited node.
      * @param whitespaceColumnNo
      *        , column number of a possible whitespace.
      * @param whitespaceLineNo
      *        , line number of a possible whitespace.
      * @return true if whitespace found.
      */
     boolean hasTrailingWhitespace(DetailAST ast,
         int whitespaceColumnNo, int whitespaceLineNo) {
         final boolean result;
@@ -230,101 +230,101 @@ public class NoWhitespaceAfterCheck extends Check {
                 case TokenTypes.TYPE_ARGUMENT:
                     final DetailAST wildcard = parent.findFirstToken(TokenTypes.WILDCARD_TYPE);
                     if (wildcard == null) {
                         // usual generic type argument like <char[]>
                         previousElement = getTypeLastNode(ast);
                     }
                     else {
                         // constructions with wildcard like <? extends String[]>
                         previousElement = getTypeLastNode(ast.getFirstChild());
                     }
                     break;
                 // 'new' is a special case with its own subtree structure
                 case TokenTypes.LITERAL_NEW:
                     previousElement = getTypeLastNode(parent);
                     break;
                 // mundane array declaration, can be either java style or C style
                 case TokenTypes.TYPE:
                     previousElement = getPreviousNodeWithParentOfTypeAst(ast, parent);
                     break;
                 // i.e. boolean[].class
                 case TokenTypes.DOT:
                     previousElement = getTypeLastNode(ast);
                     break;
                 // java 8 method reference
                 case TokenTypes.METHOD_REF:
                     final DetailAST ident = getIdentLastToken(ast);
                     if (ident == null) {
                         //i.e. int[]::new
                         previousElement = ast.getFirstChild();
                     }
                     else {
                         previousElement = ident;
                     }
                     break;
                 default:
                     throw new IllegalStateException("unexpected ast syntax" + parent);
             }
         }
         return previousElement;
     }
 
     /**
      * Gets previous node for {@link TokenTypes#INDEX_OP INDEX_OP} token
      * for usage in getPositionAfter method, it is a simplified copy of
      * getArrayDeclaratorPreviousElement method.
      * @param ast
      *        , {@link TokenTypes#INDEX_OP INDEX_OP} node.
      * @return previous node by text order.
      */
     private static DetailAST getIndexOpPreviousElement(DetailAST ast) {
-        DetailAST result;
+        final DetailAST result;
         final DetailAST firstChild = ast.getFirstChild();
         if (firstChild.getType() == TokenTypes.INDEX_OP) {
             // second or higher array index
             result = firstChild.findFirstToken(TokenTypes.RBRACK);
         }
         else {
             final DetailAST ident = getIdentLastToken(ast);
             if (ident == null) {
                 // construction like ((byte[]) pixels)[0]
                 result = ast.findFirstToken(TokenTypes.RPAREN);
             }
             else {
                 result = ident;
             }
         }
         return result;
     }
 
     /**
      * Get node that owns {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR} sequence.
      * @param ast
      *        , {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR} node.
      * @return owner node.
      */
     private static DetailAST getFirstNonArrayDeclaratorParent(DetailAST ast) {
         DetailAST parent = ast.getParent();
         while (parent.getType() == TokenTypes.ARRAY_DECLARATOR) {
             parent = parent.getParent();
         }
         return parent;
     }
 
     /**
      * Searches parameter node for a type node.
      * Returns it or its last node if it has an extended structure.
      * @param ast
      *        , subject node.
      * @return type node.
      */
     private static DetailAST getTypeLastNode(DetailAST ast) {
         DetailAST result = ast.findFirstToken(TokenTypes.TYPE_ARGUMENTS);
         if (result == null) {
             result = getIdentLastToken(ast);
             if (result == null) {
                 //primitive literal expected
                 result = ast.getFirstChild();
             }
         }
         else {
             result = result.findFirstToken(TokenTypes.GENERIC_END);
