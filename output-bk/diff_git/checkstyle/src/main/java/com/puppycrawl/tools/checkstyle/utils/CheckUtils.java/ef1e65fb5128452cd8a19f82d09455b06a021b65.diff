diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
index bd9d5ae54..871260827 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
@@ -27,122 +27,119 @@ import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Contains utility methods for the checks.
  *
  * @author Oliver Burn
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  * @author o_sukhodolsky
  */
 public final class CheckUtils {
     // constants for parseDouble()
     /** Octal radix */
     private static final int BASE_8 = 8;
 
     /** Decimal radix */
     private static final int BASE_10 = 10;
 
     /** Hex radix */
     private static final int BASE_16 = 16;
 
     /** Maximum children allowed in setter/getter */
     private static final int SETTER_GETTER_MAX_CHILDREN = 7;
 
     /** Maximum nodes allowed in a body of setter */
     private static final int SETTER_BODY_SIZE = 3;
 
     /** Maximum nodes allowed in a body of getter */
     private static final int GETTER_BODY_SIZE = 2;
 
     /** Pattern matching underscore characters ('_') */
     private static final Pattern UNDERSCORE_PATTERN = Pattern.compile("_");
 
     /** Pattern matching names of setter methods */
     private static final Pattern SETTER_PATTERN = Pattern.compile("^set[A-Z].*");
 
     /** Pattern matching names of getter methods */
     private static final Pattern GETTER_PATTERN = Pattern.compile("^(is|get)[A-Z].*");
 
     /** Prevent instances */
     private CheckUtils() {
     }
 
     /**
      * Tests whether a method definition AST defines an equals covariant.
      * @param ast the method definition AST to test.
      * Precondition: ast is a TokenTypes.METHOD_DEF node.
      * @return true if ast defines an equals covariant.
      */
     public static boolean isEqualsMethod(DetailAST ast) {
-        if (ast.getType() != TokenTypes.METHOD_DEF) {
-            // A node must be method def
-            return false;
-        }
+        boolean equalsMethod = false;
 
-        // non-static, non-abstract?
-        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
-        if (modifiers.branchContains(TokenTypes.LITERAL_STATIC)
-            || modifiers.branchContains(TokenTypes.ABSTRACT)) {
-            return false;
-        }
+        if (ast.getType() == TokenTypes.METHOD_DEF) {
+            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
+            final boolean staticOrAbstract = modifiers.branchContains(TokenTypes.LITERAL_STATIC)
+                    || modifiers.branchContains(TokenTypes.ABSTRACT);
 
-        // named "equals"?
-        final DetailAST nameNode = ast.findFirstToken(TokenTypes.IDENT);
-        final String name = nameNode.getText();
-        if (!"equals".equals(name)) {
-            return false;
-        }
+            if (!staticOrAbstract) {
+                final DetailAST nameNode = ast.findFirstToken(TokenTypes.IDENT);
+                final String name = nameNode.getText();
 
-        // one parameter?
-        final DetailAST paramsNode = ast.findFirstToken(TokenTypes.PARAMETERS);
-        return paramsNode.getChildCount() == 1;
+                if ("equals".equals(name)) {
+                    // one parameter?
+                    final DetailAST paramsNode = ast.findFirstToken(TokenTypes.PARAMETERS);
+                    equalsMethod = paramsNode.getChildCount() == 1;
+                }
+            }
+        }
+        return equalsMethod;
     }
 
     /**
      * Returns whether a token represents an ELSE as part of an ELSE / IF set.
      * @param ast the token to check
      * @return whether it is
      */
     public static boolean isElseIf(DetailAST ast) {
         final DetailAST parentAST = ast.getParent();
 
         return ast.getType() == TokenTypes.LITERAL_IF
             && (isElse(parentAST) || isElseWithCurlyBraces(parentAST));
     }
 
     /**
      * Returns whether a token represents an ELSE.
      * @param ast the token to check
      * @return whether the token represents an ELSE
      */
     private static boolean isElse(DetailAST ast) {
         return ast.getType() == TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * Returns whether a token represents an SLIST as part of an ELSE
      * statement.
      * @param ast the token to check
      * @return whether the toke does represent an SLIST as part of an ELSE
      */
     private static boolean isElseWithCurlyBraces(DetailAST ast) {
         return ast.getType() == TokenTypes.SLIST
             && ast.getChildCount() == 2
             && isElse(ast.getParent());
     }
 
     /**
      * Creates {@code FullIdent} for given type node.
      * @param typeAST a type node.
      * @return {@code FullIdent} for given type.
      */
     public static FullIdent createFullType(DetailAST typeAST) {
         final DetailAST arrayDeclaratorAST =
             typeAST.findFirstToken(TokenTypes.ARRAY_DECLARATOR);
         final FullIdent fullType;
 
         if (arrayDeclaratorAST == null) {
             fullType = createFullTypeNoArrays(typeAST);
         }
         else {
             fullType = createFullTypeNoArrays(arrayDeclaratorAST);
@@ -283,158 +280,136 @@ public final class CheckUtils {
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
             typeParameterNames.add(
                     typeParam.findFirstToken(TokenTypes.IDENT).getText());
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
                     typeParameterNames.add(
                             sibling.findFirstToken(TokenTypes.IDENT).getText());
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
         return typeParameterNames;
     }
 
     /**
      * Retrieves the type parameters to the node.
      * @param node the parameterized AST node
      * @return a list of type parameter names
      */
     public static List<DetailAST> getTypeParameters(final DetailAST node) {
         final DetailAST typeParameters =
             node.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
         final List<DetailAST> typeParams = Lists.newArrayList();
         if (typeParameters != null) {
             final DetailAST typeParam =
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
             typeParams.add(typeParam);
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
                     typeParams.add(sibling);
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
         return typeParams;
     }
 
     /**
      * Returns whether an AST represents a setter method.
      * @param ast the AST to check with
      * @return whether the AST represents a setter method
      */
     public static boolean isSetterMethod(final DetailAST ast) {
+        boolean setterMethod = false;
+
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper setter method which does not throw any
         // exceptions.
-        if (ast.getType() != TokenTypes.METHOD_DEF
-                || ast.getChildCount() != SETTER_GETTER_MAX_CHILDREN) {
-            return false;
-        }
-
-        // Should I handle only being in a class????
-
-        // Check the name matches format setX...
-        final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
-        final String name = type.getNextSibling().getText();
-
-        // Depends on JDK 1.4
-        if (!SETTER_PATTERN.matcher(name).matches()) {
-            return false;
-        }
-
-        // Check the return type is void
-        if (type.getChildCount(TokenTypes.LITERAL_VOID) == 0) {
-            return false;
-        }
-
-        // Check that is had only one parameter
-        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if (params.getChildCount(TokenTypes.PARAMETER_DEF) != 1) {
-            return false;
-        }
-
-        // Now verify that the body consists of:
-        // SLIST -> EXPR -> ASSIGN
-        // SEMI
-        // RCURLY
-        final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
-        if (slist == null || slist.getChildCount() != SETTER_BODY_SIZE) {
-            return false;
+        if (ast.getType() == TokenTypes.METHOD_DEF
+                && ast.getChildCount() == SETTER_GETTER_MAX_CHILDREN) {
+
+            final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
+            final String name = type.getNextSibling().getText();
+            final boolean matchesSetterFormat = SETTER_PATTERN.matcher(name).matches();
+            final boolean voidReturnType = type.getChildCount(TokenTypes.LITERAL_VOID) > 0;
+
+            final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
+            final boolean singleParam = params.getChildCount(TokenTypes.PARAMETER_DEF) == 1;
+
+            if (matchesSetterFormat && voidReturnType && singleParam) {
+                // Now verify that the body consists of:
+                // SLIST -> EXPR -> ASSIGN
+                // SEMI
+                // RCURLY
+                final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
+
+                if (slist != null && slist.getChildCount() == SETTER_BODY_SIZE) {
+                    final DetailAST expr = slist.getFirstChild();
+                    setterMethod = expr.getFirstChild().getType() == TokenTypes.ASSIGN;
+                }
+            }
         }
-
-        final DetailAST expr = slist.getFirstChild();
-        return expr.getFirstChild().getType() == TokenTypes.ASSIGN;
+        return setterMethod;
     }
 
     /**
      * Returns whether an AST represents a getter method.
      * @param ast the AST to check with
      * @return whether the AST represents a getter method
      */
     public static boolean isGetterMethod(final DetailAST ast) {
+        boolean getterMethod = false;
+
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper getter method which does not throw any
         // exceptions.
-        if (ast.getType() != TokenTypes.METHOD_DEF
-                || ast.getChildCount() != SETTER_GETTER_MAX_CHILDREN) {
-            return false;
-        }
-
-        // Check the name matches format of getX or isX. Technically I should
-        // check that the format isX is only used with a boolean type.
-        final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
-        final String name = type.getNextSibling().getText();
-
-        // Depends on JDK 1.4
-        if (!GETTER_PATTERN.matcher(name).matches()) {
-            return false;
-        }
-
-        // Check the return type is void
-        if (type.getChildCount(TokenTypes.LITERAL_VOID) > 0) {
-            return false;
-        }
-
-        // Check that is had only one parameter
-        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
-        if (params.getChildCount(TokenTypes.PARAMETER_DEF) > 0) {
-            return false;
-        }
-
-        // Now verify that the body consists of:
-        // SLIST -> RETURN
-        // RCURLY
-        final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
-        if (slist == null || slist.getChildCount() != GETTER_BODY_SIZE) {
-            return false;
+        if (ast.getType() == TokenTypes.METHOD_DEF
+                && ast.getChildCount() == SETTER_GETTER_MAX_CHILDREN) {
+
+            final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
+            final String name = type.getNextSibling().getText();
+            final boolean matchesGetterFormat = GETTER_PATTERN.matcher(name).matches();
+            final boolean noVoidReturnType = type.getChildCount(TokenTypes.LITERAL_VOID) == 0;
+
+            final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
+            final boolean noParams = params.getChildCount(TokenTypes.PARAMETER_DEF) == 0;
+
+            if (matchesGetterFormat && noVoidReturnType && noParams) {
+                // Now verify that the body consists of:
+                // SLIST -> RETURN
+                // RCURLY
+                final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
+
+                if (slist != null && slist.getChildCount() == GETTER_BODY_SIZE) {
+                    final DetailAST expr = slist.getFirstChild();
+                    getterMethod = expr.getType() == TokenTypes.LITERAL_RETURN;
+                }
+            }
         }
-
-        final DetailAST expr = slist.getFirstChild();
-        return expr.getType() == TokenTypes.LITERAL_RETURN;
-
+        return getterMethod;
     }
 
     /**
      * Checks whether a method is a void one.
      *
      * @param methodDefAst the method node.
      * @return true if method is a void one.
      */
     public static boolean isVoidMethod(DetailAST methodDefAst) {
         boolean retVal = false;
         if (methodDefAst.getType() == TokenTypes.METHOD_DEF) {
             final DetailAST typeAST = methodDefAst.findFirstToken(TokenTypes.TYPE);
             if (typeAST.findFirstToken(TokenTypes.LITERAL_VOID) == null) {
                 retVal = true;
             }
         }
         return retVal;
     }
 }
