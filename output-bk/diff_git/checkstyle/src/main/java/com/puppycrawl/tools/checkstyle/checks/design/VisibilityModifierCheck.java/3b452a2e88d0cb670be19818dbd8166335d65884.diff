diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index 91ae45a4c..12e7db3ed 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -262,153 +262,136 @@ public class VisibilityModifierCheck
         "java.net.Inet4Address",
         "java.net.Inet6Address",
         "java.net.InetSocketAddress"
     );
 
     /** Default ignore annotations canonical names. */
     private static final List<String> DEFAULT_IGNORE_ANNOTATIONS = ImmutableList.of(
         "org.junit.Rule",
         "com.google.common.annotations.VisibleForTesting"
     );
 
     /** Contains explicit access modifiers. */
     private static final String[] EXPLICIT_MODS = {"public", "private", "protected"};
 
     /** Whether protected members are allowed */
     private boolean protectedAllowed;
 
     /** Whether package visible members are allowed */
     private boolean packageAllowed;
 
     /**
      * Pattern for public members that should be ignored.  Note:
      * Earlier versions of checkstyle used ^f[A-Z][a-zA-Z0-9]*$ as the
      * default to allow CMP for EJB 1.1 with the default settings.
      * With EJB 2.0 it is not longer necessary to have public access
      * for persistent fields.
      */
     private String publicMemberFormat = "^serialVersionUID$";
 
     /** Regexp for public members that should be ignored */
     private Pattern publicMemberPattern = Pattern.compile(publicMemberFormat);
 
     /** List of ignore annotations canonical names. */
     private List<String> ignoreAnnotationCanonicalNames =
             new ArrayList<>(DEFAULT_IGNORE_ANNOTATIONS);
 
     /** List of ignore annotations short names. */
     private final List<String> ignoreAnnotationShortNames =
             getClassShortNames(DEFAULT_IGNORE_ANNOTATIONS);
 
     /** Allows immutable fields to be declared as public. */
     private boolean allowPublicImmutableFields = true;
 
     /** List of immutable classes canonical names. */
     private List<String> immutableClassCanonicalNames = new ArrayList<>(DEFAULT_IMMUTABLE_TYPES);
 
     /** List of immutable classes short names. */
     private final List<String> immutableClassShortNames =
             getClassShortNames(DEFAULT_IMMUTABLE_TYPES);
 
-    /** @return whether protected members are allowed */
-    public boolean isProtectedAllowed() {
-        return protectedAllowed;
-    }
-
     /**
      * Set the list of ignore annotations.
      * @param annotationNames array of ignore annotations canonical names.
      */
     public void setIgnoreAnnotationCanonicalNames(String... annotationNames) {
         ignoreAnnotationCanonicalNames = Arrays.asList(annotationNames);
     }
 
     /**
      * Set whether protected members are allowed.
      * @param protectedAllowed whether protected members are allowed
      */
     public void setProtectedAllowed(boolean protectedAllowed) {
         this.protectedAllowed = protectedAllowed;
     }
 
-    /** @return whether package visible members are allowed */
-    public boolean isPackageAllowed() {
-        return packageAllowed;
-    }
-
     /**
      * Set whether package visible members are allowed.
      * @param packageAllowed whether package visible members are allowed
      */
     public void setPackageAllowed(boolean packageAllowed) {
         this.packageAllowed = packageAllowed;
     }
 
     /**
      * Set the pattern for public members to ignore.
      * @param pattern
      *        pattern for public members to ignore.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object
      */
     public void setPublicMemberPattern(String pattern) {
         publicMemberPattern = Utils.createPattern(pattern);
         publicMemberFormat = pattern;
     }
 
-    /**
-     * @return the regexp for public members to ignore.
-     */
-    private Pattern getPublicMemberRegexp() {
-        return publicMemberPattern;
-    }
-
     /**
      * Sets whether public immutable are allowed.
      * @param allow user's value.
      */
     public void setAllowPublicImmutableFields(boolean allow) {
         allowPublicImmutableFields = allow;
     }
 
     /**
      * Set the list of immutable classes types names.
      * @param classNames array of immutable types canonical names.
      */
     public void setImmutableClassCanonicalNames(String... classNames) {
         immutableClassCanonicalNames = Arrays.asList(classNames);
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.OBJBLOCK,
             TokenTypes.IMPORT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAst) {
         immutableClassShortNames.clear();
         final List<String> classShortNames =
                 getClassShortNames(immutableClassCanonicalNames);
         immutableClassShortNames.addAll(classShortNames);
 
         ignoreAnnotationShortNames.clear();
         final List<String> annotationShortNames =
                 getClassShortNames(ignoreAnnotationCanonicalNames);
         ignoreAnnotationShortNames.addAll(annotationShortNames);
     }
@@ -486,129 +469,129 @@ public class VisibilityModifierCheck
             // but its short name collides with one of specified class - removes the short name
             // from list to avoid names collision
             if (!immutableClassCanonicalNames.contains(canonicalName)
                      && immutableClassShortNames.contains(shortName)) {
                 immutableClassShortNames.remove(shortName);
             }
             if (!ignoreAnnotationCanonicalNames.contains(canonicalName)
                      && ignoreAnnotationShortNames.contains(shortName)) {
                 ignoreAnnotationShortNames.remove(shortName);
             }
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * {@code
      * import java.util.*;
      * }
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks if current variable has proper access modifier according to Check's options.
      * @param variableDef Variable definition node.
      * @param variableName Variable's name.
      * @return true if variable has proper access modifier.
      */
     private boolean hasProperAccessModifier(DetailAST variableDef, String variableName) {
         boolean result = true;
 
         final String variableScope = getVisibilityScope(variableDef);
 
         if (!"private".equals(variableScope)) {
             result =
                 isStaticFinalVariable(variableDef)
-                || isPackageAllowed() && "package".equals(variableScope)
-                || isProtectedAllowed() && "protected".equals(variableScope)
+                || packageAllowed && "package".equals(variableScope)
+                || protectedAllowed && "protected".equals(variableScope)
                 || isIgnoredPublicMember(variableName, variableScope)
                    || allowPublicImmutableFields
                       && isImmutableFieldDefinedInFinalClass(variableDef);
         }
 
         return result;
     }
 
     /**
      * Checks whether variable has static final modifiers.
      * @param variableDef Variable definition node.
      * @return true of variable has static final modifiers.
      */
     private static boolean isStaticFinalVariable(DetailAST variableDef) {
         final Set<String> modifiers = getModifiers(variableDef);
         return modifiers.contains("static") && modifiers.contains("final");
     }
 
     /**
      * Checks whether variable belongs to public members that should be ignored.
      * @param variableName Variable's name.
      * @param variableScope Variable's scope.
      * @return true if variable belongs to public members that should be ignored.
      */
     private boolean isIgnoredPublicMember(String variableName, String variableScope) {
         return "public".equals(variableScope)
-            && getPublicMemberRegexp().matcher(variableName).find();
+            && publicMemberPattern.matcher(variableName).find();
     }
 
     /**
      * Checks whether immutable field is defined in final class.
      * @param variableDef Variable definition node.
      * @return true if immutable field is defined in final class.
      */
     private boolean isImmutableFieldDefinedInFinalClass(DetailAST variableDef) {
         final DetailAST classDef = variableDef.getParent().getParent();
         final Set<String> classModifiers = getModifiers(classDef);
         return classModifiers.contains("final") && isImmutableField(variableDef);
     }
 
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST) {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
 
     }
 
     /**
      * Returns the visibility scope for the variable.
      * @param variableDef Variable definition node.
      * @return one of "public", "private", "protected", "package"
      */
     private static String getVisibilityScope(DetailAST variableDef) {
         final Set<String> modifiers = getModifiers(variableDef);
         String accessModifier = "package";
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
