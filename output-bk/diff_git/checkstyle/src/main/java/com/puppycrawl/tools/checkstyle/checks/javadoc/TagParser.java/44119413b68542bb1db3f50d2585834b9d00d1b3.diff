diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
index 9aea02025..0b42e51ca 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java
@@ -46,103 +46,101 @@ import com.google.common.collect.Lists;
  * @author Chris Stillwell
  */
 class TagParser {
     /** List of HtmlTags found on the input line of text. */
     private final List<HtmlTag> tags = Lists.newLinkedList();
 
     /**
      * Constructs a TagParser and finds the first tag if any.
      * @param text the line of text to parse.
      * @param lineNo the source line number.
      */
     TagParser(String[] text, int lineNo) {
         parseTags(text, lineNo);
     }
 
     /**
      * Returns the next available HtmlTag.
      * @return a HtmlTag or {@code null} if none available.
      * @throws IndexOutOfBoundsException if there are no HtmlTags
      *         left to return.
      */
     public HtmlTag nextTag() {
         return tags.remove(0);
     }
 
     /**
      * Indicates if there are any more HtmlTag to retrieve.
      * @return {@code true} if there are more tags.
      */
     public boolean hasNextTag() {
         return !tags.isEmpty();
     }
 
     /**
      * Performs lazy initialization on the internal tags List
      * and adds the tag.
      * @param tag the HtmlTag to add.
      */
     private void add(HtmlTag tag) {
         tags.add(tag);
     }
 
     /**
      * Parses the text line for any HTML tags and adds them to the internal
      * List of tags.
      * @param text the source line to parse.
      * @param lineNo the source line number.
      */
     private void parseTags(String[] text, int lineNo) {
         final int nLines = text.length;
-        Point position = new Point(0, 0);
-
-        position = findChar(text, '<', position);
+        Point position = findChar(text, '<', new Point(0, 0));
         while (position.getLineNo() < nLines) {
             // if this is html comment then skip it
             if (isCommentTag(text, position)) {
                 position = skipHtmlComment(text, position);
             }
             else if (isTag(text, position)) {
                 position = parseTag(text, lineNo, nLines, position);
             }
             else {
                 position = getNextCharPos(text, position);
             }
             position = findChar(text, '<', position);
         }
     }
 
     /**
      * Parses the tag and return position after it
      * @param text the source line to parse.
      * @param lineNo the source line number.
      * @param nLines line length
      * @param position start position for parsing
      * @return position after tag
      */
     private Point parseTag(String[] text, int lineNo, final int nLines, Point position) {
         // find end of tag
         final Point endTag = findChar(text, '>', position);
         final boolean incompleteTag = endTag.getLineNo() >= nLines;
         // get tag id (one word)
         final String tagId;
 
         if (incompleteTag) {
             tagId = "";
         }
         else {
             tagId = getTagId(text, position);
         }
         // is this closed tag
         final boolean closedTag =
                 endTag.getLineNo() < nLines
                  && text[endTag.getLineNo()]
                  .charAt(endTag.getColumnNo() - 1) == '/';
         // add new tag
         add(new HtmlTag(tagId,
                         position.getLineNo() + lineNo,
                         position.getColumnNo(),
                         closedTag,
                         incompleteTag,
                         text[position.getLineNo()]));
         return endTag;
     }
