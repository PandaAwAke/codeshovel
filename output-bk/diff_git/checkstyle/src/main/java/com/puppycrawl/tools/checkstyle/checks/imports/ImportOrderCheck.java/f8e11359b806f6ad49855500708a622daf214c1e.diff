diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
index 373143110..778d6eb7b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java
@@ -435,101 +435,101 @@ public class ImportOrderCheck
         else if (groupIdx > lastGroup) {
             if (!beforeFirstImport && separated && line - lastImportLine < 2) {
                 log(line, MSG_SEPARATION, name);
             }
         }
         else {
             log(line, MSG_ORDERING, name);
         }
 
         lastGroup = groupIdx;
         lastImport = name;
     }
 
     /**
      * Checks whether static imports grouped by <b>top</b> or <b>bottom</b> option
      * are sorted alphabetically or not.
      * @param isStatic if current import is static.
      * @return true if static imports should be sorted alphabetically.
      */
     private boolean isAlphabeticallySortableStaticImport(boolean isStatic) {
         return isStatic && sortStaticImportsAlphabetically
                 && (getAbstractOption() == ImportOrderOption.TOP
                     || getAbstractOption() == ImportOrderOption.BOTTOM);
     }
 
     /**
      * Shares processing...
      *
      * @param isStatic whether the token is static or not.
      * @param previous previous non-static but current is static (above), or
      *     previous static but current is non-static (under).
      * @param name the name of the current import.
      * @param line the line of the current import.
      */
     private void doVisitTokenInSameGroup(boolean isStatic,
             boolean previous, String name, int line) {
         if (!ordered) {
             return;
         }
 
         if (getAbstractOption() == ImportOrderOption.INFLOW) {
             // out of lexicographic order
             if (compare(lastImport, name, caseSensitive) > 0) {
                 log(line, MSG_ORDERING, name);
             }
         }
         else {
             final boolean shouldFireError =
                 // current and previous static or current and
                 // previous non-static
-                !(lastImportStatic ^ isStatic)
+                lastImportStatic == isStatic
                 &&
                         // and out of lexicographic order
                         compare(lastImport, name, caseSensitive) > 0
                 ||
                 // previous non-static but current is static (above)
                 // or
                 // previous static but current is non-static (under)
                 previous;
 
             if (shouldFireError) {
                 log(line, MSG_ORDERING, name);
             }
         }
     }
 
     /**
      * Finds out what group the specified import belongs to.
      *
      * @param name the import name to find.
      * @return group number for given import name.
      */
     private int getGroupNumber(String name) {
         int bestIndex = groups.length;
         int bestLength = -1;
         int bestPos = 0;
 
         // find out what group this belongs in
         // loop over groups and get index
         for (int i = 0; i < groups.length; i++) {
             final Matcher matcher = groups[i].matcher(name);
             while (matcher.find()) {
                 final int length = matcher.end() - matcher.start();
                 if (length > bestLength
                     || length == bestLength && matcher.start() < bestPos) {
                     bestIndex = i;
                     bestLength = length;
                     bestPos = matcher.start();
                 }
             }
         }
 
         return bestIndex;
     }
 
     /**
      * Compares two strings.
      *
      * @param string1
      *            the first string.
      * @param string2
