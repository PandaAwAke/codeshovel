diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
index 4ce49b764..048827a27 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
@@ -1,97 +1,106 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2015 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks;
 
 import java.util.List;
 
 import com.google.common.collect.Lists;
 import com.puppycrawl.tools.checkstyle.Utils;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * Contains utility methods for the checks.
  *
  * @author Oliver Burn
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  * @author o_sukhodolsky
  */
 public final class CheckUtils {
     // constants for parseDouble()
     /** octal radix */
     private static final int BASE_8 = 8;
 
     /** decimal radix */
     private static final int BASE_10 = 10;
 
     /** hex radix */
     private static final int BASE_16 = 16;
 
+    /** Maximum children allowed in setter/getter */
+    private static final int SETTER_GETTER_MAX_CHILDREN = 7;
+
+    /** Maximum nodes allowed in a body of setter */
+    private static final int SETTER_BODY_SIZE = 3;
+
+    /** Maximum nodes allowed in a body of getter */
+    private static final int GETTER_BODY_SIZE = 2;
+
     /** prevent instances */
     private CheckUtils() {
     }
 
     /**
      * Tests whether a method definition AST defines an equals covariant.
      * @param ast the method definition AST to test.
      * Precondition: ast is a TokenTypes.METHOD_DEF node.
      * @return true if ast defines an equals covariant.
      */
     public static boolean isEqualsMethod(DetailAST ast) {
         if (ast.getType() != TokenTypes.METHOD_DEF) {
             // A node must be method def
             return false;
         }
 
         // non-static, non-abstract?
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
         if (modifiers.branchContains(TokenTypes.LITERAL_STATIC)
             || modifiers.branchContains(TokenTypes.ABSTRACT)) {
             return false;
         }
 
         // named "equals"?
         final DetailAST nameNode = ast.findFirstToken(TokenTypes.IDENT);
         final String name = nameNode.getText();
         if (!"equals".equals(name)) {
             return false;
         }
 
         // one parameter?
         final DetailAST paramsNode = ast.findFirstToken(TokenTypes.PARAMETERS);
         return paramsNode.getChildCount() == 1;
     }
 
     /**
      * Returns whether a token represents an ELSE as part of an ELSE / IF set.
      * @param ast the token to check
      * @return whether it is
      */
     public static boolean isElseIf(DetailAST ast) {
         final DetailAST parentAST = ast.getParent();
 
         return ast.getType() == TokenTypes.LITERAL_IF
             && (isElse(parentAST) || isElseWithCurlyBraces(parentAST));
     }
 
     /**
      * Returns whether a token represents an ELSE.
      * @param ast the token to check
@@ -258,51 +267,144 @@ public final class CheckUtils {
     public static List<String> getTypeParameterNames(final DetailAST node) {
         final DetailAST typeParameters =
             node.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
         final List<String> typeParanames = Lists.newArrayList();
         if (typeParameters != null) {
             final DetailAST typeParam =
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
             typeParanames.add(
                 typeParam.findFirstToken(TokenTypes.IDENT).getText());
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
                     typeParanames.add(
                         sibling.findFirstToken(TokenTypes.IDENT).getText());
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
         return typeParanames;
     }
 
     /**
      * Retrieves the type parameters to the node.
      * @param node the parameterised AST node
      * @return a list of type parameter names
      */
     public static List<DetailAST> getTypeParameters(final DetailAST node) {
         final DetailAST typeParameters =
             node.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
         final List<DetailAST> typeParams = Lists.newArrayList();
         if (typeParameters != null) {
             final DetailAST typeParam =
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
             typeParams.add(typeParam);
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
                     typeParams.add(sibling);
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
         return typeParams;
     }
+
+    /**
+     * Returns whether an AST represents a setter method.
+     * @param ast the AST to check with
+     * @return whether the AST represents a setter method
+     */
+    public static boolean isSetterMethod(final DetailAST ast) {
+        // Check have a method with exactly 7 children which are all that
+        // is allowed in a proper setter method which does not throw any
+        // exceptions.
+        if (ast.getType() != TokenTypes.METHOD_DEF
+                || ast.getChildCount() != SETTER_GETTER_MAX_CHILDREN) {
+            return false;
+        }
+
+        // Should I handle only being in a class????
+
+        // Check the name matches format setX...
+        final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
+        final String name = type.getNextSibling().getText();
+        if (!name.matches("^set[A-Z].*")) { // Depends on JDK 1.4
+            return false;
+        }
+
+        // Check the return type is void
+        if (type.getChildCount(TokenTypes.LITERAL_VOID) == 0) {
+            return false;
+        }
+
+        // Check that is had only one parameter
+        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
+        if (params.getChildCount(TokenTypes.PARAMETER_DEF) != 1) {
+            return false;
+        }
+
+        // Now verify that the body consists of:
+        // SLIST -> EXPR -> ASSIGN
+        // SEMI
+        // RCURLY
+        final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
+        if (slist == null || slist.getChildCount() != SETTER_BODY_SIZE) {
+            return false;
+        }
+
+        final DetailAST expr = slist.getFirstChild();
+        return expr.getFirstChild().getType() == TokenTypes.ASSIGN;
+    }
+
+    /**
+     * Returns whether an AST represents a getter method.
+     * @param ast the AST to check with
+     * @return whether the AST represents a getter method
+     */
+    public static boolean isGetterMethod(final DetailAST ast) {
+        // Check have a method with exactly 7 children which are all that
+        // is allowed in a proper getter method which does not throw any
+        // exceptions.
+        if (ast.getType() != TokenTypes.METHOD_DEF
+                || ast.getChildCount() != SETTER_GETTER_MAX_CHILDREN) {
+            return false;
+        }
+
+        // Check the name matches format of getX or isX. Technically I should
+        // check that the format isX is only used with a boolean type.
+        final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
+        final String name = type.getNextSibling().getText();
+        if (!name.matches("^(is|get)[A-Z].*")) { // Depends on JDK 1.4
+            return false;
+        }
+
+        // Check the return type is void
+        if (type.getChildCount(TokenTypes.LITERAL_VOID) > 0) {
+            return false;
+        }
+
+        // Check that is had only one parameter
+        final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
+        if (params.getChildCount(TokenTypes.PARAMETER_DEF) > 0) {
+            return false;
+        }
+
+        // Now verify that the body consists of:
+        // SLIST -> RETURN
+        // RCURLY
+        final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
+        if (slist == null || slist.getChildCount() != GETTER_BODY_SIZE) {
+            return false;
+        }
+
+        final DetailAST expr = slist.getFirstChild();
+        return expr.getType() == TokenTypes.LITERAL_RETURN;
+
+    }
 }
