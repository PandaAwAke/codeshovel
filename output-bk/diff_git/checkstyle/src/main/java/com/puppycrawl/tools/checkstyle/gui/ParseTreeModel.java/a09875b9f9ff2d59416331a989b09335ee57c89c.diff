diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeModel.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeModel.java
index e1ef4dc87..5603a9160 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeModel.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeModel.java
@@ -23,108 +23,121 @@ import javax.swing.tree.TreePath;
 
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
 
 /**
  * The model that backs the parse tree in the GUI.
  *
  * @author Lars KÃ¼hne
  */
 public class ParseTreeModel extends AbstractTreeTableModel {
     private static final String[] COLUMN_NAMES = {
         "Tree", "Type", "Line", "Column", "Text",
     };
 
     public ParseTreeModel(DetailAST parseTree) {
         super(createArtificialTreeRoot());
         setParseTree(parseTree);
     }
 
     private static DetailAST createArtificialTreeRoot() {
         final ASTFactory factory = new ASTFactory();
         factory.setASTNodeClass(DetailAST.class.getName());
         return (DetailAST) factory.create(TokenTypes.EOF, "ROOT");
     }
 
     final void setParseTree(DetailAST parseTree) {
         final DetailAST root = (DetailAST) getRoot();
         root.setFirstChild(parseTree);
         final Object[] path = {root};
         // no need to setup remaining info, as the call results in a
         // table structure changed event anyway - we just pass nulls
         fireTreeStructureChanged(this, path, null, (Object[]) null);
     }
 
     @Override
     public int getColumnCount() {
         return COLUMN_NAMES.length;
     }
 
     @Override
     public String getColumnName(int column) {
         return COLUMN_NAMES[column];
     }
 
     @Override
     public Class<?> getColumnClass(int column) {
+        Class<?> columnClass;
+
         switch (column) {
             case 0:
-                return TreeTableModel.class;
+                columnClass = TreeTableModel.class;
+                break;
             case 1:
-                return String.class;
+                columnClass = String.class;
+                break;
             case 2:
-                return Integer.class;
+                columnClass = Integer.class;
+                break;
             case 3:
-                return Integer.class;
+                columnClass = Integer.class;
+                break;
             case 4:
-                return String.class;
+                columnClass = String.class;
+                break;
             default:
-                return Object.class;
+                columnClass = Object.class;
         }
+        return columnClass;
     }
 
     @Override
     public Object getValueAt(Object node, int column) {
         final DetailAST ast = (DetailAST) node;
+        Object value;
+
         switch (column) {
-            case 0:
-                return null;
             case 1:
-                return TokenUtils.getTokenName(ast.getType());
+                value = TokenUtils.getTokenName(ast.getType());
+                break;
             case 2:
-                return ast.getLineNo();
+                value = ast.getLineNo();
+                break;
             case 3:
-                return ast.getColumnNo();
+                value = ast.getColumnNo();
+                break;
             case 4:
-                return ast.getText();
+                value = ast.getText();
+                break;
             default:
-                return null;
+                value = null;
         }
+        return value;
     }
 
     @Override
     public Object getChild(Object parent, int index) {
         final DetailAST ast = (DetailAST) parent;
         int i = 0;
         AST child = ast.getFirstChild();
         while (i < index) {
             child = child.getNextSibling();
             i++;
         }
         return child;
     }
 
     @Override
     public int getChildCount(Object parent) {
         final DetailAST ast = (DetailAST) parent;
         return ast.getChildCount();
     }
 
     @Override
     public void valueForPathChanged(TreePath path, Object newValue) {
         //No Code, as tree is read-only
     }
 }
