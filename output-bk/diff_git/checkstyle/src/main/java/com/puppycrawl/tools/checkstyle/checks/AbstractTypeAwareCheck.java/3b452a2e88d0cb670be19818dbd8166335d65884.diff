diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index 0ce2ef77d..f8487b36d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -274,101 +274,101 @@ public abstract class AbstractTypeAwareCheck extends Check {
         if (!suppressLoadErrors) {
             log(lineNo, columnNo, msgKey, values);
         }
     }
 
     /**
      * Collects the details of a package.
      * @param ast node containing the package details
      */
     private void processPackage(DetailAST ast) {
         final DetailAST nameAST = ast.getLastChild().getPreviousSibling();
         packageFullIdent = FullIdent.createFullIdent(nameAST);
     }
 
     /**
      * Collects the details of imports.
      * @param ast node containing the import details
      */
     private void processImport(DetailAST ast) {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
         imports.add(name.getText());
     }
 
     /**
      * Process type params (if any) for given class, enum or method.
      * @param ast class, enum or method to process.
      */
     private void processTypeParams(DetailAST ast) {
         final DetailAST params =
             ast.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
         final Map<String, AbstractClassInfo> paramsMap = Maps.newHashMap();
         typeParams.push(paramsMap);
 
         if (params == null) {
             return;
         }
 
         for (DetailAST child = params.getFirstChild();
              child != null;
              child = child.getNextSibling()) {
             if (child.getType() == TokenTypes.TYPE_PARAMETER) {
                 final String alias =
                     child.findFirstToken(TokenTypes.IDENT).getText();
                 final DetailAST bounds =
                     child.findFirstToken(TokenTypes.TYPE_UPPER_BOUNDS);
                 if (bounds != null) {
                     final FullIdent name =
                         FullIdent.createFullIdentBelow(bounds);
                     final AbstractClassInfo ci =
-                        createClassInfo(new Token(name), getCurrentClassName());
+                        createClassInfo(new Token(name), currentClassName);
                     paramsMap.put(alias, ci);
                 }
             }
         }
     }
 
     /**
      * Processes class definition.
      * @param ast class definition to process.
      */
     private void processClass(DetailAST ast) {
         final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);
         String innerClass = ident.getText();
 
         if (!currentClassName.isEmpty()) {
             innerClass = "$" + innerClass;
         }
         currentClassName += innerClass;
         processTypeParams(ast);
     }
 
     /**
      * Returns current class.
      * @return name of current class.
      */
     protected final String getCurrentClassName() {
         return currentClassName;
     }
 
     /**
      * Creates class info for given name.
      * @param name name of type.
      * @param surroundingClass name of surrounding class.
      * @return class infor for given name.
      */
     protected final AbstractClassInfo createClassInfo(final Token name,
                                               final String surroundingClass) {
         final AbstractClassInfo ci = findClassAlias(name.getText());
         if (ci != null) {
             return new ClassAlias(name, ci);
         }
         return new RegularClass(name, surroundingClass, this);
     }
 
     /**
      * Looking if a given name is alias.
      * @param name given name
      * @return ClassInfo for alias if it exists, null otherwise
      */
     protected final AbstractClassInfo findClassAlias(final String name) {
@@ -389,162 +389,158 @@ public abstract class AbstractTypeAwareCheck extends Check {
      */
     protected abstract static class AbstractClassInfo {
         /** {@code FullIdent} associated with this class. */
         private final Token name;
 
         /**
          * Creates new instance of class inforamtion object.
          * @param className token which represents class name.
          */
         protected AbstractClassInfo(final Token className) {
             if (className == null) {
                 throw new IllegalArgumentException(
                     "ClassInfo's name should be non-null");
             }
             name = className;
         }
 
         /** @return class name */
         public final Token getName() {
             return name;
         }
 
         /** @return {@code Class} associated with an object. */
         public abstract Class<?> getClazz();
     }
 
     /** Represents regular classes/enumes. */
     private static final class RegularClass extends AbstractClassInfo {
         /** Name of surrounding class. */
         private final String surroundingClass;
         /** Is class loadable. */
         private boolean loadable = true;
         /** {@code Class} object of this class if it's loadable. */
         private Class<?> classObj;
         /** The check we use to resolve classes. */
         private final AbstractTypeAwareCheck check;
 
         /**
          * Creates new instance of of class information object.
          * @param name {@code FullIdent} associated with new object.
          * @param surroundingClass name of current surrounding class.
          * @param check the check we use to load class.
          */
         public RegularClass(final Token name,
                              final String surroundingClass,
                              final AbstractTypeAwareCheck check) {
             super(name);
             this.surroundingClass = surroundingClass;
             this.check = check;
         }
-        /** @return if class is loadable ot not. */
-        private boolean isLoadable() {
-            return loadable;
-        }
 
         @Override
         public Class<?> getClazz() {
-            if (isLoadable() && classObj == null) {
+            if (loadable && classObj == null) {
                 setClazz(check.tryLoadClass(getName(), surroundingClass));
             }
             return classObj;
         }
 
         /**
          * Associates {@code Class} with an object.
          * @param clazz {@code Class} to associate with.
          */
         private void setClazz(Class<?> clazz) {
             classObj = clazz;
             loadable = clazz != null;
         }
 
         @Override
         public String toString() {
             return "RegularClass[name=" + getName()
                 + ", in class=" + surroundingClass
                 + ", loadable=" + loadable
                 + ", class=" + classObj + "]";
         }
     }
 
     /** Represents type param which is "alias" for real type. */
     private static class ClassAlias extends AbstractClassInfo {
         /** Class information associated with the alias. */
         private final AbstractClassInfo classInfo;
 
         /**
          * Creates nnew instance of the class.
          * @param name token which represents name of class alias.
          * @param classInfo class information associated with the alias.
          */
         ClassAlias(final Token name, AbstractClassInfo classInfo) {
             super(name);
             this.classInfo = classInfo;
         }
 
         @Override
         public final Class<?> getClazz() {
             return classInfo.getClazz();
         }
 
         @Override
         public String toString() {
             return "ClassAlias[alias " + getName() + " for " + classInfo.getName() + "]";
         }
     }
 
     /**
      * Represents text element with location in the text.
      */
     protected static class Token {
         /** Token's column number. */
         private final int columnNo;
         /** Token's line number. */
         private final int lineNo;
         /** Token's text. */
         private final String text;
 
         /**
          * Creates token.
          * @param text token's text
          * @param lineNo token's line number
          * @param columnNo token's column number
          */
         public Token(String text, int lineNo, int columnNo) {
             this.text = text;
             this.lineNo = lineNo;
             this.columnNo = columnNo;
         }
 
         /**
          * Converts FullIdent to Token.
          * @param fullIdent full ident to convert.
          */
         public Token(FullIdent fullIdent) {
             text = fullIdent.getText();
             lineNo = fullIdent.getLineNo();
             columnNo = fullIdent.getColumnNo();
         }
 
         /** @return line number of the token */
         public int getLineNo() {
             return lineNo;
         }
 
         /** @return column number of the token */
         public int getColumnNo() {
             return columnNo;
         }
 
         /** @return text of the token */
         public String getText() {
             return text;
         }
 
         @Override
         public String toString() {
-            return "Token[" + getText() + "(" + getLineNo()
-                + "x" + getColumnNo() + ")]";
+            return "Token[" + text + "(" + lineNo
+                + "x" + columnNo + ")]";
         }
     }
 }
