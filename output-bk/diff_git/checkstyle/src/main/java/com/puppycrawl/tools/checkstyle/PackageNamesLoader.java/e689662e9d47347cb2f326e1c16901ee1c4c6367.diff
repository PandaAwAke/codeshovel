diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java b/src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java
index 0b347b5b2..eef3f7f04 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java
@@ -45,170 +45,134 @@ import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
  * @author Rick Giles
  */
 public final class PackageNamesLoader
     extends AbstractLoader {
     /** the public ID for the configuration dtd */
     private static final String DTD_PUBLIC_ID =
         "-//Puppy Crawl//DTD Package Names 1.0//EN";
 
     /** the resource for the configuration dtd */
     private static final String DTD_RESOURCE_NAME =
         "com/puppycrawl/tools/checkstyle/packages_1_0.dtd";
 
     /** Name of default checkstyle package names resource file.
      * The file must be in the classpath.
      */
     private static final String CHECKSTYLE_PACKAGES =
         "checkstyle_packages.xml";
 
     /** The temporary stack of package name parts */
     private final Deque<String> packageStack = new ArrayDeque<>();
 
     /** The fully qualified package names. */
     private final Set<String> packageNames = Sets.newLinkedHashSet();
 
     /**
      * Creates a new <code>PackageNamesLoader</code> instance.
      * @throws ParserConfigurationException if an error occurs
      * @throws SAXException if an error occurs
      */
     private PackageNamesLoader()
         throws ParserConfigurationException, SAXException {
         super(DTD_PUBLIC_ID, DTD_RESOURCE_NAME);
     }
 
     /**
      * Returns the set of fully qualified package names this
      * this loader processed.
      * @return the set of package names
      */
     private Set<String> getPackageNames() {
         return packageNames;
     }
 
     @Override
     public void startElement(String namespaceURI,
                              String localName,
                              String qName,
                              Attributes atts)
         throws SAXException {
         if ("package".equals(qName)) {
-            //push package name
+            //push package name, name is mandatory attribute with not empty value by DTD
             final String name = atts.getValue("name");
-            if (name == null) {
-                throw new SAXException("missing package name");
-            }
             packageStack.push(name);
         }
     }
 
     /**
      * Creates a full package name from the package names on the stack.
      * @return the full name of the current package.
      */
     private String getPackageName() {
         final StringBuilder buf = new StringBuilder();
         final Iterator<String> iterator = packageStack.descendingIterator();
         while (iterator.hasNext()) {
             final String subPackage = iterator.next();
             buf.append(subPackage);
             if (!Utils.endsWithChar(subPackage, '.')) {
                 buf.append('.');
             }
         }
         return buf.toString();
     }
 
     @Override
     public void endElement(String namespaceURI,
                            String localName,
                            String qName) {
         if ("package".equals(qName)) {
 
             packageNames.add(getPackageName());
             packageStack.pop();
         }
     }
 
     /**
      * Returns the set of package names, compiled from all
      * checkstyle_packages.xml files found on the given classloaders
      * classpath.
      * @param classLoader the class loader for loading the
      *          checkstyle_packages.xml files.
      * @return the set of package names.
      * @throws CheckstyleException if an error occurs.
      */
     public static Set<String> getPackageNames(ClassLoader classLoader)
-        throws CheckstyleException {
+            throws CheckstyleException {
 
-        Enumeration<URL> packageFiles = null;
+        Set<String> result;
         try {
-            packageFiles = classLoader.getResources(CHECKSTYLE_PACKAGES);
-        }
-        catch (IOException e) {
-            throw new CheckstyleException(
-                    "unable to get package file resources", e);
-        }
-
-        //create the loader outside the loop to prevent PackageObjectFactory
-        //being created anew for each file
-        final PackageNamesLoader namesLoader = newPackageNamesLoader();
+            //create the loader outside the loop to prevent PackageObjectFactory
+            //being created anew for each file
+            final PackageNamesLoader namesLoader = new PackageNamesLoader();
+
+            final Enumeration<URL> packageFiles = classLoader.getResources(CHECKSTYLE_PACKAGES);
+
+            while (packageFiles.hasMoreElements()) {
+                final URL packageFile = packageFiles.nextElement();
+                InputStream stream = null;
+
+                try {
+                    stream = new BufferedInputStream(packageFile.openStream());
+                    final InputSource source = new InputSource(stream);
+                    namesLoader.parseInputSource(source);
+                }
+                catch (IOException e) {
+                    throw new CheckstyleException("unable to open " + packageFile, e);
+                }
+                finally {
+                    Closeables.closeQuietly(stream);
+                }
+            }
 
-        while (packageFiles.hasMoreElements()) {
-            final URL packageFile = packageFiles.nextElement();
-            InputStream stream = null;
+            result = namesLoader.getPackageNames();
 
-            try {
-                stream = new BufferedInputStream(packageFile.openStream());
-                final InputSource source = new InputSource(stream);
-                loadPackageNamesSource(source, "default package names",
-                    namesLoader);
-            }
-            catch (IOException e) {
-                throw new CheckstyleException(
-                        "unable to open " + packageFile, e);
-            }
-            finally {
-                Closeables.closeQuietly(stream);
-            }
         }
-        return namesLoader.getPackageNames();
-    }
-
-    /**
-     * Creates a PackageNamesLoader instance.
-     * @return the PackageNamesLoader
-     * @throws CheckstyleException if the creation failed
-     */
-    private static PackageNamesLoader newPackageNamesLoader()
-        throws CheckstyleException {
-        try {
-            return new PackageNamesLoader();
+        catch (IOException e) {
+            throw new CheckstyleException("unable to get package file resources", e);
         }
-        catch (final ParserConfigurationException | SAXException e) {
-            throw new CheckstyleException(
-                    "unable to create PackageNamesLoader - "
-                    + e.getMessage(), e);
+        catch (ParserConfigurationException | SAXException e) {
+            throw new CheckstyleException("unable to open one of package files", e);
         }
-    }
 
-    /**
-     * Returns the list of package names in a specified source.
-     * @param source the source for the list.
-     * @param sourceName the name of the source.
-     * @param nameLoader the PackageNamesLoader instance
-     * @throws CheckstyleException if an error occurs.
-     */
-    private static void loadPackageNamesSource(
-            InputSource source, String sourceName,
-            PackageNamesLoader nameLoader)
-        throws CheckstyleException {
-        try {
-            nameLoader.parseInputSource(source);
-        }
-        catch (final SAXException | IOException e) {
-            throw new CheckstyleException("Unable to parse "
-                    + sourceName + " - " + e.getMessage(), e);
-        }
+        return result;
     }
 }
