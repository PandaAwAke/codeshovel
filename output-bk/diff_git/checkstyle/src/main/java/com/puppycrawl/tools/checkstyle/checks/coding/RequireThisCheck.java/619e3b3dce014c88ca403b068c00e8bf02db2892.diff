diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index 0712599cc..3d6e80d03 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -236,227 +236,248 @@ public class RequireThisCheck extends AbstractCheck {
             case TokenTypes.CTOR_DEF :
                 current = frames.get(ast);
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Checks if a given IDENT is method call or field name which
      * requires explicit {@code this} qualifier.
      * @param ast IDENT to check.
      */
     private void processIdent(DetailAST ast) {
         final int parentType = ast.getParent().getType();
         switch (parentType) {
             case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:
             case TokenTypes.ANNOTATION:
             case TokenTypes.ANNOTATION_FIELD_DEF:
                 // no need to check annotations content
                 break;
             case TokenTypes.METHOD_CALL:
                 if (checkMethods) {
                     final AbstractFrame frame = getMethodWithoutThis(ast);
                     if (frame != null) {
                         logViolation(MSG_METHOD, ast, frame);
                     }
                 }
                 break;
             default:
                 if (checkFields) {
                     final AbstractFrame frame = getFieldWithoutThis(ast, parentType);
                     if (frame != null) {
                         logViolation(MSG_VARIABLE, ast, frame);
                     }
                 }
                 break;
         }
     }
 
     /**
      * Helper method to log a LocalizedMessage.
      * @param ast a node to get line id column numbers associated with the message.
      * @param msgKey key to locale message format.
      * @param frame the class frame where the violation is found.
      */
     private void logViolation(String msgKey, DetailAST ast, AbstractFrame frame) {
         if (frame.getFrameName().equals(getNearestClassFrameName())) {
             log(ast, msgKey, ast.getText(), "");
         }
-        else {
+        else if (!(frame instanceof AnonymousClassFrame)) {
             log(ast, msgKey, ast.getText(), frame.getFrameName() + '.');
         }
     }
 
     /**
      * Returns the frame where the field is declared, if the given field is used without
      * 'this', and null otherwise.
      * @param ast field definition ast token.
      * @param parentType type of the parent.
      * @return the frame where the field is declared, if the given field is used without
      *         'this' and null otherwise.
      */
     private AbstractFrame getFieldWithoutThis(DetailAST ast, int parentType) {
         final boolean importOrPackage = ScopeUtils.getSurroundingScope(ast) == null;
         final boolean methodNameInMethodCall = parentType == TokenTypes.DOT
                 && ast.getPreviousSibling() != null;
         final boolean typeName = parentType == TokenTypes.TYPE
                 || parentType == TokenTypes.LITERAL_NEW;
         AbstractFrame frame = null;
 
         if (!importOrPackage
                 && !methodNameInMethodCall
                 && !typeName
                 && !isDeclarationToken(parentType)) {
             final AbstractFrame fieldFrame = findClassFrame(ast, false);
 
             if (fieldFrame != null && ((ClassFrame) fieldFrame).hasInstanceMember(ast)) {
                 frame = getClassFrameWhereViolationIsFound(ast);
             }
         }
         return frame;
     }
 
     /**
      * Parses the next AST for declarations.
      * @param frameStack stack containing the FrameTree being built.
      * @param ast AST to parse.
      */
     private static void collectDeclarations(Deque<AbstractFrame> frameStack, DetailAST ast) {
         final AbstractFrame frame = frameStack.peek();
         switch (ast.getType()) {
             case TokenTypes.VARIABLE_DEF :
                 collectVariableDeclarations(ast, frame);
                 break;
             case TokenTypes.PARAMETER_DEF :
                 if (!CheckUtils.isReceiverParameter(ast)) {
                     final DetailAST parameterIdent = ast.findFirstToken(TokenTypes.IDENT);
                     frame.addIdent(parameterIdent);
                 }
                 break;
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
                 final DetailAST classFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ClassFrame(frame, classFrameNameIdent));
                 break;
             case TokenTypes.SLIST :
                 frameStack.addFirst(new BlockFrame(frame, ast));
                 break;
             case TokenTypes.METHOD_DEF :
                 final DetailAST methodFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 if (frame.getType() == FrameType.CLASS_FRAME) {
                     final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
                     if (mods.branchContains(TokenTypes.LITERAL_STATIC)) {
                         ((ClassFrame) frame).addStaticMethod(methodFrameNameIdent);
                     }
                     else {
                         ((ClassFrame) frame).addInstanceMethod(methodFrameNameIdent);
                     }
                 }
                 frameStack.addFirst(new MethodFrame(frame, methodFrameNameIdent));
                 break;
             case TokenTypes.CTOR_DEF :
                 final DetailAST ctorFrameNameIdent = ast.findFirstToken(TokenTypes.IDENT);
                 frameStack.addFirst(new ConstructorFrame(frame, ctorFrameNameIdent));
                 break;
+            case TokenTypes.LITERAL_NEW:
+                if (isAnonymousClassDef(ast)) {
+                    frameStack.addFirst(new AnonymousClassFrame(frame,
+                            ast.getFirstChild().toString()));
+                }
+                break;
             default:
                 // do nothing
         }
     }
 
     /**
      * Collects variable declarations.
      * @param ast variable token.
      * @param frame current frame.
      */
     private static void collectVariableDeclarations(DetailAST ast, AbstractFrame frame) {
         final DetailAST ident = ast.findFirstToken(TokenTypes.IDENT);
         if (frame.getType() == FrameType.CLASS_FRAME) {
             final DetailAST mods =
                     ast.findFirstToken(TokenTypes.MODIFIERS);
             if (ScopeUtils.isInInterfaceBlock(ast)
                     || mods.branchContains(TokenTypes.LITERAL_STATIC)) {
                 ((ClassFrame) frame).addStaticMember(ident);
             }
             else {
                 ((ClassFrame) frame).addInstanceMember(ident);
             }
         }
         else {
             frame.addIdent(ident);
         }
     }
 
     /**
      * Ends parsing of the AST for declarations.
      * @param frameStack Stack containing the FrameTree being built.
      * @param ast AST that was parsed.
      */
     private void endCollectingDeclarations(Queue<AbstractFrame> frameStack, DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
                 frames.put(ast, frameStack.poll());
                 break;
+            case TokenTypes.LITERAL_NEW :
+                if (isAnonymousClassDef(ast)) {
+                    frames.put(ast, frameStack.poll());
+                }
+                break;
             default :
                 // do nothing
         }
     }
 
+    /**
+     * Whether the AST is a definition of an anonymous class.
+     * @param ast the AST to process.
+     * @return true if the AST is a definition of an anonymous class.
+     */
+    private static boolean isAnonymousClassDef(DetailAST ast) {
+        final DetailAST lastChild = ast.getLastChild();
+        return lastChild != null && lastChild.getType() == TokenTypes.OBJBLOCK;
+    }
+
     /**
      * Returns the class frame where violation is found (where the field is used without 'this')
      * or null otherwise.
      * @param ast IDENT ast to check.
      * @return the class frame where violation is found or null otherwise.
      */
     // -@cs[CyclomaticComplexity] Method already invokes too many methods that fully explain
     // a logic, additional abstraction will not make logic/algorithm more readable.
     private AbstractFrame getClassFrameWhereViolationIsFound(DetailAST ast) {
         AbstractFrame frameWhereViolationIsFound = null;
         final AbstractFrame variableDeclarationFrame = findFrame(ast, false);
         final FrameType variableDeclarationFrameType = variableDeclarationFrame.getType();
         final DetailAST prevSibling = ast.getPreviousSibling();
         if (variableDeclarationFrameType == FrameType.CLASS_FRAME
                 && !validateOnlyOverlapping
                 && prevSibling == null
                 && canBeReferencedFromStaticContext(ast)) {
             frameWhereViolationIsFound = variableDeclarationFrame;
         }
         else if (variableDeclarationFrameType == FrameType.METHOD_FRAME) {
             if (isOverlappingByArgument(ast)) {
                 if (!isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
                         && !isReturnedVariable(variableDeclarationFrame, ast)
                         && canBeReferencedFromStaticContext(ast)
                         && canAssignValueToClassField(ast)) {
                     frameWhereViolationIsFound = findFrame(ast, true);
                 }
             }
             else if (!validateOnlyOverlapping
                      && prevSibling == null
                      && isAssignToken(ast.getParent().getType())
                      && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
                      && canBeReferencedFromStaticContext(ast)
                      && canAssignValueToClassField(ast)) {
                 frameWhereViolationIsFound = findFrame(ast, true);
 
             }
         }
         else if (variableDeclarationFrameType == FrameType.CTOR_FRAME
                  && isOverlappingByArgument(ast)
                  && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)) {
             frameWhereViolationIsFound = findFrame(ast, true);
         }
         else if (variableDeclarationFrameType == FrameType.BLOCK_FRAME) {
             if (isOverlappingByLocalVariable(ast)) {
                 if (canAssignValueToClassField(ast)
                         && !isUserDefinedArrangementOfThis(variableDeclarationFrame, ast)
                         && !isReturnedVariable(variableDeclarationFrame, ast)
                         && canBeReferencedFromStaticContext(ast)) {
                     frameWhereViolationIsFound = findFrame(ast, true);
@@ -1015,101 +1036,101 @@ public class RequireThisCheck extends AbstractCheck {
                 result = true;
             }
             return result;
         }
     }
 
     /**
      * A frame initiated at method definition; holds a method definition token.
      * @author Stephen Bloch
      * @author Andrei Selkin
      */
     private static class MethodFrame extends AbstractFrame {
 
         /**
          * Creates method frame.
          * @param parent parent frame.
          * @param ident method name identifier token.
          */
         protected MethodFrame(AbstractFrame parent, DetailAST ident) {
             super(parent, ident);
         }
 
         @Override
         protected FrameType getType() {
             return FrameType.METHOD_FRAME;
         }
     }
 
     /**
      * A frame initiated at constructor definition.
      * @author Andrei Selkin
      */
     private static class ConstructorFrame extends AbstractFrame {
 
         /**
          * Creates a constructor frame.
          * @param parent parent frame.
          * @param ident frame name ident.
          */
         protected ConstructorFrame(AbstractFrame parent, DetailAST ident) {
             super(parent, ident);
         }
 
         @Override
         protected FrameType getType() {
             return FrameType.CTOR_FRAME;
         }
     }
 
     /**
-     * A frame initiated at class< enum or interface definition; holds instance variable names.
+     * A frame initiated at class, enum or interface definition; holds instance variable names.
      * @author Stephen Bloch
      * @author Andrei Selkin
      */
     private static class ClassFrame extends AbstractFrame {
         /** Set of idents of instance members declared in this frame. */
         private final Set<DetailAST> instanceMembers;
         /** Set of idents of instance methods declared in this frame. */
         private final Set<DetailAST> instanceMethods;
         /** Set of idents of variables declared in this frame. */
         private final Set<DetailAST> staticMembers;
         /** Set of idents of static methods declared in this frame. */
         private final Set<DetailAST> staticMethods;
 
         /**
          * Creates new instance of ClassFrame.
          * @param parent parent frame.
          * @param ident frame name ident.
          */
         ClassFrame(AbstractFrame parent, DetailAST ident) {
             super(parent, ident);
             instanceMembers = new HashSet<>();
             instanceMethods = new HashSet<>();
             staticMembers = new HashSet<>();
             staticMethods = new HashSet<>();
         }
 
         @Override
         protected FrameType getType() {
             return FrameType.CLASS_FRAME;
         }
 
         /**
          * Adds static member's ident.
          * @param ident an ident of static member of the class.
          */
         public void addStaticMember(final DetailAST ident) {
             staticMembers.add(ident);
         }
 
         /**
          * Adds static method's name.
          * @param ident an ident of static method of the class.
          */
         public void addStaticMethod(final DetailAST ident) {
             staticMethods.add(ident);
         }
 
         /**
          * Adds instance member's ident.
          * @param ident an ident of instance member of the class.
@@ -1201,71 +1222,95 @@ public class RequireThisCheck extends AbstractCheck {
 
         /**
          * Check whether the frame contains a given method.
          * @param methodToFind the AST of the method to find.
          * @return true, if a method with the same name and number of parameters is found.
          */
         private boolean containsMethod(DetailAST methodToFind) {
             return containsMethodDef(instanceMethods, methodToFind)
                 || containsMethodDef(staticMethods, methodToFind);
         }
 
         /**
          * Whether the set contains a method definition with the
          *     same name and number of parameters.
          * @param set the set of definitions.
          * @param ident the specified method call IDENT ast.
          * @return true if the set contains a definition with the
          *     same name and number of parameters.
          */
         private static boolean containsMethodDef(Set<DetailAST> set, DetailAST ident) {
             boolean result = false;
             for (DetailAST ast: set) {
                 if (isSimilarSignature(ident, ast)) {
                     result = true;
                     break;
                 }
             }
             return result;
         }
 
         /**
          * Whether the method definition has the same name and number of parameters.
          * @param ident the specified method call IDENT ast.
          * @param ast the ast of a method definition to compare with.
          * @return true if a method definition has the same name and number of parameters
          *     as the method call.
          */
         private static boolean isSimilarSignature(DetailAST ident, DetailAST ast) {
             boolean result = false;
             final DetailAST elistToken = ident.getParent().findFirstToken(TokenTypes.ELIST);
             if (elistToken != null && ident.getText().equals(ast.getText())) {
                 final int paramsNumber =
                     ast.getParent().findFirstToken(TokenTypes.PARAMETERS).getChildCount();
                 final int argsNumber = elistToken.getChildCount();
                 result = paramsNumber == argsNumber;
             }
             return result;
         }
     }
 
+    /**
+     * An anonymous class frame; holds instance variable names.
+     */
+    private static class AnonymousClassFrame extends ClassFrame {
+
+        /** The name of the frame. */
+        private final String frameName;
+
+        /**
+         * Creates anonymous class frame.
+         * @param parent parent frame.
+         * @param frameName name of the frame.
+         */
+        protected AnonymousClassFrame(AbstractFrame parent, String frameName) {
+            super(parent, null);
+            this.frameName = frameName;
+        }
+
+        @Override
+        protected String getFrameName() {
+            return frameName;
+        }
+    }
+
     /**
      * A frame initiated on entering a statement list; holds local variable names.
      * @author Stephen Bloch
      */
     private static class BlockFrame extends AbstractFrame {
 
         /**
          * Creates block frame.
          * @param parent parent frame.
          * @param ident ident frame name ident.
          */
         protected BlockFrame(AbstractFrame parent, DetailAST ident) {
             super(parent, ident);
         }
 
         @Override
         protected FrameType getType() {
             return FrameType.BLOCK_FRAME;
         }
     }
 }
