diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index fcb2cb601..5cba91437 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -180,101 +180,102 @@ public class WhitespaceAroundCheck extends Check
             TokenTypes.QUESTION,
             TokenTypes.RCURLY,
             TokenTypes.SL,
             TokenTypes.SLIST,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.LITERAL_ASSERT,
             TokenTypes.TYPE_EXTENSION_AND,
         };
     }
 
     /**
      * Sets whether or not empty method bodies are allowed.
      * @param aAllow <code>true</code> to allow empty method bodies.
      */
     public void setAllowEmptyMethods(boolean aAllow)
     {
         mAllowEmptyMethods = aAllow;
     }
 
     /**
      * Sets whether or not empty constructor bodies are allowed.
      * @param aAllow <code>true</code> to allow empty constructor bodies.
      */
     public void setAllowEmptyConstructors(boolean aAllow)
     {
         mAllowEmptyCtors = aAllow;
     }
 
     /**
      * Sets whether or not to ignore the whitespace around the
      * colon in an enhanced for loop.
      * @param aIgnore <code>true</code> to ignore enhanced for colon.
      */
     public void setIgnoreEnhancedForColon(boolean aIgnore)
     {
         mIgnoreEnhancedForColon = aIgnore;
     }
 
     @Override
     public void visitToken(DetailAST aAST)
     {
         final int type = aAST.getType();
         final int parentType = aAST.getParent().getType();
 
         // Check for CURLY in array initializer
         if (((type == TokenTypes.RCURLY) || (type == TokenTypes.LCURLY))
-            && (parentType == TokenTypes.ARRAY_INIT))
+            && ((parentType == TokenTypes.ARRAY_INIT)
+                || (parentType == TokenTypes.ANNOTATION_ARRAY_INIT)))
         {
             return;
         }
 
         // Check for import pkg.name.*;
         if ((type == TokenTypes.STAR)
             && (parentType == TokenTypes.DOT))
         {
             return;
         }
 
         // Check for an SLIST that has a parent CASE_GROUP. It is not a '{'.
         if ((type == TokenTypes.SLIST)
             && (parentType == TokenTypes.CASE_GROUP))
         {
             return;
         }
 
         if ((type == TokenTypes.COLON)) {
             //we do not want to check colon for cases and defaults
             if (parentType == TokenTypes.LITERAL_DEFAULT
                 || parentType == TokenTypes.LITERAL_CASE)
             {
                 return;
             }
             else if (parentType == TokenTypes.FOR_EACH_CLAUSE
                 && this.mIgnoreEnhancedForColon)
             {
                 return;
             }
         }
 
         // Check for allowed empty method or ctor blocks.
         if (emptyMethodBlockCheck(aAST, parentType)
             || emptyCtorBlockCheck(aAST, parentType))
         {
             return;
         }
 
         final String[] lines = getLines();
         final String line = lines[aAST.getLineNo() - 1];
         final int before = aAST.getColumnNo() - 1;
         final int after = aAST.getColumnNo() + aAST.getText().length();
 
         if ((before >= 0) && !Character.isWhitespace(line.charAt(before))) {
             log(aAST.getLineNo(), aAST.getColumnNo(),
                     "ws.notPreceded", aAST.getText());
         }
 
         if (after >= line.length()) {
