diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
index 6346fc454..2465edcab 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java
@@ -2,237 +2,283 @@
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
 
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.utils.ModuleReflectionUtils;
 
 /**
  * A factory for creating objects from package names and names.
  * Consider the below example for better understanding.
  * <ul>
  *     <li>module name - name of java class that represents module;</li>
  *     <li>module full name - fully qualifies name of java class that represents module;</li>
  *     <li>check module short name - name of Check without 'Check' suffix;</li>
  *     <li>check module name - name of java class that represents Check (with 'Check' suffix);</li>
  *     <li>
  *         check module full name - fully qualifies name of java class
  *         that represents Check (with 'Check' suffix).
  *     </li>
  * </ul>
  * @author Rick Giles
  * @author lkuehne
  */
 public class PackageObjectFactory implements ModuleFactory {
+
+    /**
+     * Enum class to define loading options.
+     */
+    public enum ModuleLoadOption {
+        /**
+         * Searching from registred checkstyle modules and from packages given in countructor.
+         **/
+        SEARCH_REGISTERED_PACKAGES,
+        /**
+         * As SEARCH_REGISTERED_PACKAGES and also try to load class from all of packages given in
+         * constructor.
+         * Required for eclipse-cs plugin.
+         **/
+        TRY_IN_ALL_REGISTERED_PACKAGES,
+    }
+
     /** Base package of checkstyle modules checks. */
     public static final String BASE_PACKAGE = "com.puppycrawl.tools.checkstyle";
 
     /** Exception message when it is unable to create a class instance. */
     public static final String UNABLE_TO_INSTANTIATE_EXCEPTION_MESSAGE =
             "PackageObjectFactory.unableToInstantiateExceptionMessage";
 
     /** Exception message when there is ambigugous module name in config file. */
     public static final String AMBIGUOUS_MODULE_NAME_EXCEPTION_MESSAGE =
             "PackageObjectFactory.ambiguousModuleNameExceptionMessage";
 
     /** Suffix of checks. */
     public static final String CHECK_SUFFIX = "Check";
 
     /** Character separate package names in qualified name of java class. */
     public static final String PACKAGE_SEPARATOR = ".";
 
     /** Exception message when null class loader is given. */
     public static final String NULL_LOADER_MESSAGE = "moduleClassLoader must not be null";
 
     /** Exception message when null package name is given. */
     public static final String NULL_PACKAGE_MESSAGE = "package name must not be null";
 
     /** Separator to use in strings. */
     public static final String STRING_SEPARATOR = ", ";
 
     /** Map of Checkstyle module names to their fully qualified names. */
     private static final Map<String, String> NAME_TO_FULL_MODULE_NAME = new HashMap<>();
 
     /** A list of package names to prepend to class names. */
     private final Set<String> packages;
 
     /** The class loader used to load Checkstyle core and custom modules. */
     private final ClassLoader moduleClassLoader;
 
     /** Map of third party Checkstyle module names to the set of their fully qualified names. */
     private Map<String, Set<String>> thirdPartyNameToFullModuleNames;
 
+    /** Module load option which defines class search type. */
+    private ModuleLoadOption moduleLoadOption;
+
     static {
         fillShortToFullModuleNamesMap();
     }
 
     /**
      * Creates a new {@code PackageObjectFactory} instance.
      * @param packageNames the list of package names to use
      * @param moduleClassLoader class loader used to load Checkstyle
      *          core and custom modules
      */
     public PackageObjectFactory(Set<String> packageNames, ClassLoader moduleClassLoader) {
+        this(packageNames, moduleClassLoader, ModuleLoadOption.SEARCH_REGISTERED_PACKAGES);
+    }
+
+    /**
+     * Creates a new {@code PackageObjectFactory} instance.
+     * @param packageNames the list of package names to use
+     * @param moduleClassLoader class loader used to load Checkstyle
+     *          core and custom modules
+     * @param moduleLoadOption loading option
+     */
+    public PackageObjectFactory(Set<String> packageNames, ClassLoader moduleClassLoader,
+            ModuleLoadOption moduleLoadOption) {
         if (moduleClassLoader == null) {
             throw new IllegalArgumentException(NULL_LOADER_MESSAGE);
         }
         if (packageNames.contains(null)) {
             throw new IllegalArgumentException(NULL_PACKAGE_MESSAGE);
         }
 
         //create a copy of the given set, but retain ordering
         packages = new LinkedHashSet<>(packageNames);
         this.moduleClassLoader = moduleClassLoader;
+        this.moduleLoadOption = moduleLoadOption;
     }
 
     /**
      * Creates a new {@code PackageObjectFactory} instance.
      * @param packageName The package name to use
      * @param moduleClassLoader class loader used to load Checkstyle
      *          core and custom modules
      */
     public PackageObjectFactory(String packageName, ClassLoader moduleClassLoader) {
         if (moduleClassLoader == null) {
             throw new IllegalArgumentException(NULL_LOADER_MESSAGE);
         }
         if (packageName == null) {
             throw new IllegalArgumentException(NULL_PACKAGE_MESSAGE);
         }
 
         packages = new LinkedHashSet<>(1);
         packages.add(packageName);
         this.moduleClassLoader = moduleClassLoader;
     }
 
     /**
      * Creates a new instance of a class from a given name, or that name
      * concatenated with &quot;Check&quot;. If the name is
      * a class name, creates an instance of the named class. Otherwise, creates
      * an instance of a class name obtained by concatenating the given name
      * to a package name from a given list of package names.
      * @param name the name of a class.
      * @return the {@code Object} created by loader.
      * @throws CheckstyleException if an error occurs.
      */
     @Override
     public Object createModule(String name) throws CheckstyleException {
         Object instance = null;
         // if the name is a simple class name, try to find it in maps at first
         if (!name.contains(PACKAGE_SEPARATOR)) {
-            // find the name in hardcode map
-            final String fullModuleName = NAME_TO_FULL_MODULE_NAME.get(name);
-            if (fullModuleName == null) {
-                final String fullCheckModuleName =
-                        NAME_TO_FULL_MODULE_NAME.get(name + CHECK_SUFFIX);
-                if (fullCheckModuleName != null) {
-                    instance = createObject(fullCheckModuleName);
-                }
-            }
-            else {
-                instance = createObject(fullModuleName);
-            }
-
+            instance = createFromStandardCheckSet(name);
             // find the name in third party map
             if (instance == null) {
                 if (thirdPartyNameToFullModuleNames == null) {
                     thirdPartyNameToFullModuleNames =
                             generateThirdPartyNameToFullModuleName(moduleClassLoader);
                 }
                 instance = createObjectFromMap(name, thirdPartyNameToFullModuleNames);
             }
         }
-
         if (instance == null) {
             instance = createObject(name);
         }
+        if (instance == null
+                && moduleLoadOption == ModuleLoadOption.TRY_IN_ALL_REGISTERED_PACKAGES) {
+            instance = createModuleByTryInEachPackage(name);
+        }
         if (instance == null) {
             String attemptedNames = null;
             if (!name.contains(PACKAGE_SEPARATOR)) {
                 final String nameCheck = name + CHECK_SUFFIX;
                 attemptedNames = joinPackageNamesWithClassName(name, packages)
                         + STRING_SEPARATOR + nameCheck + STRING_SEPARATOR
                         + joinPackageNamesWithClassName(nameCheck, packages);
             }
             final LocalizedMessage exceptionMessage = new LocalizedMessage(0,
                 Definitions.CHECKSTYLE_BUNDLE, UNABLE_TO_INSTANTIATE_EXCEPTION_MESSAGE,
                 new String[] {name, attemptedNames}, null, getClass(), null);
             throw new CheckstyleException(exceptionMessage.getMessage());
         }
         return instance;
     }
 
+    /**
+     * Create object from one of Checkstyle module names.
+     * @param name name of module.
+     * @return instance of module.
+     * @throws CheckstyleException if the class fails to instantiate or there are ambiguous classes.
+     */
+    private Object createFromStandardCheckSet(String name) throws CheckstyleException {
+        final String fullModuleName = NAME_TO_FULL_MODULE_NAME.get(name);
+        Object instance = null;
+        if (fullModuleName == null) {
+            final String fullCheckModuleName =
+                    NAME_TO_FULL_MODULE_NAME.get(name + CHECK_SUFFIX);
+            if (fullCheckModuleName != null) {
+                instance = createObject(fullCheckModuleName);
+            }
+        }
+        else {
+            instance = createObject(fullModuleName);
+        }
+        return instance;
+    }
+
     /**
      * Create object with the help of the supplied map.
      * @param name name of module.
      * @param map the supplied map.
      * @return instance of module if it is found in modules map and no ambiguous classes exist.
      * @throws CheckstyleException if the class fails to instantiate or there are ambiguous classes.
      */
     private Object createObjectFromMap(String name, Map<String, Set<String>> map)
             throws CheckstyleException {
         final Set<String> fullModuleNames = map.get(name);
         Object instance = null;
         if (fullModuleNames == null) {
             final Set<String> fullCheckModuleNames = map.get(name + CHECK_SUFFIX);
             if (fullCheckModuleNames != null) {
                 instance = createObjectFromFullModuleNames(name, fullCheckModuleNames);
             }
         }
         else {
             instance = createObjectFromFullModuleNames(name, fullModuleNames);
         }
         return instance;
     }
 
     /**
      * Create Object from optional full module names.
      * In most case, there should be only one element in {@code fullModuleName}, otherwise
      * an exception would be thrown.
      * @param name name of module
      * @param fullModuleNames the supplied full module names set
      * @return instance of module if there is only one element in {@code fullModuleName}
      * @throws CheckstyleException if the class fails to instantiate or there are more than one
      *      element in {@code fullModuleName}
      */
     private Object createObjectFromFullModuleNames(String name, Set<String> fullModuleNames)
             throws CheckstyleException {
         final Object returnValue;
         if (fullModuleNames.size() == 1) {
             returnValue = createObject(fullModuleNames.iterator().next());
         }
         else {
             final String optionalNames = fullModuleNames.stream()
                     .sorted()
                     .collect(Collectors.joining(STRING_SEPARATOR));
             final LocalizedMessage exceptionMessage = new LocalizedMessage(0,
                     Definitions.CHECKSTYLE_BUNDLE, AMBIGUOUS_MODULE_NAME_EXCEPTION_MESSAGE,
                     new String[] {name, optionalNames}, null, getClass(), null);
             throw new CheckstyleException(exceptionMessage.getMessage());
         }
         return returnValue;
     }
@@ -260,100 +306,124 @@ public class PackageObjectFactory implements ModuleFactory {
         catch (IOException ignore) {
             returnValue = new HashMap<>();
         }
         return returnValue;
     }
 
     /**
      * Creates a string by joining package names with a class name.
      * @param className name of the class for joining.
      * @param packages packages names.
      * @return a string which is obtained by joining package names with a class name.
      */
     private static String joinPackageNamesWithClassName(String className, Set<String> packages) {
         return packages.stream().collect(
             Collectors.joining(PACKAGE_SEPARATOR + className + STRING_SEPARATOR, "",
                     PACKAGE_SEPARATOR + className));
     }
 
     /**
      * Creates a new instance of a named class.
      * @param className the name of the class to instantiate.
      * @return the {@code Object} created by loader or null.
      * @throws CheckstyleException if the class fails to instantiate.
      */
     private Object createObject(String className) throws CheckstyleException {
         Class<?> clazz = null;
 
         try {
             clazz = Class.forName(className, true, moduleClassLoader);
         }
         catch (final ReflectiveOperationException | NoClassDefFoundError ignored) {
             // ignore the exception
         }
 
         Object instance = null;
 
         if (clazz != null) {
             try {
                 final Constructor<?> declaredConstructor = clazz.getDeclaredConstructor();
                 declaredConstructor.setAccessible(true);
                 instance = declaredConstructor.newInstance();
             }
             catch (final ReflectiveOperationException ex) {
                 throw new CheckstyleException("Unable to instantiate " + className, ex);
             }
         }
 
         return instance;
     }
 
+    /**
+     * Searching to class with given name (or name concatinated with &quot;Check&quot;) in existing
+     * packages. Returns instance if class found or, otherwise, null.
+     * @param name the name of a class.
+     * @return the {@code Object} created by loader.
+     * @throws CheckstyleException if an error occurs.
+     */
+    private Object createModuleByTryInEachPackage(String name) throws CheckstyleException {
+        final Set<String> possibleNames = packages.stream()
+                .map(packageName -> packageName + PACKAGE_SEPARATOR + name)
+                .collect(Collectors.toSet());
+        possibleNames.addAll(possibleNames.stream()
+                .map(possibleName -> possibleName + CHECK_SUFFIX)
+                .collect(Collectors.toSet()));
+        Object instance = null;
+        for (String possibleName : possibleNames) {
+            instance = createObject(possibleName);
+            if (instance != null) {
+                break;
+            }
+        }
+        return instance;
+    }
+
     /**
      * Fill short-to-full module names map.
      */
     private static void fillShortToFullModuleNamesMap() {
         fillChecksFromAnnotationPackage();
         fillChecksFromBlocksPackage();
         fillChecksFromCodingPackage();
         fillChecksFromDesignPackage();
         fillChecksFromHeaderPackage();
         fillChecksFromImportsPackage();
         fillChecksFromIndentationPackage();
         fillChecksFromJavadocPackage();
         fillChecksFromMetricsPackage();
         fillChecksFromModifierPackage();
         fillChecksFromNamingPackage();
         fillChecksFromRegexpPackage();
         fillChecksFromSizesPackage();
         fillChecksFromWhitespacePackage();
         fillModulesFromChecksPackage();
         fillModulesFromFilefiltersPackage();
         fillModulesFromFiltersPackage();
         fillModulesFromCheckstylePackage();
     }
 
     /**
      * Fill short-to-full module names map with Checks from annotation package.
      */
     private static void fillChecksFromAnnotationPackage() {
         NAME_TO_FULL_MODULE_NAME.put("AnnotationLocationCheck",
                 BASE_PACKAGE + ".checks.annotation.AnnotationLocationCheck");
         NAME_TO_FULL_MODULE_NAME.put("AnnotationOnSameLineCheck",
                 BASE_PACKAGE + ".checks.annotation.AnnotationOnSameLineCheck");
         NAME_TO_FULL_MODULE_NAME.put("AnnotationUseStyleCheck",
                 BASE_PACKAGE + ".checks.annotation.AnnotationUseStyleCheck");
         NAME_TO_FULL_MODULE_NAME.put("MissingDeprecatedCheck",
                 BASE_PACKAGE + ".checks.annotation.MissingDeprecatedCheck");
         NAME_TO_FULL_MODULE_NAME.put("MissingOverrideCheck",
                 BASE_PACKAGE + ".checks.annotation.MissingOverrideCheck");
         NAME_TO_FULL_MODULE_NAME.put("PackageAnnotationCheck",
                 BASE_PACKAGE + ".checks.annotation.PackageAnnotationCheck");
         NAME_TO_FULL_MODULE_NAME.put("SuppressWarningsCheck",
                 BASE_PACKAGE + ".checks.annotation.SuppressWarningsCheck");
     }
 
     /**
      * Fill short-to-full module names map with Checks from blocks package.
      */
     private static void fillChecksFromBlocksPackage() {
         NAME_TO_FULL_MODULE_NAME.put("AvoidNestedBlocksCheck",
                 BASE_PACKAGE + ".checks.blocks.AvoidNestedBlocksCheck");
@@ -722,51 +792,52 @@ public class PackageObjectFactory implements ModuleFactory {
                 BASE_PACKAGE + ".checks.TrailingCommentCheck");
         NAME_TO_FULL_MODULE_NAME.put("TranslationCheck",
                 BASE_PACKAGE + ".checks.TranslationCheck");
         NAME_TO_FULL_MODULE_NAME.put("UncommentedMainCheck",
                 BASE_PACKAGE + ".checks.UncommentedMainCheck");
         NAME_TO_FULL_MODULE_NAME.put("UniquePropertiesCheck",
                 BASE_PACKAGE + ".checks.UniquePropertiesCheck");
         NAME_TO_FULL_MODULE_NAME.put("UpperEllCheck",
                 BASE_PACKAGE + ".checks.UpperEllCheck");
     }
 
     /**
      * Fill short-to-full module names map with modules from filefilters package.
      */
     private static void fillModulesFromFilefiltersPackage() {
         NAME_TO_FULL_MODULE_NAME.put("BeforeExecutionExclusionFileFilter",
                 BASE_PACKAGE + ".filefilters.BeforeExecutionExclusionFileFilter");
     }
 
     /**
      * Fill short-to-full module names map with modules from filters package.
      */
     private static void fillModulesFromFiltersPackage() {
         NAME_TO_FULL_MODULE_NAME.put("CsvFilter",
                 BASE_PACKAGE + ".filters.CsvFilter");
         NAME_TO_FULL_MODULE_NAME.put("IntMatchFilter",
                 BASE_PACKAGE + ".filters.IntMatchFilter");
         NAME_TO_FULL_MODULE_NAME.put("IntRangeFilter",
                 BASE_PACKAGE + ".filters.IntRangeFilter");
         NAME_TO_FULL_MODULE_NAME.put("SeverityMatchFilter",
                 BASE_PACKAGE + ".filters.SeverityMatchFilter");
         NAME_TO_FULL_MODULE_NAME.put("SuppressionCommentFilter",
                 BASE_PACKAGE + ".filters.SuppressionCommentFilter");
         NAME_TO_FULL_MODULE_NAME.put("SuppressionFilter",
                 BASE_PACKAGE + ".filters.SuppressionFilter");
         NAME_TO_FULL_MODULE_NAME.put("SuppressionXpathFilter",
                 BASE_PACKAGE + ".filters.SuppressionXpathFilter");
         NAME_TO_FULL_MODULE_NAME.put("SuppressWarningsFilter",
                 BASE_PACKAGE + ".filters.SuppressWarningsFilter");
         NAME_TO_FULL_MODULE_NAME.put("SuppressWithNearbyCommentFilter",
                 BASE_PACKAGE + ".filters.SuppressWithNearbyCommentFilter");
     }
 
     /**
      * Fill short-to-full module names map with modules from checkstyle package.
      */
     private static void fillModulesFromCheckstylePackage() {
         NAME_TO_FULL_MODULE_NAME.put("Checker", BASE_PACKAGE + ".Checker");
         NAME_TO_FULL_MODULE_NAME.put("TreeWalker", BASE_PACKAGE + ".TreeWalker");
     }
+
 }
