diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
index f88554306..b0dec5fcf 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
@@ -97,148 +97,177 @@ public class GenericWhitespaceCheck extends Check {
     private int depth;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         // Reset for each tree, just incase there are errors in preceeding
         // trees.
         depth = 0;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.GENERIC_START) {
             processStart(ast);
             depth++;
         }
         else if (ast.getType() == TokenTypes.GENERIC_END) {
             processEnd(ast);
             depth--;
         }
     }
 
     /**
      * Checks the token for the end of Generics.
      * @param ast the token to check
      */
     private void processEnd(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         if (0 <= before && Character.isWhitespace(line.charAt(before))
                 && !Utils.whitespaceBefore(before, line)) {
             log(ast.getLineNo(), before, WS_PRECEDED, ">");
         }
 
         if (after < line.length()) {
 
             // Check if the last Generic, in which case must be a whitespace
             // or a '(),[.'.
             if (1 == depth) {
-                final char charAfter = line.charAt(after);
-
-                // Need to handle a number of cases. First is:
-                //    Collections.<Object>emptySet();
-                //                        ^
-                //                        +--- whitespace not allowed
-                if (ast.getParent().getType() == TokenTypes.TYPE_ARGUMENTS
-                        && ast.getParent().getParent().getType()
-                            == TokenTypes.DOT
-                        && ast.getParent().getParent().getParent().getType()
-                            == TokenTypes.METHOD_CALL
-                        || isAfterMethodReference(ast)) {
-                    if (Character.isWhitespace(charAfter)) {
-                        log(ast.getLineNo(), after, WS_FOLLOWED, ">");
-                    }
-                }
-                else if (!Character.isWhitespace(charAfter)
-                    && '(' != charAfter && ')' != charAfter
-                    && ',' != charAfter && '[' != charAfter
-                    && '.' != charAfter && ':' != charAfter
-                    && !isAfterMethodReference(ast)) {
-                    log(ast.getLineNo(), after, WS_ILLEGAL_FOLLOW, ">");
-                }
+                processSingleGeneric(ast, line, after);
             }
             else {
-                // In a nested Generic type, so can only be a '>' or ',' or '&'
+                processNestedGenerics(ast, line, after);
+            }
+        }
+    }
 
-                // In case of several extends definitions:
-                //
-                //   class IntEnumValueType<E extends Enum<E> & IntEnum>
-                //                                          ^
-                //   should be whitespace if followed by & -+
-                //
-                final int indexOfAmp = line.indexOf('&', after);
-                if (indexOfAmp != -1
-                    && whitespaceBetween(after, indexOfAmp, line)) {
-                    if (indexOfAmp - after == 0) {
-                        log(ast.getLineNo(), after, WS_NOT_PRECEDED, "&");
-                    }
-                    else if (indexOfAmp - after != 1) {
-                        log(ast.getLineNo(), after, WS_FOLLOWED, ">");
-                    }
-                }
-                else if (line.charAt(after) == ' ') {
-                    log(ast.getLineNo(), after, WS_FOLLOWED, ">");
-                }
+    /**
+     * process Nested generics
+     * @param ast token
+     * @param line line content
+     * @param after position after
+     */
+    private void processNestedGenerics(DetailAST ast, String line, int after) {
+        // In a nested Generic type, so can only be a '>' or ',' or '&'
+
+        // In case of several extends definitions:
+        //
+        //   class IntEnumValueType<E extends Enum<E> & IntEnum>
+        //                                          ^
+        //   should be whitespace if followed by & -+
+        //
+        final int indexOfAmp = line.indexOf('&', after);
+        if (indexOfAmp != -1
+            && whitespaceBetween(after, indexOfAmp, line)) {
+            if (indexOfAmp - after == 0) {
+                log(ast.getLineNo(), after, WS_NOT_PRECEDED, "&");
+            }
+            else if (indexOfAmp - after != 1) {
+                log(ast.getLineNo(), after, WS_FOLLOWED, ">");
             }
         }
+        else if (line.charAt(after) == ' ') {
+            log(ast.getLineNo(), after, WS_FOLLOWED, ">");
+        }
+    }
+
+    /**
+     * process Single-generic
+     * @param ast token
+     * @param line line content
+     * @param after position after
+     */
+    private void processSingleGeneric(DetailAST ast, String line, int after) {
+        final char charAfter = line.charAt(after);
+
+        // Need to handle a number of cases. First is:
+        //    Collections.<Object>emptySet();
+        //                        ^
+        //                        +--- whitespace not allowed
+        if (isGenericBeforeMethod(ast)) {
+            if (Character.isWhitespace(charAfter)) {
+                log(ast.getLineNo(), after, WS_FOLLOWED, ">");
+            }
+        }
+        else if (!Character.isWhitespace(charAfter)
+            && '(' != charAfter && ')' != charAfter
+            && ',' != charAfter && '[' != charAfter
+            && '.' != charAfter && ':' != charAfter
+            && !isAfterMethodReference(ast)) {
+            log(ast.getLineNo(), after, WS_ILLEGAL_FOLLOW, ">");
+        }
+    }
+
+    /**
+     * is generic before method reference
+     * @param ast ast
+     * @return true if generic before a method ref
+     */
+    private boolean isGenericBeforeMethod(DetailAST ast) {
+        return ast.getParent().getType() == TokenTypes.TYPE_ARGUMENTS
+                && ast.getParent().getParent().getType()
+                    == TokenTypes.DOT
+                && ast.getParent().getParent().getParent().getType()
+                    == TokenTypes.METHOD_CALL
+                || isAfterMethodReference(ast);
     }
 
     /**
      * Checks if current generic end ('>') is located after
      * {@link TokenTypes#METHOD_REF method reference operator}.
      * @param genericEnd {@link TokenTypes#GENERIC_END}
      * @return true if '>' follows after method reference.
      */
     private static boolean isAfterMethodReference(DetailAST genericEnd) {
         return genericEnd.getParent().getParent().getType() == TokenTypes.METHOD_REF;
     }
 
     /**
      * Checks the token for the start of Generics.
      * @param ast the token to check
      */
     private void processStart(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         // Need to handle two cases as in:
         //
         //   public static <T> Callable<T> callable(Runnable task, T result)
         //                 ^           ^
         //      ws reqd ---+           +--- whitespace NOT required
         //
         if (0 <= before) {
             // Detect if the first case
             final DetailAST parent = ast.getParent();
             final DetailAST grandparent = parent.getParent();
             if (TokenTypes.TYPE_PARAMETERS == parent.getType()
                 && (TokenTypes.CTOR_DEF == grandparent.getType()
                     || TokenTypes.METHOD_DEF == grandparent.getType())) {
                 // Require whitespace
                 if (!Character.isWhitespace(line.charAt(before))) {
                     log(ast.getLineNo(), before, WS_NOT_PRECEDED, "<");
                 }
             }
             // Whitespace not required
             else if (Character.isWhitespace(line.charAt(before))
                 && !Utils.whitespaceBefore(before, line)) {
                 log(ast.getLineNo(), before, WS_PRECEDED, "<");
             }
         }
 
         if (after < line.length()
                 && Character.isWhitespace(line.charAt(after))) {
             log(ast.getLineNo(), after, WS_FOLLOWED, "<");
         }
