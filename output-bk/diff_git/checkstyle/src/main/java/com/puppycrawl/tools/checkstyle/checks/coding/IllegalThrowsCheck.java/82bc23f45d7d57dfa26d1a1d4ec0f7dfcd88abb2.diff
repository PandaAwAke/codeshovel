diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
index e73cc6f1a..238ce48a6 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java
@@ -62,103 +62,103 @@ public final class IllegalThrowsCheck extends AbstractCheck {
     /** Methods which should be ignored. */
     private final Set<String> ignoredMethodNames =
         Arrays.stream(new String[] {"finalize", }).collect(Collectors.toSet());
 
     /** Illegal class names. */
     private final Set<String> illegalClassNames = Arrays.stream(
         new String[] {"Error", "RuntimeException", "Throwable", "java.lang.Error",
                       "java.lang.RuntimeException", "java.lang.Throwable", })
         .collect(Collectors.toSet());
 
     /** Property for ignoring overridden methods. */
     private boolean ignoreOverriddenMethods = true;
 
     /**
      * Set the list of illegal classes.
      *
      * @param classNames
      *            array of illegal exception classes
      */
     public void setIllegalClassNames(final String... classNames) {
         illegalClassNames.clear();
         for (final String name : classNames) {
             illegalClassNames.add(name);
             final int lastDot = name.lastIndexOf('.');
             if (lastDot > 0 && lastDot < name.length() - 1) {
                 final String shortName = name
                         .substring(name.lastIndexOf('.') + 1);
                 illegalClassNames.add(shortName);
             }
         }
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.LITERAL_THROWS};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.LITERAL_THROWS};
     }
 
     @Override
     public void visitToken(DetailAST detailAST) {
         final DetailAST methodDef = detailAST.getParent();
-        DetailAST token = detailAST.getFirstChild();
         // Check if the method with the given name should be ignored.
         if (!isIgnorableMethod(methodDef)) {
+            DetailAST token = detailAST.getFirstChild();
             while (token != null) {
                 if (token.getType() != TokenTypes.COMMA) {
                     final FullIdent ident = FullIdent.createFullIdent(token);
                     if (illegalClassNames.contains(ident.getText())) {
                         log(token, MSG_KEY, ident.getText());
                     }
                 }
                 token = token.getNextSibling();
             }
         }
     }
 
     /**
      * Checks if current method is ignorable due to Check's properties.
      * @param methodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
      * @return true if method is ignorable.
      */
     private boolean isIgnorableMethod(DetailAST methodDef) {
         return shouldIgnoreMethod(methodDef.findFirstToken(TokenTypes.IDENT).getText())
             || ignoreOverriddenMethods
                && (AnnotationUtility.containsAnnotation(methodDef, "Override")
                   || AnnotationUtility.containsAnnotation(methodDef, "java.lang.Override"));
     }
 
     /**
      * Check if the method is specified in the ignore method list.
      * @param name the name to check
      * @return whether the method with the passed name should be ignored
      */
     private boolean shouldIgnoreMethod(String name) {
         return ignoredMethodNames.contains(name);
     }
 
     /**
      * Set the list of ignore method names.
      * @param methodNames array of ignored method names
      */
     public void setIgnoredMethodNames(String... methodNames) {
         ignoredMethodNames.clear();
         Collections.addAll(ignoredMethodNames, methodNames);
     }
 
     /**
      * Sets <b>ignoreOverriddenMethods</b> property value.
      * @param ignoreOverriddenMethods Check's property.
      */
     public void setIgnoreOverriddenMethods(boolean ignoreOverriddenMethods) {
         this.ignoreOverriddenMethods = ignoreOverriddenMethods;
     }
 }
