diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
index 76f27b1ba..b25714499 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
@@ -1,106 +1,108 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2016 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 import java.util.SortedSet;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.puppycrawl.tools.checkstyle.api.AuditEvent;
 import com.puppycrawl.tools.checkstyle.api.AuditListener;
 import com.puppycrawl.tools.checkstyle.api.AutomaticBean;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.api.Context;
+import com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;
 import com.puppycrawl.tools.checkstyle.api.FileSetCheck;
 import com.puppycrawl.tools.checkstyle.api.FileText;
 import com.puppycrawl.tools.checkstyle.api.Filter;
 import com.puppycrawl.tools.checkstyle.api.FilterSet;
 import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
 import com.puppycrawl.tools.checkstyle.api.MessageDispatcher;
 import com.puppycrawl.tools.checkstyle.api.SeverityLevel;
 import com.puppycrawl.tools.checkstyle.api.SeverityLevelCounter;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * This class provides the functionality to check a set of files.
  * @author Oliver Burn
  * @author <a href="mailto:stephane.bailliez@wanadoo.fr">Stephane Bailliez</a>
  * @author lkuehne
+ * @author Andrei Selkin
  */
 public class Checker extends AutomaticBean implements MessageDispatcher {
     /** Logger for Checker. */
     private static final Log LOG = LogFactory.getLog(Checker.class);
 
     /** Maintains error count. */
     private final SeverityLevelCounter counter = new SeverityLevelCounter(
             SeverityLevel.ERROR);
 
     /** Vector of listeners. */
     private final List<AuditListener> listeners = Lists.newArrayList();
 
     /** Vector of fileset checks. */
     private final List<FileSetCheck> fileSetChecks = Lists.newArrayList();
 
     /** The audit event filters. */
     private final FilterSet filters = new FilterSet();
 
     /** Class loader to resolve classes with. **/
     private ClassLoader classLoader = Thread.currentThread()
             .getContextClassLoader();
 
     /** The basedir to strip off in file names. */
     private String basedir;
 
     /** Locale country to report messages . **/
     private String localeCountry = Locale.getDefault().getCountry();
     /** Locale language to report messages . **/
     private String localeLanguage = Locale.getDefault().getLanguage();
 
     /** The factory for instantiating submodules. */
     private ModuleFactory moduleFactory;
 
     /** The classloader used for loading Checkstyle module classes. */
     private ClassLoader moduleClassLoader;
 
     /** The context of all child components. */
     private Context childContext;
 
     /** The file extensions that are accepted. */
     private String[] fileExtensions = CommonUtils.EMPTY_STRING_ARRAY;
 
     /**
      * The severity level of any violations found by submodules.
      * The value of this property is passed to submodules via
      * contextualize().
      *
      * <p>Note: Since the Checker is merely a container for modules
      * it does not make sense to implement logging functionality
      * here. Consequently Checker does not extend AbstractViolationReporter,
@@ -134,124 +136,153 @@ public class Checker extends AutomaticBean implements MessageDispatcher {
     }
 
     /**
      * Removes filter.
      * @param filter filter to remove.
      */
     public void removeFilter(Filter filter) {
         filters.removeFilter(filter);
     }
 
     /** Cleans up the object. **/
     public void destroy() {
         listeners.clear();
         filters.clear();
         if (cache != null) {
             try {
                 cache.persist();
             }
             catch (IOException ex) {
                 throw new IllegalStateException("Unable to persist cache file.", ex);
             }
         }
     }
 
     /**
      * Removes a given listener.
      * @param listener a listener to remove
      */
     public void removeListener(AuditListener listener) {
         listeners.remove(listener);
     }
 
     /**
      * Sets base directory.
      * @param basedir the base directory to strip off in file names
      */
     public void setBasedir(String basedir) {
         this.basedir = basedir;
     }
 
     /**
      * Processes a set of files with all FileSetChecks.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param files the list of files to be audited.
      * @return the total number of errors found
      * @throws CheckstyleException if error condition within Checkstyle occurs
      * @see #destroy()
      */
     public int process(List<File> files) throws CheckstyleException {
+        if (cache != null) {
+            cache.putExternalResources(getExternalResourceLocations());
+        }
+
         // Prepare to start
         fireAuditStarted();
         for (final FileSetCheck fsc : fileSetChecks) {
             fsc.beginProcessing(charset);
         }
 
         processFiles(files);
 
         // Finish up
         for (final FileSetCheck fsc : fileSetChecks) {
             // It may also log!!!
             fsc.finishProcessing();
         }
 
         for (final FileSetCheck fsc : fileSetChecks) {
             // It may also log!!!
             fsc.destroy();
         }
 
         final int errorCount = counter.getCount();
         fireAuditFinished();
         return errorCount;
     }
 
+    /**
+     * Returns a set of external configuration resource locations which are used by all file set
+     * checks and filters.
+     * @return a set of external configuration resource locations which are used by all file set
+     *         checks and filters.
+     */
+    private Set<String> getExternalResourceLocations() {
+        final Set<String> externalResources = Sets.newHashSet();
+        for (FileSetCheck check : fileSetChecks) {
+            if (check instanceof ExternalResourceHolder) {
+                final Set<String> locations =
+                    ((ExternalResourceHolder) check).getExternalResourceLocations();
+                externalResources.addAll(locations);
+            }
+        }
+        for (Filter filter : filters.getFilters()) {
+            if (filter instanceof ExternalResourceHolder) {
+                final Set<String> locations =
+                    ((ExternalResourceHolder) filter).getExternalResourceLocations();
+                externalResources.addAll(locations);
+            }
+        }
+        return externalResources;
+    }
+
     /** Notify all listeners about the audit start. */
     private void fireAuditStarted() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditStarted(event);
         }
     }
 
     /** Notify all listeners about the audit end. */
     private void fireAuditFinished() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditFinished(event);
         }
     }
 
     /**
      * Processes a list of files with all FileSetChecks.
      * @param files a list of files to process.
      * @throws CheckstyleException if error condition within Checkstyle occurs.
      * @noinspection ProhibitedExceptionThrown
      */
     private void processFiles(List<File> files) throws CheckstyleException {
         for (final File file : files) {
             try {
                 final String fileName = file.getAbsolutePath();
                 final long timestamp = file.lastModified();
                 if (cache != null && cache.isInCache(fileName, timestamp)
                         || !CommonUtils.matchesFileExtension(file, fileExtensions)) {
                     continue;
                 }
                 fireFileStarted(fileName);
                 final SortedSet<LocalizedMessage> fileMessages = processFile(file);
                 fireErrors(fileName, fileMessages);
                 fireFileFinished(fileName);
                 if (cache != null && fileMessages.isEmpty()) {
                     cache.put(fileName, timestamp);
                 }
             }
             catch (Exception ex) {
                 // We need to catch all exceptions to put a reason failure (file name) in exception
                 throw new CheckstyleException("Exception was thrown while processing "
                         + file.getPath(), ex);
             }
             catch (Error error) {
                 // We need to catch all errors to put a reason failure (file name) in error
                 throw new Error("Error was thrown while processing " + file.getPath(), error);
             }
         }
     }
