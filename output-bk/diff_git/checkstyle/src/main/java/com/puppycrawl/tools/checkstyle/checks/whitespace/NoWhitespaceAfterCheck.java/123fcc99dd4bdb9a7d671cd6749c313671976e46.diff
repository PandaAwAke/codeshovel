diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
index b27bcbb63..1b80bc49c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java
@@ -216,101 +216,101 @@ public class NoWhitespaceAfterCheck extends AbstractCheck {
      *        , {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR} node.
      * @return previous node by text order.
      */
     private static DetailAST getArrayDeclaratorPreviousElement(DetailAST ast) {
         final DetailAST previousElement;
         final DetailAST firstChild = ast.getFirstChild();
         if (firstChild.getType() == TokenTypes.ARRAY_DECLARATOR) {
             // second or higher array index
             previousElement = firstChild.findFirstToken(TokenTypes.RBRACK);
         }
         else {
             // first array index, is preceded with identifier or type
             final DetailAST parent = getFirstNonArrayDeclaratorParent(ast);
             switch (parent.getType()) {
                 // generics
                 case TokenTypes.TYPE_ARGUMENT:
                     final DetailAST wildcard = parent.findFirstToken(TokenTypes.WILDCARD_TYPE);
                     if (wildcard == null) {
                         // usual generic type argument like <char[]>
                         previousElement = getTypeLastNode(ast);
                     }
                     else {
                         // constructions with wildcard like <? extends String[]>
                         previousElement = getTypeLastNode(ast.getFirstChild());
                     }
                     break;
                 // 'new' is a special case with its own subtree structure
                 case TokenTypes.LITERAL_NEW:
                     previousElement = getTypeLastNode(parent);
                     break;
                 // mundane array declaration, can be either java style or C style
                 case TokenTypes.TYPE:
                     previousElement = getPreviousNodeWithParentOfTypeAst(ast, parent);
                     break;
                 // i.e. boolean[].class
                 case TokenTypes.DOT:
                     previousElement = getTypeLastNode(ast);
                     break;
                 // java 8 method reference
                 case TokenTypes.METHOD_REF:
                     final DetailAST ident = getIdentLastToken(ast);
                     if (ident == null) {
                         //i.e. int[]::new
                         previousElement = ast.getFirstChild();
                     }
                     else {
                         previousElement = ident;
                     }
                     break;
                 default:
-                    throw new IllegalStateException("unexpected ast syntax" + parent);
+                    throw new IllegalStateException("unexpected ast syntax " + parent);
             }
         }
         return previousElement;
     }
 
     /**
      * Gets previous node for {@link TokenTypes#INDEX_OP INDEX_OP} token
      * for usage in getPositionAfter method, it is a simplified copy of
      * getArrayDeclaratorPreviousElement method.
      * @param ast
      *        , {@link TokenTypes#INDEX_OP INDEX_OP} node.
      * @return previous node by text order.
      */
     private static DetailAST getIndexOpPreviousElement(DetailAST ast) {
         final DetailAST result;
         final DetailAST firstChild = ast.getFirstChild();
         if (firstChild.getType() == TokenTypes.INDEX_OP) {
             // second or higher array index
             result = firstChild.findFirstToken(TokenTypes.RBRACK);
         }
         else {
             final DetailAST ident = getIdentLastToken(ast);
             if (ident == null) {
                 // construction like ((byte[]) pixels)[0]
                 result = ast.findFirstToken(TokenTypes.RPAREN);
             }
             else {
                 result = ident;
             }
         }
         return result;
     }
 
     /**
      * Get node that owns {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR} sequence.
      * @param ast
      *        , {@link TokenTypes#ARRAY_DECLARATOR ARRAY_DECLARATOR} node.
      * @return owner node.
      */
     private static DetailAST getFirstNonArrayDeclaratorParent(DetailAST ast) {
         DetailAST parent = ast.getParent();
         while (parent.getType() == TokenTypes.ARRAY_DECLARATOR) {
             parent = parent.getParent();
         }
         return parent;
     }
 
     /**
      * Searches parameter node for a type node.
      * Returns it or its last node if it has an extended structure.
