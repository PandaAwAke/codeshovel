diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
index 9a9e342f3..26c49fcff 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
@@ -82,171 +82,182 @@ public final class FileText extends AbstractList<String> {
      * {@code null} if the file was reconstructed from a list of lines.
      */
     private final Charset charset;
 
     /**
      * The full text contents of the file.
      */
     private final String fullText;
 
     /**
      * The lines of the file, without terminators.
      */
     private final String[] lines;
 
     /**
      * The first position of each line within the full text.
      */
     private int[] lineBreaks;
 
     /**
      * Creates a new file text representation.
      *
      * The file will be read using the specified encoding, replacing
      * malformed input and unmappable characters with the default
      * replacement character.
      *
      * @param file the name of the file
      * @param charsetName the encoding to use when reading the file
      * @throws NullPointerException if the text is null
      * @throws IOException if the file could not be read
      */
     public FileText(File file, String charsetName) throws IOException {
         this.file = file;
 
         // We use our own decoder, to be sure we have complete control
         // about replacements.
         final CharsetDecoder decoder;
         try {
             charset = Charset.forName(charsetName);
             decoder = charset.newDecoder();
             decoder.onMalformedInput(CodingErrorAction.REPLACE);
             decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
         }
         catch (final UnsupportedCharsetException ex) {
             final String message = "Unsupported charset: " + charsetName;
             final UnsupportedEncodingException ex2 = new UnsupportedEncodingException(message);
             ex2.initCause(ex);
             throw ex2;
         }
 
-        final StringBuilder buf = new StringBuilder();
-        final FileInputStream stream = new FileInputStream(file);
-        final Reader reader = new InputStreamReader(stream, decoder);
-        try {
-            final char[] chars = new char[READ_BUFFER_SIZE];
-            while (true) {
-                final int len = reader.read(chars);
-                if (len < 0) {
-                    break;
-                }
-                buf.append(chars, 0, len);
-            }
-        }
-        finally {
-            Closeables.closeQuietly(reader);
-        }
-        // buf.trimToSize(); // could be used instead of toString().
-        fullText = buf.toString();
+        fullText = readFile(file, decoder);
 
         // Use the BufferedReader to break down the lines as this
         // is about 30% faster than using the
         // LINE_TERMINATOR.split(fullText, -1) method
         final ArrayList<String> textLines = new ArrayList<>();
         final BufferedReader br =
             new BufferedReader(new StringReader(fullText));
         while (true) {
             final String line = br.readLine();
             if (line == null) {
                 break;
             }
             textLines.add(line);
         }
         lines = textLines.toArray(new String[textLines.size()]);
     }
 
     /**
      * Compatibility constructor.
      *
      * This constructor reconstructs the text of the file by joining
      * lines with linefeed characters. This process does not restore
      * the original line terminators and should therefore be avoided.
      *
      * @param file the name of the file
      * @param lines the lines of the text, without terminators
      * @throws NullPointerException if the lines array is null
      */
     private FileText(File file, List<String> lines) {
         final StringBuilder buf = new StringBuilder();
         for (final String line : lines) {
             buf.append(line).append('\n');
         }
         buf.trimToSize();
 
         this.file = file;
         charset = null;
         fullText = buf.toString();
         this.lines = lines.toArray(new String[lines.size()]);
     }
 
     /**
      * Copy constructor.
      * @param fileText to make copy of
      */
     public FileText(FileText fileText) {
         file = fileText.file;
         charset = fileText.charset;
         fullText = fileText.fullText;
         lines = fileText.lines.clone();
         lineBreaks = ArrayUtils.clone(fileText.lineBreaks);
     }
 
+    /**
+     * Reads file using specific decoder and returns all its content as a String.
+     * @param inputFile File to read
+     * @param decoder Charset decoder
+     * @return File's text
+     * @throws IOException Unable to open or read the file
+     */
+    private String readFile(final File inputFile, final CharsetDecoder decoder)
+            throws IOException {
+        final StringBuilder buf = new StringBuilder();
+        final FileInputStream stream = new FileInputStream(inputFile);
+        final Reader reader = new InputStreamReader(stream, decoder);
+        try {
+            final char[] chars = new char[READ_BUFFER_SIZE];
+            while (true) {
+                final int len = reader.read(chars);
+                if (len < 0) {
+                    break;
+                }
+                buf.append(chars, 0, len);
+            }
+        }
+        finally {
+            Closeables.closeQuietly(reader);
+        }
+        return buf.toString();
+    }
+
     /**
      * Compatibility conversion.
      *
      * This method can be used to convert the arguments passed to
      * {@link FileSetCheck#process(File,List)} to a FileText
      * object. If the list of lines already is a FileText, it is
      * returned as is. Otherwise, a new FileText is constructed by
      * joining the lines using line feed characters.
      *
      * @param file the name of the file
      * @param lines the lines of the text, without terminators
      * @return an object representing the denoted text file
      */
     public static FileText fromLines(File file, List<String> lines) {
         if (lines instanceof FileText) {
             return (FileText) lines;
         }
         else {
             return new FileText(file, lines);
         }
     }
 
     /**
      * Get the name of the file.
      * @return an object containing the name of the file
      */
     public File getFile() {
         return file;
     }
 
     /**
      * Get the character set which was used to read the file.
      * Will be {@code null} for a file reconstructed from its lines.
      * @return the charset used when the file was read
      */
     public Charset getCharset() {
         return charset;
     }
 
     /**
      * Retrieve the full text of the file.
      * @return the full text of the file
      */
     public CharSequence getFullText() {
         return fullText;
     }
 
     /**
      * Returns an array of all lines.
      * {@code text.toLinesArray()} is equivalent to
