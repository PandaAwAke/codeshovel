diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
index 00f7a758a..a30c0bdb8 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java
@@ -163,103 +163,101 @@ public final class TreeWalker
 
     @Override
     public void setupChild(Configuration childConf)
         throws CheckstyleException {
         final String name = childConf.getName();
         final Object module = moduleFactory.createModule(name);
         if (!(module instanceof Check)) {
             throw new CheckstyleException(
                 "TreeWalker is not allowed as a parent of " + name);
         }
         final Check c = (Check) module;
         c.contextualize(childContext);
         c.configure(childConf);
         c.init();
 
         registerCheck(c);
     }
 
     @Override
     protected void processFiltered(File file, List<String> lines) {
         // check if already checked and passed the file
         final String fileName = file.getPath();
         final long timestamp = file.lastModified();
         if (cache != null
                 && (cache.inCache(fileName, timestamp)
                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {
             return;
         }
 
         final String msg = "%s occurred during the analysis of file %s.";
 
         try {
             final FileText text = FileText.fromLines(file, lines);
             final FileContents contents = new FileContents(text);
             final DetailAST rootAST = TreeWalker.parse(contents);
 
             getMessageCollector().reset();
 
             walk(rootAST, contents, AstState.ORDINARY);
 
             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);
 
             walk(astWithComments, contents, AstState.WITH_COMMENTS);
         }
         catch (final TokenStreamRecognitionException tre) {
             final String exceptionMsg = String.format(msg, "TokenStreamRecognitionException",
                      fileName);
             LOG.error(exceptionMsg);
             final RecognitionException re = tre.recog;
             String message = "TokenStreamRecognitionException occured";
-            if (re != null) {
-                message = re.getMessage();
-            }
+            message = re.getMessage();
             getMessageCollector().add(createLocalizedMessage(message));
         }
         // RecognitionException and any other (need to check if needed)
         catch (Throwable ex) {
             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);
             LOG.error(exceptionMsg, ex);
             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));
         }
 
         if (cache != null && getMessageCollector().size() == 0) {
             cache.put(fileName, timestamp);
         }
     }
 
     /**
      * Creates {@link LocalizedMessage} object using default attributes.
      * @param message
      *        message that will be used for created object
      * @return instance of created object
      */
     private LocalizedMessage createLocalizedMessage(String message) {
         return new LocalizedMessage(
                 0,
                 Definitions.CHECKSTYLE_BUNDLE,
                 "general.exception",
                 new String[] {message },
                 getId(),
                 this.getClass(), null);
     }
 
     /**
      * Register a check for a given configuration.
      * @param check the check to register
      * @throws CheckstyleException if an error occurs
      */
     private void registerCheck(Check check)
         throws CheckstyleException {
         final int[] tokens;
         final Set<String> checkTokens = check.getTokenNames();
         if (!checkTokens.isEmpty()) {
             tokens = check.getRequiredTokens();
 
             //register configured tokens
             final int[] acceptableTokens = check.getAcceptableTokens();
             Arrays.sort(acceptableTokens);
             for (String token : checkTokens) {
                 final int tokenId = Utils.getTokenId(token);
                 if (Arrays.binarySearch(acceptableTokens, tokenId) >= 0) {
                     registerCheck(token, check);
                 }
