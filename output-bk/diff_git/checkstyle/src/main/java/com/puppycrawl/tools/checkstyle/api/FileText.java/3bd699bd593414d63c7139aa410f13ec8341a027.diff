diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
index 243059c1b..efc235d18 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java
@@ -104,215 +104,215 @@ public final class FileText extends AbstractList<String> {
      * The file will be read using the specified encoding, replacing
      * malformed input and unmappable characters with the default
      * replacement character.
      *
      * @param file the name of the file
      * @param charsetName the encoding to use when reading the file
      * @throws NullPointerException if the text is null
      * @throws IOException if the file could not be read
      */
     public FileText(File file, String charsetName) throws IOException {
         this.file = file;
 
         // We use our own decoder, to be sure we have complete control
         // about replacements.
         final CharsetDecoder decoder;
         try {
             charset = Charset.forName(charsetName);
             decoder = charset.newDecoder();
             decoder.onMalformedInput(CodingErrorAction.REPLACE);
             decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
         }
         catch (final UnsupportedCharsetException ex) {
             final String message = "Unsupported charset: " + charsetName;
             final UnsupportedEncodingException ex2 = new UnsupportedEncodingException(message);
             ex2.initCause(ex);
             throw ex2;
         }
 
         final StringBuilder buf = new StringBuilder();
         final FileInputStream stream = new FileInputStream(file);
         final Reader reader = new InputStreamReader(stream, decoder);
         try {
             final char[] chars = new char[READ_BUFFER_SIZE];
             while (true) {
                 final int len = reader.read(chars);
                 if (len < 0) {
                     break;
                 }
                 buf.append(chars, 0, len);
             }
         }
         finally {
             Closeables.closeQuietly(reader);
         }
         // buf.trimToSize(); // could be used instead of toString().
         fullText = buf.toString();
 
         // Use the BufferedReader to break down the lines as this
         // is about 30% faster than using the
         // LINE_TERMINATOR.split(fullText, -1) method
-        final ArrayList<String> lines = new ArrayList<>();
+        final ArrayList<String> textLines = new ArrayList<>();
         final BufferedReader br =
             new BufferedReader(new StringReader(fullText));
         while (true) {
             final String line = br.readLine();
             if (line == null) {
                 break;
             }
-            lines.add(line);
+            textLines.add(line);
         }
-        this.lines = lines.toArray(new String[lines.size()]);
+        this.lines = textLines.toArray(new String[textLines.size()]);
     }
 
     /**
      * Compatibility constructor.
      *
      * This constructor reconstructs the text of the file by joining
      * lines with linefeed characters. This process does not restore
      * the original line terminators and should therefore be avoided.
      *
      * @param file the name of the file
      * @param lines the lines of the text, without terminators
      * @throws NullPointerException if the lines array is null
      */
     private FileText(File file, List<String> lines) {
         final StringBuilder buf = new StringBuilder();
         for (final String line : lines) {
             buf.append(line).append('\n');
         }
         buf.trimToSize();
 
         this.file = file;
         charset = null;
         fullText = buf.toString();
         this.lines = lines.toArray(new String[lines.size()]);
     }
 
     /**
      * Copy constructor.
      * @param fileText to make copy of
      */
     public FileText(FileText fileText) {
         file = fileText.file;
         charset = fileText.charset;
         fullText = fileText.fullText;
         lines = fileText.lines.clone();
         lineBreaks = ArrayUtils.clone(fileText.lineBreaks);
     }
 
     /**
      * Compatibility conversion.
      *
      * This method can be used to convert the arguments passed to
      * {@link FileSetCheck#process(File,List)} to a FileText
      * object. If the list of lines already is a FileText, it is
      * returned as is. Otherwise, a new FileText is constructed by
      * joining the lines using line feed characters.
      *
      * @param file the name of the file
      * @param lines the lines of the text, without terminators
      * @return an object representing the denoted text file
      */
     public static FileText fromLines(File file, List<String> lines) {
         return lines instanceof FileText
             ? (FileText) lines
             : new FileText(file, lines);
     }
 
     /**
      * Get the name of the file.
      * @return an object containing the name of the file
      */
     public File getFile() {
         return file;
     }
 
     /**
      * Get the character set which was used to read the file.
      * Will be {@code null} for a file reconstructed from its lines.
      * @return the charset used when the file was read
      */
     public Charset getCharset() {
         return charset;
     }
 
     /**
      * Retrieve the full text of the file.
      * @return the full text of the file
      */
     public CharSequence getFullText() {
         return fullText;
     }
 
     /**
      * Returns an array of all lines.
      * {@code text.toLinesArray()} is equivalent to
      * {@code text.toArray(new String[text.size()])}.
      * @return an array of all lines of the text
      */
     public String[] toLinesArray() {
         return lines.clone();
     }
 
     /**
      * Find positions of line breaks in the full text.
      * @return an array giving the first positions of each line.
      */
     private int[] findLineBreaks() {
         if (lineBreaks == null) {
-            final int[] lineBreaks = new int[size() + 1];
-            lineBreaks[0] = 0;
+            final int[] lineBreakPositions = new int[size() + 1];
+            lineBreakPositions[0] = 0;
             int lineNo = 1;
             final Matcher matcher = LINE_TERMINATOR.matcher(fullText);
             while (matcher.find()) {
-                lineBreaks[lineNo] = matcher.end();
+                lineBreakPositions[lineNo] = matcher.end();
                 lineNo++;
             }
-            if (lineNo < lineBreaks.length) {
-                lineBreaks[lineNo] = fullText.length();
+            if (lineNo < lineBreakPositions.length) {
+                lineBreakPositions[lineNo] = fullText.length();
             }
-            this.lineBreaks = lineBreaks;
+            this.lineBreaks = lineBreakPositions;
         }
         return lineBreaks;
     }
 
     /**
      * Determine line and column numbers in full text.
      * @param pos the character position in the full text
      * @return the line and column numbers of this character
      */
     public LineColumn lineColumn(int pos) {
-        final int[] lineBreaks = findLineBreaks();
-        int lineNo = Arrays.binarySearch(lineBreaks, pos);
+        final int[] lineBreakPositions = findLineBreaks();
+        int lineNo = Arrays.binarySearch(lineBreakPositions, pos);
         if (lineNo < 0) {
             // we have: lineNo = -(insertion point) - 1
             // we want: lineNo =  (insertion point) - 1
             lineNo = -lineNo - 2;
         }
-        final int startOfLine = lineBreaks[lineNo];
+        final int startOfLine = lineBreakPositions[lineNo];
         final int columnNo = pos - startOfLine;
         // now we have lineNo and columnNo, both starting at zero.
         return new LineColumn(lineNo + 1, columnNo);
     }
 
     /**
      * Retrieves a line of the text by its number.
      * The returned line will not contain a trailing terminator.
      * @param lineNo the number of the line to get, starting at zero
      * @return the line with the given number
      */
     @Override
     public String get(final int lineNo) {
         return lines[lineNo];
     }
 
     /**
      * Counts the lines of the text.
      * @return the number of lines in the text
      */
     @Override
     public int size() {
         return lines.length;
     }
 
 }
