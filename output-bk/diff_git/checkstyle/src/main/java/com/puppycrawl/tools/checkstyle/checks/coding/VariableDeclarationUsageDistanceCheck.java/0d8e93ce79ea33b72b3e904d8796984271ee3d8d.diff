diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index 42ba85f57..ed9116ddb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -221,101 +221,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
     public void setIgnoreVariablePattern(String ignorePattern) {
         ignoreVariablePattern = CommonUtils.createPattern(ignorePattern);
     }
 
     /**
      * Sets option which allows to calculate distance between declaration of
      * variable and its first usage in different scopes.
      * @param validateBetweenScopes
      *        Defines if allow to calculate distance between declaration of
      *        variable and its first usage in different scopes or not.
      */
     public void setValidateBetweenScopes(boolean validateBetweenScopes) {
         this.validateBetweenScopes = validateBetweenScopes;
     }
 
     /**
      * Sets ignore option for variables with 'final' modifier.
      * @param ignoreFinal
      *        Defines if ignore variables with 'final' modifier or not.
      */
     public void setIgnoreFinal(boolean ignoreFinal) {
         this.ignoreFinal = ignoreFinal;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int parentType = ast.getParent().getType();
         final DetailAST modifiers = ast.getFirstChild();
 
         if (parentType != TokenTypes.OBJBLOCK
                 && (!ignoreFinal || !modifiers.branchContains(TokenTypes.FINAL))) {
             final DetailAST variable = ast.findFirstToken(TokenTypes.IDENT);
 
             if (!isVariableMatchesIgnorePattern(variable.getText())) {
                 final DetailAST semicolonAst = ast.getNextSibling();
-                Entry<DetailAST, Integer> entry;
+                final Entry<DetailAST, Integer> entry;
                 if (validateBetweenScopes) {
                     entry = calculateDistanceBetweenScopes(semicolonAst, variable);
                 }
                 else {
                     entry = calculateDistanceInSingleScope(semicolonAst, variable);
                 }
                 final DetailAST variableUsageAst = entry.getKey();
                 final int dist = entry.getValue();
                 if (dist > allowedDistance
                         && !isInitializationSequence(variableUsageAst, variable.getText())) {
                     if (ignoreFinal) {
                         log(variable.getLineNo(),
                                 MSG_KEY_EXT, variable.getText(), dist, allowedDistance);
                     }
                     else {
                         log(variable.getLineNo(),
                                 MSG_KEY, variable.getText(), dist, allowedDistance);
                     }
                 }
             }
         }
     }
 
     /**
      * Get name of instance whose method is called.
      * @param methodCallAst
      *        DetailAST of METHOD_CALL.
      * @return name of instance.
      */
     private static String getInstanceName(DetailAST methodCallAst) {
         final String methodCallName =
                 FullIdent.createFullIdentBelow(methodCallAst).getText();
         final int lastDotIndex = methodCallName.lastIndexOf('.');
         String instanceName = "";
         if (lastDotIndex != -1) {
             instanceName = methodCallName.substring(0, lastDotIndex);
         }
         return instanceName;
     }
 
     /**
      * Processes statements until usage of variable to detect sequence of
      * initialization methods.
      * @param variableUsageAst
      *        DetailAST of expression that uses variable named variableName.
      * @param variableName
      *        name of considered variable.
      * @return true if statements between declaration and usage of variable are
      *         initialization methods.
      */
@@ -525,101 +525,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
         }
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Searches variable usages starting from specified statement.
      * @param variableAst Variable that is used.
      * @param statementAst DetailAST to start searching from.
      * @return entry which contains list with found expressions that use the variable
      *     and distance from specified statement to first found expression.
      */
     private static Entry<List<DetailAST>, Integer>
         searchVariableUsageExpressions(final DetailAST variableAst, final DetailAST statementAst) {
         final List<DetailAST> variableUsageExpressions = new ArrayList<>();
         int distance = 0;
         DetailAST currentStatementAst = statementAst;
         while (currentStatementAst != null
                 && currentStatementAst.getType() != TokenTypes.RCURLY) {
             if (currentStatementAst.getFirstChild() != null) {
                 if (isChild(currentStatementAst, variableAst)) {
                     variableUsageExpressions.add(currentStatementAst);
                 }
                 // If expression doesn't contain variable and this variable
                 // hasn't been met yet, than distance + 1.
                 else if (variableUsageExpressions.isEmpty()
                         && currentStatementAst.getType() != TokenTypes.VARIABLE_DEF) {
                     distance++;
                 }
             }
             currentStatementAst = currentStatementAst.getNextSibling();
         }
         return new SimpleEntry<>(variableUsageExpressions, distance);
     }
 
     /**
      * Gets first Ast node inside FOR, WHILE or DO-WHILE blocks if variable
      * usage is met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents FOR, WHILE or DO-WHILE block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
-            DetailAST currentNode;
+            final DetailAST currentNode;
 
             // Find currentNode for DO-WHILE block.
             if (block.getType() == TokenTypes.LITERAL_DO) {
                 currentNode = block.getFirstChild();
             }
             // Find currentNode for FOR or WHILE block.
             else {
                 // Looking for RPAREN ( ')' ) token to mark the end of operator
                 // expression.
                 currentNode = block.findFirstToken(TokenTypes.RPAREN).getNextSibling();
             }
 
             final int currentNodeType = currentNode.getType();
 
             if (currentNodeType == TokenTypes.SLIST) {
                 firstNodeInsideBlock = currentNode.getFirstChild();
             }
             else if (currentNodeType != TokenTypes.EXPR) {
                 firstNodeInsideBlock = currentNode;
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside IF block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents IF block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideIfBlock(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = block.getLastChild();
             final List<DetailAST> variableUsageExpressions =
                     new ArrayList<>();
 
             while (currentNode != null
                     && currentNode.getType() == TokenTypes.LITERAL_ELSE) {
                 final DetailAST previousNode =
                         currentNode.getPreviousSibling();
 
