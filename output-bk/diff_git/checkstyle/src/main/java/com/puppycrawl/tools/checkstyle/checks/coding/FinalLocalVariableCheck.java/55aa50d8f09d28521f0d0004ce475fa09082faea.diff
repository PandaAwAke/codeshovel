diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index 64dfec2b3..47a7d7c2d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -162,316 +162,456 @@ public class FinalLocalVariableCheck extends AbstractCheck {
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.OBJBLOCK,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.PARAMETER_DEF,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.METHOD_DEF:
             case TokenTypes.CTOR_DEF:
                 scopeStack.push(new ScopeData());
                 break;
             case TokenTypes.SLIST:
                 if (ast.getParent().getType() != TokenTypes.CASE_GROUP
                     || ast.getParent().getParent().findFirstToken(TokenTypes.CASE_GROUP)
                     == ast.getParent()) {
                     storePrevScopeUninitializedVariableData();
                     scopeStack.push(new ScopeData());
                 }
                 break;
             case TokenTypes.PARAMETER_DEF:
                 if (!isInLambda(ast)
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isInAbstractOrNativeMethod(ast)
                         && !ScopeUtils.isInInterfaceBlock(ast)) {
                     insertParameter(ast);
                 }
                 break;
             case TokenTypes.VARIABLE_DEF:
                 if (ast.getParent().getType() != TokenTypes.OBJBLOCK
                         && !ast.branchContains(TokenTypes.FINAL)
                         && !isVariableInForInit(ast)
                         && shouldCheckEnhancedForLoopVariable(ast)) {
                     insertVariable(ast);
                 }
                 break;
 
             case TokenTypes.IDENT:
                 final int parentType = ast.getParent().getType();
                 if (isAssignOperator(parentType)
                         && isFirstChild(ast)) {
+                    if (isInIfBlock(ast))
+                    {
+                        markFinalVariableCandidateAsAssignInIfBlock(ast);
+                    }
+                    else if (isInElseBlock(ast))
+                    {
+                        markFinalVariableCandidateAsAssignInElseBlock(ast);
+                    }
+                    else
+                    {
+                        markFinalVariableCandidateAsAssignOutsideIfOrElseBlock(ast);
+                    }
                     removeVariable(ast);
                 }
                 break;
 
             default:
                 throw new IllegalStateException("Incorrect token type");
         }
     }
 
+    private boolean isInIfBlock(DetailAST node) {
+        boolean returnValue = false;
+        for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {
+            final int type = token.getType();
+            if (type == TokenTypes.LITERAL_IF) {
+                returnValue = true;
+                break;
+            }
+        }
+        return returnValue;
+    }
+
+    private boolean isInElseBlock(DetailAST node) {
+        boolean returnValue = false;
+        for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {
+            final int type = token.getType();
+            if (type == TokenTypes.LITERAL_ELSE) {
+                returnValue = true;
+                break;
+            }
+        }
+        return returnValue;
+    }
+
+    private void markFinalVariableCandidateAsAssignInIfBlock(DetailAST ast) {
+        final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
+        while (iterator.hasNext()) {
+            final ScopeData scopeData = iterator.next();
+            final Map<String, FinalVariableCandidate> scope = scopeData.scope;
+            DetailAST storedVariable = null;
+            final FinalVariableCandidate candidate = scope.get(ast.getText());
+            if (candidate != null) {
+                storedVariable = candidate.variableIdent;
+            }
+            if (storedVariable != null && isSameVariables(storedVariable, ast)) {
+                candidate.assignInIfBlock = true;
+                break;
+            }
+        }
+    }
+
+    private void markFinalVariableCandidateAsAssignInElseBlock(DetailAST ast) {
+        final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
+        while (iterator.hasNext()) {
+            final ScopeData scopeData = iterator.next();
+            final Map<String, FinalVariableCandidate> scope = scopeData.scope;
+            DetailAST storedVariable = null;
+            final FinalVariableCandidate candidate = scope.get(ast.getText());
+            if (candidate != null) {
+                storedVariable = candidate.variableIdent;
+            }
+            if (storedVariable != null && isSameVariables(storedVariable, ast)) {
+                candidate.assignInElseBlock = true;
+                break;
+            }
+        }
+    }
+
+    private void markFinalVariableCandidateAsAssignOutsideIfOrElseBlock(DetailAST ast) {
+        final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
+        while (iterator.hasNext()) {
+            final ScopeData scopeData = iterator.next();
+            final Map<String, FinalVariableCandidate> scope = scopeData.scope;
+            DetailAST storedVariable = null;
+            final FinalVariableCandidate candidate = scope.get(ast.getText());
+            if (candidate != null) {
+                storedVariable = candidate.variableIdent;
+            }
+            if (storedVariable != null && isSameVariables(storedVariable, ast)) {
+                candidate.assignOutsideIfOrElseBlock = true;
+                break;
+            }
+        }
+    }
+
     @Override
     public void leaveToken(DetailAST ast) {
-        Map<String, DetailAST> scope = null;
+        Map<String, FinalVariableCandidate> scope = null;
         switch (ast.getType()) {
             case TokenTypes.OBJBLOCK:
             case TokenTypes.CTOR_DEF:
             case TokenTypes.METHOD_DEF:
                 scope = scopeStack.pop().scope;
                 break;
             case TokenTypes.SLIST:
                 final Deque<DetailAST> prevScopeUnitializedVariableData =
                     prevScopeUninitializedVariables.peek();
                 if (ast.getParent().getType() != TokenTypes.CASE_GROUP
                     || findLastChildWhichContainsSpecifiedToken(ast.getParent().getParent(),
                             TokenTypes.CASE_GROUP, TokenTypes.SLIST) == ast.getParent()) {
                     scope = scopeStack.pop().scope;
                     prevScopeUninitializedVariables.pop();
                 }
                 final DetailAST parent = ast.getParent();
                 if (shouldUpdateUninitializedVariables(parent)) {
                     updateUninitializedVariables(prevScopeUnitializedVariableData);
                 }
                 break;
             default:
                 // do nothing
         }
         if (scope != null) {
-            for (DetailAST node : scope.values()) {
-                log(node.getLineNo(), node.getColumnNo(), MSG_KEY, node.getText());
+            for (FinalVariableCandidate candidate : scope.values()) {
+                DetailAST ident = candidate.variableIdent;
+                log(ident.getLineNo(), ident.getColumnNo(), MSG_KEY, ident.getText());
             }
         }
     }
 
     /**
      * Store un-initialized variables in a temporary stack for future use.
      */
     private void storePrevScopeUninitializedVariableData() {
         final ScopeData scopeData = scopeStack.peek();
         final Deque<DetailAST> prevScopeUnitializedVariableData =
                 new ArrayDeque<>();
         for (DetailAST variable : scopeData.uninitializedVariables) {
             prevScopeUnitializedVariableData.push(variable);
         }
         prevScopeUninitializedVariables.push(prevScopeUnitializedVariableData);
     }
 
     /**
      * Update current scope data uninitialized variable according to the previous scope data.
      * @param prevScopeUnitializedVariableData variable for previous stack of uninitialized
      *     variables
      */
     private void updateUninitializedVariables(Deque<DetailAST>
             prevScopeUnitializedVariableData) {
         // Check for only previous scope
         for (DetailAST variable : prevScopeUnitializedVariableData) {
             for (ScopeData scopeData : scopeStack) {
-                final DetailAST storedVariable = scopeData.scope.get(variable.getText());
+                final FinalVariableCandidate candidate = scopeData.scope.get(variable.getText());
+                DetailAST storedVariable = null;
+                if (candidate != null) {
+                    storedVariable = candidate.variableIdent;
+                }
                 if (storedVariable != null && isSameVariables(storedVariable, variable)
                         && !scopeData.uninitializedVariables.contains(storedVariable)) {
                     scopeData.uninitializedVariables.push(variable);
                 }
             }
         }
         // Check for rest of the scope
         for (Deque<DetailAST> unitializedVariableData : prevScopeUninitializedVariables) {
             for (DetailAST variable : unitializedVariableData) {
                 for (ScopeData scopeData : scopeStack) {
-                    final DetailAST storedVariable = scopeData.scope.get(variable.getText());
+                    final FinalVariableCandidate candidate = scopeData.scope.get(variable.getText());
+                    DetailAST storedVariable = null;
+                    if (candidate != null) {
+                        storedVariable = candidate.variableIdent;
+                    }
                     if (storedVariable != null
                             && isSameVariables(storedVariable, variable)
                             && !scopeData.uninitializedVariables.contains(storedVariable)) {
                         scopeData.uninitializedVariables.push(variable);
                     }
                 }
             }
         }
     }
 
     /**
      * If token is LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, or LITERAL_ELSE, then do not
      * update the uninitialized variables.
      * @param ast token to be checked
      * @return true if should be updated, else false
      */
     private boolean shouldUpdateUninitializedVariables(DetailAST ast) {
         return ast.getType() != TokenTypes.LITERAL_TRY
                 && ast.getType() != TokenTypes.LITERAL_CATCH
                 && ast.getType() != TokenTypes.LITERAL_FINALLY
                 && ast.getType() != TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * Returns the last child token that makes a specified type and contains containType in
      * its branch.
      * @param ast token to be tested
      * @param childType the token type to match
      * @param containType the token type which has to be present in the branch
      * @return the matching token, or null if no match
      */
     public DetailAST findLastChildWhichContainsSpecifiedToken(DetailAST ast, int childType,
             int containType) {
         DetailAST returnValue = null;
         for (DetailAST astIterator = ast.getFirstChild(); astIterator != null;
                 astIterator = astIterator.getNextSibling()) {
             if (astIterator.getType() == childType && astIterator.branchContains(containType)) {
                 returnValue = astIterator;
             }
         }
         return returnValue;
     }
 
     /**
      * Determines whether enhanced for-loop variable should be checked or not.
      * @param ast The ast to compare.
      * @return true if enhanced for-loop variable should be checked.
      */
     private boolean shouldCheckEnhancedForLoopVariable(DetailAST ast) {
         return validateEnhancedForLoopVariable
                 || ast.getParent().getType() != TokenTypes.FOR_EACH_CLAUSE;
     }
 
     /**
      * Insert a parameter at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertParameter(DetailAST ast) {
-        final Map<String, DetailAST> scope = scopeStack.peek().scope;
+        final Map<String, FinalVariableCandidate> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
-        scope.put(astNode.getText(), astNode);
+        scope.put(astNode.getText(), new FinalVariableCandidate(astNode));
     }
 
     /**
      * Insert a variable at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertVariable(DetailAST ast) {
-        final Map<String, DetailAST> scope = scopeStack.peek().scope;
+        final Map<String, FinalVariableCandidate> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
-        scope.put(astNode.getText(), astNode);
+        scope.put(astNode.getText(), new FinalVariableCandidate(astNode));
         if (!isInitialized(astNode)) {
             scopeStack.peek().uninitializedVariables.add(astNode);
         }
     }
 
     /**
      * Check if VARIABLE_DEF is initialized or not.
      * @param ast VARIABLE_DEF to be checked
      * @return true if initialized
      */
     private static boolean isInitialized(DetailAST ast) {
         return ast.getParent().getLastChild().getType() == TokenTypes.ASSIGN;
     }
 
     /**
      * Whether the ast is the first child of its parent.
      * @param ast the ast to check.
      * @return true if the ast is the first child of its parent.
      */
     private static boolean isFirstChild(DetailAST ast) {
         return ast.getPreviousSibling() == null;
     }
 
     /**
      * Remove the variable from the Stack.
      * @param ast Variable to remove
      */
     private void removeVariable(DetailAST ast) {
         final Iterator<ScopeData> iterator = scopeStack.descendingIterator();
         while (iterator.hasNext()) {
             final ScopeData scopeData = iterator.next();
-            final Map<String, DetailAST> scope = scopeData.scope;
-            final DetailAST storedVariable = scope.get(ast.getText());
+            final Map<String, FinalVariableCandidate> scope = scopeData.scope;
+            final FinalVariableCandidate candidate = scope.get(ast.getText());
+            DetailAST storedVariable = null;
+            if (candidate != null) {
+                storedVariable = candidate.variableIdent;
+            }
             if (storedVariable != null && isSameVariables(storedVariable, ast)) {
                 if (shouldRemoveVariable(scopeData, ast)) {
                     scope.remove(ast.getText());
                 }
                 break;
             }
         }
     }
 
     /**
      * Whether the variable should be removed from the list of final local variable
      * candidates.
      * @param scopeData the scope data of the variable.
      * @param ast the variable ast.
      * @return true, if the variable should be removed.
      */
     private static boolean shouldRemoveVariable(ScopeData scopeData, DetailAST ast) {
         boolean shouldRemove = true;
         for (DetailAST variable : scopeData.uninitializedVariables) {
             if (variable.getText().equals(ast.getText())) {
 
                 // if the variable is declared outside the loop and initialized inside
                 // the loop, then it cannot be declared final, as it can be initialized
                 // more than once in this case
                 if (isInTheSameLoop(variable, ast)
                         || !isUseOfExternalVariableInsideLoop(ast)) {
-                    shouldRemove = false;
+                    if (isAssignInIfBlock(scopeData, ast) && isAssignInElseBlock(scopeData, ast)) {
+                        shouldRemove = true;
+                    }
+                    else if (isAssignInIfBlock(scopeData, ast)
+                        && isAssignOutsideIfOrElseBlock(scopeData, ast)) {
+                        shouldRemove = true;
+                    }
+                    else {
+                        shouldRemove = false;
+                    }
                 }
+
                 scopeData.uninitializedVariables.remove(variable);
                 break;
             }
         }
         return shouldRemove;
     }
 
+    private static boolean isAssignInIfBlock(ScopeData scopeData, DetailAST ast) {
+        boolean assignInIfElseBlock = false;
+        FinalVariableCandidate candidate = scopeData.scope.get(ast.getText());
+        if (candidate != null)
+        {
+            assignInIfElseBlock = candidate.assignInIfBlock;
+        }
+        return assignInIfElseBlock;
+    }
+
+    private static boolean isAssignInElseBlock(ScopeData scopeData, DetailAST ast) {
+        boolean assignInIfElseBlock = false;
+        FinalVariableCandidate candidate = scopeData.scope.get(ast.getText());
+        if (candidate != null)
+        {
+            assignInIfElseBlock = candidate.assignInElseBlock;
+        }
+        return assignInIfElseBlock;
+    }
+
+    private static boolean isAssignOutsideIfOrElseBlock(ScopeData scopeData, DetailAST ast) {
+        boolean assignInIfElseBlock = false;
+        FinalVariableCandidate candidate = scopeData.scope.get(ast.getText());
+        if (candidate != null)
+        {
+            assignInIfElseBlock = candidate.assignOutsideIfOrElseBlock;
+        }
+        return assignInIfElseBlock;
+    }
+
     /**
      * Checks whether a variable which is declared ouside loop is used inside loop.
      * For example:
      * <p>
      * {@code
      * int x;
      * for (int i = 0, j = 0; i < j; i++) {
      *     x = 5;
      * }
      * }
      * </p>
      * @param variable variable.
      * @return true if a variable which is declared ouside loop is used inside loop.
      */
     private static boolean isUseOfExternalVariableInsideLoop(DetailAST variable) {
         boolean result = true;
         DetailAST loop2 = variable.getParent();
         while (loop2 != null
             && !isLoopAst(loop2.getType())) {
             loop2 = loop2.getParent();
         }
         return loop2 != null;
     }
 
     /**
      * Is Arithmetic operator.
      * @param parentType token AST
      * @return true is token type is in arithmetic operator
      */
     private static boolean isAssignOperator(int parentType) {
         return Arrays.binarySearch(ASSIGN_OPERATOR_TYPES, parentType) >= 0;
     }
 
     /**
      * Checks if current variable is defined in
      *  {@link TokenTypes#FOR_INIT for-loop init}, e.g.:
      * <p>
      * {@code
      * for (int i = 0, j = 0; i < j; i++) { . . . }
      * }
      * </p>
      * {@code i, j} are defined in {@link TokenTypes#FOR_INIT for-loop init}
      * @param variableDef variable definition node.
      * @return true if variable is defined in {@link TokenTypes#FOR_INIT for-loop init}
      */
     private static boolean isVariableInForInit(DetailAST variableDef) {
         return variableDef.getParent().getType() == TokenTypes.FOR_INIT;
     }
 
     /**
@@ -518,56 +658,71 @@ public class FinalLocalVariableCheck extends AbstractCheck {
         }
         return astTraverse;
     }
 
     /**
      * Check if both the Variables are same.
      * @param ast1 Variable to compare
      * @param ast2 Variable to compare
      * @return true if both the variables are same, otherwise false
      */
     private static boolean isSameVariables(DetailAST ast1, DetailAST ast2) {
         final DetailAST classOrMethodOfAst1 =
             findFirstUpperNamedBlock(ast1);
         final DetailAST classOrMethodOfAst2 =
             findFirstUpperNamedBlock(ast2);
         return classOrMethodOfAst1 == classOrMethodOfAst2;
     }
 
     /**
      * Check if both the variables are in the same loop.
      * @param ast1 variable to compare.
      * @param ast2 variable to compare.
      * @return true if both the variables are in the same loop.
      */
     private static boolean isInTheSameLoop(DetailAST ast1, DetailAST ast2) {
         DetailAST loop1 = ast1.getParent();
         while (loop1 != null && !isLoopAst(loop1.getType())) {
             loop1 = loop1.getParent();
         }
         DetailAST loop2 = ast2.getParent();
         while (loop2 != null && !isLoopAst(loop2.getType())) {
             loop2 = loop2.getParent();
         }
         return loop1 != null && loop1 == loop2;
     }
 
     /**
      * Checks whether the ast is a loop.
      * @param ast the ast to check.
      * @return true if the ast is a loop.
      */
     private static boolean isLoopAst(int ast) {
         return Arrays.binarySearch(LOOP_TYPES, ast) >= 0;
     }
 
     /**
      * Holder for the scope data.
      */
     private static class ScopeData {
         /** Contains variable definitions. */
-        private final Map<String, DetailAST> scope = new HashMap<>();
+        private final Map<String, FinalVariableCandidate> scope = new HashMap<>();
 
         /** Contains definitions of uninitialized variables. */
         private final Deque<DetailAST> uninitializedVariables = new ArrayDeque<>();
     }
+
+    private static class FinalVariableCandidate {
+
+        private DetailAST variableIdent;
+
+        private boolean assignInIfBlock;
+
+        private boolean assignInElseBlock;
+
+        private boolean assignOutsideIfOrElseBlock;
+
+        public FinalVariableCandidate(DetailAST variableIdent) {
+            this.variableIdent = variableIdent;
+        }
+    }
 }
