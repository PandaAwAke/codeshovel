diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
index cb7927668..1379d3380 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
@@ -60,272 +60,272 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * <p>
  * An example of how to configure the check to allow using escapes
  * for non-printable(control) characters:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"&gt;
  *     &lt;property name="allowEscapesForControlCharacters" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>
  * Example of using escapes with trail comment:
  * </p>
  * <pre>
  * String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"
  * </pre>
  * <p>An example of how to configure the check to allow using escapes
  * if trail comment is present:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"&gt;
  *     &lt;property name="allowByTailComment" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>Example of using escapes if literal contains only them:
  * </p>
  * <pre>
  * String unitAbbrev = "\u03bc\u03bc\u03bc";
  * </pre>
  * <p>An example of how to configure the check to allow escapes
  * if literal contains only them:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"&gt;
  *    &lt;property name="allowIfAllCharactersEscaped" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>An example of how to configure the check to allow non-printable escapes:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"&gt;
  *    &lt;property name="allowNonPrintableEscapes" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * @author maxvetrenko
  *
  */
 public class AvoidEscapedUnicodeCharactersCheck
     extends Check {
     /** Regular expression for Unicode chars */
-    private static Pattern sUnicodeRegexp = Pattern.compile("\\\\u[a-fA-F0-9]{4}");
+    private static final Pattern UNICODE_REGEXP = Pattern.compile("\\\\u[a-fA-F0-9]{4}");
 
     /** Regular expression Unicode control characters */
-    private static Pattern sUnicodeControl = Pattern.compile("\\\\(u|U)"
+    private static final Pattern UNICODE_CONTROL = Pattern.compile("\\\\(u|U)"
             + "(00[0-1][0-1A-Fa-f]|00[8-9][0-9A-Fa-f]|034(f|F)|070(f|F)"
             + "|180(e|E)|200[b-fB-F]|202[b-eB-E]|206[0-4a-fA-F]"
             + "|[fF]{3}[9a-bA-B]|[fF][eE][fF]{2})");
 
     /** Regular expression for trail comment */
-    private static Pattern sCommentRegexp = Pattern.compile(";[ ]*//+"
+    private static final Pattern COMMENT_REGEXP = Pattern.compile(";[ ]*//+"
             + "[a-zA-Z0-9 ]*|;[ ]*/[*]{1}+[a-zA-Z0-9 ]*");
 
     /** Regular expression for all escaped chars */
-    private static Pattern sAllEscapedChars =
+    private static final Pattern ALL_ESCAPED_CHARS =
             Pattern.compile("^((\\\\u)[a-fA-F0-9]{4}"
                     + "||\\\\b|\\\\t|\\\\n|\\\\f|\\\\r|\\\\|\\\"|\\\')+$");
 
     /** Regular expression for non-printable unicode chars */
-    private static Pattern sNonPrintableChars = Pattern.compile("\\\\u1680|\\\\u2028"
+    private static final Pattern NON_PRINTABLE_CHARS = Pattern.compile("\\\\u1680|\\\\u2028"
             + "|\\\\u2029|\\\\u205(f|F)|\\\\u3000|\\\\u2007|\\\\u2000|\\\\u200(a|A)"
             + "|\\\\u007(F|f)|\\\\u009(f|F)|\\\\u(f|F){4}|\\\\u007(F|f)|\\\\u00(a|A)(d|D)"
             + "|\\\\u0600|\\\\u061(c|C)|\\\\u06(d|D){2}|\\\\u070(f|F)|\\\\u1680|\\\\u180(e|E)"
             + "|\\\\u2000|\\\\u2028|\\\\u205(f|F)|\\\\u2066|\\\\u2067|\\\\u2068|\\\\u2069"
             + "|\\\\u206(a|A)|\\\\u(d|D)800|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){3}9"
             + "|\\\\u(f|F){3}(a|A)|\\\\u0020|\\\\u00(a|A)0|\\\\u00(a|A)(d|D)|\\\\u0604"
             + "|\\\\u061(c|C)|\\\\u06(d|D){2}|\\\\u070(f|F)|\\\\u1680|\\\\u180(e|E)|\\\\u200(f|F)"
             + "|\\\\u202(f|F)|\\\\u2064|\\\\u2066|\\\\u2067|\\\\u2068|\\\\u2069|\\\\u206(f|F)"
             + "|\\\\u(f|F)8(f|F){2}|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){3}9|\\\\u(f|F){3}(b|B)"
             + "|\\\\u05(d|D)0|\\\\u05(f|F)3|\\\\u0600|\\\\u0750|\\\\u0(e|E)00|\\\\u1(e|E)00"
             + "|\\\\u2100|\\\\u(f|F)(b|B)50|\\\\u(f|F)(e|E)70|\\\\u(F|f){2}61|\\\\u04(f|F)9"
             + "|\\\\u05(b|B)(e|E)|\\\\u05(e|E)(a|A)|\\\\u05(f|F)4|\\\\u06(f|F){2}"
             + "|\\\\u077(f|F)|\\\\u0(e|E)7(f|F)|\\\\u20(a|A)(f|F)|\\\\u213(a|A)|\\\\u0000"
             + "|\\\\u(f|F)(d|D)(f|F){2}|\\\\u(f|F)(e|E)(f|F){2}|\\\\u(f|F){2}(d|D)(c|C)"
             + "|\\\\u2002|\\\\u0085|\\\\u200(a|A)|\\\\u2005|\\\\u2000|\\\\u2029|\\\\u000(B|b)"
             + "|\\\\u2008|\\\\u2003|\\\\u205(f|F)|\\\\u1680|\\\\u0009|\\\\u0020|\\\\u2006"
             + "|\\\\u2001|\\\\u202(f|F)|\\\\u00(a|A)0|\\\\u000(c|C)|\\\\u2009|\\\\u2004|\\\\u2028"
             + "|\\\\u2028|\\\\u2007|\\\\u2004|\\\\u2028|\\\\u2007|\\\\u2025"
             + "|\\\\u(f|F){2}0(e|E)|\\\\u(f|F){2}61");
 
     /** Allow use escapes for non-printable(control) characters.  */
     private boolean allowEscapesForControlCharacters;
 
     /** Allow use escapes if trail comment is present*/
     private boolean allowByTailComment;
 
     /** Allow if all characters in literal are excaped*/
     private boolean allowIfAllCharactersEscaped;
 
     /** Allow escapes for space literals*/
     private boolean allowNonPrintableEscapes;
 
     /**
      * Set allowIfAllCharactersEscaped.
      * @param allow user's value.
      */
     public final void setAllowEscapesForControlCharacters(boolean allow) {
         allowEscapesForControlCharacters = allow;
     }
 
     /**
      * Set allowByTailComment.
      * @param allow user's value.
      */
     public final void setAllowByTailComment(boolean allow) {
         allowByTailComment = allow;
     }
 
     /**
      * Set allowIfAllCharactersEscaped.
      * @param allow user's value.
      */
     public final void setAllowIfAllCharactersEscaped(boolean allow) {
         allowIfAllCharactersEscaped = allow;
     }
 
     /**
      * Set allowSpaceEscapes.
      * @param allow user's value.
      */
     public final void setAllowNonPrintableEscapes(boolean allow) {
         allowNonPrintableEscapes = allow;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.STRING_LITERAL, TokenTypes.CHAR_LITERAL};
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.STRING_LITERAL, TokenTypes.CHAR_LITERAL};
     }
 
     @Override
     public void visitToken(DetailAST ast) {
 
         final String literal = ast.getText();
 
         if (hasUnicodeChar(literal) && !(allowByTailComment && hasTrailComment(ast)
                 || isAllCharactersEscaped(literal)
                 || allowEscapesForControlCharacters
-                        && isOnlyUnicodeValidChars(literal, sUnicodeControl)
+                        && isOnlyUnicodeValidChars(literal, UNICODE_CONTROL)
                 || allowNonPrintableEscapes
-                        && isOnlyUnicodeValidChars(literal, sNonPrintableChars))) {
+                        && isOnlyUnicodeValidChars(literal, NON_PRINTABLE_CHARS))) {
             log(ast.getLineNo(), "forbid.escaped.unicode.char");
         }
     }
 
     /**
      * Checks if literal has Unicode chars.
      * @param literal String literal.
      * @return true if literal has Unicode chars.
      */
     private static boolean hasUnicodeChar(String literal) {
-        return sUnicodeRegexp.matcher(literal).find();
+        return UNICODE_REGEXP.matcher(literal).find();
     }
 
     /**
      * Check if String literal contains Unicode control chars.
      * @param literal String llteral.
      * @param pattern RegExp for valid characters.
      * @return true, if String literal contains Unicode control chars.
      */
     private static boolean isOnlyUnicodeValidChars(String literal, Pattern pattern) {
         final int unicodeMatchesCounter =
-                countMatches(sUnicodeRegexp, literal);
+                countMatches(UNICODE_REGEXP, literal);
         final int unicodeValidMatchesCouter =
                 countMatches(pattern, literal);
         return unicodeMatchesCounter - unicodeValidMatchesCouter == 0;
     }
 
     /**
      * Check if trail comment is present after ast token.
      * @param ast current token.
      * @return true if trail comment is present after ast token.
      */
     private boolean hasTrailComment(DetailAST ast) {
         boolean result = false;
         final DetailAST variableDef = getVariableDef(ast);
         DetailAST semi;
 
         if (variableDef != null) {
 
             semi = variableDef.getNextSibling();
 
             if (semi.getType() != TokenTypes.SEMI) {
                 semi = variableDef.getLastChild();
             }
         }
         else {
             semi = getSemi(ast);
         }
 
         if (semi != null) {
             final int lineNo = semi.getLineNo();
             final String currentLine = getLine(lineNo - 1);
 
-            if (sCommentRegexp.matcher(currentLine).find()) {
+            if (COMMENT_REGEXP.matcher(currentLine).find()) {
                 result = true;
             }
         }
 
         return result;
     }
 
     /**
      * Count regexp matchers into String literal.
      * @param pattern pattern.
      * @param target String literal.
      * @return count of regexp matchers.
      */
     private static int countMatches(Pattern pattern, String target) {
         int matcherCounter = 0;
         final Matcher matcher = pattern.matcher(target);
         while (matcher.find()) {
             matcherCounter++;
         }
         return matcherCounter;
     }
 
     /**
      * Get variable definition.
      * @param ast current token.
      * @return variable definition.
      */
     private static DetailAST getVariableDef(DetailAST ast) {
         DetailAST result = ast.getParent();
         while (result != null
                 && result.getType() != TokenTypes.VARIABLE_DEF) {
             result = result.getParent();
         }
         return result;
     }
 
     /**
      * Get semi token.
      * @param ast current token.
      * @return semi token or null.
      */
     private static DetailAST getSemi(DetailAST ast) {
         DetailAST result = ast.getParent();
         while (result != null
                 && result.getLastChild().getType() != TokenTypes.SEMI) {
             result = result.getParent();
         }
         if (result != null) {
             result = result.getLastChild();
         }
         return result;
     }
 
     /**
      * Checks if all characters in String literal is escaped.
      * @param literal current literal.
      * @return true if all characters in String literal is escaped.
      */
     private boolean isAllCharactersEscaped(String literal) {
         return allowIfAllCharactersEscaped
-                && sAllEscapedChars.matcher(literal.substring(1,
+                && ALL_ESCAPED_CHARS.matcher(literal.substring(1,
                         literal.length() - 1)).find();
     }
 }
