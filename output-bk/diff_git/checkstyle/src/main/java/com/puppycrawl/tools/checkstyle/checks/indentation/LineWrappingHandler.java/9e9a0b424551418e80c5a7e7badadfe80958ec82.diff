diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
index e9c3958f7..7e1ff94cf 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
@@ -27,111 +27,134 @@ import java.util.TreeMap;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * This class checks line-wrapping into definitions and expressions. The
  * line-wrapping indentation should be not less then value of the
  * lineWrappingIndentation parameter.
  *
  * @author maxvetrenko
  * @author <a href="mailto:piotr.listkiewicz@gmail.com">liscju</a>
  */
 public class LineWrappingHandler {
 
     /**
      * The current instance of {@code IndentationCheck} class using this
      * handler. This field used to get access to private fields of
      * IndentationCheck instance.
      */
     private final IndentationCheck indentCheck;
 
     /**
      * Sets values of class field, finds last node and calculates indentation level.
      *
      * @param instance
      *            instance of IndentationCheck.
      */
     public LineWrappingHandler(IndentationCheck instance) {
         indentCheck = instance;
     }
 
     /**
      * Checks line wrapping into expressions and definitions using property
      * 'lineWrappingIndentation'.
      *
      * @param firstNode First node to start examining.
      * @param lastNode Last node to examine inclusively.
      */
     public void checkIndentation(DetailAST firstNode, DetailAST lastNode) {
         checkIndentation(firstNode, lastNode, indentCheck.getLineWrappingIndentation());
     }
 
     /**
      * Checks line wrapping into expressions and definitions.
      *
      * @param firstNode First node to start examining.
      * @param lastNode Last node to examine inclusively.
      * @param indentLevel Indentation all wrapped lines should use.
      */
     public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel) {
+        checkIndentation(firstNode, lastNode, indentLevel, -1, true);
+    }
+
+    /**
+     * Checks line wrapping into expressions and definitions.
+     *
+     * @param firstNode First node to start examining.
+     * @param lastNode Last node to examine inclusively.
+     * @param indentLevel Indentation all wrapped lines should use.
+     * @param startIndent Indentation first line before wrapped lines used.
+     * @param ignoreFirstLine Test if first line's indentation should be checked or not.
+     */
+    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,
+            int startIndent, boolean ignoreFirstLine) {
         final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,
                 lastNode);
 
         final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());
         if (firstLineNode.getType() == TokenTypes.AT) {
             checkAnnotationIndentation(firstLineNode, firstNodesOnLines, indentLevel);
         }
 
-        // First node should be removed because it was already checked before.
-        firstNodesOnLines.remove(firstNodesOnLines.firstKey());
-        final int firstNodeIndent = getLineStart(firstLineNode);
+        if (ignoreFirstLine) {
+            // First node should be removed because it was already checked before.
+            firstNodesOnLines.remove(firstNodesOnLines.firstKey());
+        }
+
+        final int firstNodeIndent;
+        if (startIndent == -1) {
+            firstNodeIndent = getLineStart(firstLineNode);
+        }
+        else {
+            firstNodeIndent = startIndent;
+        }
         final int currentIndent = firstNodeIndent + indentLevel;
 
         for (DetailAST node : firstNodesOnLines.values()) {
             final int currentType = node.getType();
 
             if (currentType == TokenTypes.RPAREN) {
                 logWarningMessage(node, firstNodeIndent);
             }
             else if (currentType != TokenTypes.RCURLY && currentType != TokenTypes.ARRAY_INIT) {
                 logWarningMessage(node, currentIndent);
             }
         }
     }
 
     /**
      * Finds first nodes on line and puts them into Map.
      *
      * @param firstNode First node to start examining.
      * @param lastNode Last node to examine inclusively.
      * @return NavigableMap which contains lines numbers as a key and first
      *         nodes on lines as a values.
      */
     private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,
             DetailAST lastNode) {
         final NavigableMap<Integer, DetailAST> result = new TreeMap<>();
 
         result.put(firstNode.getLineNo(), firstNode);
         DetailAST curNode = firstNode.getFirstChild();
 
         while (curNode != lastNode) {
 
             if (curNode.getType() == TokenTypes.OBJBLOCK
                     || curNode.getType() == TokenTypes.SLIST) {
                 curNode = curNode.getLastChild();
             }
 
             final DetailAST firstTokenOnLine = result.get(curNode.getLineNo());
 
             if (firstTokenOnLine == null
                 || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)) {
                 result.put(curNode.getLineNo(), curNode);
             }
             curNode = getNextCurNode(curNode);
         }
         return result;
     }
 
     /**
      * Returns next curNode node.
      *
