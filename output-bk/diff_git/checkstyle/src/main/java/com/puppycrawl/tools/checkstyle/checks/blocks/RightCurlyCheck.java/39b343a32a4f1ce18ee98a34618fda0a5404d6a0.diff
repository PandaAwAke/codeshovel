diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index 67a9ba602..e620742fb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -128,116 +128,113 @@ public class RightCurlyCheck extends AbstractCheck {
     }
 
     /**
      * Does the check need to check if right curly starts line.
      * @param flag new value of this property.
      */
     public void setShouldStartLine(boolean flag) {
         shouldStartLine = flag;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.LITERAL_TRY,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.CLASS_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.STATIC_INIT,
             TokenTypes.INSTANCE_INIT,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final Details details = getDetails(ast);
         final DetailAST rcurly = details.rcurly;
 
-        if (rcurly == null || rcurly.getType() != TokenTypes.RCURLY) {
-            // we need to have both tokens to perform the check
-            return;
-        }
-
-        final String violation;
-        if (shouldStartLine) {
-            final String targetSourceLine = getLines()[rcurly.getLineNo() - 1];
-            violation = validate(details, option, true, targetSourceLine);
-        }
-        else {
-            violation = validate(details, option, false, "");
-        }
+        if (rcurly != null && rcurly.getType() == TokenTypes.RCURLY) {
+            final String violation;
+            if (shouldStartLine) {
+                final String targetSourceLine = getLines()[rcurly.getLineNo() - 1];
+                violation = validate(details, option, true, targetSourceLine);
+            }
+            else {
+                violation = validate(details, option, false, "");
+            }
 
-        if (!violation.isEmpty()) {
-            log(rcurly, violation, "}", rcurly.getColumnNo() + 1);
+            if (!violation.isEmpty()) {
+                log(rcurly, violation, "}", rcurly.getColumnNo() + 1);
+            }
         }
     }
 
     /**
      * Does general validation.
      * @param details for validation.
      * @param bracePolicy for placing the right curly brace.
      * @param shouldStartLine do we need to check if right curly starts line.
      * @param targetSourceLine line that we need to check if shouldStartLine is true.
      * @return violation message or empty string
      *     if there was not violation during validation.
      */
     private static String validate(Details details, RightCurlyOption bracePolicy,
                                    boolean shouldStartLine, String targetSourceLine) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;
         String violation = "";
 
         if (bracePolicy == RightCurlyOption.SAME
                 && !hasLineBreakBefore(rcurly)
                 && lcurly.getLineNo() != rcurly.getLineNo()) {
             violation = MSG_KEY_LINE_BREAK_BEFORE;
         }
         else if (shouldCheckLastRcurly) {
             if (rcurly.getLineNo() == nextToken.getLineNo()) {
                 violation = MSG_KEY_LINE_ALONE;
             }
         }
         else if (shouldBeOnSameLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_SAME;
         }
         else if (shouldBeAloneOnLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_ALONE;
         }
         else if (shouldStartLine && !isOnStartOfLine(details, targetSourceLine)) {
             violation = MSG_KEY_LINE_NEW;
         }
         return violation;
     }
 
     /**
      * Checks that a right curly should be on the same line as the next statement.
      * @param bracePolicy option for placing the right curly brace
      * @param details Details for validation
      * @return true if a right curly should be alone on a line.
      */
     private static boolean shouldBeOnSameLine(RightCurlyOption bracePolicy, Details details) {
         return bracePolicy == RightCurlyOption.SAME
