diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
index e248e4752..f9927aab2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java
@@ -72,100 +72,112 @@ public final class MethodCountCheck extends Check
             else {
                 counts.put(scope, 1 + value(scope));
             }
         }
 
         /**
          * @return the value of a scope counter
          * @param scope the scope counter to get the value of
          */
         int value(Scope scope)
         {
             final Integer value = counts.get(scope);
             return (null == value) ? 0 : value;
         }
 
         /** @return the total number of methods. */
         int getTotal()
         {
             return total;
         }
     };
 
     /** default maximum number of methods */
     private static final int DEFAULT_MAX_METHODS = 100;
     /** Maximum private methods. */
     private int maxPrivate = DEFAULT_MAX_METHODS;
     /** Maximum package methods. */
     private int maxPackage = DEFAULT_MAX_METHODS;
     /** Maximum protected methods. */
     private int maxProtected = DEFAULT_MAX_METHODS;
     /** Maximum public methods. */
     private int maxPublic = DEFAULT_MAX_METHODS;
     /** Maximum total number of methods. */
     private int maxTotal = DEFAULT_MAX_METHODS;
     /** Maintains stack of counters, to support inner types. */
     private final FastStack<MethodCounter> counters =
         new FastStack<MethodCounter>();
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.CLASS_DEF,
+            TokenTypes.ENUM_CONSTANT_DEF,
+            TokenTypes.ENUM_DEF,
+            TokenTypes.INTERFACE_DEF,
+            TokenTypes.METHOD_DEF,
+        };
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         if ((TokenTypes.CLASS_DEF == ast.getType())
             || (TokenTypes.INTERFACE_DEF == ast.getType())
             || (TokenTypes.ENUM_CONSTANT_DEF == ast.getType())
             || (TokenTypes.ENUM_DEF == ast.getType()))
         {
             counters.push(new MethodCounter(
                 TokenTypes.INTERFACE_DEF == ast.getType()));
         }
         else if (TokenTypes.METHOD_DEF == ast.getType()) {
             raiseCounter(ast);
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         if ((TokenTypes.CLASS_DEF == ast.getType())
             || (TokenTypes.INTERFACE_DEF == ast.getType())
             || (TokenTypes.ENUM_CONSTANT_DEF == ast.getType())
             || (TokenTypes.ENUM_DEF == ast.getType()))
         {
             final MethodCounter counter = counters.pop();
             checkCounters(counter, ast);
         }
     }
 
     /**
      * Determine the visibility modifier and raise the corresponding counter.
      * @param method
      *            The method-subtree from the AbstractSyntaxTree.
      */
     private void raiseCounter(DetailAST method)
     {
         final MethodCounter actualCounter = counters.peek();
         final DetailAST temp = method.findFirstToken(TokenTypes.MODIFIERS);
         final Scope scope = ScopeUtils.getScopeFromMods(temp);
         actualCounter.increment(scope);
     }
 
     /**
      * Check the counters and report violations.
      * @param counter the method counters to check
      * @param ast to report errors against.
      */
     private void checkCounters(MethodCounter counter, DetailAST ast)
     {
         checkMax(maxPrivate, counter.value(Scope.PRIVATE),
