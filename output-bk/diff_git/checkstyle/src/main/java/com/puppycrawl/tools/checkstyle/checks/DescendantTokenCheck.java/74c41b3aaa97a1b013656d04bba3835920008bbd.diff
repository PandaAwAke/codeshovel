diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
index 8a8c3fd9c..a9d0f3763 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java
@@ -308,101 +308,101 @@ public class DescendantTokenCheck extends AbstractCheck {
                     String.valueOf(maximumNumber), name);
         }
     }
 
     /**
      * Counts the number of occurrences of descendant tokens.
      * @param ast the root token for descendants.
      * @param depth the maximum depth of the counted descendants.
      */
     private void countTokens(AST ast, int depth) {
         if (depth <= maximumDepth) {
             //update count
             if (depth >= minimumDepth) {
                 final int type = ast.getType();
                 if (type <= counts.length) {
                     counts[type - 1]++;
                 }
             }
             AST child = ast.getFirstChild();
             final int nextDepth = depth + 1;
             while (child != null) {
                 countTokens(child, nextDepth);
                 child = child.getNextSibling();
             }
         }
     }
 
     @Override
     public int[] getAcceptableTokens() {
         // Any tokens set by property 'tokens' are acceptable
         final Set<String> tokenNames = getTokenNames();
         final int[] result = new int[tokenNames.size()];
         int index = 0;
         for (String name : tokenNames) {
             result[index] = TokenUtils.getTokenId(name);
             index++;
         }
         return result;
     }
 
     /**
      * Sets the tokens which occurrence as descendant is limited.
      * @param limitedTokensParam - list of tokens to ignore.
      */
     public void setLimitedTokens(String... limitedTokensParam) {
         limitedTokens = new int[limitedTokensParam.length];
 
         int maxToken = 0;
         for (int i = 0; i < limitedTokensParam.length; i++) {
             limitedTokens[i] = TokenUtils.getTokenId(limitedTokensParam[i]);
-            if (limitedTokens[i] > maxToken) {
+            if (limitedTokens[i] >= maxToken + 1) {
                 maxToken = limitedTokens[i];
             }
         }
         counts = new int[maxToken];
     }
 
     /**
      * Sets the minimum depth for descendant counts.
      * @param minimumDepth the minimum depth for descendant counts.
      */
     public void setMinimumDepth(int minimumDepth) {
         this.minimumDepth = minimumDepth;
     }
 
     /**
      * Sets the maximum depth for descendant counts.
      * @param maximumDepth the maximum depth for descendant counts.
      */
     public void setMaximumDepth(int maximumDepth) {
         this.maximumDepth = maximumDepth;
     }
 
     /**
      * Sets a minimum count for descendants.
      * @param minimumNumber the minimum count for descendants.
      */
     public void setMinimumNumber(int minimumNumber) {
         this.minimumNumber = minimumNumber;
     }
 
     /**
       * Sets a maximum count for descendants.
       * @param maximumNumber the maximum count for descendants.
       */
     public void setMaximumNumber(int maximumNumber) {
         this.maximumNumber = maximumNumber;
     }
 
     /**
      * Sets the error message for minimum count not reached.
      * @param message the error message for minimum count not reached.
      *     Used as a {@code MessageFormat} pattern with arguments
      *     <ul>
      *     <li>{0} - token count</li>
      *     <li>{1} - minimum number</li>
      *     <li>{2} - name of token</li>
      *     <li>{3} - name of limited token</li>
      *     </ul>
      */
     public void setMinimumMessage(String message) {
