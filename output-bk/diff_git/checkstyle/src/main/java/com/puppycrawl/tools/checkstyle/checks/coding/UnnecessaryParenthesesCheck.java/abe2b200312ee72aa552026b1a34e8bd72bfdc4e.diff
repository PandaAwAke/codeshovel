diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index 8f839f104..c98be27a7 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -76,100 +76,129 @@ public class UnnecessaryParenthesesCheck extends Check
         TokenTypes.BAND_ASSIGN,
         TokenTypes.BOR_ASSIGN,
         TokenTypes.BSR_ASSIGN,
         TokenTypes.BXOR_ASSIGN,
         TokenTypes.DIV_ASSIGN,
         TokenTypes.MINUS_ASSIGN,
         TokenTypes.MOD_ASSIGN,
         TokenTypes.PLUS_ASSIGN,
         TokenTypes.SL_ASSIGN,
         TokenTypes.SR_ASSIGN,
         TokenTypes.STAR_ASSIGN,
     };
 
     /**
      * Used to test if logging a warning in a parent node may be skipped
      * because a warning was already logged on an immediate child node.
      */
     private DetailAST parentToSkip;
     /** Depth of nested assignments.  Normally this will be 0 or 1. */
     private int assignDepth;
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {
             TokenTypes.EXPR,
             TokenTypes.IDENT,
             TokenTypes.NUM_DOUBLE,
             TokenTypes.NUM_FLOAT,
             TokenTypes.NUM_INT,
             TokenTypes.NUM_LONG,
             TokenTypes.STRING_LITERAL,
             TokenTypes.LITERAL_NULL,
             TokenTypes.LITERAL_FALSE,
             TokenTypes.LITERAL_TRUE,
             TokenTypes.ASSIGN,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.MINUS_ASSIGN,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.SL_ASSIGN,
             TokenTypes.SR_ASSIGN,
             TokenTypes.STAR_ASSIGN,
         };
     }
 
+    @Override
+    public int[] getAcceptableTokens()
+    {
+        return new int[] {
+            TokenTypes.EXPR,
+            TokenTypes.IDENT,
+            TokenTypes.NUM_DOUBLE,
+            TokenTypes.NUM_FLOAT,
+            TokenTypes.NUM_INT,
+            TokenTypes.NUM_LONG,
+            TokenTypes.STRING_LITERAL,
+            TokenTypes.LITERAL_NULL,
+            TokenTypes.LITERAL_FALSE,
+            TokenTypes.LITERAL_TRUE,
+            TokenTypes.ASSIGN,
+            TokenTypes.BAND_ASSIGN,
+            TokenTypes.BOR_ASSIGN,
+            TokenTypes.BSR_ASSIGN,
+            TokenTypes.BXOR_ASSIGN,
+            TokenTypes.DIV_ASSIGN,
+            TokenTypes.MINUS_ASSIGN,
+            TokenTypes.MOD_ASSIGN,
+            TokenTypes.PLUS_ASSIGN,
+            TokenTypes.SL_ASSIGN,
+            TokenTypes.SR_ASSIGN,
+            TokenTypes.STAR_ASSIGN,
+        };
+    }
+
     @Override
     public void visitToken(DetailAST ast)
     {
         final int type = ast.getType();
         final boolean surrounded = isSurrounded(ast);
         final DetailAST parent = ast.getParent();
 
         if ((type == TokenTypes.ASSIGN)
             && (parent.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR))
         {
             // shouldn't process assign in annotation pairs
             return;
         }
 
         // An identifier surrounded by parentheses.
         if (surrounded && (type == TokenTypes.IDENT)) {
             parentToSkip = ast.getParent();
             log(ast, "unnecessary.paren.ident", ast.getText());
             return;
         }
 
         // A literal (numeric or string) surrounded by parentheses.
         if (surrounded && inTokenList(type, LITERALS)) {
             parentToSkip = ast.getParent();
             if (type == TokenTypes.STRING_LITERAL) {
                 log(ast, "unnecessary.paren.string",
                     chopString(ast.getText()));
             }
             else {
                 log(ast, "unnecessary.paren.literal", ast.getText());
             }
             return;
         }
 
         // The rhs of an assignment surrounded by parentheses.
         if (inTokenList(type, ASSIGNMENTS)) {
             assignDepth++;
             final DetailAST last = ast.getLastChild();
             if (last.getType() == TokenTypes.RPAREN) {
                 log(ast, "unnecessary.paren.assign");
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast)
     {
         final int type = ast.getType();
         final DetailAST parent = ast.getParent();
 
