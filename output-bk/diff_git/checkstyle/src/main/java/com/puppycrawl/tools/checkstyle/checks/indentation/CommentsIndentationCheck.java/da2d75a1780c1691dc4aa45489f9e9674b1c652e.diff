diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index 04bb27c18..9d6cb6ef0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -119,119 +119,119 @@ public class CommentsIndentationCheck extends Check {
                 final String exceptionMsg = "Unexpected token type: " + commentAst.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks single line comment indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * // some comment - this is ok
      * double d = 3.14;
      *     // some comment - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param singleLineComment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      */
     private void visitSingleLineComment(DetailAST singleLineComment) {
         final DetailAST prevStmt = getPreviousStatementOfSingleLineComment(singleLineComment);
         final DetailAST nextStmt = singleLineComment.getNextSibling();
 
         if (!isTrailingSingleLineComment(singleLineComment)) {
             if (isInEmptyCaseBlock(prevStmt, nextStmt)) {
                 handleSingleLineCommentInEmptyCaseBlock(prevStmt, singleLineComment,
                     nextStmt);
             }
             else if (isFallThroughSingleLineComment(prevStmt, nextStmt)) {
                 handleFallThroughtSingleLineComment(prevStmt, singleLineComment,
                     nextStmt);
             }
             else if (isInEmptyCodeBlock(prevStmt, nextStmt)) {
                 handleSingleLineCommentInEmptyCodeBlock(singleLineComment, nextStmt);
             }
             else if (isSingleLineCommentAtTheEndOfTheCodeBlock(nextStmt)) {
                 handleSIngleLineCommentAtTheEndOfTheCodeBlock(prevStmt, singleLineComment,
                     nextStmt);
             }
             else if (nextStmt != null
                         && !areSameLevelIndented(singleLineComment, nextStmt, nextStmt)) {
                 log(singleLineComment.getLineNo(), MSG_KEY_SINGLE, nextStmt.getLineNo(),
                     singleLineComment.getColumnNo(), nextStmt.getColumnNo());
             }
         }
     }
 
     /**
      * Returns the previous statement of a single line comment.
      * @param comment single line comment.
      * @return the previous statement of a single line comment.
      */
-    private DetailAST getPreviousStatementOfSingleLineComment(DetailAST comment) {
+    private static DetailAST getPreviousStatementOfSingleLineComment(DetailAST comment) {
         final DetailAST prevStatement;
         if (isDistributedPreviousStatement(comment)) {
             prevStatement = getDistributedPreviousStatementOfSingleLineComment(comment);
         }
         else {
             prevStatement = getOneLinePreviousStatementOfSingleLineComment(comment);
         }
         return prevStatement;
     }
 
     /**
      * Checks whether the previous statement of a single line comment is distributed over two or
      * more lines.
      * @param singleLineComment single line comment.
      * @return true if the previous statement of a single line comment is distributed over two or
      *         more lines.
      */
-    private boolean isDistributedPreviousStatement(DetailAST singleLineComment) {
+    private static boolean isDistributedPreviousStatement(DetailAST singleLineComment) {
         final DetailAST previousSibling = singleLineComment.getPreviousSibling();
         return isDistributedMethodChainOrConcatenationStatement(singleLineComment, previousSibling)
             || isDistributedReturnStatement(previousSibling)
             || isDistributedThrowStatement(previousSibling);
     }
 
     /**
      * Checks whether the previous statement of a single line comment is a method call chain or
      * string concatenation statemen distributed over two ore more lines.
      * @param comment single line comment.
      * @param commentPreviousSibling previous sibling of the sinle line comment.
      * @return if the previous statement of a single line comment is a method call chain or
      *         string concatenation statemen distributed over two ore more lines.
      */
     private static boolean isDistributedMethodChainOrConcatenationStatement(
         DetailAST comment, DetailAST commentPreviousSibling) {
         boolean destributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.SEMI
                 && comment.getLineNo() - commentPreviousSibling.getLineNo() == 1) {
             DetailAST currentToken = commentPreviousSibling.getPreviousSibling();
             while (currentToken.getFirstChild() != null) {
                 currentToken = currentToken.getFirstChild();
             }
             if (currentToken.getType() != TokenTypes.COMMENT_CONTENT
                     && commentPreviousSibling.getLineNo() != currentToken.getLineNo()) {
                 destributed = true;
             }
         }
         return destributed;
     }
 
     /**
      * Checks whether the previous statement of a single line comment is a destributed return
      * statement.
      * @param commentPreviousSibling previous sibling of the single line comment.
      * @return true if the previous statement of a single line comment is a destributed return
      *         statement.
      */
     private static boolean isDistributedReturnStatement(DetailAST commentPreviousSibling) {
         boolean destributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.LITERAL_RETURN) {
             final DetailAST firstChild = commentPreviousSibling.getFirstChild();
             final DetailAST nextSibling = firstChild.getNextSibling();
             if (nextSibling != null) {
                 destributed = true;
             }
         }
         return  destributed;
@@ -276,121 +276,121 @@ public class CommentsIndentationCheck extends Check {
         return previousStatement;
     }
 
     /**
      * Checks whether case block is empty.
      * @param nextStmt previous statement.
      * @param prevStmt next statement.
      * @return true if case block is empty.
      */
     private static boolean isInEmptyCaseBlock(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && (prevStmt.getType() == TokenTypes.LITERAL_CASE
                 || prevStmt.getType() == TokenTypes.CASE_GROUP)
             && (nextStmt.getType() == TokenTypes.LITERAL_CASE
                 || nextStmt.getType() == TokenTypes.LITERAL_DEFAULT);
     }
 
     /**
      * Checks whether single line comment is a 'fall through' comment.
      * For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *        // fall through
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if a single line comment is a 'fall through' comment.
      */
     private static boolean isFallThroughSingleLineComment(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && prevStmt.getType() != TokenTypes.LITERAL_CASE
             && nextStmt != null
             && (nextStmt.getType() == TokenTypes.LITERAL_CASE
                 || nextStmt.getType() == TokenTypes.LITERAL_DEFAULT);
     }
 
     /**
      * Checks whether a single line comment is placed at the end of the code block.
      * @param nextStmt next statement.
      * @return true if a single line comment is placed at the end of the block.
      */
-    private boolean isSingleLineCommentAtTheEndOfTheCodeBlock(DetailAST nextStmt) {
+    private static boolean isSingleLineCommentAtTheEndOfTheCodeBlock(DetailAST nextStmt) {
         return nextStmt != null
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Checks whether comment is placed in the empty code block.
      * For example:
      * <p>
      * ...
      * {@code
      *  // empty code block
      * }
      * ...
      * </p>
      * Note, the method does not treat empty case blocks.
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if comment is placed in the empty code block.
      */
-    private boolean isInEmptyCodeBlock(DetailAST prevStmt, DetailAST nextStmt) {
+    private static boolean isInEmptyCodeBlock(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && (prevStmt.getType() == TokenTypes.SLIST
                 || prevStmt.getType() == TokenTypes.OBJBLOCK)
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Handles a single line comment which is plased within empty case block.
      * Note, if comment is placed at the end of the empty case block, we have Checkstyle's
      * limitations to clearly detect user intention of explanation target - above or below. The
      * only case we can assume as a violation is when a single line comment within the empty case
      * block has indentation level that is lower than the indentation level of the next case
      * token. For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      * // violation
      *    case OPTION_TWO:
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment single line comment.
      * @param nextStmt next statement.
      */
     private void handleSingleLineCommentInEmptyCaseBlock(DetailAST prevStmt, DetailAST comment,
                                                          DetailAST nextStmt) {
 
         if (comment.getColumnNo() < prevStmt.getColumnNo()
                 || comment.getColumnNo() < nextStmt.getColumnNo()) {
             logMultilineIndentation(prevStmt, comment, nextStmt);
         }
     }
 
     /**
      * Handles 'fall through' single line comment.
      * Note, 'fall through' and similar comments can have indentation level as next or previous
      * statement.
      * For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *        // fall through - OK
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
