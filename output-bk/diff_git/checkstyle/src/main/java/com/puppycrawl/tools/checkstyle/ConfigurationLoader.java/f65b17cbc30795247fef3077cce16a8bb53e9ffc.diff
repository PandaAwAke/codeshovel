diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java b/src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java
index 9084a77d5..ec1a71b27 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java
@@ -184,108 +184,108 @@ public final class ConfigurationLoader {
                 omitIgnoredModules);
     }
 
     /**
      * Returns the module configurations from a specified input stream.
      * Note that clients are required to close the given stream by themselves
      *
      * @param configStream the input stream to the Checkstyle configuration
      * @param overridePropsResolver overriding properties
      * @param omitIgnoredModules {@code true} if modules with severity
      *            'ignore' should be omitted, {@code false} otherwise
      * @return the check configurations
      * @throws CheckstyleException if an error occurs
      *
      * @deprecated As this method does not provide a valid system ID,
      *     preventing resolution of external entities, a
      *     {@link #loadConfiguration(InputSource,PropertyResolver,boolean)
      *          version using an InputSource}
      *     should be used instead
      */
     @Deprecated
     public static Configuration loadConfiguration(InputStream configStream,
         PropertyResolver overridePropsResolver, boolean omitIgnoredModules)
         throws CheckstyleException {
         return loadConfiguration(new InputSource(configStream),
                                  overridePropsResolver, omitIgnoredModules);
     }
 
     /**
      * Returns the module configurations from a specified input source.
      * Note that if the source does wrap an open byte or character
      * stream, clients are required to close that stream by themselves
      *
      * @param configSource the input stream to the Checkstyle configuration
      * @param overridePropsResolver overriding properties
      * @param omitIgnoredModules {@code true} if modules with severity
      *            'ignore' should be omitted, {@code false} otherwise
      * @return the check configurations
      * @throws CheckstyleException if an error occurs
      */
     public static Configuration loadConfiguration(InputSource configSource,
             PropertyResolver overridePropsResolver, boolean omitIgnoredModules)
         throws CheckstyleException {
         try {
             final ConfigurationLoader loader =
                 new ConfigurationLoader(overridePropsResolver,
                                         omitIgnoredModules);
             loader.parseInputSource(configSource);
             return loader.configuration;
         }
-        catch (final SAXParseException e) {
+        catch (final SAXParseException ex) {
             final String message = String.format(Locale.ROOT, "%s - %s:%s:%s",
                     UNABLE_TO_PARSE_EXCEPTION_PREFIX,
-                    e.getMessage(), e.getLineNumber(), e.getColumnNumber());
-            throw new CheckstyleException(message, e);
+                    ex.getMessage(), ex.getLineNumber(), ex.getColumnNumber());
+            throw new CheckstyleException(message, ex);
         }
-        catch (final ParserConfigurationException | IOException | SAXException e) {
-            throw new CheckstyleException(UNABLE_TO_PARSE_EXCEPTION_PREFIX, e);
+        catch (final ParserConfigurationException | IOException | SAXException ex) {
+            throw new CheckstyleException(UNABLE_TO_PARSE_EXCEPTION_PREFIX, ex);
         }
     }
 
     /**
      * Replaces {@code ${xxx}} style constructions in the given value
      * with the string value of the corresponding data types.
      *
      * <p>The method is package visible to facilitate testing.
      *
      * <p>Code copied from ant -
      * http://cvs.apache.org/viewcvs/jakarta-ant/src/main/org/apache/tools/ant/ProjectHelper.java
      *
      * @param value The string to be scanned for property references.
      *              May be {@code null}, in which case this
      *              method returns immediately with no effect.
      * @param props Mapping (String to String) of property names to their
      *              values. Must not be {@code null}.
      * @param defaultValue default to use if one of the properties in value
      *              cannot be resolved from props.
      *
      * @return the original string with the properties replaced, or
      *         {@code null} if the original string is {@code null}.
      * @throws CheckstyleException if the string contains an opening
      *                           {@code ${} without a closing
      *                           {@code }}
      */
     @VisibleForTesting
     static String replaceProperties(
             String value, PropertyResolver props, String defaultValue)
         throws CheckstyleException {
         if (value == null) {
             return null;
         }
 
         final List<String> fragments = Lists.newArrayList();
         final List<String> propertyRefs = Lists.newArrayList();
         parsePropertyString(value, fragments, propertyRefs);
 
         final StringBuilder sb = new StringBuilder();
         final Iterator<String> fragmentsIterator = fragments.iterator();
         final Iterator<String> propertyRefsIterator = propertyRefs.iterator();
         while (fragmentsIterator.hasNext()) {
             String fragment = fragmentsIterator.next();
             if (fragment == null) {
                 final String propertyName = propertyRefsIterator.next();
                 fragment = props.resolve(propertyName);
                 if (fragment == null) {
                     if (defaultValue != null) {
                         return defaultValue;
                     }
@@ -435,68 +435,68 @@ public final class ConfigurationLoader {
             }
             else if (qName.equals(PROPERTY)) {
                 //extract value and name
                 final String value;
                 try {
                     value = replaceProperties(attributes.getValue(VALUE),
                         overridePropsResolver, attributes.getValue(DEFAULT));
                 }
                 catch (final CheckstyleException ex) {
                     throw new SAXException(ex);
                 }
                 final String name = attributes.getValue(NAME);
 
                 //add to attributes of configuration
                 final DefaultConfiguration top =
                     configStack.peek();
                 top.addAttribute(name, value);
             }
             else if (qName.equals(MESSAGE)) {
                 //extract key and value
                 final String key = attributes.getValue(KEY);
                 final String value = attributes.getValue(VALUE);
 
                 //add to messages of configuration
                 final DefaultConfiguration top = configStack.peek();
                 top.addMessage(key, value);
             }
             else {
                 if (!qName.equals(METADATA)) {
                     throw new IllegalStateException("Unknown name:" + qName + ".");
                 }
             }
         }
 
         @Override
         public void endElement(String uri,
                                String localName,
                                String qName) {
             if (qName.equals(MODULE)) {
 
                 final Configuration recentModule =
                     configStack.pop();
 
                 // remove modules with severity ignore if these modules should
                 // be omitted
                 SeverityLevel level = null;
                 try {
                     final String severity = recentModule.getAttribute(SEVERITY);
                     level = SeverityLevel.getInstance(severity);
                 }
-                catch (final CheckstyleException e) {
-                    LOG.debug("Severity not set, ignoring exception", e);
+                catch (final CheckstyleException ex) {
+                    LOG.debug("Severity not set, ignoring exception", ex);
                 }
 
                 // omit this module if these should be omitted and the module
                 // has the severity 'ignore'
                 final boolean omitModule = omitIgnoredModules
                     && level == SeverityLevel.IGNORE;
 
                 if (omitModule && !configStack.isEmpty()) {
                     final DefaultConfiguration parentModule =
                         configStack.peek();
                     parentModule.removeChild(recentModule);
                 }
             }
         }
     }
 }
