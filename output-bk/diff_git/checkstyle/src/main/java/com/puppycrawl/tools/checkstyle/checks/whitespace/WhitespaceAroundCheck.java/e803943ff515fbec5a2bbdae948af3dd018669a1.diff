diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index f5972820b..130a54901 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -461,112 +461,115 @@ public class WhitespaceAroundCheck extends AbstractCheck {
                     && ast.getFirstChild().getType() == TokenTypes.SEMI)
                 && ast.getType() != TokenTypes.ARRAY_INIT
                 && !isAnonymousInnerClassEnd(ast.getType(), nextChar)
                 && !isPartOfDoubleBraceInitializerForNextToken(ast);
     }
 
     /**
      * Check for "})" or "};" or "},". Happens with anon-inners
      * @param currentType token
      * @param nextChar next symbol
      * @return true is that is end of anon inner class
      */
     private static boolean isAnonymousInnerClassEnd(int currentType, char nextChar) {
         return currentType == TokenTypes.RCURLY
                 && (nextChar == ')'
                         || nextChar == ';'
                         || nextChar == ','
                         || nextChar == '.');
     }
 
     /**
      * Is empty block.
      * @param ast ast
      * @param parentType parent
      * @return true is block is empty
      */
     private boolean isEmptyBlock(DetailAST ast, int parentType) {
         return isEmptyMethodBlock(ast, parentType)
                 || isEmptyCtorBlock(ast, parentType)
                 || isEmptyLoop(ast, parentType)
                 || isEmptyLambda(ast, parentType)
                 || isEmptyCatch(ast, parentType);
     }
 
     /**
      * Tests if a given {@code DetailAST} is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * </p>
      * In the above, the method body is an empty block ("{}").
      *
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @param match the parent token type we're looking to match.
      * @return {@code true} if {@code ast} makes up part of an
      *         empty block contained under a {@code match} token type
      *         node.
      */
     private static boolean isEmptyBlock(DetailAST ast, int parentType, int match) {
+        final boolean result;
         final int type = ast.getType();
         if (type == TokenTypes.RCURLY) {
             final DetailAST parent = ast.getParent();
             final DetailAST grandParent = ast.getParent().getParent();
-            return parentType == TokenTypes.SLIST
+            result = parentType == TokenTypes.SLIST
                     && parent.getFirstChild().getType() == TokenTypes.RCURLY
                     && grandParent.getType() == match;
         }
-
-        return type == TokenTypes.SLIST
+        else {
+            result = type == TokenTypes.SLIST
                 && parentType == match
                 && ast.getFirstChild().getType() == TokenTypes.RCURLY;
+        }
+        return result;
     }
 
     /**
      * Whether colon belongs to cases or defaults.
      * @param currentType current
      * @param parentType parent
      * @return true if current token in colon of case or default tokens
      */
     private static boolean isColonOfCaseOrDefault(int currentType, int parentType) {
         return currentType == TokenTypes.COLON
                 && (parentType == TokenTypes.LITERAL_DEFAULT
                         || parentType == TokenTypes.LITERAL_CASE);
     }
 
     /**
      * Whether colon belongs to for-each.
      * @param currentType current
      * @param parentType parent
      * @return true if current token in colon of for-each token
      */
     private boolean isColonOfForEach(int currentType, int parentType) {
         return currentType == TokenTypes.COLON
                 && parentType == TokenTypes.FOR_EACH_CLAUSE
                 && ignoreEnhancedForColon;
     }
 
     /**
      * Is array initialization.
      * @param currentType current token
      * @param parentType parent token
      * @return true is current token inside array initialization
      */
     private static boolean isArrayInitialization(int currentType, int parentType) {
         return (currentType == TokenTypes.RCURLY || currentType == TokenTypes.LCURLY)
                 && (parentType == TokenTypes.ARRAY_INIT
                         || parentType == TokenTypes.ANNOTATION_ARRAY_INIT);
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an allowed empty
      * method block.
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty method block.
      */
     private boolean isEmptyMethodBlock(DetailAST ast, int parentType) {
         return allowEmptyMethods
                 && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
