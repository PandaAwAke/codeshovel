diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
index dc2b3dda3..9d696463d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/Checker.java
@@ -247,136 +247,152 @@ public class Checker extends AutomaticBean implements MessageDispatcher {
     public final void addListener(AuditListener listener) {
         listeners.add(listener);
     }
 
     /**
      * Removes a given listener.
      * @param listener a listener to remove
      */
     public void removeListener(AuditListener listener) {
         listeners.remove(listener);
     }
 
     /**
      * Processes a set of files with all FileSetChecks.
      * Once this is done, it is highly recommended to call for
      * the destroy method to close and remove the listeners.
      * @param files the list of files to be audited.
      * @return the total number of errors found
      * @throws CheckstyleException if error condition within Checkstyle occurs
      * @see #destroy()
      */
     public int process(List<File> files) throws CheckstyleException {
         // Prepare to start
         fireAuditStarted();
         for (final FileSetCheck fsc : fileSetChecks) {
             fsc.beginProcessing(charset);
         }
 
         processFiles(files);
 
         // Finish up
         for (final FileSetCheck fsc : fileSetChecks) {
             // It may also log!!!
             fsc.finishProcessing();
         }
 
         for (final FileSetCheck fsc : fileSetChecks) {
             // It may also log!!!
             fsc.destroy();
         }
 
         final int errorCount = counter.getCount();
         fireAuditFinished();
         return errorCount;
     }
 
     /**
      * Processes a list of files with all FileSetChecks.
      * @param files a list of files to process.
      * @throws CheckstyleException if error condition within Checkstyle occurs.
+     * @noinspection ProhibitedExceptionThrown
      */
     private void processFiles(List<File> files) throws CheckstyleException {
         for (final File file : files) {
             try {
                 final String fileName = file.getAbsolutePath();
                 fireFileStarted(fileName);
                 final long timestamp = file.lastModified();
                 if (cache != null && cache.isInCache(fileName, timestamp)
-                    || !CommonUtils.matchesFileExtension(file, fileExtensions)) {
+                        || !CommonUtils.matchesFileExtension(file, fileExtensions)) {
                     continue;
                 }
-                final SortedSet<LocalizedMessage> fileMessages = Sets.newTreeSet();
-                try {
-                    final FileText theText = new FileText(file.getAbsoluteFile(), charset);
-                    for (final FileSetCheck fsc : fileSetChecks) {
-                        fileMessages.addAll(fsc.process(file, theText));
-                    }
-                }
-                catch (final IOException ioe) {
-                    LOG.debug("IOException occurred.", ioe);
-                    fileMessages.add(new LocalizedMessage(0,
-                        Definitions.CHECKSTYLE_BUNDLE, "general.exception",
-                        new String[] {ioe.getMessage()}, null, getClass(), null));
-                }
+                final SortedSet<LocalizedMessage> fileMessages = processFile(file);
                 fireErrors(fileName, fileMessages);
                 fireFileFinished(fileName);
                 if (cache != null && fileMessages.isEmpty()) {
                     cache.put(fileName, timestamp);
                 }
             }
             catch (Exception ex) {
-                // We need to catch all exception to put a reason failure(file name) in exception
+                // We need to catch all exceptions to put a reason failure (file name) in exception
                 throw new CheckstyleException("Exception was thrown while processing "
                     + file.getPath(), ex);
             }
+            catch (Error error) {
+                // We need to catch all errors to put a reason failure (file name) in error
+                throw new Error("Error was thrown while processing " + file.getPath(), error);
+            }
+        }
+    }
+
+    /**
+     * Processes a file with all FileSetChecks.
+     * @param file a file to process.
+     * @return a sorted set of messages to be logged.
+     * @throws CheckstyleException if error condition within Checkstyle occurs.
+     */
+    private SortedSet<LocalizedMessage> processFile(File file) throws CheckstyleException {
+        final SortedSet<LocalizedMessage> fileMessages = Sets.newTreeSet();
+        try {
+            final FileText theText = new FileText(file.getAbsoluteFile(), charset);
+            for (final FileSetCheck fsc : fileSetChecks) {
+                fileMessages.addAll(fsc.process(file, theText));
+            }
+        }
+        catch (final IOException ioe) {
+            LOG.debug("IOException occurred.", ioe);
+            fileMessages.add(new LocalizedMessage(0,
+                Definitions.CHECKSTYLE_BUNDLE, "general.exception",
+                new String[] {ioe.getMessage()}, null, getClass(), null));
         }
+        return fileMessages;
     }
 
     /**
      * Sets base directory.
      * @param basedir the base directory to strip off in file names
      */
     public void setBasedir(String basedir) {
         this.basedir = basedir;
     }
 
     /** Notify all listeners about the audit start. */
     void fireAuditStarted() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditStarted(event);
         }
     }
 
     /** Notify all listeners about the audit end. */
     void fireAuditFinished() {
         final AuditEvent event = new AuditEvent(this);
         for (final AuditListener listener : listeners) {
             listener.auditFinished(event);
         }
     }
 
     /**
      * Notify all listeners about the beginning of a file audit.
      *
      * @param fileName
      *            the file to be audited
      */
     @Override
     public void fireFileStarted(String fileName) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
         final AuditEvent event = new AuditEvent(this, stripped);
         for (final AuditListener listener : listeners) {
             listener.fileStarted(event);
         }
     }
 
     /**
      * Notify all listeners about the end of a file audit.
      *
      * @param fileName
      *            the audited file
      */
     @Override
     public void fireFileFinished(String fileName) {
         final String stripped = CommonUtils.relativizeAndNormalizePath(basedir, fileName);
