diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java b/src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java
index 81d2a3d4c..515ed5c36 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java
@@ -61,129 +61,129 @@ public final class DetailNodeTreeStringPrinter {
 
     /**
      * Parse block comment DetailAST as Javadoc DetailNode tree.
      * @param blockComment DetailAST
      * @return DetailNode tree
      */
     public static DetailNode parseJavadocAsDetailNode(DetailAST blockComment) {
         final JavadocDetailNodeParser parser = new JavadocDetailNodeParser();
         final ParseStatus status = parser.parseJavadocAsDetailNode(blockComment);
         if (status.getParseErrorMessage() != null) {
             throw new IllegalArgumentException(getParseErrorMessage(status.getParseErrorMessage()));
         }
         return status.getTree();
     }
 
     /**
      * Parse javadoc comment to DetailNode tree.
      * @param javadocComment javadoc comment content
      * @return tree
      */
     private static DetailNode parseJavadocAsDetailNode(String javadocComment) {
         final DetailAST blockComment = createFakeBlockComment(javadocComment);
         return parseJavadocAsDetailNode(blockComment);
     }
 
     /**
      * Builds error message base on ParseErrorMessage's message key, its arguments, etc.
      * @param parseErrorMessage ParseErrorMessage
      * @return error message
      */
     private static String getParseErrorMessage(ParseErrorMessage parseErrorMessage) {
         final LocalizedMessage lmessage = new LocalizedMessage(
                 parseErrorMessage.getLineNumber(),
                 "com.puppycrawl.tools.checkstyle.checks.javadoc.messages",
                 parseErrorMessage.getMessageKey(),
                 parseErrorMessage.getMessageArguments(),
                 "",
                 DetailNodeTreeStringPrinter.class,
                 null);
         return "[ERROR:" + parseErrorMessage.getLineNumber() + "] " + lmessage.getMessage();
     }
 
     /**
      * Print AST.
      * @param ast the root AST node.
      * @param rootPrefix prefix for the root node
      * @param prefix prefix for other nodes
      * @return string AST.
      */
     public static String printTree(DetailNode ast, String rootPrefix, String prefix) {
-        final StringBuilder messageBuilder = new StringBuilder();
+        final StringBuilder messageBuilder = new StringBuilder(1024);
         DetailNode node = ast;
         while (node != null) {
             if (node.getType() == JavadocTokenTypes.JAVADOC) {
                 messageBuilder.append(rootPrefix);
             }
             else {
                 messageBuilder.append(prefix);
             }
             messageBuilder.append(getIndentation(node))
                     .append(JavadocUtils.getTokenName(node.getType())).append(" -> ")
                     .append(JavadocUtils.escapeAllControlChars(node.getText())).append(" [")
                     .append(node.getLineNumber()).append(':').append(node.getColumnNumber())
                     .append(']').append(LINE_SEPARATOR)
                     .append(printTree(JavadocUtils.getFirstChild(node), rootPrefix, prefix));
             node = JavadocUtils.getNextSibling(node);
         }
         return messageBuilder.toString();
     }
 
     /**
      * Get indentation for a node.
      * @param node the DetailNode to get the indentation for.
      * @return the indentation in String format.
      */
     private static String getIndentation(DetailNode node) {
         final boolean isLastChild = JavadocUtils.getNextSibling(node) == null;
         DetailNode currentNode = node;
-        final StringBuilder indentation = new StringBuilder();
+        final StringBuilder indentation = new StringBuilder(1024);
         while (currentNode.getParent() != null) {
             currentNode = currentNode.getParent();
             if (currentNode.getParent() == null) {
                 if (isLastChild) {
                     // only ASCII symbols must be used due to
                     // problems with running tests on Windows
                     indentation.append("`--");
                 }
                 else {
                     indentation.append("|--");
                 }
             }
             else {
                 if (JavadocUtils.getNextSibling(currentNode) == null) {
                     indentation.insert(0, "    ");
                 }
                 else {
                     indentation.insert(0, "|   ");
                 }
             }
         }
         return indentation.toString();
     }
 
     /**
      * Parse a file and return the parse tree.
      * @param file the file to parse.
      * @return the root node of the parse tree.
      * @throws IOException if the file could not be read.
      */
     private static DetailNode parseFile(File file) throws IOException {
         final FileText text = new FileText(file.getAbsoluteFile(),
             System.getProperty("file.encoding", "UTF-8"));
         return parseJavadocAsDetailNode(text.getFullText().toString());
     }
 
     /**
      * Creates DetailAST block comment to pass it to the Javadoc parser.
      * @param content comment content.
      * @return DetailAST block comment
      */
     private static DetailAST createFakeBlockComment(String content) {
         final DetailAST blockCommentBegin = new DetailAST();
         blockCommentBegin.setType(TokenTypes.BLOCK_COMMENT_BEGIN);
         blockCommentBegin.setText("/*");
         blockCommentBegin.setLineNo(0);
         blockCommentBegin.setColumnNo(-JAVADOC_START.length());
 
         final DetailAST commentContent = new DetailAST();
         commentContent.setType(TokenTypes.COMMENT_CONTENT);
