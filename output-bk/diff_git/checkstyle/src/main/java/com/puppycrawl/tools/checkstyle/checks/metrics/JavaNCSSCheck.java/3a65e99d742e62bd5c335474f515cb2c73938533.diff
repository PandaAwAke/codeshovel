diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java
index ec89abae8..9a13b2de7 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java
@@ -38,198 +38,140 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * equivalent to counting the semicolons and opening curly braces.
  *
  * @author Lars KÃ¶dderitzsch
  */
 // -@cs[AbbreviationAsWordInName] We can not change it as,
 // check's name is a part of API (used in configurations).
 @FileStatefulCheck
 public class JavaNCSSCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_METHOD = "ncss.method";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_CLASS = "ncss.class";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_FILE = "ncss.file";
 
     /** Default constant for max file ncss. */
     private static final int FILE_MAX_NCSS = 2000;
 
     /** Default constant for max file ncss. */
     private static final int CLASS_MAX_NCSS = 1500;
 
     /** Default constant for max method ncss. */
     private static final int METHOD_MAX_NCSS = 50;
 
     /** Maximum ncss for a complete source file. */
     private int fileMaximum = FILE_MAX_NCSS;
 
     /** Maximum ncss for a class. */
     private int classMaximum = CLASS_MAX_NCSS;
 
     /** Maximum ncss for a method. */
     private int methodMaximum = METHOD_MAX_NCSS;
 
     /** List containing the stacked counters. */
     private Deque<Counter> counters;
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {
-            TokenTypes.CLASS_DEF,
-            TokenTypes.INTERFACE_DEF,
-            TokenTypes.METHOD_DEF,
-            TokenTypes.CTOR_DEF,
-            TokenTypes.INSTANCE_INIT,
-            TokenTypes.STATIC_INIT,
-            TokenTypes.PACKAGE_DEF,
-            TokenTypes.IMPORT,
-            TokenTypes.VARIABLE_DEF,
-            TokenTypes.CTOR_CALL,
-            TokenTypes.SUPER_CTOR_CALL,
-            TokenTypes.LITERAL_IF,
-            TokenTypes.LITERAL_ELSE,
-            TokenTypes.LITERAL_WHILE,
-            TokenTypes.LITERAL_DO,
-            TokenTypes.LITERAL_FOR,
-            TokenTypes.LITERAL_SWITCH,
-            TokenTypes.LITERAL_BREAK,
-            TokenTypes.LITERAL_CONTINUE,
-            TokenTypes.LITERAL_RETURN,
-            TokenTypes.LITERAL_THROW,
-            TokenTypes.LITERAL_SYNCHRONIZED,
-            TokenTypes.LITERAL_CATCH,
-            TokenTypes.LITERAL_FINALLY,
-            TokenTypes.EXPR,
-            TokenTypes.LABELED_STAT,
-            TokenTypes.LITERAL_CASE,
-            TokenTypes.LITERAL_DEFAULT,
-        };
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.INSTANCE_INIT,
             TokenTypes.STATIC_INIT,
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.VARIABLE_DEF,
             TokenTypes.CTOR_CALL,
             TokenTypes.SUPER_CTOR_CALL,
             TokenTypes.LITERAL_IF,
             TokenTypes.LITERAL_ELSE,
             TokenTypes.LITERAL_WHILE,
             TokenTypes.LITERAL_DO,
             TokenTypes.LITERAL_FOR,
             TokenTypes.LITERAL_SWITCH,
             TokenTypes.LITERAL_BREAK,
             TokenTypes.LITERAL_CONTINUE,
             TokenTypes.LITERAL_RETURN,
             TokenTypes.LITERAL_THROW,
             TokenTypes.LITERAL_SYNCHRONIZED,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_FINALLY,
             TokenTypes.EXPR,
             TokenTypes.LABELED_STAT,
             TokenTypes.LITERAL_CASE,
             TokenTypes.LITERAL_DEFAULT,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {
-            TokenTypes.CLASS_DEF,
-            TokenTypes.INTERFACE_DEF,
-            TokenTypes.METHOD_DEF,
-            TokenTypes.CTOR_DEF,
-            TokenTypes.INSTANCE_INIT,
-            TokenTypes.STATIC_INIT,
-            TokenTypes.PACKAGE_DEF,
-            TokenTypes.IMPORT,
-            TokenTypes.VARIABLE_DEF,
-            TokenTypes.CTOR_CALL,
-            TokenTypes.SUPER_CTOR_CALL,
-            TokenTypes.LITERAL_IF,
-            TokenTypes.LITERAL_ELSE,
-            TokenTypes.LITERAL_WHILE,
-            TokenTypes.LITERAL_DO,
-            TokenTypes.LITERAL_FOR,
-            TokenTypes.LITERAL_SWITCH,
-            TokenTypes.LITERAL_BREAK,
-            TokenTypes.LITERAL_CONTINUE,
-            TokenTypes.LITERAL_RETURN,
-            TokenTypes.LITERAL_THROW,
-            TokenTypes.LITERAL_SYNCHRONIZED,
-            TokenTypes.LITERAL_CATCH,
-            TokenTypes.LITERAL_FINALLY,
-            TokenTypes.EXPR,
-            TokenTypes.LABELED_STAT,
-            TokenTypes.LITERAL_CASE,
-            TokenTypes.LITERAL_DEFAULT,
-        };
+        return getRequiredTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         counters = new ArrayDeque<>();
 
         //add a counter for the file
         counters.push(new Counter());
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final int tokenType = ast.getType();
 
         if (tokenType == TokenTypes.CLASS_DEF
             || tokenType == TokenTypes.METHOD_DEF
             || tokenType == TokenTypes.CTOR_DEF
             || tokenType == TokenTypes.STATIC_INIT
             || tokenType == TokenTypes.INSTANCE_INIT) {
             //add a counter for this class/method
             counters.push(new Counter());
         }
 
         //check if token is countable
         if (isCountable(ast)) {
             //increment the stacked counters
             counters.forEach(Counter::increment);
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         final int tokenType = ast.getType();
         if (tokenType == TokenTypes.METHOD_DEF
             || tokenType == TokenTypes.CTOR_DEF
             || tokenType == TokenTypes.STATIC_INIT
             || tokenType == TokenTypes.INSTANCE_INIT) {
             //pop counter from the stack
             final Counter counter = counters.pop();
 
             final int count = counter.getCount();
             if (count > methodMaximum) {
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_METHOD,
                         count, methodMaximum);
             }
         }
         else if (tokenType == TokenTypes.CLASS_DEF) {
             //pop counter from the stack
             final Counter counter = counters.pop();
 
