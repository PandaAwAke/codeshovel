diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
index 303f9f1b4..a5b929ec0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java
@@ -43,100 +43,108 @@ import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
  * they should be redundant because of outer class.
  *
  * @author Oliver Burn
  * @author Michael Tamm
  */
 public class JavadocTypeCheck
     extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_JAVADOC_MISSING = "javadoc.missing";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_UNKNOWN_TAG = "javadoc.unknownTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_TAG_FORMAT = "type.tagFormat";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_MISSING_TAG = "type.missingTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_UNUSED_TAG = "javadoc.unusedTag";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_UNUSED_TAG_GENERAL = "javadoc.unusedTagGeneral";
 
     /** Open angle bracket literal. */
     private static final String OPEN_ANGLE_BRACKET = "<";
 
     /** Close angle bracket literal. */
     private static final String CLOSE_ANGLE_BRACKET = ">";
 
+    /** Pattern to match type name within angle brackets in javadoc param tag. */
+    private static final Pattern TYPE_NAME_IN_JAVADOC_TAG =
+            Pattern.compile("\\s*<([^>]+)>.*");
+
+    /** Pattern to split type name field in javadoc param tag. */
+    private static final Pattern TYPE_NAME_IN_JAVADOC_TAG_SPLITTER =
+            Pattern.compile("\\s+");
+
     /** The scope to check for. */
     private Scope scope = Scope.PRIVATE;
     /** The visibility scope where Javadoc comments shouldn't be checked. **/
     private Scope excludeScope;
     /** Compiled regexp to match author tag content. **/
     private Pattern authorFormatPattern;
     /** Compiled regexp to match version tag content. **/
     private Pattern versionFormatPattern;
     /** Regexp to match author tag content. */
     private String authorFormat;
     /** Regexp to match version tag content. */
     private String versionFormat;
     /**
      * Controls whether to ignore errors when a method has type parameters but
      * does not have matching param tags in the javadoc. Defaults to false.
      */
     private boolean allowMissingParamTags;
     /** Controls whether to flag errors for unknown tags. Defaults to false. */
     private boolean allowUnknownTags;
 
     /**
      * Sets the scope to check.
      * @param from string to set scope from
      */
     public void setScope(String from) {
         scope = Scope.getInstance(from);
     }
 
     /**
      * Set the excludeScope.
      * @param excludeScope a {@code String} value
      */
     public void setExcludeScope(String excludeScope) {
         this.excludeScope = Scope.getInstance(excludeScope);
     }
 
     /**
      * Set the author tag pattern.
      * @param format a {@code String} value
      */
     public void setAuthorFormat(String format) {
         authorFormat = format;
         authorFormatPattern = CommonUtils.createPattern(format);
     }
 
     /**
      * Set the version format pattern.
      * @param format a {@code String} value
      */
     public void setVersionFormat(String format) {
@@ -275,69 +283,84 @@ public class JavadocTypeCheck
         }
 
         int tagCount = 0;
         final String tagPrefix = "@";
         for (int i = tags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = tags.get(i);
             if (tag.getTagName().equals(tagName)) {
                 tagCount++;
                 if (!formatPattern.matcher(tag.getFirstArg()).find()) {
                     log(lineNo, MSG_TAG_FORMAT, tagPrefix + tagName, format);
                 }
             }
         }
         if (tagCount == 0) {
             log(lineNo, MSG_MISSING_TAG, tagPrefix + tagName);
         }
     }
 
     /**
      * Verifies that a type definition has the specified param tag for
      * the specified type parameter name.
      * @param lineNo the line number for the type definition.
      * @param tags tags from the Javadoc comment for the type definition.
      * @param typeParamName the name of the type parameter
      */
     private void checkTypeParamTag(final int lineNo,
             final List<JavadocTag> tags, final String typeParamName) {
         boolean found = false;
         for (int i = tags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = tags.get(i);
             if (tag.isParamTag()
                 && tag.getFirstArg().indexOf(OPEN_ANGLE_BRACKET
                         + typeParamName + CLOSE_ANGLE_BRACKET) == 0) {
                 found = true;
             }
         }
         if (!found) {
             log(lineNo, MSG_MISSING_TAG, JavadocTagInfo.PARAM.getText()
                 + " " + OPEN_ANGLE_BRACKET + typeParamName + CLOSE_ANGLE_BRACKET);
         }
     }
 
     /**
      * Checks for unused param tags for type parameters.
      * @param tags tags from the Javadoc comment for the type definition.
      * @param typeParamNames names of type parameters
      */
     private void checkUnusedTypeParamTags(
         final List<JavadocTag> tags,
         final List<String> typeParamNames) {
-        final Pattern pattern = Pattern.compile("\\s*<([^>]+)>.*");
         for (int i = tags.size() - 1; i >= 0; i--) {
             final JavadocTag tag = tags.get(i);
             if (tag.isParamTag()) {
 
-                final Matcher matcher = pattern.matcher(tag.getFirstArg());
-                if (matcher.find()) {
-                    final String typeParamName = matcher.group(1).trim();
-                    if (!typeParamNames.contains(typeParamName)) {
-                        log(tag.getLineNo(), tag.getColumnNo(),
+                final String typeParamName = extractTypeParamNameFromTag(tag);
+
+                if (!typeParamNames.contains(typeParamName)) {
+                    log(tag.getLineNo(), tag.getColumnNo(),
                             MSG_UNUSED_TAG,
                             JavadocTagInfo.PARAM.getText(),
                             OPEN_ANGLE_BRACKET + typeParamName + CLOSE_ANGLE_BRACKET);
-                    }
                 }
             }
         }
     }
+
+    /**
+     * Extracts type parameter name from tag.
+     * @param tag javadoc tag to extract parameter name
+     * @return extracts type parameter name from tag
+     */
+    private static String extractTypeParamNameFromTag(JavadocTag tag) {
+        final String typeParamName;
+        final Matcher matchInAngleBrackets =
+                TYPE_NAME_IN_JAVADOC_TAG.matcher(tag.getFirstArg());
+        if (matchInAngleBrackets.find()) {
+            typeParamName = matchInAngleBrackets.group(1).trim();
+        }
+        else {
+            typeParamName = TYPE_NAME_IN_JAVADOC_TAG_SPLITTER.split(tag.getFirstArg())[0];
+        }
+        return typeParamName;
+    }
 }
