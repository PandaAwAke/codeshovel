diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/gui/AbstractTreeTableModel.java b/src/main/java/com/puppycrawl/tools/checkstyle/gui/AbstractTreeTableModel.java
index 81b5474fd..93041e856 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/gui/AbstractTreeTableModel.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/gui/AbstractTreeTableModel.java
@@ -62,107 +62,107 @@ package com.puppycrawl.tools.checkstyle.gui;
 import javax.swing.event.EventListenerList;
 import javax.swing.event.TreeModelEvent;
 import javax.swing.event.TreeModelListener;
 import javax.swing.tree.TreePath;
 
 /**
  * An abstract implementation of the TreeTableModel interface, handling
  * the list of listeners.
  *
  * <a href="https://docs.oracle.com/cd/E48246_01/apirefs.1111/e13403/oracle/ide/controls/TreeTableModel.html">Original&nbsp;Source&nbsp;Location</a>
  *
  * @author Philip Milne
  */
 public abstract class AbstractTreeTableModel implements TreeTableModel {
     private final Object root;
     private final EventListenerList listenerList = new EventListenerList();
 
     public AbstractTreeTableModel(Object root) {
         this.root = root;
     }
 
     //
     // Default implmentations for methods in the TreeModel interface.
     //
 
     @Override
     public Object getRoot() {
         return root;
     }
 
     @Override
     public boolean isLeaf(Object node) {
         return getChildCount(node) == 0;
     }
 
     @Override
     public abstract void valueForPathChanged(TreePath path, Object newValue);
 
     // This is not called in the JTree's default mode: use a naive implementation.
     @Override
     public int getIndexOfChild(Object parent, Object child) {
         for (int i = 0; i < getChildCount(parent); i++) {
             if (getChild(parent, i).equals(child)) {
                 return i;
             }
         }
         return -1;
     }
 
     @Override
-    public void addTreeModelListener(TreeModelListener l) {
-        listenerList.add(TreeModelListener.class, l);
+    public void addTreeModelListener(TreeModelListener listener) {
+        listenerList.add(TreeModelListener.class, listener);
     }
 
     @Override
-    public void removeTreeModelListener(TreeModelListener l) {
-        listenerList.remove(TreeModelListener.class, l);
+    public void removeTreeModelListener(TreeModelListener listener) {
+        listenerList.remove(TreeModelListener.class, listener);
     }
 
     /*
      * Notify all listeners that have registered interest for
      * notification on this event type.  The event instance
      * is lazily created using the parameters passed into
      * the fire method.
      * @see EventListenerList
      */
     protected void fireTreeNodesChanged(Object source, Object[] path,
             int[] childIndices,
             Object... children) {
         // Guaranteed to return a non-null array
         final Object[] listeners = listenerList.getListenerList();
         TreeModelEvent e = null;
         // Process the listeners last to first, notifying
         // those that are interested in this event
         for (int i = listeners.length - 2; i >= 0; i -= 2) {
             if (listeners[i] == TreeModelListener.class) {
                 // Lazily create the event:
                 if (e == null) {
                     e = new TreeModelEvent(source, path,
                             childIndices, children);
                 }
                 ((TreeModelListener) listeners[i + 1]).treeNodesChanged(e);
             }
         }
     }
 
     /*
      * Notify all listeners that have registered interest for
      * notification on this event type.  The event instance
      * is lazily created using the parameters passed into
      * the fire method.
      * @see EventListenerList
      */
     protected void fireTreeNodesInserted(Object source, Object[] path,
             int[] childIndices,
             Object... children) {
         // Guaranteed to return a non-null array
         final Object[] listeners = listenerList.getListenerList();
         TreeModelEvent e = null;
         // Process the listeners last to first, notifying
         // those that are interested in this event
         for (int i = listeners.length - 2; i >= 0; i -= 2) {
             if (listeners[i] == TreeModelListener.class) {
                 // Lazily create the event:
                 if (e == null) {
                     e = new TreeModelEvent(source, path,
                             childIndices, children);
