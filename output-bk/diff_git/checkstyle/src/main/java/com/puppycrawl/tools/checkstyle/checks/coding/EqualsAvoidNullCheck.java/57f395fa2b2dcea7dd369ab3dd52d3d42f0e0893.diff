diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
index 33838317a..260dc2206 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
@@ -74,129 +74,140 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * The following example will cause a
  * NullPointerException as a result of what autoboxing does.
  * <pre>
  * Integer i = null, j = null;
  * String number = "5"
  * number.equals(i + j);
  * </pre>
  *
  *
  * Since, it is difficult to determine what kind of Object is being
  * concatenated all ident concatenation is considered unsafe.
  *
  * @author Travis Schneeberger
  * version 1.0
  */
 public class EqualsAvoidNullCheck extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_EQUALS_AVOID_NULL = "equals.avoid.null";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_EQUALS_IGNORE_CASE_AVOID_NULL = "equalsIgnoreCase.avoid.null";
 
     /** Whether to process equalsIgnoreCase() invocations. */
     private boolean ignoreEqualsIgnoreCase;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.METHOD_CALL};
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.METHOD_CALL};
     }
 
     @Override
     public void visitToken(final DetailAST methodCall) {
         final DetailAST dot = methodCall.getFirstChild();
         if (dot.getType() != TokenTypes.DOT) {
             return;
         }
 
         final DetailAST objCalledOn = dot.getFirstChild();
-
-        //checks for calling equals on String literal and
-        //anon object which cannot be null
-        //Also, checks if calling using strange inner class
-        //syntax outter.inner.equals(otherObj) by looking
-        //for the dot operator which cannot be improved
-        if (objCalledOn.getType() == TokenTypes.STRING_LITERAL
-                || objCalledOn.getType() == TokenTypes.LITERAL_NEW
-                || objCalledOn.getType() == TokenTypes.DOT) {
+        if (isStringLiteral(objCalledOn)) {
             return;
         }
 
+
         final DetailAST method = objCalledOn.getNextSibling();
         final DetailAST expr = dot.getNextSibling().getFirstChild();
 
         if ("equals".equals(method.getText())
             && containsOneArg(expr) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_AVOID_NULL);
         }
 
         if (!ignoreEqualsIgnoreCase
             && "equalsIgnoreCase".equals(method.getText())
             && containsOneArg(expr) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_IGNORE_CASE_AVOID_NULL);
         }
     }
 
+    /**
+     * checks for calling equals on String literal and
+     * anon object which cannot be null
+     * Also, checks if calling using strange inner class
+     * syntax outter.inner.equals(otherObj) by looking
+     * for the dot operator which cannot be improved
+     * @param objCalledOn object AST
+     * @return if it is string literal
+     */
+    private boolean isStringLiteral(DetailAST objCalledOn) {
+        if (objCalledOn.getType() == TokenTypes.STRING_LITERAL
+                || objCalledOn.getType() == TokenTypes.LITERAL_NEW
+                || objCalledOn.getType() == TokenTypes.DOT) {
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Checks if a method contains no arguments
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains no args, false if not
      */
     private boolean containsNoArgs(final AST expr) {
         return expr == null;
     }
 
     /**
      * Checks if a method contains multiple arguments
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains multiple args, false if not
      */
     private boolean containsMultiArgs(final AST expr) {
         final AST comma = expr.getNextSibling();
         return comma != null && comma.getType() == TokenTypes.COMMA;
     }
 
     /**
      * Checks if a method contains a single argument
      * starting at with the argument expression.
      *
      * @param expr the argument expression
      * @return true if the method contains a single arg, false if not
      */
     private boolean containsOneArg(final AST expr) {
         return !containsNoArgs(expr) && !containsMultiArgs(expr);
     }
 
     /**
      * <p>
      * Looks for all "safe" Token combinations in the argument
      * expression branch.
      * </p>
      *
      * <p>
      * See class documentation for details on autoboxing's affect
      * on this method implementation.
      * </p>
      *
      * @param expr the argument expression
      * @return - true if any child matches the set of tokens, false if not
      */
     private boolean containsAllSafeTokens(final DetailAST expr) {
         DetailAST arg = expr.getFirstChild();
