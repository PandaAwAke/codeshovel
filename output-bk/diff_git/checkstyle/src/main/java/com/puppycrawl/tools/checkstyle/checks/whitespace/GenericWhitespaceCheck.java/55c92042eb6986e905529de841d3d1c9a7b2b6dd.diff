diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
index 7239aa98a..37b298b5c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
@@ -72,101 +72,101 @@ public class GenericWhitespaceCheck extends Check {
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_PRECEDED = "ws.preceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_FOLLOWED = "ws.followed";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_PRECEDED = "ws.notPreceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_ILLEGAL_FOLLOW = "ws.illegalFollow";
 
     /** Open angle bracket literal. */
     private static final String OPEN_ANGLE_BRACKET = "<";
 
     /** Close angle bracket literal. */
     private static final String CLOSE_ANGLE_BRACKET = ">";
 
     /** Used to count the depth of a Generic expression. */
     private int depth;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
-        // Reset for each tree, just incase there are errors in preceeding
+        // Reset for each tree, just increase there are errors in preceding
         // trees.
         depth = 0;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.GENERIC_START:
                 processStart(ast);
                 depth++;
                 break;
             case TokenTypes.GENERIC_END:
                 processEnd(ast);
                 depth--;
                 break;
             default:
                 throw new IllegalArgumentException("Unknown type " + ast);
         }
     }
 
     /**
      * Checks the token for the end of Generics.
      * @param ast the token to check
      */
     private void processEnd(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         if (before >= 0 && Character.isWhitespace(line.charAt(before))
                 && !CommonUtils.whitespaceBefore(before, line)) {
             log(ast.getLineNo(), before, WS_PRECEDED, CLOSE_ANGLE_BRACKET);
         }
 
         if (after < line.length()) {
 
             // Check if the last Generic, in which case must be a whitespace
             // or a '(),[.'.
             if (depth == 1) {
                 processSingleGeneric(ast, line, after);
             }
             else {
                 processNestedGenerics(ast, line, after);
             }
         }
     }
 
     /**
      * Process Nested generics
      * @param ast token
