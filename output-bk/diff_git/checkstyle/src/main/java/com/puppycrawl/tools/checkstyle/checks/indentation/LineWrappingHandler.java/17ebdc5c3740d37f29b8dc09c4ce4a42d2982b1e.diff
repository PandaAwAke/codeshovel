diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
index f92127c24..f0629477c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java
@@ -189,146 +189,122 @@ public class LineWrappingHandler
     {
         final NavigableMap<Integer, DetailAST> result = new TreeMap<Integer, DetailAST>();
 
         result.put(mFirstNode.getLineNo(), mFirstNode);
         DetailAST curNode = mFirstNode.getFirstChild();
 
         while (curNode != null && curNode != mLastNode) {
 
             if (curNode.getType() == TokenTypes.OBJBLOCK) {
                 curNode = curNode.getNextSibling();
             }
 
             if (curNode != null) {
                 final DetailAST firstTokenOnLine = result.get(curNode.getLineNo());
 
                 if (firstTokenOnLine == null
                         || firstTokenOnLine != null
                         && firstTokenOnLine.getColumnNo() >= curNode.getColumnNo())
                 {
                     result.put(curNode.getLineNo(), curNode);
                 }
                 curNode = getNextCurNode(curNode);
             }
         }
         return result;
     }
 
     /**
      * Returns next curNode node.
      *
      * @param aCurNode current node.
      * @return next curNode node.
      */
     private DetailAST getNextCurNode(DetailAST aCurNode)
     {
         DetailAST nodeToVisit = aCurNode.getFirstChild();
         DetailAST currentNode = aCurNode;
 
         while ((currentNode != null) && (nodeToVisit == null)) {
             nodeToVisit = currentNode.getNextSibling();
             if (nodeToVisit == null) {
                 currentNode = currentNode.getParent();
             }
         }
         return nodeToVisit;
     }
 
     /**
      * Checks line wrapping into annotations.
      *
-     * @param aModifiersNode modifiers node.
+     * @param aAtNode at-clause node.
      * @param aFirstNodesOnLines map which contains
      *     first nodes as values and line numbers as keys.
      */
-    private void checkAnnotationIndentation(DetailAST aModifiersNode,
+    private void checkAnnotationIndentation(DetailAST aAtNode,
             NavigableMap<Integer, DetailAST> aFirstNodesOnLines)
     {
-        final int currentIndent = aModifiersNode.getColumnNo() + mIndentLevel;
-        final int firstNodeIndent = aModifiersNode.getColumnNo();
+        final int currentIndent = aAtNode.getColumnNo() + mIndentLevel;
+        final int firstNodeIndent = aAtNode.getColumnNo();
         final Collection<DetailAST> values = aFirstNodesOnLines.values();
+        final DetailAST lastAnnotationNode = getLastAnnotationNode(aAtNode);
+        final int lastAnnotationLine = lastAnnotationNode.getLineNo();
+        final int lastAnnotattionColumn = lastAnnotationNode.getColumnNo();
 
         final Iterator<DetailAST> itr = values.iterator();
         while (itr.hasNext() && aFirstNodesOnLines.size() > 1) {
             final DetailAST node = itr.next();
-            final int parentType = node.getParent().getType();
 
-            if (node.getType() == TokenTypes.AT) {
-
-                if (isAnnotationAloneOnLine(node.getParent())) {
+            if (node.getLineNo() < lastAnnotationLine
+                    || node.getLineNo() == lastAnnotationLine
+                    && node.getColumnNo() <= lastAnnotattionColumn)
+            {
+                final DetailAST parentNode = node.getParent();
+                if (node.getType() == TokenTypes.AT
+                        && parentNode.getParent().getType() == TokenTypes.MODIFIERS)
+                {
                     logWarningMessage(node, firstNodeIndent);
-                    itr.remove();
                 }
-            }
-            else if (parentType != TokenTypes.MODIFIERS
-                    && !hasTypeNodeAsParent(node)
-                    && parentType != TokenTypes.ENUM_DEF
-                    && parentType != TokenTypes.CTOR_DEF
-                    && node.getType() != TokenTypes.LITERAL_CLASS)
-            {
-                logWarningMessage(node, currentIndent);
+                else {
+                    logWarningMessage(node, currentIndent);
+                }
                 itr.remove();
             }
+            else {
+                break;
+            }
         }
     }
 
     /**
-     * Checks if annotation is alone on line.
-     *
-     * @param aAnnotationNode
-     *            current annotation.
-     * @return true if annotation is alone on line.
-     */
-    private boolean isAnnotationAloneOnLine(DetailAST aAnnotationNode)
-    {
-        final DetailAST nextSibling = aAnnotationNode.getNextSibling();
-        if (nextSibling == null) {
-            final DetailAST typeNode = aAnnotationNode.getParent().getNextSibling();
-            return aAnnotationNode.getLineNo() != typeNode.getLineNo();
-        }
-        else {
-            return (nextSibling.getType() == TokenTypes.ANNOTATION
-                || aAnnotationNode.getLineNo() != nextSibling.getLineNo());
-        }
-    }
-
-    /**
-     * Checks if current node has TYPE node as a parent.
-     *
-     * @param aCurrentNode
-     *            current node.
-     * @return true if current node has TYPE node as a parent.
+     * Finds and returns last annotation node.
+     * @param aAtNode first at-clause node.
+     * @return last annotation node.
      */
-    private boolean hasTypeNodeAsParent(DetailAST aCurrentNode)
+    private DetailAST getLastAnnotationNode(DetailAST aAtNode)
     {
-        DetailAST typeNode = aCurrentNode;
-        boolean result = false;
-        while (typeNode != null && typeNode.getType() != TokenTypes.SLIST
-                && typeNode.getType() != TokenTypes.OBJBLOCK)
+        DetailAST lastAnnotation = aAtNode.getParent();
+        while (lastAnnotation.getNextSibling() != null
+                && lastAnnotation.getNextSibling().getType() == TokenTypes.ANNOTATION)
         {
-            if (typeNode.getType() == TokenTypes.TYPE
-                    || typeNode.getType() == TokenTypes.TYPE_PARAMETERS)
-            {
-                result = true;
-            }
-            typeNode = typeNode.getParent();
+            lastAnnotation = lastAnnotation.getNextSibling();
         }
-        return result;
+        return lastAnnotation.getLastChild();
     }
 
     /**
      * Logs warning message if indentation is incorrect.
      *
      * @param aCurrentNode
      *            current node which probably invoked an error.
      * @param aCurrentIndent
      *            correct indentation.
      */
     private void logWarningMessage(DetailAST aCurrentNode, int aCurrentIndent)
     {
         if (aCurrentNode.getColumnNo() < aCurrentIndent) {
             mIndentCheck.indentationLog(aCurrentNode.getLineNo(),
                     "indentation.error", aCurrentNode.getText(),
                     aCurrentNode.getColumnNo(), aCurrentIndent);
         }
     }
 }
