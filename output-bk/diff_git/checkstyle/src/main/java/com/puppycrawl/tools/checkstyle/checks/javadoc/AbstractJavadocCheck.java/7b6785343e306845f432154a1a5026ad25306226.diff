diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
index 7f58353c8..913cce632 100755
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java
@@ -133,102 +133,101 @@ public abstract class AbstractJavadocCheck extends Check
     {
         return super.getRequiredTokens();
     }
 
     @Override
     public final boolean isCommentNodesRequired()
     {
         return true;
     }
 
     @Override
     public final void beginTree(DetailAST aRootAST)
     {
     }
 
     @Override
     public final void finishTree(DetailAST aRootAST)
     {
         TREE_CACHE.clear();
     }
 
     @Override
     public final void leaveToken(DetailAST aAST)
     {
     }
 
     @Override
     public final void visitToken(DetailAST aBlockCommentAst)
     {
         if (JavadocUtils.isJavadocComment(aBlockCommentAst)) {
             mBlockCommentAst = aBlockCommentAst;
 
             final String treeCacheKey = aBlockCommentAst.getLineNo() + ":"
                     + aBlockCommentAst.getColumnNo();
 
             ParseStatus ps;
 
             if (TREE_CACHE.containsKey(treeCacheKey)) {
                 ps = TREE_CACHE.get(treeCacheKey);
             }
             else {
                 ps = parseJavadocAsDetailNode(aBlockCommentAst);
                 TREE_CACHE.put(treeCacheKey, ps);
             }
 
             if (ps.getParseErrorMessage() == null) {
                 processTree(ps.getTree());
             }
             else {
                 final LocalizedMessage parseErrorMessage = ps.getParseErrorMessage();
-                log(parseErrorMessage.getLineNo(), parseErrorMessage.getColumnNo()
-                        , parseErrorMessage.getMessage());
+                log(parseErrorMessage.getLineNo(), parseErrorMessage.getMessage());
             }
         }
 
     }
 
     protected DetailAST getBlockCommentAst()
     {
         return mBlockCommentAst;
     }
 
     /**
      * Parses Javadoc comment as DetailNode tree.
      * @param aJavadocCommentAst
      *        DetailAST of Javadoc comment
      * @return DetailNode tree of Javadoc comment
      */
     private ParseStatus parseJavadocAsDetailNode(DetailAST aJavadocCommentAst)
     {
         final String javadocComment = JavadocUtils.getJavadocCommentContent(aJavadocCommentAst);
 
         // Log messages should have line number in scope of file,
         // not in scope of Javadoc comment.
         // Offset is line number of beginning of Javadoc comment.
         mErrorListener.setOffset(aJavadocCommentAst.getLineNo() - 1);
 
         final ParseStatus result = new ParseStatus();
         ParseTree parseTree = null;
         LocalizedMessage parseErrorMessage = null;
 
         try {
             parseTree = parseJavadocAsParseTree(javadocComment);
         }
         catch (IOException e) {
             // Antlr can not initiate its ANTLRInputStream
             parseErrorMessage = createLogMessage(aJavadocCommentAst.getLineNo(),
                     "javadoc.parse.error",
                     aJavadocCommentAst.getColumnNo(), e.getMessage());
         }
         catch (ParseCancellationException e) {
             // If syntax error occurs then message is printed by error listener
             // and parser throws this runtime exception to stop parsing.
             // Just stop processing current Javadoc comment.
             parseErrorMessage = mErrorListener.getErrorMessage();
         }
 
         if (parseErrorMessage == null) {
             final DetailNode tree = convertParseTree2DetailNode(parseTree);
             result.setTree(tree);
         }
         else {
