diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java
index 72df156f7..afbd42f46 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java
@@ -64,101 +64,103 @@ public class UniquePropertiesCheck extends AbstractFileSetCheck {
     }
 
     @Override
     protected void processFiltered(File file, FileText fileText) {
         final UniqueProperties properties = new UniqueProperties();
         FileInputStream fileInputStream = null;
         try {
             fileInputStream = new FileInputStream(file);
             properties.load(fileInputStream);
         }
         catch (IOException ex) {
             log(0, MSG_IO_EXCEPTION_KEY, file.getPath(),
                     ex.getLocalizedMessage());
         }
         finally {
             Closeables.closeQuietly(fileInputStream);
         }
 
         for (Entry<String> duplication : properties
                 .getDuplicatedKeys().entrySet()) {
             final String keyName = duplication.getElement();
             final int lineNumber = getLineNumber(fileText, keyName);
             // Number of occurrences is number of duplications + 1
             log(lineNumber, MSG_KEY, keyName, duplication.getCount() + 1);
         }
     }
 
     /**
      * Method returns line number the key is detected in the checked properties
      * files first.
      *
      * @param fileText
      *            {@link FileText} object contains the lines to process
      * @param keyName
      *            key name to look for
      * @return line number of first occurrence. If no key found in properties
      *         file, 0 is returned
      */
     private static int getLineNumber(FileText fileText, String keyName) {
         final Pattern keyPattern = getKeyPattern(keyName);
         int lineNumber = 1;
         final Matcher matcher = keyPattern.matcher("");
         for (int index = 0; index < fileText.size(); index++) {
             final String line = fileText.get(index);
             matcher.reset(line);
             if (matcher.matches()) {
                 break;
             }
             ++lineNumber;
         }
-        if (lineNumber > fileText.size()) {
+        // -1 as check seeks for the first duplicate occurance in file,
+        // so it cannot be the last line.
+        if (lineNumber > fileText.size() - 1) {
             lineNumber = 0;
         }
         return lineNumber;
     }
 
     /**
      * Method returns regular expression pattern given key name.
      *
      * @param keyName
      *            key name to look for
      * @return regular expression pattern given key name
      */
     private static Pattern getKeyPattern(String keyName) {
         final String keyPatternString = "^" + SPACE_PATTERN.matcher(keyName)
                 .replaceAll(Matcher.quoteReplacement("\\\\ ")) + "[\\s:=].*$";
         return Pattern.compile(keyPatternString);
     }
 
     /**
      * Properties subclass to store duplicated property keys in a separate map.
      *
      * @author Pavel Baranchikov
      * @noinspection ClassExtendsConcreteCollection, SerializableHasSerializationMethods
      */
     private static class UniqueProperties extends Properties {
         private static final long serialVersionUID = 1L;
         /**
          * Multiset, holding duplicated keys. Keys are added here only if they
          * already exist in Properties' inner map.
          */
         private final Multiset<String> duplicatedKeys = HashMultiset
                 .create();
 
         /**
          * Puts the value into properties by the key specified.
          * @noinspection UseOfPropertiesAsHashtable
          */
         @Override
         public synchronized Object put(Object key, Object value) {
             final Object oldValue = super.put(key, value);
             if (oldValue != null && key instanceof String) {
                 final String keyString = (String) key;
                 duplicatedKeys.add(keyString);
             }
             return oldValue;
         }
 
         /**
          * Retrieves a collections of duplicated properties keys.
          *
