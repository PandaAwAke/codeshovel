diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtils.java
index 827a62dad..44bb5c175 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtils.java
@@ -155,103 +155,103 @@ public final class CommonUtils {
             }
         }
         return len;
     }
 
     /**
      * Validates whether passed string is a valid pattern or not.
      *
      * @param pattern
      *            string to validate
      * @return true if the pattern is valid false otherwise
      */
     public static boolean isPatternValid(String pattern) {
         try {
             Pattern.compile(pattern);
         }
         catch (final PatternSyntaxException ignored) {
             return false;
         }
         return true;
     }
 
     /**
      * Helper method to create a regular expression.
      *
      * @param pattern
      *            the pattern to match
      * @return a created regexp object
      * @throws ConversionException
      *             if unable to create Pattern object.
      **/
     public static Pattern createPattern(String pattern) {
         return createPattern(pattern, 0);
     }
 
     /**
      * Helper method to create a regular expression with a specific flags.
      *
      * @param pattern
      *            the pattern to match
      * @param flags
      *            the flags to set
      * @return a created regexp object
      * @throws ConversionException
      *             if unable to create Pattern object.
      **/
     public static Pattern createPattern(String pattern, int flags) {
         try {
             return Pattern.compile(pattern, flags);
         }
-        catch (final PatternSyntaxException e) {
+        catch (final PatternSyntaxException ex) {
             throw new ConversionException(
-                    "Failed to initialise regular expression " + pattern, e);
+                    "Failed to initialise regular expression " + pattern, ex);
         }
     }
 
     /**
      * @param type
      *            the fully qualified name. Cannot be null
      * @return the base class name from a fully qualified name
      */
     public static String baseClassName(String type) {
         final int index = type.lastIndexOf('.');
 
         if (index == -1) {
             return type;
         }
         else {
             return type.substring(index + 1);
         }
     }
 
     /**
      * Constructs a normalized relative path between base directory and a given path.
      *
      * @param baseDirectory
      *            the base path to which given path is relativized
      * @param path
      *            the path to relativize against base directory
      * @return the relative normalized path between base directory and
      *     path or path if base directory is null.
      */
     public static String relativizeAndNormalizePath(final String baseDirectory, final String path) {
         if (baseDirectory == null) {
             return path;
         }
         final Path pathAbsolute = Paths.get(path).normalize();
         final Path pathBase = Paths.get(baseDirectory).normalize();
         return pathBase.relativize(pathAbsolute).toString();
     }
 
     /**
      * Tests if this string starts with the specified prefix.
      * <p>
      * It is faster version of {@link String#startsWith(String)} optimized for
      *  one-character prefixes at the expense of
      * some readability. Suggested by SimplifyStartsWith PMD rule:
      * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith
      * </p>
      *
      * @param value
      *            the {@code String} to check
      * @param prefix
@@ -286,117 +286,117 @@ public final class CommonUtils {
     /**
      * Gets constructor of targetClass.
      * @param targetClass
      *            from which constructor is returned
      * @param parameterTypes
      *            of constructor
      * @return constructor of targetClass or {@link IllegalStateException} if any exception occurs
      * @see Class#getConstructor(Class[])
      */
     public static Constructor<?> getConstructor(Class<?> targetClass, Class<?>... parameterTypes) {
         try {
             return targetClass.getConstructor(parameterTypes);
         }
         catch (NoSuchMethodException ex) {
             throw new IllegalStateException(ex);
         }
     }
 
     /**
      * @param constructor
      *            to invoke
      * @param parameters
      *            to pass to constructor
      * @param <T>
      *            type of constructor
      * @return new instance of class or {@link IllegalStateException} if any exception occurs
      * @see Constructor#newInstance(Object...)
      */
     public static <T> T invokeConstructor(Constructor<T> constructor, Object... parameters) {
         try {
             return constructor.newInstance(parameters);
         }
         catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
             throw new IllegalStateException(ex);
         }
     }
 
     /**
      * Closes a stream re-throwing IOException as IllegalStateException.
      *
      * @param closeable
      *            Closeable object
      */
     public static void close(Closeable closeable) {
         if (closeable == null) {
             return;
         }
         try {
             closeable.close();
         }
-        catch (IOException e) {
-            throw new IllegalStateException("Cannot close the stream", e);
+        catch (IOException ex) {
+            throw new IllegalStateException("Cannot close the stream", ex);
         }
     }
 
     /**
      * Resolve the specified filename to a URI.
      * @param filename name os the file
      * @return resolved header file URI
      * @throws CheckstyleException on failure
      */
     public static URI getUriByFilename(String filename) throws CheckstyleException {
         // figure out if this is a File or a URL
         URI uri;
         try {
             final URL url = new URL(filename);
             uri = url.toURI();
         }
         catch (final URISyntaxException | MalformedURLException ignored) {
             uri = null;
         }
 
         if (uri == null) {
             final File file = new File(filename);
             if (file.exists()) {
                 uri = file.toURI();
             }
             else {
                 // check to see if the file is in the classpath
                 try {
                     final URL configUrl = CommonUtils.class
                             .getResource(filename);
                     if (configUrl == null) {
                         throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);
                     }
                     uri = configUrl.toURI();
                 }
-                catch (final URISyntaxException e) {
-                    throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, e);
+                catch (final URISyntaxException ex) {
+                    throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);
                 }
             }
         }
 
         return uri;
     }
 
     /**
      * Puts part of line, which matches regexp into given template
      * on positions $n where 'n' is number of matched part in line.
      * @param template the string to expand.
      * @param lineToPlaceInTemplate contains expression which should be placed into string.
      * @param regexp expression to find in comment.
      * @return the string, based on template filled with given lines
      */
     public static String fillTemplateWithStringsByRegexp(
         String template, String lineToPlaceInTemplate, Pattern regexp) {
         final Matcher matcher = regexp.matcher(lineToPlaceInTemplate);
         String result = template;
         if (matcher.find()) {
             for (int i = 0; i <= matcher.groupCount(); i++) {
                 // $n expands comment match like in Pattern.subst().
                 result = result.replaceAll("\\$" + i, matcher.group(i));
             }
         }
         return result;
     }
 }
