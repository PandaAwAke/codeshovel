diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
index d15c32c1b..1c761a482 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java
@@ -1,83 +1,82 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2018 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.coding;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
-import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
 import com.puppycrawl.tools.checkstyle.utils.TokenUtils;
 
 /**
  * Checks that particular class are never used as types in variable
  * declarations, return values or parameters.
  *
  * <p>Rationale:
  * Helps reduce coupling on concrete classes.
  *
  * <p>Check has following properties:
  *
  * <p><b>format</b> - Pattern for illegal class names.
  *
  * <p><b>legalAbstractClassNames</b> - Abstract classes that may be used as types.
  *
  * <p><b>illegalClassNames</b> - Classes that should not be used as types in variable
    declarations, return values or parameters.
  * It is possible to set illegal class names via short or
  * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
  *  canonical</a> name.
  *  Specifying illegal type invokes analyzing imports and Check puts violations at
  *   corresponding declarations
  *  (of variables, methods or parameters). This helps to avoid ambiguous cases, e.g.:
  *
  * <p>{@code java.awt.List} was set as illegal class name, then, code like:
  *
  * <p>{@code
  * import java.util.List;<br>
  * ...<br>
  * List list; //No violation here
  * }
  *
  * <p>will be ok.
  *
  * <p><b>validateAbstractClassNames</b> - controls whether to validate abstract class names.
  * Default value is <b>false</b>
  * </p>
  *
  * <p><b>ignoredMethodNames</b> - Methods that should not be checked.
  *
  * <p><b>memberModifiers</b> - To check only methods and fields with only specified modifiers.
  *
  * <p>In most cases it's justified to put following classes to <b>illegalClassNames</b>:
  * <ul>
  * <li>GregorianCalendar</li>
  * <li>Hashtable</li>
  * <li>ArrayList</li>
  * <li>LinkedList</li>
  * <li>Vector</li>
  * </ul>
@@ -279,101 +278,101 @@ public final class IllegalTypeCheck extends AbstractCheck {
     /**
      * Checks type of given variable.
      * @param variableDef variable to check.
      */
     private void visitVariableDef(DetailAST variableDef) {
         checkClassName(variableDef);
     }
 
     /**
      * Checks imported type (as static and star imports are not supported by Check,
      *  only type is in the consideration).<br>
      * If this type is illegal due to Check's options - puts violation on it.
      * @param importAst {@link TokenTypes#IMPORT Import}
      */
     private void visitImport(DetailAST importAst) {
         if (!isStarImport(importAst)) {
             final String canonicalName = getImportedTypeCanonicalName(importAst);
             extendIllegalClassNamesWithShortName(canonicalName);
         }
     }
 
     /**
      * Checks if current import is star import. E.g.:
      * <p>
      * {@code
      * import java.util.*;
      * }
      * </p>
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return true if it is star import
      */
     private static boolean isStarImport(DetailAST importAst) {
         boolean result = false;
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.STAR) {
                 result = true;
                 break;
             }
         }
         return result;
     }
 
     /**
      * Checks type of given method, parameter or variable.
      * @param ast node to check.
      */
     private void checkClassName(DetailAST ast) {
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
-        final FullIdent ident = CheckUtils.createFullType(type);
+        final FullIdent ident = FullIdent.createFullIdent(type.getFirstChild());
 
         if (isMatchingClassName(ident.getText())) {
             log(ident.getLineNo(), ident.getColumnNo(),
                 MSG_KEY, ident.getText());
         }
     }
 
     /**
      * Returns true if given class name is one of illegal classes or else false.
      * @param className class name to check.
      * @return true if given class name is one of illegal classes
      *         or if it matches to abstract class names pattern.
      */
     private boolean isMatchingClassName(String className) {
         final String shortName = className.substring(className.lastIndexOf('.') + 1);
         return illegalClassNames.contains(className)
                 || illegalShortClassNames.contains(shortName)
                 || validateAbstractClassNames
                     && !legalAbstractClassNames.contains(className)
                     && format.matcher(className).find();
     }
 
     /**
      * Extends illegal class names set via imported short type name.
      * @param canonicalName
      *  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  Canonical</a> name of imported type.
      */
     private void extendIllegalClassNamesWithShortName(String canonicalName) {
         if (illegalClassNames.contains(canonicalName)) {
             final String shortName = canonicalName
                 .substring(canonicalName.lastIndexOf('.') + 1);
             illegalShortClassNames.add(shortName);
         }
     }
 
     /**
      * Gets imported type's
      * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">
      *  canonical name</a>.
      * @param importAst {@link TokenTypes#IMPORT Import}
      * @return Imported canonical type's name.
      */
     private static String getImportedTypeCanonicalName(DetailAST importAst) {
         final StringBuilder canonicalNameBuilder = new StringBuilder(256);
         DetailAST toVisit = importAst;
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, importAst);
             if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
                 canonicalNameBuilder.append(toVisit.getText());
