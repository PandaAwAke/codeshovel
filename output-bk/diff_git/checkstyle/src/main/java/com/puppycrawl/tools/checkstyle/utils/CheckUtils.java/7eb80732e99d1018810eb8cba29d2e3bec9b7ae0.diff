diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
index 3115322b8..484c0b90e 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtils.java
@@ -90,109 +90,109 @@ public final class CheckUtils {
         final DetailAST nameNode = ast.findFirstToken(TokenTypes.IDENT);
         final String name = nameNode.getText();
         if (!"equals".equals(name)) {
             return false;
         }
 
         // one parameter?
         final DetailAST paramsNode = ast.findFirstToken(TokenTypes.PARAMETERS);
         return paramsNode.getChildCount() == 1;
     }
 
     /**
      * Returns whether a token represents an ELSE as part of an ELSE / IF set.
      * @param ast the token to check
      * @return whether it is
      */
     public static boolean isElseIf(DetailAST ast) {
         final DetailAST parentAST = ast.getParent();
 
         return ast.getType() == TokenTypes.LITERAL_IF
             && (isElse(parentAST) || isElseWithCurlyBraces(parentAST));
     }
 
     /**
      * Returns whether a token represents an ELSE.
      * @param ast the token to check
      * @return whether the token represents an ELSE
      */
     private static boolean isElse(DetailAST ast) {
         return ast.getType() == TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * Returns whether a token represents an SLIST as part of an ELSE
      * statement.
      * @param ast the token to check
      * @return whether the toke does represent an SLIST as part of an ELSE
      */
     private static boolean isElseWithCurlyBraces(DetailAST ast) {
         return ast.getType() == TokenTypes.SLIST
             && ast.getChildCount() == 2
             && isElse(ast.getParent());
     }
 
     /**
      * Creates {@code FullIdent} for given type node.
      * @param typeAST a type node.
      * @return {@code FullIdent} for given type.
      */
     public static FullIdent createFullType(DetailAST typeAST) {
-        final DetailAST arrayDeclAST =
+        final DetailAST arrayDeclaratorAST =
             typeAST.findFirstToken(TokenTypes.ARRAY_DECLARATOR);
         final FullIdent fullType;
 
-        if (arrayDeclAST == null) {
+        if (arrayDeclaratorAST == null) {
             fullType = createFullTypeNoArrays(typeAST);
         }
         else {
-            fullType = createFullTypeNoArrays(arrayDeclAST);
+            fullType = createFullTypeNoArrays(arrayDeclaratorAST);
         }
         return fullType;
     }
 
     /**
      * @param typeAST a type node (no array)
      * @return {@code FullIdent} for given type.
      */
     private static FullIdent createFullTypeNoArrays(DetailAST typeAST) {
         return FullIdent.createFullIdent(typeAST.getFirstChild());
     }
 
     /**
      * Returns the value represented by the specified string of the specified
      * type. Returns 0 for types other than float, double, int, and long.
      * @param text the string to be parsed.
      * @param type the token type of the text. Should be a constant of
      * {@link TokenTypes}.
      * @return the double value represented by the string argument.
      */
     public static double parseDouble(String text, int type) {
         String txt = UNDERSCORE_PATTERN.matcher(text).replaceAll("");
         double result = 0;
         switch (type) {
             case TokenTypes.NUM_FLOAT:
             case TokenTypes.NUM_DOUBLE:
                 result = Double.parseDouble(txt);
                 break;
             case TokenTypes.NUM_INT:
             case TokenTypes.NUM_LONG:
                 int radix = BASE_10;
                 if (txt.startsWith("0x") || txt.startsWith("0X")) {
                     radix = BASE_16;
                     txt = txt.substring(2);
                 }
                 else if (txt.charAt(0) == '0') {
                     radix = BASE_8;
                     txt = txt.substring(1);
                 }
                 if (CommonUtils.endsWithChar(txt, 'L') || CommonUtils.endsWithChar(txt, 'l')) {
                     txt = txt.substring(0, txt.length() - 1);
                 }
                 if (!txt.isEmpty()) {
                     if (type == TokenTypes.NUM_INT) {
                         result = parseInt(txt, radix);
                     }
                     else {
                         result = parseLong(txt, radix);
                     }
                 }
@@ -223,130 +223,130 @@ public final class CheckUtils {
             result += digit;
         }
         return result;
     }
 
     /**
      * Parses the string argument as a signed long in the radix specified by
      * the second argument. The characters in the string must all be digits of
      * the specified radix. Handles negative values, which method
      * java.lang.Integer.parseInt(String, int) does not.
      * @param text the String containing the integer representation to be
      * parsed. Precondition: text contains a parsable int.
      * @param radix the radix to be used while parsing text.
      * @return the long represented by the string argument in the specified
      * radix.
      */
     public static long parseLong(String text, int radix) {
         long result = 0;
         final int max = text.length();
         for (int i = 0; i < max; i++) {
             final int digit = Character.digit(text.charAt(i), radix);
             result *= radix;
             result += digit;
         }
         return result;
     }
 
     /**
      * Finds sub-node for given node minimal (line, column) pair.
      * @param node the root of tree for search.
      * @return sub-node with minimal (line, column) pair.
      */
     public static DetailAST getFirstNode(final DetailAST node) {
         DetailAST currentNode = node;
         DetailAST child = node.getFirstChild();
         while (child != null) {
             final DetailAST newNode = getFirstNode(child);
             if (newNode.getLineNo() < currentNode.getLineNo()
                 || newNode.getLineNo() == currentNode.getLineNo()
                     && newNode.getColumnNo() < currentNode.getColumnNo()) {
                 currentNode = newNode;
             }
             child = child.getNextSibling();
         }
 
         return currentNode;
     }
 
     /**
      * Retrieves the names of the type parameters to the node.
-     * @param node the parameterised AST node
+     * @param node the parameterized AST node
      * @return a list of type parameter names
      */
     public static List<String> getTypeParameterNames(final DetailAST node) {
         final DetailAST typeParameters =
             node.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
-        final List<String> typeParanames = Lists.newArrayList();
+        final List<String> typeParameterNames = Lists.newArrayList();
         if (typeParameters != null) {
             final DetailAST typeParam =
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
-            typeParanames.add(
-                typeParam.findFirstToken(TokenTypes.IDENT).getText());
+            typeParameterNames.add(
+                    typeParam.findFirstToken(TokenTypes.IDENT).getText());
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
-                    typeParanames.add(
-                        sibling.findFirstToken(TokenTypes.IDENT).getText());
+                    typeParameterNames.add(
+                            sibling.findFirstToken(TokenTypes.IDENT).getText());
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
-        return typeParanames;
+        return typeParameterNames;
     }
 
     /**
      * Retrieves the type parameters to the node.
-     * @param node the parameterised AST node
+     * @param node the parameterized AST node
      * @return a list of type parameter names
      */
     public static List<DetailAST> getTypeParameters(final DetailAST node) {
         final DetailAST typeParameters =
             node.findFirstToken(TokenTypes.TYPE_PARAMETERS);
 
         final List<DetailAST> typeParams = Lists.newArrayList();
         if (typeParameters != null) {
             final DetailAST typeParam =
                 typeParameters.findFirstToken(TokenTypes.TYPE_PARAMETER);
             typeParams.add(typeParam);
 
             DetailAST sibling = typeParam.getNextSibling();
             while (sibling != null) {
                 if (sibling.getType() == TokenTypes.TYPE_PARAMETER) {
                     typeParams.add(sibling);
                 }
                 sibling = sibling.getNextSibling();
             }
         }
 
         return typeParams;
     }
 
     /**
      * Returns whether an AST represents a setter method.
      * @param ast the AST to check with
      * @return whether the AST represents a setter method
      */
     public static boolean isSetterMethod(final DetailAST ast) {
         // Check have a method with exactly 7 children which are all that
         // is allowed in a proper setter method which does not throw any
         // exceptions.
         if (ast.getType() != TokenTypes.METHOD_DEF
                 || ast.getChildCount() != SETTER_GETTER_MAX_CHILDREN) {
             return false;
         }
 
         // Should I handle only being in a class????
 
         // Check the name matches format setX...
         final DetailAST type = ast.findFirstToken(TokenTypes.TYPE);
         final String name = type.getNextSibling().getText();
 
         // Depends on JDK 1.4
         if (!SETTER_PATTERN.matcher(name).matches()) {
             return false;
         }
 
         // Check the return type is void
