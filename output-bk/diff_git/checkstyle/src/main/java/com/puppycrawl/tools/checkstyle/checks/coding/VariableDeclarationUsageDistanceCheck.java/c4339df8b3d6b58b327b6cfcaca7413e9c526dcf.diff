diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index 2e4608e08..4aded473f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -285,102 +285,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
                                 MSG_KEY, variable.getText(), dist, allowedDistance);
                     }
                 }
             }
         }
     }
 
     /**
      * Get name of instance whose method is called.
      * @param methodCallAst
      *        DetailAST of METHOD_CALL.
      * @return name of instance.
      */
     private static String getInstanceName(DetailAST methodCallAst) {
         final String methodCallName =
                 FullIdent.createFullIdentBelow(methodCallAst).getText();
         final int lastDotIndex = methodCallName.lastIndexOf('.');
         String instanceName = "";
         if (lastDotIndex != -1) {
             instanceName = methodCallName.substring(0, lastDotIndex);
         }
         return instanceName;
     }
 
     /**
      * Processes statements until usage of variable to detect sequence of
      * initialization methods.
      * @param variableUsageAst
      *        DetailAST of expression that uses variable named variableName.
      * @param variableName
      *        name of considered variable.
      * @return true if statements between declaration and usage of variable are
      *         initialization methods.
      */
     private static boolean isInitializationSequence(
             DetailAST variableUsageAst, String variableName) {
         boolean result = true;
         boolean isUsedVariableDeclarationFound = false;
         DetailAST currentSiblingAst = variableUsageAst;
         String initInstanceName = "";
 
         while (result
                 && !isUsedVariableDeclarationFound
                 && currentSiblingAst != null) {
 
             switch (currentSiblingAst.getType()) {
 
                 case TokenTypes.EXPR:
                     final DetailAST methodCallAst = currentSiblingAst.getFirstChild();
 
-                    if (methodCallAst != null
-                        && methodCallAst.getType() == TokenTypes.METHOD_CALL) {
+                    if (methodCallAst.getType() == TokenTypes.METHOD_CALL) {
                         final String instanceName =
                             getInstanceName(methodCallAst);
                         // method is called without instance
                         if (instanceName.isEmpty()) {
                             result = false;
                         }
                         // differs from previous instance
                         else if (!instanceName.equals(initInstanceName)) {
                             if (initInstanceName.isEmpty()) {
                                 initInstanceName = instanceName;
                             }
                             else {
                                 result = false;
                             }
                         }
                     }
                     else { // is not method call
                         result = false;
                     }
                     break;
 
                 case TokenTypes.VARIABLE_DEF:
                     final String currentVariableName = currentSiblingAst
                         .findFirstToken(TokenTypes.IDENT).getText();
                     isUsedVariableDeclarationFound = variableName.equals(currentVariableName);
                     break;
 
                 case TokenTypes.SEMI:
                     break;
 
                 default:
                     result = false;
             }
 
             currentSiblingAst = currentSiblingAst.getPreviousSibling();
         }
 
         return result;
     }
 
     /**
      * Calculates distance between declaration of variable and its first usage
      * in single scope.
      * @param semicolonAst
      *        Regular node of Ast which is checked for content of checking
      *        variable.
      * @param variableIdentAst
      *        Variable which distance is calculated for.
      * @return entry which contains expression with variable usage and distance.
      */
@@ -511,116 +510,111 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
                         exprWithVariableUsage = blockWithVariableUsage.getFirstChild();
                 }
                 currentScopeAst = exprWithVariableUsage;
                 if (exprWithVariableUsage != null) {
                     variableUsageAst = exprWithVariableUsage;
                 }
                 else {
                     variableUsageAst = blockWithVariableUsage;
                 }
             }
             // If variable usage exists in different scopes, then distance =
             // distance until variable first usage.
             else if (variableUsageExpressions.size() > 1) {
                 dist++;
                 variableUsageAst = variableUsageExpressions.get(0);
             }
             // If there's no any variable usage, then distance = 0.
             else {
                 variableUsageAst = null;
             }
         }
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Gets first Ast node inside FOR, WHILE or DO-WHILE blocks if variable
      * usage is met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents FOR, WHILE or DO-WHILE block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode;
 
             // Find currentNode for DO-WHILE block.
             if (block.getType() == TokenTypes.LITERAL_DO) {
                 currentNode = block.getFirstChild();
             }
             // Find currentNode for FOR or WHILE block.
             else {
                 // Looking for RPAREN ( ')' ) token to mark the end of operator
                 // expression.
-                currentNode = block.findFirstToken(TokenTypes.RPAREN);
-                if (currentNode != null) {
-                    currentNode = currentNode.getNextSibling();
-                }
+                currentNode = block.findFirstToken(TokenTypes.RPAREN).getNextSibling();
             }
 
-            if (currentNode != null) {
-                final int currentNodeType = currentNode.getType();
+            final int currentNodeType = currentNode.getType();
 
-                if (currentNodeType == TokenTypes.SLIST) {
-                    firstNodeInsideBlock = currentNode.getFirstChild();
-                }
-                else if (currentNodeType != TokenTypes.VARIABLE_DEF
-                        && currentNodeType != TokenTypes.EXPR) {
-                    firstNodeInsideBlock = currentNode;
-                }
+            if (currentNodeType == TokenTypes.SLIST) {
+                firstNodeInsideBlock = currentNode.getFirstChild();
+            }
+            else if (currentNodeType != TokenTypes.VARIABLE_DEF
+                    && currentNodeType != TokenTypes.EXPR) {
+                firstNodeInsideBlock = currentNode;
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside IF block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents IF block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideIfBlock(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = block.getLastChild();
             final List<DetailAST> variableUsageExpressions =
                     new ArrayList<>();
 
             while (currentNode != null
                     && currentNode.getType() == TokenTypes.LITERAL_ELSE) {
                 final DetailAST previousNode =
                         currentNode.getPreviousSibling();
 
                 // Checking variable usage inside IF block.
                 if (isChild(previousNode, variable)) {
                     variableUsageExpressions.add(previousNode);
                 }
 
                 // Looking into ELSE block, get its first child and analyze it.
                 currentNode = currentNode.getFirstChild();
 
                 if (currentNode.getType() == TokenTypes.LITERAL_IF) {
                     currentNode = currentNode.getLastChild();
                 }
                 else if (isChild(currentNode, variable)) {
                     variableUsageExpressions.add(currentNode);
                     currentNode = null;
                 }
             }
 
             // If IF block doesn't include ELSE than analyze variable usage
             // only inside IF block.
@@ -717,154 +711,143 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
             final DetailAST catchBlock = currentNode.getLastChild();
 
             if (isChild(catchBlock, variable)) {
                 variableUsageExpressions.add(catchBlock);
             }
             currentNode = currentNode.getNextSibling();
         }
 
         // Checking variable usage inside FINALLY block.
         if (currentNode != null) {
             final DetailAST finalBlock = currentNode.getLastChild();
 
             if (isChild(finalBlock, variable)) {
                 variableUsageExpressions.add(finalBlock);
             }
         }
 
         DetailAST variableUsageNode = null;
 
         // If variable usage exists in several related blocks, then
         // firstNodeInsideBlock = null, otherwise if variable usage exists
         // only inside one block, then get node from
         // variableUsageExpressions.
         if (variableUsageExpressions.size() == 1) {
             variableUsageNode = variableUsageExpressions.get(0).getFirstChild();
         }
 
         return variableUsageNode;
     }
 
     /**
      * Checks if variable is in operator declaration. For instance:
      * <pre>
      * boolean b = true;
      * if (b) {...}
      * </pre>
      * Variable 'b' is in declaration of operator IF.
      * @param operator
      *        Ast node which represents operator.
      * @param variable
      *        Variable which is checked for content in operator.
      * @return true if operator contains variable in its declaration, otherwise
      *         - false.
      */
     private static boolean isVariableInOperatorExpr(
             DetailAST operator, DetailAST variable) {
         boolean isVarInOperatorDeclr = false;
         final DetailAST openingBracket =
                 operator.findFirstToken(TokenTypes.LPAREN);
 
-        if (openingBracket != null) {
-            // Get EXPR between brackets
-            DetailAST exprBetweenBrackets = openingBracket
-                    .getNextSibling();
+        // Get EXPR between brackets
+        DetailAST exprBetweenBrackets = openingBracket.getNextSibling();
 
-            // Look if variable is in operator expression
-            while (exprBetweenBrackets.getType() != TokenTypes.RPAREN) {
+        // Look if variable is in operator expression
+        while (exprBetweenBrackets.getType() != TokenTypes.RPAREN) {
 
-                if (isChild(exprBetweenBrackets, variable)) {
-                    isVarInOperatorDeclr = true;
-                    break;
-                }
-                exprBetweenBrackets = exprBetweenBrackets.getNextSibling();
+            if (isChild(exprBetweenBrackets, variable)) {
+                isVarInOperatorDeclr = true;
+                break;
             }
+            exprBetweenBrackets = exprBetweenBrackets.getNextSibling();
+        }
 
-            // Variable may be met in ELSE declaration or in CASE declaration.
-            // So, check variable usage in these declarations.
-            if (!isVarInOperatorDeclr) {
-                switch (operator.getType()) {
-                    case TokenTypes.LITERAL_IF:
-                        final DetailAST elseBlock = operator.getLastChild();
-
-                        if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
-                            // Get IF followed by ELSE
-                            final DetailAST firstNodeInsideElseBlock = elseBlock
-                                .getFirstChild();
-
-                            if (firstNodeInsideElseBlock.getType() == TokenTypes.LITERAL_IF) {
-                                isVarInOperatorDeclr |=
-                                    isVariableInOperatorExpr(
-                                        firstNodeInsideElseBlock,
-                                            variable);
-                            }
-                        }
-                        break;
+        // Variable may be met in ELSE declaration or in CASE declaration.
+        // So, check variable usage in these declarations.
+        if (!isVarInOperatorDeclr) {
+            switch (operator.getType()) {
+            case TokenTypes.LITERAL_IF:
+                final DetailAST elseBlock = operator.getLastChild();
 
-                    case TokenTypes.LITERAL_SWITCH:
-                        DetailAST currentCaseBlock = operator
-                            .findFirstToken(TokenTypes.CASE_GROUP);
-
-                        while (currentCaseBlock != null
-                            && currentCaseBlock.getType() == TokenTypes.CASE_GROUP) {
-                            final DetailAST firstNodeInsideCaseBlock =
-                                currentCaseBlock.getFirstChild();
-
-                            if (isChild(firstNodeInsideCaseBlock,
-                                variable)) {
-                                isVarInOperatorDeclr = true;
-                                break;
-                            }
-                            currentCaseBlock = currentCaseBlock.getNextSibling();
+                if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
+                    // Get IF followed by ELSE
+                    final DetailAST firstNodeInsideElseBlock = elseBlock.getFirstChild();
+
+                    if (firstNodeInsideElseBlock.getType() == TokenTypes.LITERAL_IF) {
+                        isVarInOperatorDeclr |= isVariableInOperatorExpr(firstNodeInsideElseBlock, variable);
                         }
-                        break;
+                }
+                break;
 
-                    default:
-                        // no code
+            case TokenTypes.LITERAL_SWITCH:
+                DetailAST currentCaseBlock = operator.findFirstToken(TokenTypes.CASE_GROUP);
+
+                while (currentCaseBlock != null && currentCaseBlock.getType() == TokenTypes.CASE_GROUP) {
+                    final DetailAST firstNodeInsideCaseBlock = currentCaseBlock.getFirstChild();
+
+                    if (isChild(firstNodeInsideCaseBlock, variable)) {
+                        isVarInOperatorDeclr = true;
+                        break;
+                        }
+                    currentCaseBlock = currentCaseBlock.getNextSibling();
                 }
+                break;
+
+            default:
+                // no code
             }
         }
 
         return isVarInOperatorDeclr;
     }
 
     /**
      * Checks if Ast node contains given element.
      * @param parent
      *        Node of AST.
      * @param ast
      *        Ast element which is checked for content in Ast node.
      * @return true if Ast element was found in Ast node, otherwise - false.
      */
     private static boolean isChild(DetailAST parent, DetailAST ast) {
         boolean isChild = false;
         final ASTEnumeration astList = parent.findAllPartial(ast);
 
         while (astList.hasMoreNodes()) {
             final DetailAST astNode = (DetailAST) astList.nextNode();
             DetailAST astParent = astNode.getParent();
 
             while (astParent != null) {
 
                 if (astParent.equals(parent)
                         && astParent.getLineNo() == parent.getLineNo()) {
                     isChild = true;
                     break;
                 }
                 astParent = astParent.getParent();
             }
         }
 
         return isChild;
     }
 
     /**
      * Checks if entrance variable is contained in ignored pattern.
      * @param variable
      *        Variable which is checked for content in ignored pattern.
      * @return true if variable was found, otherwise - false.
      */
     private boolean isVariableMatchesIgnorePattern(String variable) {
         final Matcher matcher = ignoreVariablePattern.matcher(variable);
         return matcher.matches();
     }
 }
