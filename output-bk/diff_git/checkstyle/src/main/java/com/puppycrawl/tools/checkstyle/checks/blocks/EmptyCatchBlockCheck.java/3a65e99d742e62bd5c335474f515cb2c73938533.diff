diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
index 661de3185..fbeb65046 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java
@@ -129,113 +129,113 @@ import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 public class EmptyCatchBlockCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_CATCH_BLOCK_EMPTY = "catch.block.empty";
 
     /** Format of skipping exception's variable name. */
     private String exceptionVariableName = "^$";
 
     /** Format of comment. */
     private String commentFormat = ".*";
 
     /**
      * Regular expression pattern compiled from exception's variable name.
      */
     private Pattern variableNameRegexp = Pattern.compile(exceptionVariableName);
 
     /**
      * Regular expression pattern compiled from comment's format.
      */
     private Pattern commentRegexp = Pattern.compile(commentFormat);
 
     /**
      * Setter for exception's variable name format.
      * @param exceptionVariableName
      *        format of exception's variable name.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object.
      */
     public void setExceptionVariableName(String exceptionVariableName) {
         this.exceptionVariableName = exceptionVariableName;
         variableNameRegexp = CommonUtils.createPattern(exceptionVariableName);
     }
 
     /**
      * Setter for comment format.
      * @param commentFormat
      *        format of comment.
      * @throws org.apache.commons.beanutils.ConversionException
      *         if unable to create Pattern object.
      */
     public void setCommentFormat(String commentFormat) {
         this.commentFormat = commentFormat;
         commentRegexp = CommonUtils.createPattern(commentFormat);
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {
-            TokenTypes.LITERAL_CATCH,
-        };
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getAcceptableTokens();
+        return new int[] {
+            TokenTypes.LITERAL_CATCH,
+        };
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         visitCatchBlock(ast);
     }
 
     /**
      * Visits catch ast node, if it is empty catch block - checks it according to
      *  Check's options. If exception's variable name or comment inside block are matching
      *   specified regexp - skips from consideration, else - puts violation.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      */
     private void visitCatchBlock(DetailAST catchAst) {
         if (isEmptyCatchBlock(catchAst)) {
             final String commentContent = getCommentFirstLine(catchAst);
             if (isVerifiable(catchAst, commentContent)) {
                 log(catchAst.getLineNo(), MSG_KEY_CATCH_BLOCK_EMPTY);
             }
         }
     }
 
     /**
      * Gets the first line of comment in catch block. If comment is single-line -
      *  returns it fully, else if comment is multi-line - returns the first line.
      * @param catchAst {@link TokenTypes#LITERAL_CATCH LITERAL_CATCH}
      * @return the first line of comment in catch block, "" if no comment was found.
      */
     private static String getCommentFirstLine(DetailAST catchAst) {
         final DetailAST slistToken = catchAst.getLastChild();
         final DetailAST firstElementInBlock = slistToken.getFirstChild();
         String commentContent = "";
         if (firstElementInBlock.getType() == TokenTypes.SINGLE_LINE_COMMENT) {
             commentContent = firstElementInBlock.getFirstChild().getText();
         }
         else if (firstElementInBlock.getType() == TokenTypes.BLOCK_COMMENT_BEGIN) {
             commentContent = firstElementInBlock.getFirstChild().getText();
             final String[] lines = commentContent.split(System.getProperty("line.separator"));
             for (String line : lines) {
                 if (!line.isEmpty()) {
                     commentContent = line;
                     break;
                 }
             }
         }
