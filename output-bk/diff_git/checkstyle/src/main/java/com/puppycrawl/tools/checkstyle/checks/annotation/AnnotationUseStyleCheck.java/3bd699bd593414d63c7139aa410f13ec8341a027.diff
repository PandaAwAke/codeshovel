diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
index 74975d59e..41f0a3c68 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
@@ -119,351 +119,351 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  *
  * @author Travis Schneeberger
  */
 public final class AnnotationUseStyleCheck extends Check {
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_INCORRECT_STYLE =
         "annotation.incorrect.style";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_PARENS_MISSING =
         "annotation.parens.missing";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_PARENS_PRESENT =
         "annotation.parens.present";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING =
         "annotation.trailing.comma.missing";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT =
         "annotation.trailing.comma.present";
 
     /**
      * the element name used to receive special linguistic support
      * for annotation use.
      */
     private static final String ANNOTATION_ELEMENT_SINGLE_NAME =
             "value";
 
     //not extending AbstractOptionCheck because check
     //has more than one option type.
 
     /** @see #setElementStyle(String) */
-    private ElementStyle style = ElementStyle.COMPACT_NO_ARRAY;
+    private ElementStyle elementStyle = ElementStyle.COMPACT_NO_ARRAY;
 
     //defaulting to NEVER because of the strange compiler behavior
     /** @see #setTrailingArrayComma(String) */
-    private TrailingArrayComma comma = TrailingArrayComma.NEVER;
+    private TrailingArrayComma trailingArrayComma = TrailingArrayComma.NEVER;
 
     /** @see #setClosingParens(String) */
-    private ClosingParens parens = ClosingParens.NEVER;
+    private ClosingParens closingParens = ClosingParens.NEVER;
 
     /**
      * Sets the ElementStyle from a string.
      *
      * @param style string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setElementStyle(final String style) {
-        this.style = getOption(ElementStyle.class, style);
+        this.elementStyle = getOption(ElementStyle.class, style);
     }
 
     /**
      * Sets the TrailingArrayComma from a string.
      *
      * @param comma string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setTrailingArrayComma(final String comma) {
-        this.comma = getOption(TrailingArrayComma.class, comma);
+        this.trailingArrayComma = getOption(TrailingArrayComma.class, comma);
     }
 
     /**
      * Sets the ClosingParens from a string.
      *
      * @param parens string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setClosingParens(final String parens) {
-        this.parens = getOption(ClosingParens.class, parens);
+        this.closingParens = getOption(ClosingParens.class, parens);
     }
 
     /**
      * Retrieves an {@link Enum Enum} type from a @{link String String}.
      * @param <T> the enum type
      * @param enuclass the enum class
      * @param value the string representing the enum
      * @return the enum type
      */
     private static <T extends Enum<T>> T getOption(final Class<T> enuclass,
         final String value) {
         try {
             return Enum.valueOf(enuclass, value.trim().toUpperCase(Locale.ENGLISH));
         }
         catch (final IllegalArgumentException iae) {
             throw new ConversionException("unable to parse " + value, iae);
         }
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.ANNOTATION,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         checkStyleType(ast);
         checkCheckClosingParens(ast);
         checkTrailingComma(ast);
     }
 
     /**
      * Checks to see if the
      * {@link ElementStyle AnnotationElementStyle}
      * is correct.
      *
      * @param annotation the annotation token
      */
     private void checkStyleType(final DetailAST annotation) {
 
-        switch (style) {
+        switch (elementStyle) {
             case COMPACT_NO_ARRAY:
                 checkCompactNoArrayStyle(annotation);
                 break;
             case COMPACT:
                 checkCompactStyle(annotation);
                 break;
             case EXPANDED:
                 checkExpandedStyle(annotation);
                 break;
             default:
                 break;
         }
     }
 
     /**
      * Checks for expanded style type violations.
      *
      * @param annotation the annotation token
      */
     private void checkExpandedStyle(final DetailAST annotation) {
         final int valuePairCount =
             annotation.getChildCount(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         if (valuePairCount == 0
             && annotation.branchContains(TokenTypes.EXPR)) {
             log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.EXPANDED);
         }
     }
 
     /**
      * Checks for compact style type violations.
      *
      * @param annotation the annotation token
      */
     private void checkCompactStyle(final DetailAST annotation) {
         final int valuePairCount =
             annotation.getChildCount(
                 TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         final DetailAST valuePair =
             annotation.findFirstToken(
                 TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         if (valuePairCount == 1
             && ANNOTATION_ELEMENT_SINGLE_NAME.equals(
                 valuePair.getFirstChild().getText())) {
             log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.COMPACT);
         }
     }
 
     /**
      * Checks for compact no array style type violations.
      *
      * @param annotation the annotation token
      */
     private void checkCompactNoArrayStyle(final DetailAST annotation) {
         final DetailAST arrayInit =
             annotation.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
 
         final int valuePairCount =
             annotation.getChildCount(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         final DetailAST valuePair =
             annotation.findFirstToken(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);
 
         //in compact style with one value
         if (arrayInit != null
             && arrayInit.getChildCount(TokenTypes.EXPR) == 1) {
             log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                 ElementStyle.COMPACT_NO_ARRAY);
         }
         //in expanded style with one value and the correct element name
         else if (valuePairCount == 1) {
             final DetailAST nestedArrayInit =
                 valuePair.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
 
             if (nestedArrayInit != null
                 && ANNOTATION_ELEMENT_SINGLE_NAME.equals(
                     valuePair.getFirstChild().getText())
                     && nestedArrayInit.getChildCount(TokenTypes.EXPR) == 1) {
                 log(annotation.getLineNo(), MSG_KEY_ANNOTATION_INCORRECT_STYLE,
                     ElementStyle.COMPACT_NO_ARRAY);
             }
         }
     }
 
     /**
      * Checks to see if the trailing comma is present if required or
      * prohibited.
      *
      * @param annotation the annotation token
      */
     private void checkTrailingComma(final DetailAST annotation) {
-        if (comma == TrailingArrayComma.IGNORE) {
+        if (trailingArrayComma == TrailingArrayComma.IGNORE) {
             return;
         }
 
         DetailAST child = annotation.getFirstChild();
 
         while (child != null) {
             DetailAST arrayInit = null;
 
             if (child.getType() == TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR) {
                 arrayInit = child.findFirstToken(TokenTypes.ANNOTATION_ARRAY_INIT);
             }
             else if (child.getType() == TokenTypes.ANNOTATION_ARRAY_INIT) {
                 arrayInit = child;
             }
 
             if (arrayInit != null) {
                 logCommaViolation(arrayInit);
             }
             child = child.getNextSibling();
         }
     }
 
     /**
      * logs a trailing array comma violation if one exists.
      *
      * @param ast the array init
      * {@link TokenTypes#ANNOTATION_ARRAY_INIT ANNOTATION_ARRAY_INIT}.
      */
     private void logCommaViolation(final DetailAST ast) {
         final DetailAST rCurly = ast.findFirstToken(TokenTypes.RCURLY);
 
         //comma can be null if array is empty
         final DetailAST comma = rCurly.getPreviousSibling();
 
-        if (this.comma == TrailingArrayComma.ALWAYS
+        if (this.trailingArrayComma == TrailingArrayComma.ALWAYS
             && (comma == null || comma.getType() != TokenTypes.COMMA)) {
             log(rCurly.getLineNo(),
                 rCurly.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_MISSING);
         }
-        else if (this.comma == TrailingArrayComma.NEVER
+        else if (this.trailingArrayComma == TrailingArrayComma.NEVER
             && comma != null && comma.getType() == TokenTypes.COMMA) {
             log(comma.getLineNo(),
                 comma.getColumnNo(), MSG_KEY_ANNOTATION_TRAILING_COMMA_PRESENT);
         }
     }
 
     /**
      * Checks to see if the closing parenthesis are present if required or
      * prohibited.
      *
      * @param ast the annotation token
      */
     private void checkCheckClosingParens(final DetailAST ast) {
-        if (parens == ClosingParens.IGNORE) {
+        if (closingParens == ClosingParens.IGNORE) {
             return;
         }
 
         final DetailAST paren = ast.getLastChild();
         final boolean parenExists = paren.getType() == TokenTypes.RPAREN;
 
-        if (parens == ClosingParens.ALWAYS
+        if (closingParens == ClosingParens.ALWAYS
             && !parenExists) {
             log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_MISSING);
         }
-        else if (parens == ClosingParens.NEVER
+        else if (closingParens == ClosingParens.NEVER
             && !ast.branchContains(TokenTypes.EXPR)
             && !ast.branchContains(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR)
             && !ast.branchContains(TokenTypes.ANNOTATION_ARRAY_INIT)
             && parenExists) {
             log(ast.getLineNo(), MSG_KEY_ANNOTATION_PARENS_PRESENT);
         }
     }
 
     /**
      * Defines the styles for defining elements in an annotation.
      * @author Travis Schneeberger
      */
     public enum ElementStyle {
 
         /**
          * expanded example
          *
          * <pre>@SuppressWarnings(value={"unchecked","unused",})</pre>.
          */
         EXPANDED,
 
         /**
          * compact example
          *
          * <pre>@SuppressWarnings({"unchecked","unused",})</pre>
          * <br>or<br>
          * <pre>@SuppressWarnings("unchecked")</pre>.
          */
         COMPACT,
 
         /**
          * compact example.]
          *
          * <pre>@SuppressWarnings("unchecked")</pre>.
          */
         COMPACT_NO_ARRAY,
 
         /**
          * mixed styles.
          */
         IGNORE,
     }
 
     /**
      * Defines the two styles for defining
      * elements in an annotation.
      *
      * @author Travis Schneeberger
      */
     public enum TrailingArrayComma {
