diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
index f7bde8d48..8c7c522a7 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java
@@ -47,104 +47,101 @@ import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
  * @author Daniel Grenner
  * @author Travis Schneeberger
  */
 public class JavadocStyleCheck
     extends AbstractCheck {
 
     /** Message property key for the Unclosed HTML message. */
     public static final String MSG_JAVADOC_MISSING = "javadoc.missing";
 
     /** Message property key for the Unclosed HTML message. */
     public static final String MSG_EMPTY = "javadoc.empty";
 
     /** Message property key for the Unclosed HTML message. */
     public static final String MSG_NO_PERIOD = "javadoc.noPeriod";
 
     /** Message property key for the Unclosed HTML message. */
     public static final String MSG_INCOMPLETE_TAG = "javadoc.incompleteTag";
 
     /** Message property key for the Unclosed HTML message. */
     public static final String MSG_UNCLOSED_HTML = "javadoc.unclosedHtml";
 
     /** Message property key for the Extra HTML message. */
     public static final String MSG_EXTRA_HTML = "javadoc.extraHtml";
 
     /** HTML tags that do not require a close tag. */
     private static final Set<String> SINGLE_TAGS = Collections.unmodifiableSortedSet(Stream.of(
         "br", "li", "dt", "dd", "hr", "img", "p", "td", "tr", "th")
         .collect(Collectors.toCollection(TreeSet::new)));
 
     /** HTML tags that are allowed in java docs.
      * From http://www.w3schools.com/tags/default.asp
      * The forms and structure tags are not allowed
      */
     private static final Set<String> ALLOWED_TAGS = Collections.unmodifiableSortedSet(Stream.of(
         "a", "abbr", "acronym", "address", "area", "b", "bdo", "big",
         "blockquote", "br", "caption", "cite", "code", "colgroup", "dd",
         "del", "div", "dfn", "dl", "dt", "em", "fieldset", "font", "h1",
         "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "ins", "kbd",
         "li", "ol", "p", "pre", "q", "samp", "small", "span", "strong",
         "style", "sub", "sup", "table", "tbody", "td", "tfoot", "th",
         "thead", "tr", "tt", "u", "ul", "var")
         .collect(Collectors.toCollection(TreeSet::new)));
 
     /** The scope to check. */
     private Scope scope = Scope.PRIVATE;
 
     /** The visibility scope where Javadoc comments shouldn't be checked. **/
     private Scope excludeScope;
 
     /** Format for matching the end of a sentence. */
-    private String endOfSentenceFormat = "([.?!][ \t\n\r\f<])|([.?!]$)";
-
-    /** Regular expression for matching the end of a sentence. */
-    private Pattern endOfSentencePattern;
+    private Pattern endOfSentenceFormat = Pattern.compile("([.?!][ \t\n\r\f<])|([.?!]$)");
 
     /**
      * Indicates if the first sentence should be checked for proper end of
      * sentence punctuation.
      */
     private boolean checkFirstSentence = true;
 
     /**
      * Indicates if the HTML within the comment should be checked.
      */
     private boolean checkHtml = true;
 
     /**
      * Indicates if empty javadoc statements should be checked.
      */
     private boolean checkEmptyJavadoc;
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.PACKAGE_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (shouldCheck(ast)) {
             final FileContents contents = getFileContents();
             // Need to start searching for the comment before the annotations
             // that may exist. Even if annotations are not defined on the
             // package, the ANNOTATIONS AST is defined.
@@ -189,101 +186,101 @@ public class JavadocStyleCheck
     }
 
     /**
      * Performs the various checks against the Javadoc comment.
      *
      * @param ast the AST of the element being documented
      * @param comment the source lines that make up the Javadoc comment.
      *
      * @see #checkFirstSentenceEnding(DetailAST, TextBlock)
      * @see #checkHtmlTags(DetailAST, TextBlock)
      */
     private void checkComment(final DetailAST ast, final TextBlock comment) {
         if (comment == null) {
             // checking for missing docs in JavadocStyleCheck is not consistent
             // with the rest of CheckStyle...  Even though, I didn't think it
             // made sense to make another check just to ensure that the
             // package-info.java file actually contains package Javadocs.
             if (getFileContents().inPackageInfo()) {
                 log(ast.getLineNo(), MSG_JAVADOC_MISSING);
             }
         }
         else {
             if (checkFirstSentence) {
                 checkFirstSentenceEnding(ast, comment);
             }
 
             if (checkHtml) {
                 checkHtmlTags(ast, comment);
             }
 
             if (checkEmptyJavadoc) {
                 checkJavadocIsNotEmpty(comment);
             }
         }
     }
 
     /**
      * Checks that the first sentence ends with proper punctuation.  This method
      * uses a regular expression that checks for the presence of a period,
      * question mark, or exclamation mark followed either by whitespace, an
      * HTML element, or the end of string. This method ignores {_AT_inheritDoc}
      * comments for TokenTypes that are valid for {_AT_inheritDoc}.
      *
      * @param ast the current node
      * @param comment the source lines that make up the Javadoc comment.
      */
     private void checkFirstSentenceEnding(final DetailAST ast, TextBlock comment) {
         final String commentText = getCommentText(comment.getText());
 
         if (!commentText.isEmpty()
-            && !getEndOfSentencePattern().matcher(commentText).find()
+            && !endOfSentenceFormat.matcher(commentText).find()
             && !(commentText.startsWith("{@inheritDoc}")
             && JavadocTagInfo.INHERIT_DOC.isValidOn(ast))) {
             log(comment.getStartLineNo(), MSG_NO_PERIOD);
         }
     }
 
     /**
      * Checks that the Javadoc is not empty.
      *
      * @param comment the source lines that make up the Javadoc comment.
      */
     private void checkJavadocIsNotEmpty(TextBlock comment) {
         final String commentText = getCommentText(comment.getText());
 
         if (commentText.isEmpty()) {
             log(comment.getStartLineNo(), MSG_EMPTY);
         }
     }
 
     /**
      * Returns the comment text from the Javadoc.
      * @param comments the lines of Javadoc.
      * @return a comment text String.
      */
     private static String getCommentText(String... comments) {
         final StringBuilder builder = new StringBuilder();
         for (final String line : comments) {
             final int textStart = findTextStart(line);
 
             if (textStart != -1) {
                 if (line.charAt(textStart) == '@') {
                     //we have found the tag section
                     break;
                 }
                 builder.append(line.substring(textStart));
                 trimTail(builder);
                 builder.append('\n');
             }
         }
 
         return builder.toString().trim();
     }
 
     /**
      * Finds the index of the first non-whitespace character ignoring the
      * Javadoc comment start and end strings (&#47** and *&#47) as well as any
      * leading asterisk.
      * @param line the Javadoc comment line of text to scan.
      * @return the int index relative to 0 for the start of text
      *         or -1 if not found.
@@ -461,93 +458,81 @@ public class JavadocStyleCheck
      * @param tag the HtmlTag to check.
      * @return {@code true} if the HtmlTag is an allowed html tag.
      */
     private static boolean isAllowedTag(HtmlTag tag) {
         return ALLOWED_TAGS.contains(tag.getId().toLowerCase(Locale.ENGLISH));
     }
 
     /**
      * Determines if the given token is an extra HTML tag. This indicates that
      * a close tag was found that does not have a corresponding open tag.
      *
      * @param token an HTML tag id for which a close was found.
      * @param htmlStack a Stack of previous open HTML tags.
      * @return {@code false} if a previous open tag was found
      *         for the token.
      */
     private static boolean isExtraHtml(String token, Deque<HtmlTag> htmlStack) {
         boolean isExtra = true;
         for (final HtmlTag tag : htmlStack) {
             // Loop, looking for tags that are closed.
             // The loop is needed in case there are unclosed
             // tags on the stack. In that case, the stack would
             // not be empty, but this tag would still be extra.
             if (token.equalsIgnoreCase(tag.getId())) {
                 isExtra = false;
                 break;
             }
         }
 
         return isExtra;
     }
 
     /**
      * Sets the scope to check.
      * @param from string to get the scope from
      */
     public void setScope(String from) {
         scope = Scope.getInstance(from);
     }
 
     /**
      * Set the excludeScope.
      * @param excludeScope a {@code String} value
      */
     public void setExcludeScope(String excludeScope) {
         this.excludeScope = Scope.getInstance(excludeScope);
     }
 
     /**
      * Set the format for matching the end of a sentence.
-     * @param format format for matching the end of a sentence.
+     * @param pattern a pattern.
      */
-    public void setEndOfSentenceFormat(String format) {
-        endOfSentenceFormat = format;
-    }
-
-    /**
-     * Returns a regular expression for matching the end of a sentence.
-     *
-     * @return a regular expression for matching the end of a sentence.
-     */
-    private Pattern getEndOfSentencePattern() {
-        if (endOfSentencePattern == null) {
-            endOfSentencePattern = Pattern.compile(endOfSentenceFormat);
-        }
-        return endOfSentencePattern;
+    public void setEndOfSentenceFormat(Pattern pattern) {
+        endOfSentenceFormat = pattern;
     }
 
     /**
      * Sets the flag that determines if the first sentence is checked for
      * proper end of sentence punctuation.
      * @param flag {@code true} if the first sentence is to be checked
      */
     public void setCheckFirstSentence(boolean flag) {
         checkFirstSentence = flag;
     }
 
     /**
      * Sets the flag that determines if HTML checking is to be performed.
      * @param flag {@code true} if HTML checking is to be performed.
      */
     public void setCheckHtml(boolean flag) {
         checkHtml = flag;
     }
 
     /**
      * Sets the flag that determines if empty Javadoc checking should be done.
      * @param flag {@code true} if empty Javadoc checking should be done.
      */
     public void setCheckEmptyJavadoc(boolean flag) {
         checkEmptyJavadoc = flag;
     }
 }
