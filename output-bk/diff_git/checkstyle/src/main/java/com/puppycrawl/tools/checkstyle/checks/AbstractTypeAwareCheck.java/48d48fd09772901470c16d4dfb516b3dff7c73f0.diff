diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
index 8cd0f7e02..344d03fa4 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AbstractTypeAwareCheck.java
@@ -111,100 +111,101 @@ public abstract class AbstractTypeAwareCheck extends AbstractCheck {
     public final void setSuppressLoadErrors(boolean suppressLoadErrors) {
         this.suppressLoadErrors = suppressLoadErrors;
     }
 
     @Override
     public final int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.PACKAGE_DEF,
             TokenTypes.IMPORT,
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
         };
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         packageFullIdent = FullIdent.createFullIdent(null);
         imports.clear();
         // add java.lang.* since it's always imported
         imports.add("java.lang.*");
         classResolver = null;
         currentClassName = "";
         typeParams.clear();
     }
 
     @Override
     public final void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.PACKAGE_DEF) {
             processPackage(ast);
         }
         else if (ast.getType() == TokenTypes.IMPORT) {
             processImport(ast);
         }
         else if (ast.getType() == TokenTypes.CLASS_DEF
                  || ast.getType() == TokenTypes.INTERFACE_DEF
                  || ast.getType() == TokenTypes.ENUM_DEF) {
             processClass(ast);
         }
         else {
             if (ast.getType() == TokenTypes.METHOD_DEF) {
                 processTypeParams(ast);
             }
             processAST(ast);
         }
     }
 
     @Override
     public final void leaveToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.CLASS_DEF
+            || ast.getType() == TokenTypes.INTERFACE_DEF
             || ast.getType() == TokenTypes.ENUM_DEF) {
             // perhaps it was inner class
             int dotIdx = currentClassName.lastIndexOf('$');
             if (dotIdx == -1) {
                 // perhaps just a class
                 dotIdx = currentClassName.lastIndexOf('.');
             }
             if (dotIdx == -1) {
                 // looks like a topmost class
                 currentClassName = "";
             }
             else {
                 currentClassName = currentClassName.substring(0, dotIdx);
             }
             typeParams.pop();
         }
         else if (ast.getType() == TokenTypes.METHOD_DEF) {
             typeParams.pop();
         }
     }
 
     /**
      * Is exception is unchecked (subclass of {@code RuntimeException}
      * or {@code Error}.
      *
      * @param exception {@code Class} of exception to check
      * @return true  if exception is unchecked
      *         false if exception is checked
      */
     protected static boolean isUnchecked(Class<?> exception) {
         return isSubclass(exception, RuntimeException.class)
             || isSubclass(exception, Error.class);
     }
 
     /**
      * Checks if one class is subclass of another.
      *
      * @param child {@code Class} of class
      *               which should be child
      * @param parent {@code Class} of class
      *                which should be parent
      * @return true  if aChild is subclass of aParent
      *         false otherwise
      */
     protected static boolean isSubclass(Class<?> child, Class<?> parent) {
         return parent != null && child != null
             && parent.isAssignableFrom(child);
     }
 
     /**
