diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index fb88ec879..417058d6a 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -92,432 +92,432 @@ public class CommentsIndentationCheck extends AbstractCheck {
         return new int[] {
             TokenTypes.SINGLE_LINE_COMMENT,
             TokenTypes.BLOCK_COMMENT_BEGIN,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return CommonUtils.EMPTY_INT_ARRAY;
     }
 
     @Override
     public boolean isCommentNodesRequired() {
         return true;
     }
 
     @Override
     public void visitToken(DetailAST commentAst) {
         switch (commentAst.getType()) {
             case TokenTypes.SINGLE_LINE_COMMENT:
             case TokenTypes.BLOCK_COMMENT_BEGIN:
                 visitComment(commentAst);
                 break;
             default:
                 final String exceptionMsg = "Unexpected token type: " + commentAst.getText();
                 throw new IllegalArgumentException(exceptionMsg);
         }
     }
 
     /**
      * Checks comment indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * // some comment - this is ok
      * double d = 3.14;
      *     // some comment - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param comment comment to check.
      */
     private void visitComment(DetailAST comment) {
         final DetailAST prevStmt = getPreviousStatement(comment);
         final DetailAST nextStmt = getNextStmt(comment);
 
         if (!isTrailingComment(comment)) {
             if (isInEmptyCaseBlock(prevStmt, nextStmt)) {
                 handleCommentInEmptyCaseBlock(prevStmt, comment, nextStmt);
             }
             else if (isFallThroughComment(prevStmt, nextStmt)) {
-                handleFallThroughtComment(prevStmt, comment, nextStmt);
+                handleFallThroughComment(prevStmt, comment, nextStmt);
             }
             else if (isInEmptyCodeBlock(prevStmt, nextStmt)) {
                 handleCommentInEmptyCodeBlock(comment, nextStmt);
             }
             else if (isCommentAtTheEndOfTheCodeBlock(nextStmt)) {
                 handleCommentAtTheEndOfTheCodeBlock(prevStmt, comment, nextStmt);
             }
             else if (nextStmt != null && !areSameLevelIndented(comment, nextStmt, nextStmt)) {
                 log(comment.getLineNo(), getMessageKey(comment), nextStmt.getLineNo(),
                     comment.getColumnNo(), nextStmt.getColumnNo());
             }
         }
     }
 
     /**
      * Returns the next statement of a comment.
      * @param comment comment.
      * @return the next statement of a comment.
      */
     private static DetailAST getNextStmt(DetailAST comment) {
         DetailAST nextStmt = comment.getNextSibling();
         while (nextStmt != null
                 && isComment(nextStmt)
                 && comment.getColumnNo() != nextStmt.getColumnNo()) {
             nextStmt = nextStmt.getNextSibling();
         }
         return nextStmt;
     }
 
     /**
      * Returns the previous statement of a comment.
      * @param comment comment.
      * @return the previous statement of a comment.
      */
     private DetailAST getPreviousStatement(DetailAST comment) {
         final DetailAST prevStatement;
         if (isDistributedPreviousStatement(comment)) {
             prevStatement = getDistributedPreviousStatement(comment);
         }
         else {
             prevStatement = getOneLinePreviousStatement(comment);
         }
         return prevStatement;
     }
 
     /**
      * Checks whether the previous statement of a comment is distributed over two or more lines.
      * @param comment comment to check.
      * @return true if the previous statement of a comment is distributed over two or more lines.
      */
     private boolean isDistributedPreviousStatement(DetailAST comment) {
         final DetailAST previousSibling = comment.getPreviousSibling();
         return isDistributedExpression(comment)
             || isDistributedReturnStatement(previousSibling)
             || isDistributedThrowStatement(previousSibling);
     }
 
     /**
      * Checks whether the previous statement of a comment is a method call chain or
-     * string concatenation statemen distributed over two ore more lines.
+     * string concatenation statement distributed over two ore more lines.
      * @param comment comment to check.
      * @return true if the previous statement is a distributed expression.
      */
     private boolean isDistributedExpression(DetailAST comment) {
         DetailAST previousSibling = comment.getPreviousSibling();
         while (previousSibling != null && isComment(previousSibling)) {
             previousSibling = previousSibling.getPreviousSibling();
         }
         boolean isDistributed = false;
         if (previousSibling != null) {
             if (previousSibling.getType() == TokenTypes.SEMI
                     && isOnPreviousLineIgnoringComments(comment, previousSibling)) {
                 DetailAST currentToken = previousSibling.getPreviousSibling();
                 while (currentToken.getFirstChild() != null) {
                     currentToken = currentToken.getFirstChild();
                 }
                 if (currentToken.getType() == TokenTypes.COMMENT_CONTENT) {
                     currentToken = currentToken.getParent();
                     while (isComment(currentToken)) {
                         currentToken = currentToken.getNextSibling();
                     }
                 }
                 if (previousSibling.getLineNo() != currentToken.getLineNo()) {
                     isDistributed = true;
                 }
             }
             else {
                 isDistributed = isStatementWithPossibleCurlies(previousSibling);
             }
         }
         return isDistributed;
     }
 
     /**
      * Whether the statement can have or always have curly brackets.
      * @param previousSibling the statement to check.
      * @return true if the statement can have or always have curly brackets.
      */
     private static boolean isStatementWithPossibleCurlies(DetailAST previousSibling) {
         return previousSibling.getType() == TokenTypes.LITERAL_IF
             || previousSibling.getType() == TokenTypes.LITERAL_TRY
             || previousSibling.getType() == TokenTypes.LITERAL_FOR
             || previousSibling.getType() == TokenTypes.LITERAL_DO
             || previousSibling.getType() == TokenTypes.LITERAL_WHILE
             || previousSibling.getType() == TokenTypes.LITERAL_SWITCH
             || isDefinition(previousSibling);
     }
 
     /**
      * Whether the statement is a kind of definition (method, class etc.).
      * @param previousSibling the statement to check.
      * @return true if the statement is a kind of definition.
      */
     private static boolean isDefinition(DetailAST previousSibling) {
         return previousSibling.getType() == TokenTypes.METHOD_DEF
             || previousSibling.getType() == TokenTypes.CLASS_DEF
             || previousSibling.getType() == TokenTypes.INTERFACE_DEF
             || previousSibling.getType() == TokenTypes.ENUM_DEF
             || previousSibling.getType() == TokenTypes.ANNOTATION_DEF;
     }
 
     /**
-     * Checks whether the previous statement of a comment is a destributed return statement.
+     * Checks whether the previous statement of a comment is a distributed return statement.
      * @param commentPreviousSibling previous sibling of the comment.
-     * @return true if the previous statement of a comment is a destributed return statement.
+     * @return true if the previous statement of a comment is a distributed return statement.
      */
     private static boolean isDistributedReturnStatement(DetailAST commentPreviousSibling) {
         boolean isDistributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.LITERAL_RETURN) {
             final DetailAST firstChild = commentPreviousSibling.getFirstChild();
             final DetailAST nextSibling = firstChild.getNextSibling();
             if (nextSibling != null) {
                 isDistributed = true;
             }
         }
         return isDistributed;
     }
 
     /**
-     * Checks whether the previous statement of a comment is a destributed throw statement.
+     * Checks whether the previous statement of a comment is a distributed throw statement.
      * @param commentPreviousSibling previous sibling of the comment.
-     * @return true if the previous statement of a comment is a destributed throw statement.
+     * @return true if the previous statement of a comment is a distributed throw statement.
      */
     private static boolean isDistributedThrowStatement(DetailAST commentPreviousSibling) {
         boolean isDistributed = false;
         if (commentPreviousSibling != null
                 && commentPreviousSibling.getType() == TokenTypes.LITERAL_THROW) {
             final DetailAST firstChild = commentPreviousSibling.getFirstChild();
             final DetailAST nextSibling = firstChild.getNextSibling();
             if (nextSibling.getLineNo() != commentPreviousSibling.getLineNo()) {
                 isDistributed = true;
             }
         }
         return isDistributed;
     }
 
     /**
-     * Returns the first token of the destributed previous statement of comment.
+     * Returns the first token of the distributed previous statement of comment.
      * @param comment comment to check.
-     * @return the first token of the destributed previous statement of comment.
+     * @return the first token of the distributed previous statement of comment.
      */
     private static DetailAST getDistributedPreviousStatement(DetailAST comment) {
         DetailAST currentToken = comment.getPreviousSibling();
         while (isComment(currentToken)) {
             currentToken = currentToken.getPreviousSibling();
         }
         final DetailAST previousStatement;
         if (currentToken.getType() == TokenTypes.SEMI) {
             currentToken = currentToken.getPreviousSibling();
             while (currentToken.getFirstChild() != null) {
                 currentToken = currentToken.getFirstChild();
             }
             previousStatement = currentToken;
         }
         else {
             previousStatement = currentToken;
         }
         return previousStatement;
     }
 
     /**
      * Checks whether case block is empty.
      * @param nextStmt previous statement.
      * @param prevStmt next statement.
      * @return true if case block is empty.
      */
     private static boolean isInEmptyCaseBlock(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && (prevStmt.getType() == TokenTypes.LITERAL_CASE
                 || prevStmt.getType() == TokenTypes.CASE_GROUP)
             && (nextStmt.getType() == TokenTypes.LITERAL_CASE
                 || nextStmt.getType() == TokenTypes.LITERAL_DEFAULT);
     }
 
     /**
      * Checks whether comment is a 'fall through' comment.
      * For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *        // fall through
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if a comment is a 'fall through' comment.
      */
     private static boolean isFallThroughComment(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && prevStmt.getType() != TokenTypes.LITERAL_CASE
             && (nextStmt.getType() == TokenTypes.LITERAL_CASE
                 || nextStmt.getType() == TokenTypes.LITERAL_DEFAULT);
     }
 
     /**
      * Checks whether a comment is placed at the end of the code block.
      * @param nextStmt next statement.
      * @return true if a comment is placed at the end of the block.
      */
     private static boolean isCommentAtTheEndOfTheCodeBlock(DetailAST nextStmt) {
         return nextStmt != null
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Checks whether comment is placed in the empty code block.
      * For example:
      * <p>
      * ...
      * {@code
      *  // empty code block
      * }
      * ...
      * </p>
      * Note, the method does not treat empty case blocks.
      * @param prevStmt previous statement.
      * @param nextStmt next statement.
      * @return true if comment is placed in the empty code block.
      */
     private static boolean isInEmptyCodeBlock(DetailAST prevStmt, DetailAST nextStmt) {
         return prevStmt != null
             && nextStmt != null
             && (prevStmt.getType() == TokenTypes.SLIST
                 || prevStmt.getType() == TokenTypes.LCURLY
                 || prevStmt.getType() == TokenTypes.ARRAY_INIT
                 || prevStmt.getType() == TokenTypes.OBJBLOCK)
             && nextStmt.getType() == TokenTypes.RCURLY;
     }
 
     /**
-     * Handles a comment which is plased within empty case block.
+     * Handles a comment which is placed within empty case block.
      * Note, if comment is placed at the end of the empty case block, we have Checkstyle's
      * limitations to clearly detect user intention of explanation target - above or below. The
      * only case we can assume as a violation is when a single line comment within the empty case
      * block has indentation level that is lower than the indentation level of the next case
      * token. For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      * // violation
      *    case OPTION_TWO:
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment single line comment.
      * @param nextStmt next statement.
      */
     private void handleCommentInEmptyCaseBlock(DetailAST prevStmt, DetailAST comment,
                                                DetailAST nextStmt) {
 
         if (comment.getColumnNo() < prevStmt.getColumnNo()
                 || comment.getColumnNo() < nextStmt.getColumnNo()) {
             logMultilineIndentation(prevStmt, comment, nextStmt);
         }
     }
 
     /**
      * Handles 'fall through' single line comment.
      * Note, 'fall through' and similar comments can have indentation level as next or previous
      * statement.
      * For example:
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *        // fall through - OK
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * <p>
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *    // than init variable a - OK
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment single line comment.
      * @param nextStmt next statement.
      */
-    private void handleFallThroughtComment(DetailAST prevStmt, DetailAST comment,
-                                           DetailAST nextStmt) {
+    private void handleFallThroughComment(DetailAST prevStmt, DetailAST comment,
+                                          DetailAST nextStmt) {
 
         if (!areSameLevelIndented(comment, prevStmt, nextStmt)) {
             logMultilineIndentation(prevStmt, comment, nextStmt);
         }
     }
 
     /**
      * Handles a comment which is placed at the end of non empty code block.
-     * Note, if single line comment is plcaed at the end of non empty block the comment should have
+     * Note, if single line comment is placed at the end of non empty block the comment should have
      * the same indentation level as the previous statement. For example:
      * <p>
      * {@code
      *    if (a == true) {
      *        int b = 1;
      *        // comment
      *    }
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment comment to check.
      * @param nextStmt next statement.
      */
     private void handleCommentAtTheEndOfTheCodeBlock(DetailAST prevStmt, DetailAST comment,
                                                      DetailAST nextStmt) {
         if (prevStmt != null) {
             if (prevStmt.getType() == TokenTypes.LITERAL_CASE
                     || prevStmt.getType() == TokenTypes.CASE_GROUP
                     || prevStmt.getType() == TokenTypes.LITERAL_DEFAULT) {
                 if (comment.getColumnNo() < nextStmt.getColumnNo()) {
                     log(comment.getLineNo(), getMessageKey(comment), nextStmt.getLineNo(),
                         comment.getColumnNo(), nextStmt.getColumnNo());
                 }
             }
             else if (isCommentForMultiblock(nextStmt)) {
                 if (!areSameLevelIndented(comment, prevStmt, nextStmt)) {
                     logMultilineIndentation(prevStmt, comment, nextStmt);
                 }
             }
             else if (!areSameLevelIndented(comment, prevStmt, prevStmt)) {
                 final int prevStmtLineNo = prevStmt.getLineNo();
                 log(comment.getLineNo(), getMessageKey(comment), prevStmtLineNo,
                         comment.getColumnNo(), getLineStart(prevStmtLineNo));
             }
         }
 
     }
 
     /**
      * Whether the comment might have been used for the next block in a multi-block structure.
      * @param endBlockStmt the end of the current block.
      * @return true, if the comment might have been used for the next
      *     block in a multi-block structure.
      */
     private static boolean isCommentForMultiblock(DetailAST endBlockStmt) {
         final DetailAST nextBlock = endBlockStmt.getParent().getNextSibling();
         final int endBlockLineNo = endBlockStmt.getLineNo();
         final DetailAST catchAst = endBlockStmt.getParent().getParent();
         final DetailAST finallyAst = catchAst.getNextSibling();
         return nextBlock != null && nextBlock.getLineNo() == endBlockLineNo
