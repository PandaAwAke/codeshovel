diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
index 3556d5b1b..28600db69 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java
@@ -51,108 +51,113 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * <li> should not be preceded with whitespace in all cases.</li>
  * <li> should be followed with whitespace in almost all cases,
  *   except diamond operators and when preceding method name.</li></ul>
  * <br>
  * <p>
  * Examples with correct spacing:
  * </p>
  * <br>
  * <pre>
  * public void &lt;K, V extends Number&gt; boolean foo(K, V) {}  // Generic methods definitions
  * class name&lt;T1, T2, ..., Tn&gt; {}                          // Generic type definition
  * OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p;              // Generic type reference
  * boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);   // Generic preceded method name
  * Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, "apple");// Diamond operator
  * List&lt;T&gt; list = ImmutableList.Builder&lt;T&gt;::new;     // Method reference
  * sort(list, Comparable::&lt;String&gt;compareTo);              // Method reference
  * </pre>
  * @author Oliver Burn
  */
 public class GenericWhitespaceCheck extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_PRECEDED = "ws.preceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_FOLLOWED = "ws.followed";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_PRECEDED = "ws.notPreceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_ILLEGAL_FOLLOW = "ws.illegalFollow";
 
     /** Used to count the depth of a Generic expression. */
     private int depth;
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
+        return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.GENERIC_START, TokenTypes.GENERIC_END};
     }
 
+    @Override
+    public int[] getRequiredTokens() {
+        return getAcceptableTokens();
+    }
+
     @Override
     public void beginTree(DetailAST rootAST) {
         // Reset for each tree, just incase there are errors in preceeding
         // trees.
         depth = 0;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.GENERIC_START:
                 processStart(ast);
                 depth++;
                 break;
             case TokenTypes.GENERIC_END:
                 processEnd(ast);
                 depth--;
                 break;
             default:
                 throw new IllegalArgumentException("Unknown type " + ast);
         }
     }
 
     /**
      * Checks the token for the end of Generics.
      * @param ast the token to check
      */
     private void processEnd(DetailAST ast) {
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + 1;
 
         if (before >= 0 && Character.isWhitespace(line.charAt(before))
                 && !Utils.whitespaceBefore(before, line)) {
             log(ast.getLineNo(), before, WS_PRECEDED, ">");
         }
 
         if (after < line.length()) {
 
             // Check if the last Generic, in which case must be a whitespace
             // or a '(),[.'.
             if (depth == 1) {
                 processSingleGeneric(ast, line, after);
             }
             else {
                 processNestedGenerics(ast, line, after);
             }
         }
     }
 
