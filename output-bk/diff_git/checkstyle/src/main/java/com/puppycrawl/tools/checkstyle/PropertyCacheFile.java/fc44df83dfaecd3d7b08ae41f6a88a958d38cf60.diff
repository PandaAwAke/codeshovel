diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
index b6523ea08..2a0ae4dc2 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java
@@ -1,93 +1,92 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.net.URI;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Properties;
 import java.util.Set;
 
-import javax.xml.bind.DatatypeConverter;
-
+import com.google.common.io.BaseEncoding;
 import com.google.common.io.ByteStreams;
 import com.google.common.io.Closeables;
 import com.google.common.io.Flushables;
 import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
 import com.puppycrawl.tools.checkstyle.api.Configuration;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * This class maintains a persistent(on file-system) store of the files
  * that have checked ok(no validation events) and their associated
  * timestamp. It is used to optimize Checkstyle between few launches.
  * It is mostly useful for plugin and extensions of Checkstyle.
  * It uses a property file
  * for storage.  A hashcode of the Configuration is stored in the
  * cache file to ensure the cache is invalidated when the
  * configuration has changed.
  *
  * @author Oliver Burn
  * @author Andrei Selkin
  */
 final class PropertyCacheFile {
 
     /**
      * The property key to use for storing the hashcode of the
      * configuration. To avoid name clashes with the files that are
      * checked the key is chosen in such a way that it cannot be a
      * valid file name.
      */
     public static final String CONFIG_HASH_KEY = "configuration*?";
 
     /**
      * The property prefix to use for storing the hashcode of an
      * external resource. To avoid name clashes with the files that are
      * checked the prefix is chosen in such a way that it cannot be a
      * valid file name and makes it clear it is a resource.
      */
     public static final String EXTERNAL_RESOURCE_KEY_PREFIX = "module-resource*?:";
 
     /** The details on files. **/
     private final Properties details = new Properties();
 
     /** Configuration object. **/
     private final Configuration config;
 
     /** File name of cache. **/
     private final String fileName;
 
     /** Generated configuration hash. **/
     private String configHash;
 
@@ -183,101 +182,101 @@ final class PropertyCacheFile {
      * @return whether the specified file has already been checked ok
      */
     public boolean isInCache(String uncheckedFileName, long timestamp) {
         final String lastChecked = details.getProperty(uncheckedFileName);
         return Objects.equals(lastChecked, Long.toString(timestamp));
     }
 
     /**
      * Records that a file checked ok.
      * @param checkedFileName name of the file that checked ok
      * @param timestamp the timestamp of the file
      */
     public void put(String checkedFileName, long timestamp) {
         details.setProperty(checkedFileName, Long.toString(timestamp));
     }
 
     /**
      * Retrieves the hash of a specific file.
      * @param name The name of the file to retrieve.
      * @return The has of the file or {@code null}.
      */
     public String get(String name) {
         return details.getProperty(name);
     }
 
     /**
      * Removed a specific file from the cache.
      * @param checkedFileName The name of the file to remove.
      */
     public void remove(String checkedFileName) {
         details.remove(checkedFileName);
     }
 
     /**
      * Calculates the hashcode for the serializable object based on its content.
      * @param object serializable object.
      * @return the hashcode for serializable object.
      */
     private static String getHashCodeBasedOnObjectContent(Serializable object) {
         try {
             final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             // in-memory serialization of Configuration
             serialize(object, outputStream);
             // Instead of hexEncoding outputStream.toByteArray() directly we
             // use a message digest here to keep the length of the
             // hashcode reasonable
 
             final MessageDigest digest = MessageDigest.getInstance("SHA-1");
             digest.update(outputStream.toByteArray());
 
-            return DatatypeConverter.printHexBinary(digest.digest());
+            return BaseEncoding.base16().upperCase().encode(digest.digest());
         }
         catch (final IOException | NoSuchAlgorithmException ex) {
             // rethrow as unchecked exception
             throw new IllegalStateException("Unable to calculate hashcode.", ex);
         }
     }
 
     /**
      * Serializes object to output stream.
      * @param object object to be erialized
      * @param outputStream serialization stream
      * @throws IOException if an error occurs
      */
     private static void serialize(Serializable object,
                                   OutputStream outputStream) throws IOException {
         final ObjectOutputStream oos = new ObjectOutputStream(outputStream);
         try {
             oos.writeObject(object);
         }
         finally {
             flushAndCloseOutStream(oos);
         }
     }
 
     /**
      * Puts external resources in cache.
      * If at least one external resource changed, clears the cache.
      * @param locations locations of external resources.
      */
     public void putExternalResources(Set<String> locations) {
         final Set<ExternalResource> resources = loadExternalResources(locations);
         if (areExternalResourcesChanged(resources)) {
             reset();
         }
         fillCacheWithExternalResources(resources);
     }
 
     /**
      * Loads a set of {@link ExternalResource} based on their locations.
      * @param resourceLocations locations of external configuration resources.
      * @return a set of {@link ExternalResource}.
      */
     private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {
         final Set<ExternalResource> resources = new HashSet<>();
         for (String location : resourceLocations) {
             String contentHashSum = null;
             try {
                 final byte[] content = loadExternalResource(location);
                 contentHashSum = getHashCodeBasedOnObjectContent(content);
             }
