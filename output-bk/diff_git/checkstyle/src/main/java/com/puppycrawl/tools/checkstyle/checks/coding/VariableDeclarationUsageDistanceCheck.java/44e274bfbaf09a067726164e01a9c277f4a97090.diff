diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index 9f9377d1b..f1f6ec567 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -220,101 +220,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check
      *        Pattern contains ignored variables.
      */
     public void setIgnoreVariablePattern(String ignorePattern)
     {
         this.ignoreVariablePattern = Pattern.compile(ignorePattern);
     }
 
     /**
      * Sets option which allows to calculate distance between declaration of
      * variable and its first usage in different scopes.
      * @param validateBetweenScopes
      *        Defines if allow to calculate distance between declaration of
      *        variable and its first usage in different scopes or not.
      */
     public void setValidateBetweenScopes(boolean validateBetweenScopes)
     {
         this.validateBetweenScopes = validateBetweenScopes;
     }
 
     /**
      * Sets ignore option for variables with 'final' modifier.
      * @param ignoreFinal
      *        Defines if ignore variables with 'final' modifier or not.
      */
     public void setIgnoreFinal(boolean ignoreFinal)
     {
         this.ignoreFinal = ignoreFinal;
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {TokenTypes.VARIABLE_DEF};
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         final int parentType = ast.getParent().getType();
         final DetailAST modifiers = ast.getFirstChild();
 
         if (ignoreFinal && modifiers.branchContains(TokenTypes.FINAL)
                 || parentType == TokenTypes.OBJBLOCK)
         {
-            ;// no code
+            // no code
         }
         else {
             final DetailAST variable = ast.findFirstToken(TokenTypes.IDENT);
 
             if (!isVariableMatchesIgnorePattern(variable.getText())) {
                 final DetailAST semicolonAst = ast.getNextSibling();
                 Entry<DetailAST, Integer> entry = null;
                 if (validateBetweenScopes) {
                     entry = calculateDistanceBetweenScopes(semicolonAst, variable);
                 }
                 else {
                     entry = calculateDistanceInSingleScope(semicolonAst, variable);
                 }
                 final DetailAST variableUsageAst = entry.getKey();
                 final int dist = entry.getValue();
                 if (dist > allowedDistance
                         && !isInitializationSequence(variableUsageAst, variable.getText()))
                 {
                     if (ignoreFinal) {
                         log(variable.getLineNo(),
                                 MSG_KEY_EXT, variable.getText(), dist, allowedDistance);
                     }
                     else {
                         log(variable.getLineNo(),
                                 MSG_KEY, variable.getText(), dist, allowedDistance);
                     }
                 }
             }
         }
     }
 
     /**
      * Get name of instance whose method is called.
      * @param methodCallAst
      *        DetailAST of METHOD_CALL.
      * @return name of instance.
      */
     private static String getInstanceName(DetailAST methodCallAst)
     {
         final String methodCallName =
                 FullIdent.createFullIdentBelow(methodCallAst).getText();
         final int lastDotIndex = methodCallName.lastIndexOf('.');
         String instanceName = "";
         if (lastDotIndex != -1) {
             instanceName = methodCallName.substring(0, lastDotIndex);
         }
         return instanceName;
     }
 
     /**
@@ -546,101 +546,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check
             // If there's no any variable usage, then distance = 0.
             else {
                 variableUsageAst = null;
             }
         }
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Gets first Ast node inside FOR, WHILE or DO-WHILE blocks if variable
      * usage is met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents FOR, WHILE or DO-WHILE block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
             DetailAST block, DetailAST variable)
     {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = null;
 
             // Find currentNode for DO-WHILE block.
             if (block.getType() == TokenTypes.LITERAL_DO) {
                 currentNode = block.getFirstChild();
             }
             // Find currentNode for FOR or WHILE block.
             else {
                 // Looking for RPAREN ( ')' ) token to mark the end of operator
                 // expression.
                 currentNode = block.findFirstToken(TokenTypes.RPAREN);
                 if (currentNode != null) {
                     currentNode = currentNode.getNextSibling();
                 }
             }
 
             if (currentNode != null) {
                 final int currentNodeType = currentNode.getType();
 
                 if (currentNodeType == TokenTypes.SLIST) {
                     firstNodeInsideBlock = currentNode.getFirstChild();
                 }
                 else if (currentNodeType == TokenTypes.VARIABLE_DEF
                         || currentNodeType == TokenTypes.EXPR)
                 {
-                    ; // no code
+                    // no code
                 }
                 else {
                     firstNodeInsideBlock = currentNode;
                 }
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside IF block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents IF block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private DetailAST getFirstNodeInsideIfBlock(
             DetailAST block, DetailAST variable)
     {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode = block.getLastChild();
             final List<DetailAST> variableUsageExpressions =
                     new ArrayList<>();
 
             while (currentNode != null
                     && currentNode.getType() == TokenTypes.LITERAL_ELSE)
             {
                 final DetailAST previousNode =
                         currentNode.getPreviousSibling();
 
                 // Checking variable usage inside IF block.
                 if (isChild(previousNode, variable)) {
                     variableUsageExpressions.add(previousNode);
                 }
 
                 // Looking into ELSE block, get its first child and analyze it.
                 currentNode = currentNode.getFirstChild();
 
                 if (currentNode.getType() == TokenTypes.LITERAL_IF) {
                     currentNode = currentNode.getLastChild();
                 }
                 else if (isChild(currentNode, variable)) {
                     variableUsageExpressions.add(currentNode);
@@ -809,101 +809,101 @@ public class VariableDeclarationUsageDistanceCheck extends Check
                     break;
                 }
                 exprBetweenBrackets = exprBetweenBrackets.getNextSibling();
             }
 
             // Variable may be met in ELSE declaration or in CASE declaration.
             // So, check variable usage in these declarations.
             if (!isVarInOperatorDeclr) {
                 switch (operator.getType()) {
                     case TokenTypes.LITERAL_IF:
                         final DetailAST elseBlock = operator.getLastChild();
 
                         if (elseBlock.getType() == TokenTypes.LITERAL_ELSE) {
                             // Get IF followed by ELSE
                             final DetailAST firstNodeInsideElseBlock = elseBlock
                                 .getFirstChild();
 
                             if (firstNodeInsideElseBlock.getType()
                                 == TokenTypes.LITERAL_IF)
                             {
                                 isVarInOperatorDeclr |=
                                     isVariableInOperatorExpr(
                                         firstNodeInsideElseBlock,
                                             variable);
                             }
                         }
                         break;
 
                     case TokenTypes.LITERAL_SWITCH:
                         DetailAST currentCaseBlock = operator
                             .findFirstToken(TokenTypes.CASE_GROUP);
 
                         while (currentCaseBlock != null
                             && currentCaseBlock.getType()
                             == TokenTypes.CASE_GROUP)
                         {
                             final DetailAST firstNodeInsideCaseBlock =
                                 currentCaseBlock.getFirstChild();
 
                             if (isChild(firstNodeInsideCaseBlock,
                                 variable))
                             {
                                 isVarInOperatorDeclr = true;
                                 break;
                             }
                             currentCaseBlock = currentCaseBlock.getNextSibling();
                         }
                         break;
 
                     default:
-                        ;// no code
+                        // no code
                 }
             }
         }
 
         return isVarInOperatorDeclr;
     }
 
     /**
      * Checks if Ast node contains given element.
      * @param parent
      *        Node of AST.
      * @param ast
      *        Ast element which is checked for content in Ast node.
      * @return true if Ast element was found in Ast node, otherwise - false.
      */
     private static boolean isChild(DetailAST parent, DetailAST ast)
     {
         boolean isChild = false;
         final ASTEnumeration astList = parent.findAllPartial(ast);
 
         while (astList.hasMoreNodes()) {
             final DetailAST astNode = (DetailAST) astList.nextNode();
             DetailAST astParent = astNode.getParent();
 
             while (astParent != null) {
 
                 if (astParent.equals(parent)
                         && astParent.getLineNo() == parent.getLineNo())
                 {
                     isChild = true;
                     break;
                 }
                 astParent = astParent.getParent();
             }
         }
 
         return isChild;
     }
 
     /**
      * Checks if entrance variable is contained in ignored pattern.
      * @param variable
      *        Variable which is checked for content in ignored pattern.
      * @return true if variable was found, otherwise - false.
      */
     private boolean isVariableMatchesIgnorePattern(String variable)
     {
         final Matcher matcher = ignoreVariablePattern.matcher(variable);
         return matcher.matches();
     }
