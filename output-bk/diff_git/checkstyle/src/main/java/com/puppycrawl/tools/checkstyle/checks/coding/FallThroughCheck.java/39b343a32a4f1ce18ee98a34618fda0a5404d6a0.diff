diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
index f09ba9364..f2e672955 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java
@@ -86,114 +86,111 @@ public class FallThroughCheck extends AbstractCheck {
 
     /** Relief pattern to allow fall through to the next case branch. */
     private String reliefPattern = "fallthru|falls? ?through";
 
     /** Relief regexp. */
     private Pattern regExp;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {TokenTypes.CASE_GROUP};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {TokenTypes.CASE_GROUP};
     }
 
     /**
      * Set the relief pattern.
      *
      * @param pattern
      *            The regular expression pattern.
      */
     public void setReliefPattern(String pattern) {
         reliefPattern = pattern;
     }
 
     /**
      * Configures whether we need to check last case group or not.
      * @param value new value of the property.
      */
     public void setCheckLastCaseGroup(boolean value) {
         checkLastCaseGroup = value;
     }
 
     @Override
     public void init() {
         super.init();
         regExp = Pattern.compile(reliefPattern);
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST nextGroup = ast.getNextSibling();
         final boolean isLastGroup = nextGroup.getType() != TokenTypes.CASE_GROUP;
-        if (isLastGroup && !checkLastCaseGroup) {
-            // we do not need to check last group
-            return;
-        }
-
-        final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
+        if (!isLastGroup || checkLastCaseGroup) {
+            final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);
 
-        if (slist != null && !isTerminated(slist, true, true)
-            && !hasFallThroughComment(ast, nextGroup)) {
-            if (isLastGroup) {
-                log(ast, MSG_FALL_THROUGH_LAST);
-            }
-            else {
-                log(nextGroup, MSG_FALL_THROUGH);
+            if (slist != null && !isTerminated(slist, true, true)
+                && !hasFallThroughComment(ast, nextGroup)) {
+                if (isLastGroup) {
+                    log(ast, MSG_FALL_THROUGH_LAST);
+                }
+                else {
+                    log(nextGroup, MSG_FALL_THROUGH);
+                }
             }
         }
     }
 
     /**
      * Checks if a given subtree terminated by return, throw or,
      * if allowed break, continue.
      * @param ast root of given subtree
      * @param useBreak should we consider break as terminator.
      * @param useContinue should we consider continue as terminator.
      * @return true if the subtree is terminated.
      */
     private boolean isTerminated(final DetailAST ast, boolean useBreak,
                                  boolean useContinue) {
         final boolean terminated;
 
         switch (ast.getType()) {
             case TokenTypes.LITERAL_RETURN:
             case TokenTypes.LITERAL_THROW:
                 terminated = true;
                 break;
             case TokenTypes.LITERAL_BREAK:
                 terminated = useBreak;
                 break;
             case TokenTypes.LITERAL_CONTINUE:
                 terminated = useContinue;
                 break;
             case TokenTypes.SLIST:
                 terminated = checkSlist(ast, useBreak, useContinue);
                 break;
             case TokenTypes.LITERAL_IF:
                 terminated = checkIf(ast, useBreak, useContinue);
                 break;
             case TokenTypes.LITERAL_FOR:
             case TokenTypes.LITERAL_WHILE:
             case TokenTypes.LITERAL_DO:
                 terminated = checkLoop(ast);
                 break;
             case TokenTypes.LITERAL_TRY:
                 terminated = checkTry(ast, useBreak, useContinue);
                 break;
             case TokenTypes.LITERAL_SWITCH:
                 terminated = checkSwitch(ast, useContinue);
                 break;
             default:
                 terminated = false;
         }
         return terminated;
     }
 
