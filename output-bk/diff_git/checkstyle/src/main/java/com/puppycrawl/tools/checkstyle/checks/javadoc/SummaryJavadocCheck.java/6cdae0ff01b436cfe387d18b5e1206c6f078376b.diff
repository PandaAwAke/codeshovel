diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
index 3cdb03bea..8aa0697fb 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java
@@ -88,113 +88,112 @@ public class SummaryJavadocCheck extends AbstractJavadocCheck {
      */
     private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =
             Pattern.compile("\n[ ]+(\\*)|^[ ]+(\\*)");
 
     /** Period literal. */
     private static final String PERIOD = ".";
 
     /** Set of allowed Tokens tags in summary java doc. */
     private static final Set<Integer> ALLOWED_TYPES = Collections.unmodifiableSet(
             new HashSet<>(Arrays.asList(JavadocTokenTypes.TEXT,
                     JavadocTokenTypes.WS))
     );
 
     /** Regular expression for forbidden summary fragments. */
     private Pattern forbiddenSummaryFragments = CommonUtils.createPattern("^$");
 
     /** Period symbol at the end of first javadoc sentence. */
     private String period = PERIOD;
 
     /**
      * Sets custom value of regular expression for forbidden summary fragments.
      * @param pattern a pattern.
      */
     public void setForbiddenSummaryFragments(Pattern pattern) {
         forbiddenSummaryFragments = pattern;
     }
 
     /**
      * Sets value of period symbol at the end of first javadoc sentence.
      * @param period period's value.
      */
     public void setPeriod(String period) {
         this.period = period;
     }
 
     @Override
     public int[] getDefaultJavadocTokens() {
         return new int[] {
             JavadocTokenTypes.JAVADOC,
         };
     }
 
     @Override
     public int[] getRequiredJavadocTokens() {
         return getAcceptableJavadocTokens();
     }
 
     @Override
     public void visitJavadocToken(DetailNode ast) {
         if (!startsWithInheritDoc(ast)) {
-            String firstSentence = getFirstSentence(ast);
-            final int endOfSentence = firstSentence.lastIndexOf(period);
             final String summaryDoc = getSummarySentence(ast);
             if (summaryDoc.isEmpty()) {
                 log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);
             }
-            else if (!period.isEmpty()
-                    && !summaryDoc.contains(period)) {
-                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);
-            }
-            if (endOfSentence != -1) {
-                firstSentence = firstSentence.substring(0, endOfSentence);
-                if (containsForbiddenFragment(firstSentence)) {
+            else if (!period.isEmpty()) {
+                final String firstSentence = getFirstSentence(ast);
+                final int endOfSentence = firstSentence.lastIndexOf(period);
+                if (!summaryDoc.contains(period)) {
+                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);
+                }
+                if (endOfSentence != -1
+                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {
                     log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);
                 }
             }
         }
     }
 
     /**
      * Checks if the node starts with an {&#64;inheritDoc}.
      * @param root The root node to examine.
      * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.
      */
     private static boolean startsWithInheritDoc(DetailNode root) {
         boolean found = false;
         final DetailNode[] children = root.getChildren();
 
         for (int i = 0; !found && i < children.length - 1; i++) {
             final DetailNode child = children[i];
             if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG
                     && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {
                 found = true;
             }
             else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK
                     && !CommonUtils.isBlank(child.getText())) {
                 break;
             }
         }
 
         return found;
     }
 
     /**
      * Checks if period is at the end of sentence.
      * @param ast Javadoc root node.
      * @return error string
      */
     private static String getSummarySentence(DetailNode ast) {
         boolean flag = true;
         final StringBuilder result = new StringBuilder(256);
         for (DetailNode child : ast.getChildren()) {
             if (ALLOWED_TYPES.contains(child.getType())) {
                 result.append(child.getText());
             }
             else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT
                     && CommonUtils.isBlank(result.toString().trim())) {
                 result.append(getStringInsideTag(result.toString(),
                         child.getChildren()[0].getChildren()[0]));
             }
             else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {
                 flag = false;
             }
