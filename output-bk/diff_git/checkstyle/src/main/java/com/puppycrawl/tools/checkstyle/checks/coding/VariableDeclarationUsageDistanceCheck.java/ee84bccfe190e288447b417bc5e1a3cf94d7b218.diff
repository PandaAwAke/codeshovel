diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
index 5cee36add..56e9f39e1 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java
@@ -418,173 +418,193 @@ public class VariableDeclarationUsageDistanceCheck extends Check {
                                 dist++;
                             }
                             else {
                                 // variable usage is in inner scope
                                 // reset counters, because we can't determine distance
                                 dist = 0;
                             }
                             break;
                         default:
                             if (currentAst.branchContains(TokenTypes.SLIST)) {
                                 dist = 0;
                             }
                             else {
                                 dist++;
                             }
                     }
                     variableUsageAst = currentAst;
                     firstUsageFound = true;
                 }
                 else if (currentAst.getType() != TokenTypes.VARIABLE_DEF) {
                     dist++;
                 }
             }
             currentAst = currentAst.getNextSibling();
         }
 
         // If variable wasn't used after its declaration, distance is 0.
         if (!firstUsageFound) {
             dist = 0;
         }
 
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
     /**
      * Calculates distance between declaration of variable and its first usage
      * in multiple scopes.
      * @param ast
      *        Regular node of Ast which is checked for content of checking
      *        variable.
      * @param variable
      *        Variable which distance is calculated for.
      * @return entry which contains expression with variable usage and distance.
      */
     private static Entry<DetailAST, Integer> calculateDistanceBetweenScopes(
             DetailAST ast, DetailAST variable) {
         int dist = 0;
         DetailAST currentScopeAst = ast;
         DetailAST variableUsageAst = null;
         while (currentScopeAst != null) {
-            final List<DetailAST> variableUsageExpressions = new ArrayList<>();
-            DetailAST currentStatementAst = currentScopeAst;
+            final Entry<List<DetailAST>, Integer> searchResult =
+                    searchVariableUsageExpressions(variable, currentScopeAst);
+
             currentScopeAst = null;
-            while (currentStatementAst != null
-                    && currentStatementAst.getType() != TokenTypes.RCURLY) {
-                if (currentStatementAst.getFirstChild() != null) {
-                    if (isChild(currentStatementAst, variable)) {
-                        variableUsageExpressions.add(currentStatementAst);
-                    }
-                    // If expression doesn't contain variable and this variable
-                    // hasn't been met yet, than distance + 1.
-                    else if (variableUsageExpressions.isEmpty()
-                            && currentStatementAst.getType() != TokenTypes.VARIABLE_DEF) {
-                        dist++;
-                    }
-                }
-                currentStatementAst = currentStatementAst.getNextSibling();
-            }
+
+            final List<DetailAST> variableUsageExpressions = searchResult.getKey();
+            dist += searchResult.getValue();
+
             // If variable usage exists in a single scope, then look into
             // this scope and count distance until variable usage.
             if (variableUsageExpressions.size() == 1) {
                 final DetailAST blockWithVariableUsage = variableUsageExpressions
                         .get(0);
                 DetailAST exprWithVariableUsage = null;
                 switch (blockWithVariableUsage.getType()) {
                     case TokenTypes.VARIABLE_DEF:
                     case TokenTypes.EXPR:
                         dist++;
                         break;
                     case TokenTypes.LITERAL_FOR:
                     case TokenTypes.LITERAL_WHILE:
                     case TokenTypes.LITERAL_DO:
                         exprWithVariableUsage = getFirstNodeInsideForWhileDoWhileBlocks(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_IF:
                         exprWithVariableUsage = getFirstNodeInsideIfBlock(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_SWITCH:
                         exprWithVariableUsage = getFirstNodeInsideSwitchBlock(
                             blockWithVariableUsage, variable);
                         break;
                     case TokenTypes.LITERAL_TRY:
                         exprWithVariableUsage =
                             getFirstNodeInsideTryCatchFinallyBlocks(blockWithVariableUsage,
                                 variable);
                         break;
                     default:
                         exprWithVariableUsage = blockWithVariableUsage.getFirstChild();
                 }
                 currentScopeAst = exprWithVariableUsage;
                 if (exprWithVariableUsage != null) {
                     variableUsageAst = exprWithVariableUsage;
                 }
                 else {
                     variableUsageAst = blockWithVariableUsage;
                 }
             }
             // If variable usage exists in different scopes, then distance =
             // distance until variable first usage.
             else if (variableUsageExpressions.size() > 1) {
                 dist++;
                 variableUsageAst = variableUsageExpressions.get(0);
             }
             // If there's no any variable usage, then distance = 0.
             else {
                 variableUsageAst = null;
             }
         }
         return new SimpleEntry<>(variableUsageAst, dist);
     }
 
+    /**
+     * Searches variable usages starting from specified statement.
+     * @param variableAst Variable that is used.
+     * @param statementAst DetailAST to start searching from.
+     * @return entry which contains list with found expressions that use the variable
+     * and distance from specified statement to first found expression.
+     */
+    private static Entry<List<DetailAST>, Integer>
+        searchVariableUsageExpressions(final DetailAST variableAst, final DetailAST statementAst) {
+        final List<DetailAST> variableUsageExpressions = new ArrayList<>();
+        int distance = 0;
+        DetailAST currentStatementAst = statementAst;
+        while (currentStatementAst != null
+                && currentStatementAst.getType() != TokenTypes.RCURLY) {
+            if (currentStatementAst.getFirstChild() != null) {
+                if (isChild(currentStatementAst, variableAst)) {
+                    variableUsageExpressions.add(currentStatementAst);
+                }
+                // If expression doesn't contain variable and this variable
+                // hasn't been met yet, than distance + 1.
+                else if (variableUsageExpressions.isEmpty()
+                        && currentStatementAst.getType() != TokenTypes.VARIABLE_DEF) {
+                    distance++;
+                }
+            }
+            currentStatementAst = currentStatementAst.getNextSibling();
+        }
+        return new SimpleEntry<>(variableUsageExpressions, distance);
+    }
+
     /**
      * Gets first Ast node inside FOR, WHILE or DO-WHILE blocks if variable
      * usage is met only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents FOR, WHILE or DO-WHILE block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
      *         (not in its declaration!) than return the first Ast node
      *         of this block, otherwise - null.
      */
     private static DetailAST getFirstNodeInsideForWhileDoWhileBlocks(
             DetailAST block, DetailAST variable) {
         DetailAST firstNodeInsideBlock = null;
 
         if (!isVariableInOperatorExpr(block, variable)) {
             DetailAST currentNode;
 
             // Find currentNode for DO-WHILE block.
             if (block.getType() == TokenTypes.LITERAL_DO) {
                 currentNode = block.getFirstChild();
             }
             // Find currentNode for FOR or WHILE block.
             else {
                 // Looking for RPAREN ( ')' ) token to mark the end of operator
                 // expression.
                 currentNode = block.findFirstToken(TokenTypes.RPAREN).getNextSibling();
             }
 
             final int currentNodeType = currentNode.getType();
 
             if (currentNodeType == TokenTypes.SLIST) {
                 firstNodeInsideBlock = currentNode.getFirstChild();
             }
             else if (currentNodeType != TokenTypes.EXPR) {
                 firstNodeInsideBlock = currentNode;
             }
         }
 
         return firstNodeInsideBlock;
     }
 
     /**
      * Gets first Ast node inside IF block if variable usage is met
      * only inside the block (not in its declaration!).
      * @param block
      *        Ast node represents IF block.
      * @param variable
      *        Variable which is checked for content in block.
      * @return If variable usage is met only inside the block
