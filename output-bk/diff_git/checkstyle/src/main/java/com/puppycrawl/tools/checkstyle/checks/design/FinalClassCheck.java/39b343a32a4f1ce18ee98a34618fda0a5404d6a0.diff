diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
index dc5e18ef5..af8176ec0 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
@@ -78,114 +78,112 @@ public class FinalClassCheck
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         classes = new ArrayDeque<>();
         packageName = "";
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         switch (ast.getType()) {
 
             case TokenTypes.PACKAGE_DEF:
                 packageName = extractQualifiedName(ast);
                 break;
 
             case TokenTypes.CLASS_DEF:
                 registerNestedSubclassToOuterSuperClasses(ast);
 
                 final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
                 final boolean isAbstract = modifiers.branchContains(TokenTypes.ABSTRACT);
 
                 final String qualifiedClassName = getQualifiedClassName(ast);
                 classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));
                 break;
 
             case TokenTypes.CTOR_DEF:
                 if (!ScopeUtils.isInEnumBlock(ast)) {
                     final ClassDesc desc = classes.peek();
                     if (modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)) {
                         desc.registerPrivateCtor();
                     }
                     else {
                         desc.registerNonPrivateCtor();
                     }
                 }
                 break;
 
             default:
                 throw new IllegalStateException(ast.toString());
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
-        if (ast.getType() != TokenTypes.CLASS_DEF) {
-            return;
-        }
-
-        final ClassDesc desc = classes.pop();
-        if (desc.isWithPrivateCtor()
-            && !desc.isDeclaredAsAbstract()
-            && !desc.isDeclaredAsFinal()
-            && !desc.isWithNonPrivateCtor()
-            && !desc.isWithNestedSubclass()
-            && !ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
-            final String qualifiedName = desc.getQualifiedName();
-            final String className = getClassNameFromQualifiedName(qualifiedName);
-            log(ast.getLineNo(), MSG_KEY, className);
+        if (ast.getType() == TokenTypes.CLASS_DEF) {
+            final ClassDesc desc = classes.pop();
+            if (desc.isWithPrivateCtor()
+                && !desc.isDeclaredAsAbstract()
+                && !desc.isDeclaredAsFinal()
+                && !desc.isWithNonPrivateCtor()
+                && !desc.isWithNestedSubclass()
+                && !ScopeUtils.isInInterfaceOrAnnotationBlock(ast)) {
+                final String qualifiedName = desc.getQualifiedName();
+                final String className = getClassNameFromQualifiedName(qualifiedName);
+                log(ast.getLineNo(), MSG_KEY, className);
+            }
         }
     }
 
     /**
      * Get name of class(with qualified package if specified) in extend clause.
      * @param classExtend extend clause to extract class name
      * @return super class name
      */
     private static String extractQualifiedName(DetailAST classExtend) {
         final String className;
 
         if (classExtend.findFirstToken(TokenTypes.IDENT) == null) {
             // Name specified with packages, have to traverse DOT
             final DetailAST firstChild = classExtend.findFirstToken(TokenTypes.DOT);
             final List<String> qualifiedNameParts = new LinkedList<>();
 
             qualifiedNameParts.add(0, firstChild.findFirstToken(TokenTypes.IDENT).getText());
             DetailAST traverse = firstChild.findFirstToken(TokenTypes.DOT);
             while (traverse != null) {
                 qualifiedNameParts.add(0, traverse.findFirstToken(TokenTypes.IDENT).getText());
                 traverse = traverse.findFirstToken(TokenTypes.DOT);
             }
             className = Joiner.on(PACKAGE_SEPARATOR).join(qualifiedNameParts);
         }
         else {
             className = classExtend.findFirstToken(TokenTypes.IDENT).getText();
         }
 
         return className;
     }
 
     /**
      * Register to outer super classes of given classAst that
      * given classAst is extending them.
      * @param classAst class which outer super classes will be
      *                 informed about nesting subclass
      */
     private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {
         final String currentAstSuperClassName = getSuperClassName(classAst);
         if (currentAstSuperClassName != null) {
             for (ClassDesc classDesc : classes) {
                 final String classDescQualifiedName = classDesc.getQualifiedName();
                 if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,
                         currentAstSuperClassName)) {
                     classDesc.registerNestedSubclass();
                 }
             }
         }
     }
 
