diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index 3147098be..d08ba5ea9 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -300,173 +300,173 @@ public class WhitespaceAroundCheck extends Check
      */
     public void setAllowEmptyMethods(boolean allow)
     {
         allowEmptyMethods = allow;
     }
 
     /**
      * Sets whether or not empty constructor bodies are allowed.
      * @param allow <code>true</code> to allow empty constructor bodies.
      */
     public void setAllowEmptyConstructors(boolean allow)
     {
         allowEmptyCtors = allow;
     }
 
     /**
      * Sets whether or not to ignore the whitespace around the
      * colon in an enhanced for loop.
      * @param ignore <code>true</code> to ignore enhanced for colon.
      */
     public void setIgnoreEnhancedForColon(boolean ignore)
     {
         ignoreEnhancedForColon = ignore;
     }
 
     /**
      * Sets whether or not empty type bodies are allowed.
      * @param allow <code>true</code> to allow empty type bodies.
      */
     public void setAllowEmptyTypes(boolean allow)
     {
         allowEmptyTypes = allow;
     }
 
     /**
      * Sets whether or not empty loop bodies are allowed.
      * @param allow <code>true</code> to allow empty loops bodies.
      */
     public void setAllowEmptyLoops(boolean allow)
     {
         allowEmptyLoops = allow;
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         final int currentType = ast.getType();
         final int parentType = ast.getParent().getType();
 
         // Check for CURLY in array initializer
-        if (((currentType == TokenTypes.RCURLY)
-                || (currentType == TokenTypes.LCURLY))
-            && ((parentType == TokenTypes.ARRAY_INIT)
-                || (parentType == TokenTypes.ANNOTATION_ARRAY_INIT)))
+        if ((currentType == TokenTypes.RCURLY
+                || currentType == TokenTypes.LCURLY)
+            && (parentType == TokenTypes.ARRAY_INIT
+                || parentType == TokenTypes.ANNOTATION_ARRAY_INIT))
         {
             return;
         }
 
         // Check for import pkg.name.*;
-        if ((currentType == TokenTypes.STAR)
-            && (parentType == TokenTypes.DOT))
+        if (currentType == TokenTypes.STAR
+            && parentType == TokenTypes.DOT)
         {
             return;
         }
 
         // Check for an SLIST that has a parent CASE_GROUP. It is not a '{'.
-        if ((currentType == TokenTypes.SLIST)
-            && (parentType == TokenTypes.CASE_GROUP))
+        if (currentType == TokenTypes.SLIST
+            && parentType == TokenTypes.CASE_GROUP)
         {
             return;
         }
 
-        if ((currentType == TokenTypes.COLON)) {
+        if (currentType == TokenTypes.COLON) {
             //we do not want to check colon for cases and defaults
             if (parentType == TokenTypes.LITERAL_DEFAULT
                 || parentType == TokenTypes.LITERAL_CASE)
             {
                 return;
             }
             else if (parentType == TokenTypes.FOR_EACH_CLAUSE
                 && this.ignoreEnhancedForColon)
             {
                 return;
             }
         }
 
         // Checks if empty methods, ctors or loops are allowed.
         if (isEmptyMethodBlock(ast, parentType)
                 || isEmptyCtorBlock(ast, parentType)
                 || isEmptyLoop(ast, parentType))
         {
             return;
         }
 
         // Checks if empty classes, interfaces or enums are allowed
-        if (allowEmptyTypes && (isEmptyType(ast, parentType))) {
+        if (allowEmptyTypes && isEmptyType(ast, parentType)) {
             return;
         }
 
         final String line = getLine(ast.getLineNo() - 1);
         final int before = ast.getColumnNo() - 1;
         final int after = ast.getColumnNo() + ast.getText().length();
 
-        if ((before >= 0) && !Character.isWhitespace(line.charAt(before))) {
+        if (before >= 0 && !Character.isWhitespace(line.charAt(before))) {
             log(ast.getLineNo(), ast.getColumnNo(),
                     WS_NOT_PRECEDED, ast.getText());
         }
 
         if (after >= line.length()) {
             return;
         }
 
         final char nextChar = line.charAt(after);
         if (!Character.isWhitespace(nextChar)
             // Check for "return;"
-            && !((currentType == TokenTypes.LITERAL_RETURN)
-                && (ast.getFirstChild().getType() == TokenTypes.SEMI))
+            && !(currentType == TokenTypes.LITERAL_RETURN
+                && ast.getFirstChild().getType() == TokenTypes.SEMI)
             // Check for "})" or "};" or "},". Happens with anon-inners
-            && !((currentType == TokenTypes.RCURLY)
-                && ((nextChar == ')')
-                    || (nextChar == ';')
-                    || (nextChar == ',')
-                    || (nextChar == '.'))))
+            && !(currentType == TokenTypes.RCURLY
+                && (nextChar == ')'
+                    || nextChar == ';'
+                    || nextChar == ','
+                    || nextChar == '.')))
         {
             log(ast.getLineNo(), ast.getColumnNo() + ast.getText().length(),
                     WS_NOT_FOLLOWED, ast.getText());
         }
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * method block.
      * @param ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty method block.
      */
     private boolean isEmptyMethodBlock(DetailAST ast, int parentType)
     {
         return allowEmptyMethods
             && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
 
     /**
      * Test if the given <code>DetailAST</code> is part of an allowed empty
      * constructor (ctor) block.
      * @param ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty constructor block.
      */
     private boolean isEmptyCtorBlock(DetailAST ast, int parentType)
     {
         return allowEmptyCtors
             && isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
      * @param ast ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         allowed empty loop block.
      */
     private boolean isEmptyLoop(DetailAST ast, int parentType)
     {
         return allowEmptyLoops
             && (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)
                     || isEmptyBlock(ast,
                             parentType, TokenTypes.LITERAL_WHILE)
                             || isEmptyBlock(ast,
                                     parentType, TokenTypes.LITERAL_DO));
     }
@@ -477,59 +477,59 @@ public class WhitespaceAroundCheck extends Check
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
      *
      * @param ast ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         empty block contained under a <code>match</code> token type
      *         node.
      */
     private boolean isEmptyType(DetailAST ast, int parentType)
     {
         final int type = ast.getType();
         if ((type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
                 && parentType == TokenTypes.OBJBLOCK)
         {
             final DetailAST typeNode = ast.getParent().getParent();
             final int matchType = typeNode.getType();
             if (matchType == TokenTypes.CLASS_DEF
                     || matchType == TokenTypes.INTERFACE_DEF
                     || matchType == TokenTypes.ENUM_DEF
                     || matchType == TokenTypes.LITERAL_NEW
                     || matchType == TokenTypes.ANNOTATION_DEF)
             {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Tests if a given <code>DetailAST</code> is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * </p>
      * In the above, the method body is an empty block ("{}").
      *
      * @param ast the <code>DetailAST</code> to test.
      * @param parentType the token type of <code>ast</code>'s parent.
      * @param match the parent token type we're looking to match.
      * @return <code>true</code> if <code>ast</code> makes up part of an
      *         empty block contained under a <code>match</code> token type
      *         node.
      */
     private boolean isEmptyBlock(DetailAST ast, int parentType, int match)
     {
         final int type = ast.getType();
         if (type == TokenTypes.RCURLY) {
             final DetailAST grandParent = ast.getParent().getParent();
-            return (parentType == TokenTypes.SLIST)
-                && (grandParent.getType() == match);
+            return parentType == TokenTypes.SLIST
+                && grandParent.getType() == match;
         }
 
-        return (type == TokenTypes.SLIST)
-            && (parentType == match)
-            && (ast.getFirstChild().getType() == TokenTypes.RCURLY);
+        return type == TokenTypes.SLIST
+            && parentType == match
+            && ast.getFirstChild().getType() == TokenTypes.RCURLY;
     }
 }
