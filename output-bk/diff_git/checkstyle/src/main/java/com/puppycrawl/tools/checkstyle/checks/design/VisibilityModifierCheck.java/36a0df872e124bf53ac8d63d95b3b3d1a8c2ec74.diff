diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
index bc74a4a12..72013f3dd 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java
@@ -1,81 +1,82 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2016 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks.design;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 import antlr.collections.AST;
-
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.FullIdent;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.AnnotationUtility;
 import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 import com.puppycrawl.tools.checkstyle.utils.ScopeUtils;
 
 /**
  * Checks visibility of class members. Only static final, immutable or annotated
  * by specified annotation members may be public,
  * other class members must be private unless allowProtected/Package is set.
  * <p>
  * Public members are not flagged if the name matches the public
  * member regular expression (contains "^serialVersionUID$" by
  * default).
  * </p>
  * Rationale: Enforce encapsulation.
  * <p>
  * Check also has options making it less strict:
  * </p>
  * <p>
  * <b>ignoreAnnotationCanonicalNames</b> - the list of annotations canonical names
  * which ignore variables in consideration, if user will provide short annotation name
  * that type will match to any named the same type without consideration of package,
  * list by default:
  * </p>
  * <ul>
  * <li>org.junit.Rule</li>
  * <li>org.junit.ClassRule</li>
  * <li>com.google.common.annotations.VisibleForTesting</li>
  * </ul>
  * <p>
  * For example such public field will be skipped by default value of list above:
  * </p>
  *
  * <pre>
  * {@code @org.junit.Rule
  * public TemporaryFolder publicJUnitRule = new TemporaryFolder();
  * }
  * </pre>
  *
  * <p>
  * <b>allowPublicFinalFields</b> - which allows public final fields. Default value is <b>false</b>.
  * </p>
  * <p>
  * <b>allowPublicImmutableFields</b> - which allows immutable fields to be
  * declared as public if defined in final class. Default value is <b>false</b>
  * </p>
  * <p>
@@ -606,167 +607,243 @@ public class VisibilityModifierCheck
     }
 
     /**
      * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
      * @param defAST AST for a variable or class definition.
      * @return the set of modifier Strings for defAST.
      */
     private static Set<String> getModifiers(DetailAST defAST) {
         final AST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);
         final Set<String> modifiersSet = new HashSet<>();
         if (modifiersAST != null) {
             AST modifier = modifiersAST.getFirstChild();
             while (modifier != null) {
                 modifiersSet.add(modifier.getText());
                 modifier = modifier.getNextSibling();
             }
         }
         return modifiersSet;
     }
 
     /**
      * Returns the visibility scope for the variable.
      * @param variableDef Variable definition node.
      * @return one of "public", "private", "protected", "package"
      */
     private static String getVisibilityScope(DetailAST variableDef) {
         final Set<String> modifiers = getModifiers(variableDef);
         String accessModifier = PACKAGE_ACCESS_MODIFIER;
         for (final String modifier : EXPLICIT_MODS) {
             if (modifiers.contains(modifier)) {
                 accessModifier = modifier;
                 break;
             }
         }
         return accessModifier;
     }
 
     /**
      * Checks if current field is immutable:
      * has final modifier and either a primitive type or instance of class
      * known to be immutable (such as String, ImmutableCollection from Guava and etc).
      * Classes known to be immutable are listed in
      * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
      * @param variableDef Field in consideration.
      * @return true if field is immutable.
      */
     private boolean isImmutableField(DetailAST variableDef) {
         boolean result = false;
         if (isFinalField(variableDef)) {
             final DetailAST type = variableDef.findFirstToken(TokenTypes.TYPE);
-            final boolean isCanonicalName = type.getFirstChild().getType() == TokenTypes.DOT;
+            final boolean isCanonicalName = isCanonicalName(type);
             final String typeName = getTypeName(type, isCanonicalName);
-
-            result = !isCanonicalName && isPrimitive(type)
-                     || immutableClassShortNames.contains(typeName)
-                     || isCanonicalName && immutableClassCanonicalNames.contains(typeName);
+            final DetailAST typeArgs = getGenericTypeArgs(type, isCanonicalName);
+            if (typeArgs == null) {
+                result = !isCanonicalName && isPrimitive(type)
+                    || immutableClassShortNames.contains(typeName)
+                    || isCanonicalName && immutableClassCanonicalNames.contains(typeName);
+            }
+            else {
+                final List<String> argsClassNames = getTypeArgsClassNames(typeArgs);
+                result = (immutableClassShortNames.contains(typeName)
+                    || isCanonicalName && immutableClassCanonicalNames.contains(typeName))
+                    && areImmutableTypeArguments(argsClassNames);
+            }
         }
         return result;
     }
 
+    /**
+     * Checks whether type definition is in canonical form.
+     * @param type type definition token.
+     * @return true if type definition is in canonical form.
+     */
+    private static boolean isCanonicalName(DetailAST type) {
+        return type.getFirstChild().getType() == TokenTypes.DOT;
+    }
+
+    /**
+     * Returns generic type arguments token.
+     * @param type type token.
+     * @param isCanonicalName whether type name is in canonical form.
+     * @return generic type arguments token.
+     */
+    private DetailAST getGenericTypeArgs(DetailAST type, boolean isCanonicalName) {
+        final DetailAST typeArgs;
+        if (isCanonicalName) {
+            // if type class name is in canonical form, abstract tree has specific structure
+            typeArgs = type.getFirstChild().findFirstToken(TokenTypes.TYPE_ARGUMENTS);
+        }
+        else {
+            typeArgs = type.findFirstToken(TokenTypes.TYPE_ARGUMENTS);
+        }
+        return typeArgs;
+    }
+
+    /**
+     * Returns a list of type parameters class names.
+     * @param typeArgs type arguments token.
+     * @return a list of type parameters class names.
+     */
+    private static List<String> getTypeArgsClassNames(DetailAST typeArgs) {
+        final List<String> typeClassNames = new ArrayList<>();
+        DetailAST type = typeArgs.findFirstToken(TokenTypes.TYPE_ARGUMENT);
+        boolean isCanonicalName = isCanonicalName(type);
+        String typeName = getTypeName(type, isCanonicalName);
+        typeClassNames.add(typeName);
+        DetailAST sibling = type.getNextSibling();
+        while (sibling.getType() == TokenTypes.COMMA) {
+            type = sibling.getNextSibling();
+            isCanonicalName = isCanonicalName(type);
+            typeName = getTypeName(type, isCanonicalName);
+            typeClassNames.add(typeName);
+            sibling = type.getNextSibling();
+        }
+        return typeClassNames;
+    }
+
+    /**
+     * Checks whether all of generic type arguments are immutable.
+     * If at least one argument is mutable, we assume that the whole list of type arguments
+     * is mutable.
+     * @param typeArgsClassNames type arguments class names.
+     * @return true if all of generic type arguments are immutable.
+     */
+    private boolean areImmutableTypeArguments(List<String> typeArgsClassNames) {
+        return !Iterables.tryFind(typeArgsClassNames, new Predicate<String>() {
+            @Override
+            public boolean apply(String typeName) {
+                return !immutableClassShortNames.contains(typeName)
+                    && !immutableClassCanonicalNames.contains(typeName);
+            }
+        }).isPresent();
+    }
+
     /**
      * Checks whether current field is final.
      * @param variableDef field in consideration.
      * @return true if current field is final.
      */
     private boolean isFinalField(DetailAST variableDef) {
         final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);
         return modifiers.branchContains(TokenTypes.FINAL);
     }
 
     /**
      * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
      * If type is specified via its canonical name - canonical name will be returned,
      * else - short type's name.
      * @param type {@link TokenTypes#TYPE TYPE} node.
      * @param isCanonicalName is given name canonical.
      * @return String representation of given type's name.
      */
     private static String getTypeName(DetailAST type, boolean isCanonicalName) {
         final String typeName;
         if (isCanonicalName) {
             typeName = getCanonicalName(type);
         }
         else {
             typeName = type.getFirstChild().getText();
         }
         return typeName;
     }
 
     /**
      * Checks if current type is primitive type (int, short, float, boolean, double, etc.).
      * As primitive types have special tokens for each one, such as:
      * LITERAL_INT, LITERAL_BOOLEAN, etc.
      * So, if type's identifier differs from {@link TokenTypes#IDENT IDENT} token - it's a
      * primitive type.
      * @param type Ast {@link TokenTypes#TYPE TYPE} node.
      * @return true if current type is primitive type.
      */
     private static boolean isPrimitive(DetailAST type) {
         return type.getFirstChild().getType() != TokenTypes.IDENT;
     }
 
     /**
      * Gets canonical type's name from given {@link TokenTypes#TYPE TYPE} node.
      * @param type DetailAST {@link TokenTypes#TYPE TYPE} node.
      * @return canonical type's name
      */
     private static String getCanonicalName(DetailAST type) {
         final StringBuilder canonicalNameBuilder = new StringBuilder();
         DetailAST toVisit = type.getFirstChild();
         while (toVisit != null) {
             toVisit = getNextSubTreeNode(toVisit, type);
             if (toVisit != null && toVisit.getType() == TokenTypes.IDENT) {
                 canonicalNameBuilder.append(toVisit.getText());
-                final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit,
-                         type);
+                final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, type);
                 if (nextSubTreeNode != null) {
+                    if (nextSubTreeNode.getType() == TokenTypes.TYPE_ARGUMENTS) {
+                        break;
+                    }
                     canonicalNameBuilder.append('.');
                 }
             }
         }
         return canonicalNameBuilder.toString();
     }
 
     /**
      * Gets the next node of a syntactical tree (child of a current node or
      * sibling of a current node, or sibling of a parent of a current node).
      * @param currentNodeAst Current node in considering
      * @param subTreeRootAst SubTree root
      * @return Current node after bypassing, if current node reached the root of a subtree
      *        method returns null
      */
     private static DetailAST
         getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
         DetailAST currentNode = currentNodeAst;
         DetailAST toVisitAst = currentNode.getFirstChild();
         while (toVisitAst == null) {
             toVisitAst = currentNode.getNextSibling();
             if (toVisitAst == null) {
                 if (currentNode.getParent().equals(subTreeRootAst)
                          && currentNode.getParent().getColumnNo() == subTreeRootAst.getColumnNo()) {
                     break;
                 }
                 currentNode = currentNode.getParent();
             }
         }
         return toVisitAst;
     }
 
     /**
      * Gets the list with short names classes.
      * These names are taken from array of classes canonical names.
      * @param canonicalClassNames canonical class names.
      * @return the list of short names of classes.
      */
     private static List<String> getClassShortNames(List<String> canonicalClassNames) {
         final List<String> shortNames = new ArrayList<>();
         for (String canonicalClassName : canonicalClassNames) {
             final String shortClassName = canonicalClassName
                     .substring(canonicalClassName.lastIndexOf('.') + 1,
                     canonicalClassName.length());
             shortNames.add(shortClassName);
         }
         return shortNames;
     }
 
     /**
