diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index ada165b11..5224acc5b 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -518,101 +518,101 @@ public class CommentsIndentationCheck extends Check {
             }
         }
         return previousStatement;
     }
 
     /**
      * Finds a previous statement of the single line comment.
      * Uses root token of the line while searching.
      * @param comment single line comment.
      * @param root root token of the line.
      * @return previous statement of the single line comment or null if previous statement was not
      *         found.
      */
     private static DetailAST findPreviousStatementOfSingleLineComment(DetailAST comment,
                                                                       DetailAST root) {
         DetailAST previousStatement = null;
         if (root.getLineNo() >= comment.getLineNo()) {
             // ATTENTION: parent of the comment is below the comment in case block
             // See https://github.com/checkstyle/checkstyle/issues/851
             previousStatement = getPrevStatementFromSwitchBlock(comment);
         }
         final DetailAST tokenWhichBeginsTheLine;
         if (root.getType() == TokenTypes.EXPR
                 && root.getFirstChild().getFirstChild() != null) {
             if (root.getFirstChild().getType() == TokenTypes.LITERAL_NEW) {
                 tokenWhichBeginsTheLine = root.getFirstChild();
             }
             else {
                 tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine(root);
             }
         }
         else if (root.getType() == TokenTypes.PLUS) {
             tokenWhichBeginsTheLine = root.getFirstChild();
         }
         else {
             tokenWhichBeginsTheLine = root;
         }
         if (tokenWhichBeginsTheLine != null
                 && isOnPreviousLine(comment, tokenWhichBeginsTheLine)) {
             previousStatement = tokenWhichBeginsTheLine;
         }
         return previousStatement;
     }
 
     /**
      * Finds a token which begins the line.
      * @param root root token of the line.
      * @return token which begins the line.
      */
     private static DetailAST findTokenWhichBeginsTheLine(DetailAST root) {
-        DetailAST tokenWhichBeginsTheLine;
+        final DetailAST tokenWhichBeginsTheLine;
         if (isUsingOfObjectReferenceToInvokeMethod(root)) {
             tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain(root);
         }
         else {
             tokenWhichBeginsTheLine = root.getFirstChild().findFirstToken(TokenTypes.IDENT);
         }
         return tokenWhichBeginsTheLine;
     }
 
     /**
      * Checks whether there is a use of an object reference to invoke an object's method on line.
      * @param root root token of the line.
      * @return true if there is a use of an object reference to invoke an object's method on line.
      */
     private static boolean isUsingOfObjectReferenceToInvokeMethod(DetailAST root) {
         return root.getFirstChild().getFirstChild().getFirstChild() != null
             && root.getFirstChild().getFirstChild().getFirstChild().getNextSibling() != null;
     }
 
     /**
      * Finds the start token of method call chain.
      * @param root root token of the line.
      * @return the start token of method call chain.
      */
     private static DetailAST findStartTokenOfMethodCallChain(DetailAST root) {
         DetailAST startOfMethodCallChain = root;
         while (startOfMethodCallChain.getFirstChild() != null
                 && startOfMethodCallChain.getFirstChild().getLineNo() == root.getLineNo()) {
             startOfMethodCallChain = startOfMethodCallChain.getFirstChild();
         }
         if (startOfMethodCallChain.getFirstChild() != null) {
             startOfMethodCallChain = startOfMethodCallChain.getFirstChild().getNextSibling();
         }
         return startOfMethodCallChain;
     }
 
     /**
      * Checks whether the checked statement is on previous line.
      * @param currentStatement current statement.
      * @param checkedStatement checked statement.
      * @return true if checked statement is on the line which is previous to current statement.
      */
     private static boolean isOnPreviousLine(DetailAST currentStatement,
                                             DetailAST checkedStatement) {
         return currentStatement.getLineNo() - checkedStatement.getLineNo() == 1;
     }
 
     /**
      * Logs comment which can have the same indentation level as next or previous statement.
      * @param comment comment.
@@ -679,101 +679,101 @@ public class CommentsIndentationCheck extends Check {
             }
         }
         return prevStmt;
     }
 
     /**
      * Gets previous case-token for comment.
      * @param parentStatement comment's parent statement.
      * @return previous case-token or null if previous case-token is absent.
      */
     private static DetailAST getPrevCaseToken(DetailAST parentStatement) {
         final DetailAST prevCaseToken;
         final DetailAST parentBlock = parentStatement.getParent();
         if (parentBlock != null && parentBlock.getParent() != null
                 && parentBlock.getParent().getPreviousSibling() != null
                 && parentBlock.getParent().getPreviousSibling().getType()
                     == TokenTypes.LITERAL_CASE) {
             prevCaseToken = parentBlock.getParent().getPreviousSibling();
         }
         else {
             prevCaseToken = null;
         }
         return prevCaseToken;
     }
 
     /**
      * Checks if comment and next code statement
      * (or previous code stmt like <b>case</b> in switch block) are indented at the same level,
      * e.g.:
      * <p>
      * <pre>
      * {@code
      * // some comment - same indentation level
      * int x = 10;
      *     // some comment - different indentation level
      * int x1 = 5;
      * /*
      *  *
      *  *&#47;
      *  boolean bool = true; - same indentation level
      * }
      * </pre>
      * </p>
      * @param comment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      * @param prevStmt previous code statement.
      * @param nextStmt next code statement.
      * @return true if comment and next code statement are indented at the same level.
      */
     private static boolean areSameLevelIndented(DetailAST comment, DetailAST prevStmt,
                                                 DetailAST nextStmt) {
-        boolean result;
+        final boolean result;
         if (prevStmt == null) {
             result = comment.getColumnNo() == nextStmt.getColumnNo();
         }
         else {
             result = comment.getColumnNo() == nextStmt.getColumnNo()
                 || comment.getColumnNo() == prevStmt.getColumnNo();
         }
         return result;
     }
 
     /**
      * Checks if current single line comment is trailing comment, e.g.:
      * <p>
      * {@code
      * double d = 3.14; // some comment
      * }
      * </p>
      * @param singleLineComment {@link TokenTypes#SINGLE_LINE_COMMENT single line comment}.
      * @return true if current single line comment is trailing comment.
      */
     private boolean isTrailingSingleLineComment(DetailAST singleLineComment) {
         final String targetSourceLine = getLine(singleLineComment.getLineNo() - 1);
         final int commentColumnNo = singleLineComment.getColumnNo();
         return !CommonUtils.hasWhitespaceBefore(commentColumnNo, targetSourceLine);
     }
 
     /**
      * Checks comment block indentations over surrounding code, e.g.:
      * <p>
      * {@code
      * /* some comment *&#47; - this is ok
      * double d = 3.14;
      *     /* some comment *&#47; - this is <b>not</b> ok.
      * double d1 = 5.0;
      * }
      * </p>
      * @param blockComment {@link TokenTypes#BLOCK_COMMENT_BEGIN block comment begin}.
      */
     private void visitBlockComment(DetailAST blockComment) {
         final DetailAST nextStatement = blockComment.getNextSibling();
         final DetailAST prevStatement = getPrevStatementFromSwitchBlock(blockComment);
 
         if (nextStatement != null
                 && nextStatement.getType() != TokenTypes.RCURLY
                 && !isTrailingBlockComment(blockComment)
                 && !areSameLevelIndented(blockComment, prevStatement, nextStatement)) {
             log(blockComment.getLineNo(), MSG_KEY_BLOCK, nextStatement.getLineNo(),
                 blockComment.getColumnNo(), nextStatement.getColumnNo());
         }
     }
