diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
index 2d7f84412..38f2d377d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java
@@ -1,80 +1,81 @@
 ////////////////////////////////////////////////////////////////////////////////
 // checkstyle: Checks Java source code for adherence to a set of rules.
 // Copyright (C) 2001-2017 the original author or authors.
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Lesser General Public
 // License as published by the Free Software Foundation; either
 // version 2.1 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Lesser General Public License for more details.
 //
 // You should have received a copy of the GNU Lesser General Public
 // License along with this library; if not, write to the Free Software
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.puppycrawl.tools.checkstyle.checks;
 
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
 import com.puppycrawl.tools.checkstyle.api.DetailAST;
 import com.puppycrawl.tools.checkstyle.api.TextBlock;
 import com.puppycrawl.tools.checkstyle.api.TokenTypes;
+import com.puppycrawl.tools.checkstyle.utils.CommonUtils;
 
 /**
  * <p>
  * Restrict using <a href =
  * "http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.3">
  * Unicode escapes</a> (such as <code>&#92;u221e</code>).
  * It is possible to allow using escapes for
  * <a href="https://en.wiktionary.org/wiki/Appendix:Control_characters">
  * non-printable(control) characters</a>.
  * Also, this check can be configured to allow using escapes
  * if trail comment is present. By the option it is possible to
  * allow using escapes if literal contains only them. By the option it
  * is possible to allow using escapes for space literals.
  * </p>
  * <p>
  * Examples of using Unicode:</p>
  * <pre>
  * String unitAbbrev = "Î¼s";      // Best: perfectly clear even without a comment.
  * String unitAbbrev = "&#92;u03bcs"; // Poor: the reader has no idea what this is.
  * </pre>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"/&gt;
  * </pre>
  * <p>
  * An example of non-printable(control) characters.
  * </p>
  * <pre>
  * return '&#92;ufeff' + content; // byte order mark
  * </pre>
  * <p>
  * An example of how to configure the check to allow using escapes
  * for non-printable(control) characters:
  * </p>
  * <pre>
  * &lt;module name="AvoidEscapedUnicodeCharacters"&gt;
  *     &lt;property name="allowEscapesForControlCharacters" value="true"/&gt;
  * &lt;/module&gt;
  * </pre>
  * <p>
  * Example of using escapes with trail comment:
  * </p>
  * <pre>
  * String unitAbbrev = "&#92;u03bcs"; // Greek letter mu, "s"
  * </pre>
  * <p>An example of how to configure the check to allow using escapes
  * if trail comment is present:
  * </p>
@@ -252,79 +253,79 @@ public class AvoidEscapedUnicodeCharactersCheck
     private static boolean hasUnicodeChar(String literal) {
         final String literalWithoutEscapedBackslashes =
                 ESCAPED_BACKSLASH.matcher(literal).replaceAll("");
         return UNICODE_REGEXP.matcher(literalWithoutEscapedBackslashes).find();
     }
 
     /**
      * Check if String literal contains Unicode control chars.
      * @param literal String literal.
      * @param pattern RegExp for valid characters.
      * @return true, if String literal contains Unicode control chars.
      */
     private static boolean isOnlyUnicodeValidChars(String literal, Pattern pattern) {
         final int unicodeMatchesCounter =
                 countMatches(UNICODE_REGEXP, literal);
         final int unicodeValidMatchesCounter =
                 countMatches(pattern, literal);
         return unicodeMatchesCounter - unicodeValidMatchesCounter == 0;
     }
 
     /**
      * Check if trail comment is present after ast token.
      * @param ast current token.
      * @return true if trail comment is present after ast token.
      */
     private boolean hasTrailComment(DetailAST ast) {
         boolean result = false;
         final int lineNo = ast.getLineNo();
         if (singlelineComments.containsKey(lineNo)) {
             result = true;
         }
         else {
             final List<TextBlock> commentList = blockComments.get(lineNo);
             if (commentList != null) {
                 final TextBlock comment = commentList.get(commentList.size() - 1);
                 final String line = getLines()[lineNo - 1];
                 result = isTrailingBlockComment(comment, line);
             }
         }
         return result;
     }
 
     /**
      * Whether the C style comment is trailing.
      * @param comment the comment to check.
      * @param line the line where the comment starts.
      * @return true if the comment is trailing.
      */
     private static boolean isTrailingBlockComment(TextBlock comment, String line) {
         return comment.getText().length != 1
-            || line.substring(comment.getEndColNo() + 1).trim().isEmpty();
+            || CommonUtils.isBlank(line.substring(comment.getEndColNo() + 1));
     }
 
     /**
      * Count regexp matches into String literal.
      * @param pattern pattern.
      * @param target String literal.
      * @return count of regexp matches.
      */
     private static int countMatches(Pattern pattern, String target) {
         int matcherCounter = 0;
         final Matcher matcher = pattern.matcher(target);
         while (matcher.find()) {
             matcherCounter++;
         }
         return matcherCounter;
     }
 
     /**
      * Checks if all characters in String literal is escaped.
      * @param literal current literal.
      * @return true if all characters in String literal is escaped.
      */
     private boolean isAllCharactersEscaped(String literal) {
         return allowIfAllCharactersEscaped
                 && ALL_ESCAPED_CHARS.matcher(literal.substring(1,
                         literal.length() - 1)).find();
     }
 }
