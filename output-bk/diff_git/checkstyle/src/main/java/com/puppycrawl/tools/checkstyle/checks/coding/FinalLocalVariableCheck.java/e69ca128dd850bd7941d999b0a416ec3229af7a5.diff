diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
index ebde379fb..bf7297c9c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java
@@ -316,121 +316,139 @@ public class FinalLocalVariableCheck extends AbstractCheck {
     private void storePrevScopeUninitializedVariableData() {
         final ScopeData scopeData = scopeStack.peek();
         final Deque<DetailAST> prevScopeUnitializedVariableData =
                 new ArrayDeque<>();
         scopeData.uninitializedVariables.forEach(prevScopeUnitializedVariableData::push);
         prevScopeUninitializedVariables.push(prevScopeUnitializedVariableData);
     }
 
     /**
      * Update current scope data uninitialized variable according to the previous scope data.
      * @param prevScopeUnitializedVariableData variable for previous stack of uninitialized
      *     variables
      */
     // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation.
     private void updateUninitializedVariables(Deque<DetailAST> prevScopeUnitializedVariableData) {
         // Check for only previous scope
         for (DetailAST variable : prevScopeUnitializedVariableData) {
             for (ScopeData scopeData : scopeStack) {
                 final FinalVariableCandidate candidate = scopeData.scope.get(variable.getText());
                 DetailAST storedVariable = null;
                 if (candidate != null) {
                     storedVariable = candidate.variableIdent;
                 }
                 if (storedVariable != null && isSameVariables(storedVariable, variable)
                         && !scopeData.uninitializedVariables.contains(storedVariable)) {
                     scopeData.uninitializedVariables.push(variable);
                 }
             }
         }
         // Check for rest of the scope
         for (Deque<DetailAST> unitializedVariableData : prevScopeUninitializedVariables) {
             for (DetailAST variable : unitializedVariableData) {
                 for (ScopeData scopeData : scopeStack) {
                     final FinalVariableCandidate candidate =
                         scopeData.scope.get(variable.getText());
                     DetailAST storedVariable = null;
                     if (candidate != null) {
                         storedVariable = candidate.variableIdent;
                     }
                     if (storedVariable != null
                             && isSameVariables(storedVariable, variable)
                             && !scopeData.uninitializedVariables.contains(storedVariable)) {
                         scopeData.uninitializedVariables.push(variable);
                     }
                 }
             }
         }
     }
 
     /**
-     * If token is LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, or LITERAL_ELSE, then do not
-     * update the uninitialized variables.
+     * If token is LITERAL_IF and there is an {@code else} following or token is CASE_GROUP and
+     * there is another {@code case} following, then update the uninitialized variables.
      * @param ast token to be checked
      * @return true if should be updated, else false
      */
     private static boolean shouldUpdateUninitializedVariables(DetailAST ast) {
-        return ast.getType() != TokenTypes.LITERAL_TRY
-                && ast.getType() != TokenTypes.LITERAL_CATCH
-                && ast.getType() != TokenTypes.LITERAL_FINALLY
-                && ast.getType() != TokenTypes.LITERAL_ELSE;
+        return isIfTokenWithAnElseFollowing(ast) || isCaseTokenWithAnotherCaseFollowing(ast);
+    }
+
+    /**
+     * If token is LITERAL_IF and there is an {@code else} following.
+     * @param ast token to be checked
+     * @return true if token is LITERAL_IF and there is an {@code else} following, else false
+     */
+    private static boolean isIfTokenWithAnElseFollowing(DetailAST ast) {
+        return ast.getType() == TokenTypes.LITERAL_IF
+                && ast.getLastChild().getType() == TokenTypes.LITERAL_ELSE;
+    }
+
+    /**
+     * If token is CASE_GROUP and there is another {@code case} following.
+     * @param ast token to be checked
+     * @return true if token is CASE_GROUP and there is another {@code case} following, else false
+     */
+    private static boolean isCaseTokenWithAnotherCaseFollowing(DetailAST ast) {
+        return ast.getType() == TokenTypes.CASE_GROUP
+                && findLastChildWhichContainsSpecifiedToken(
+                        ast.getParent(), TokenTypes.CASE_GROUP, TokenTypes.SLIST) != ast;
     }
 
     /**
      * Returns the last child token that makes a specified type and contains containType in
      * its branch.
      * @param ast token to be tested
      * @param childType the token type to match
      * @param containType the token type which has to be present in the branch
      * @return the matching token, or null if no match
      */
-    public DetailAST findLastChildWhichContainsSpecifiedToken(DetailAST ast, int childType,
+    private static DetailAST findLastChildWhichContainsSpecifiedToken(DetailAST ast, int childType,
                                                               int containType) {
         DetailAST returnValue = null;
         for (DetailAST astIterator = ast.getFirstChild(); astIterator != null;
                 astIterator = astIterator.getNextSibling()) {
             if (astIterator.getType() == childType && astIterator.branchContains(containType)) {
                 returnValue = astIterator;
             }
         }
         return returnValue;
     }
 
     /**
      * Determines whether enhanced for-loop variable should be checked or not.
      * @param ast The ast to compare.
      * @return true if enhanced for-loop variable should be checked.
      */
     private boolean shouldCheckEnhancedForLoopVariable(DetailAST ast) {
         return validateEnhancedForLoopVariable
                 || ast.getParent().getType() != TokenTypes.FOR_EACH_CLAUSE;
     }
 
     /**
      * Insert a parameter at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertParameter(DetailAST ast) {
         final Map<String, FinalVariableCandidate> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
         scope.put(astNode.getText(), new FinalVariableCandidate(astNode));
     }
 
     /**
      * Insert a variable at the topmost scope stack.
      * @param ast the variable to insert.
      */
     private void insertVariable(DetailAST ast) {
         final Map<String, FinalVariableCandidate> scope = scopeStack.peek().scope;
         final DetailAST astNode = ast.findFirstToken(TokenTypes.IDENT);
         scope.put(astNode.getText(), new FinalVariableCandidate(astNode));
         if (!isInitialized(astNode)) {
             scopeStack.peek().uninitializedVariables.add(astNode);
         }
     }
 
     /**
      * Check if VARIABLE_DEF is initialized or not.
      * @param ast VARIABLE_DEF to be checked
      * @return true if initialized
      */
     private static boolean isInitialized(DetailAST ast) {
