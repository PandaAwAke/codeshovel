diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java
index 843ba1328..1d5c17d96 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java
@@ -31,111 +31,111 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 import com.puppycrawl.tools.checkstyle.utils.CheckUtils;
 
 /**
  * <p>
  * Checks that classes that either override {@code equals()} or {@code hashCode()} also
  * overrides the other.
  * This checks only verifies that the method declarations match {@link Object#equals(Object)} and
  * {@link Object#hashCode()} exactly to be considered an override. This check does not verify
  * invalid method names, parameters other than {@code Object}, or anything else.
  * </p>
  * <p>
  * Rationale: The contract of equals() and hashCode() requires that
  * equal objects have the same hashCode. Hence, whenever you override
  * equals() you must override hashCode() to ensure that your class can
  * be used in collections that are hash based.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="EqualsHashCode"/&gt;
  * </pre>
  * @author lkuehne
  */
 @FileStatefulCheck
 public class EqualsHashCodeCheck
         extends AbstractCheck {
     // implementation note: we have to use the following members to
     // keep track of definitions in different inner classes
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_HASHCODE = "equals.noHashCode";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY_EQUALS = "equals.noEquals";
 
     /** Maps OBJ_BLOCK to the method definition of equals(). */
     private final Map<DetailAST, DetailAST> objBlockWithEquals = new HashMap<>();
 
     /** Maps OBJ_BLOCKs to the method definition of hashCode(). */
     private final Map<DetailAST, DetailAST> objBlockWithHashCode = new HashMap<>();
 
     @Override
     public int[] getDefaultTokens() {
-        return getAcceptableTokens();
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {TokenTypes.METHOD_DEF};
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getAcceptableTokens();
+        return new int[] {TokenTypes.METHOD_DEF};
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         objBlockWithEquals.clear();
         objBlockWithHashCode.clear();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (isEqualsMethod(ast)) {
             objBlockWithEquals.put(ast.getParent(), ast);
         }
         else if (isHashCodeMethod(ast)) {
             objBlockWithHashCode.put(ast.getParent(), ast);
         }
     }
 
     /**
      * Determines if an AST is a valid Equals method implementation.
      *
      * @param ast the AST to check
      * @return true if the {code ast} is a Equals method.
      */
     private static boolean isEqualsMethod(DetailAST ast) {
         final DetailAST modifiers = ast.getFirstChild();
         final DetailAST parameters = ast.findFirstToken(TokenTypes.PARAMETERS);
 
         return CheckUtils.isEqualsMethod(ast)
                 && modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null
                 && isObjectParam(parameters.getFirstChild())
                 && (ast.findFirstToken(TokenTypes.SLIST) != null
                         || modifiers.findFirstToken(TokenTypes.LITERAL_NATIVE) != null);
     }
 
     /**
      * Determines if an AST is a valid HashCode method implementation.
      *
      * @param ast the AST to check
      * @return true if the {code ast} is a HashCode method.
      */
     private static boolean isHashCodeMethod(DetailAST ast) {
         final DetailAST modifiers = ast.getFirstChild();
         final AST type = ast.findFirstToken(TokenTypes.TYPE);
         final AST methodName = ast.findFirstToken(TokenTypes.IDENT);
         final DetailAST parameters = ast.findFirstToken(TokenTypes.PARAMETERS);
 
         return type.getFirstChild().getType() == TokenTypes.LITERAL_INT
                 && "hashCode".equals(methodName.getText())
                 && modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null
