diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
index 4ef9bbad6..adeae49bd 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java
@@ -433,109 +433,131 @@ public class CommentsIndentationCheck extends AbstractCheck {
      * {@code
      *    ...
      *    case OPTION_ONE:
      *        int someVariable = 1;
      *    // than init variable a - OK
      *    case OPTION_TWO:
      *        int a = 5;
      *        break;
      *    ...
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment single line comment.
      * @param nextStmt next statement.
      */
     private void handleFallThroughtComment(DetailAST prevStmt, DetailAST comment,
                                            DetailAST nextStmt) {
 
         if (!areSameLevelIndented(comment, prevStmt, nextStmt)) {
             logMultilineIndentation(prevStmt, comment, nextStmt);
         }
     }
 
     /**
      * Handles a comment which is placed at the end of non empty code block.
      * Note, if single line comment is plcaed at the end of non empty block the comment should have
      * the same indentation level as the previous statement. For example:
      * <p>
      * {@code
      *    if (a == true) {
      *        int b = 1;
      *        // comment
      *    }
      * }
      * </p>
      * @param prevStmt previous statement.
      * @param comment comment to check.
      * @param nextStmt next statement.
      */
     private void handleCommentAtTheEndOfTheCodeBlock(DetailAST prevStmt, DetailAST comment,
                                                      DetailAST nextStmt) {
         if (prevStmt != null) {
             if (prevStmt.getType() == TokenTypes.LITERAL_CASE
                     || prevStmt.getType() == TokenTypes.CASE_GROUP
                     || prevStmt.getType() == TokenTypes.LITERAL_DEFAULT) {
                 if (comment.getColumnNo() < nextStmt.getColumnNo()) {
                     log(comment.getLineNo(), getMessageKey(comment), nextStmt.getLineNo(),
                         comment.getColumnNo(), nextStmt.getColumnNo());
                 }
             }
+            else if (isCommentForMultiblock(nextStmt)) {
+                if (!areSameLevelIndented(comment, prevStmt, nextStmt)) {
+                    logMultilineIndentation(prevStmt, comment, nextStmt);
+                }
+            }
             else if (!areSameLevelIndented(comment, prevStmt, prevStmt)) {
                 final int prevStmtLineNo = prevStmt.getLineNo();
                 log(comment.getLineNo(), getMessageKey(comment), prevStmtLineNo,
-                    comment.getColumnNo(), getLineStart(prevStmtLineNo));
+                        comment.getColumnNo(), getLineStart(prevStmtLineNo));
             }
         }
 
     }
 
+    /**
+     * Whether the comment might have been used for the next block in a multi-block structure.
+     * @param endBlockStmt the end of the current block.
+     * @return true, if the comment might have been used for the next
+     *     block in a multi-block structure.
+     */
+    private static boolean isCommentForMultiblock(DetailAST endBlockStmt) {
+        final DetailAST nextBlock = endBlockStmt.getParent().getNextSibling();
+        final int endBlockLineNo = endBlockStmt.getLineNo();
+        final DetailAST catchAst = endBlockStmt.getParent().getParent();
+        final DetailAST finallyAst = catchAst.getNextSibling();
+        return nextBlock != null && nextBlock.getLineNo() == endBlockLineNo
+                || finallyAst != null
+                    && catchAst.getType() == TokenTypes.LITERAL_CATCH
+                    && finallyAst.getLineNo() == endBlockLineNo;
+    }
+
     /**
      * Handles a comment which is placed within the empty code block.
      * Note, if comment is placed at the end of the empty code block, we have Checkstyle's
      * limitations to clearly detect user intention of explanation target - above or below. The
      * only case we can assume as a violation is when a single line comment within the empty
      * code block has indentation level that is lower than the indentation level of the closing
      * right curly brace. For example:
      * <p>
      * {@code
      *    if (a == true) {
      * // violation
      *    }
      * }
      * </p>
      *
      * @param comment comment to check.
      * @param nextStmt next statement.
      */
     private void handleCommentInEmptyCodeBlock(DetailAST comment, DetailAST nextStmt) {
         if (comment.getColumnNo() < nextStmt.getColumnNo()) {
             log(comment.getLineNo(), getMessageKey(comment), nextStmt.getLineNo(),
                 comment.getColumnNo(), nextStmt.getColumnNo());
         }
     }
 
     /**
      * Does pre-order traverse of abstract syntax tree to find the previous statement of the
      * comment. If previous statement of the comment is found, then the traverse will
      * be finished.
      * @param comment current statement.
      * @return previous statement of the comment or null if the comment does not have previous
      *         statement.
      */
     private DetailAST getOneLinePreviousStatement(DetailAST comment) {
         DetailAST root = comment.getParent();
         while (root != null && !isBlockStart(root)) {
             root = root.getParent();
         }
 
         final Deque<DetailAST> stack = new ArrayDeque<>();
         DetailAST previousStatement = null;
         while (root != null || !stack.isEmpty()) {
             if (!stack.isEmpty()) {
                 root = stack.pop();
             }
             while (root != null) {
                 previousStatement = findPreviousStatement(comment, root);
                 if (previousStatement != null) {
                     root = null;
                     stack.clear();
