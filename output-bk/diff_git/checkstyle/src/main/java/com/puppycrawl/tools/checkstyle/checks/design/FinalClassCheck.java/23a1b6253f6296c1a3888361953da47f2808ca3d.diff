diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
index 1cf09296d..d7b70498d 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java
@@ -29,101 +29,102 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
 
 /**
  * <p>
  * Checks that class which has only private ctors
  * is declared as final.
  * </p>
  * <p>
  * An example of how to configure the check is:
  * </p>
  * <pre>
  * &lt;module name="FinalClass"/&gt;
  * </pre>
  * @author o_sukhodolsky
  */
 public class FinalClassCheck
     extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "final.class";
 
     /** Keeps ClassDesc objects for stack of declared classes. */
     private final Deque<ClassDesc> classes = new ArrayDeque<>();
 
     @Override
     public int[] getDefaultTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[]{TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF};
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getAcceptableTokens();
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);
 
         if (ast.getType() == TokenTypes.CLASS_DEF) {
             final boolean isFinal = modifiers.branchContains(TokenTypes.FINAL);
             final boolean isAbstract = modifiers.branchContains(TokenTypes.ABSTRACT);
             classes.push(new ClassDesc(isFinal, isAbstract));
         }
-        else if (!ScopeUtils.inEnumBlock(ast)) { //ctors in enums don't matter
+        // ctors in enums don't matter
+        else if (!ScopeUtils.inEnumBlock(ast)) {
             final ClassDesc desc = classes.peek();
             if (modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)) {
                 desc.reportPrivateCtor();
             }
             else {
                 desc.reportNonPrivateCtor();
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         if (ast.getType() != TokenTypes.CLASS_DEF) {
             return;
         }
 
         final ClassDesc desc = classes.pop();
         if (!desc.isDeclaredAsFinal()
             && !desc.isDeclaredAsAbstract()
             && desc.isWithPrivateCtor()
             && !desc.isWithNonPrivateCtor()) {
             final String className =
                 ast.findFirstToken(TokenTypes.IDENT).getText();
             log(ast.getLineNo(), MSG_KEY, className);
         }
     }
 
     /** Maintains information about class' ctors */
     private static final class ClassDesc {
         /** Is class declared as final */
         private final boolean declaredAsFinal;
 
         /** Is class declared as abstract */
         private final boolean declaredAsAbstract;
 
         /** Does class have non-provate ctors */
         private boolean withNonPrivateCtor;
 
         /** Does class have private ctors */
         private boolean withPrivateCtor;
 
         /**
          *  Create a new ClassDesc instance.
          *  @param declaredAsFinal indicates if the
          *         class declared as final
          *  @param declaredAsAbstract indicates if the
          *         class declared as abstract
          */
         ClassDesc(boolean declaredAsFinal, boolean declaredAsAbstract) {
             this.declaredAsFinal = declaredAsFinal;
