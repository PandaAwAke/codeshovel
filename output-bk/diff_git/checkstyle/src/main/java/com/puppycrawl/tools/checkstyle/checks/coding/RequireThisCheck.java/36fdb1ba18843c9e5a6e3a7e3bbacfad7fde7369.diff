diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
index bc39110db..1e34daf37 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java
@@ -99,196 +99,213 @@ public class RequireThisCheck extends AbstractCheck {
      * file.
      */
     public static final String MSG_METHOD = "require.this.method";
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_VARIABLE = "require.this.variable";
 
     /** Set of all declaration tokens. */
     private static final Set<Integer> DECLARATION_TOKENS = Collections.unmodifiableSet(
         Arrays.stream(new Integer[] {
             TokenTypes.VARIABLE_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.PARAMETER_DEF,
             TokenTypes.TYPE_ARGUMENT,
         }).collect(Collectors.toSet()));
     /** Set of all assign tokens. */
     private static final Set<Integer> ASSIGN_TOKENS = Collections.unmodifiableSet(
         Arrays.stream(new Integer[] {
             TokenTypes.ASSIGN,
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.SR_ASSIGN,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.SL_ASSIGN,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BXOR_ASSIGN,
         }).collect(Collectors.toSet()));
     /** Set of all compound assign tokens. */
     private static final Set<Integer> COMPOUND_ASSIGN_TOKENS = Collections.unmodifiableSet(
         Arrays.stream(new Integer[] {
             TokenTypes.PLUS_ASSIGN,
             TokenTypes.STAR_ASSIGN,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.MOD_ASSIGN,
             TokenTypes.SR_ASSIGN,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.SL_ASSIGN,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BXOR_ASSIGN,
         }).collect(Collectors.toSet()));
 
+    /** Frame for the currently processed AST. */
+    private final Deque<AbstractFrame> current = new ArrayDeque<>();
+
     /** Tree of all the parsed frames. */
     private Map<DetailAST, AbstractFrame> frames;
 
-    /** Frame for the currently processed AST. */
-    private AbstractFrame current;
-
     /** Whether we should check fields usage. */
     private boolean checkFields = true;
     /** Whether we should check methods usage. */
     private boolean checkMethods = true;
     /** Whether we should check only overlapping by variables or arguments. */
     private boolean validateOnlyOverlapping = true;
 
     /**
      * Setter for checkFields property.
      * @param checkFields should we check fields usage or not.
      */
     public void setCheckFields(boolean checkFields) {
         this.checkFields = checkFields;
     }
 
     /**
      * Setter for checkMethods property.
      * @param checkMethods should we check methods usage or not.
      */
     public void setCheckMethods(boolean checkMethods) {
         this.checkMethods = checkMethods;
     }
 
     /**
      * Setter for validateOnlyOverlapping property.
      * @param validateOnlyOverlapping should we check only overlapping by variables or arguments.
      */
     public void setValidateOnlyOverlapping(boolean validateOnlyOverlapping) {
         this.validateOnlyOverlapping = validateOnlyOverlapping;
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.SLIST,
             TokenTypes.IDENT,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         frames = new HashMap<>();
-        current = null;
+        current.clear();
 
         final Deque<AbstractFrame> frameStack = new LinkedList<>();
         DetailAST curNode = rootAST;
         while (curNode != null) {
             collectDeclarations(frameStack, curNode);
             DetailAST toVisit = curNode.getFirstChild();
             while (curNode != null && toVisit == null) {
                 endCollectingDeclarations(frameStack, curNode);
                 toVisit = curNode.getNextSibling();
                 if (toVisit == null) {
                     curNode = curNode.getParent();
                 }
             }
             curNode = toVisit;
         }
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         switch (ast.getType()) {
             case TokenTypes.IDENT :
                 processIdent(ast);
                 break;
             case TokenTypes.CLASS_DEF :
             case TokenTypes.INTERFACE_DEF :
             case TokenTypes.ENUM_DEF :
             case TokenTypes.ANNOTATION_DEF :
             case TokenTypes.SLIST :
             case TokenTypes.METHOD_DEF :
             case TokenTypes.CTOR_DEF :
-                current = frames.get(ast);
+                current.push(frames.get(ast));
+                break;
+            default :
+                // do nothing
+        }
+    }
+
+    @Override
+    public void leaveToken(DetailAST ast) {
+        switch (ast.getType()) {
+            case TokenTypes.CLASS_DEF :
+            case TokenTypes.INTERFACE_DEF :
+            case TokenTypes.ENUM_DEF :
+            case TokenTypes.ANNOTATION_DEF :
+            case TokenTypes.SLIST :
+            case TokenTypes.METHOD_DEF :
+            case TokenTypes.CTOR_DEF :
+                current.pop();
                 break;
             default :
                 // do nothing
         }
     }
 
     /**
      * Checks if a given IDENT is method call or field name which
      * requires explicit {@code this} qualifier.
      * @param ast IDENT to check.
      */
     private void processIdent(DetailAST ast) {
         int parentType = ast.getParent().getType();
         if (parentType == TokenTypes.EXPR
                 && ast.getParent().getParent().getParent().getType()
                     == TokenTypes.ANNOTATION_FIELD_DEF) {
             parentType = TokenTypes.ANNOTATION_FIELD_DEF;
         }
         switch (parentType) {
             case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:
             case TokenTypes.ANNOTATION:
             case TokenTypes.ANNOTATION_FIELD_DEF:
                 // no need to check annotations content
                 break;
             case TokenTypes.METHOD_CALL:
                 if (checkMethods) {
                     final AbstractFrame frame = getMethodWithoutThis(ast);
                     if (frame != null) {
                         logViolation(MSG_METHOD, ast, frame);
                     }
                 }
                 break;
             default:
                 if (checkFields) {
                     final AbstractFrame frame = getFieldWithoutThis(ast, parentType);
                     if (frame != null) {
                         logViolation(MSG_VARIABLE, ast, frame);
                     }
                 }
                 break;
         }
     }
 
     /**
      * Helper method to log a LocalizedMessage.
      * @param ast a node to get line id column numbers associated with the message.
      * @param msgKey key to locale message format.
      * @param frame the class frame where the violation is found.
      */
     private void logViolation(String msgKey, DetailAST ast, AbstractFrame frame) {
@@ -796,170 +813,170 @@ public class RequireThisCheck extends AbstractCheck {
     private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,
                                                                      int endLineNumber) {
         DetailAST vertex = ast;
         final Set<DetailAST> result = new HashSet<>();
         final Deque<DetailAST> stack = new ArrayDeque<>();
         while (vertex != null || !stack.isEmpty()) {
             if (!stack.isEmpty()) {
                 vertex = stack.pop();
             }
             while (vertex != null) {
                 if (token.equals(vertex)
                         && vertex.getLineNo() <= endLineNumber) {
                     result.add(vertex);
                 }
                 if (vertex.getNextSibling() != null) {
                     stack.push(vertex.getNextSibling());
                 }
                 vertex = vertex.getFirstChild();
             }
         }
         return result;
     }
 
     /**
      * Returns the frame where the method is declared, if the given method is used without
      * 'this' and null otherwise.
      * @param ast the IDENT ast of the name to check.
      * @return the frame where the method is declared, if the given method is used without
      *         'this' and null otherwise.
      */
     private AbstractFrame getMethodWithoutThis(DetailAST ast) {
         AbstractFrame result = null;
         if (!validateOnlyOverlapping) {
             final AbstractFrame frame = findFrame(ast, true);
             if (frame != null
                     && ((ClassFrame) frame).hasInstanceMethod(ast)
                     && !((ClassFrame) frame).hasStaticMethod(ast)) {
                 result = frame;
             }
         }
         return result;
     }
 
     /**
      * Find the class frame containing declaration.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private AbstractFrame findClassFrame(DetailAST name, boolean lookForMethod) {
-        AbstractFrame frame = current;
+        AbstractFrame frame = current.peek();
 
         while (true) {
             frame = findFrame(frame, name, lookForMethod);
 
             if (frame == null || frame instanceof ClassFrame) {
                 break;
             }
 
             frame = frame.getParent();
         }
 
         return frame;
     }
 
     /**
      * Find frame containing declaration.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private AbstractFrame findFrame(DetailAST name, boolean lookForMethod) {
-        return findFrame(current, name, lookForMethod);
+        return findFrame(current.peek(), name, lookForMethod);
     }
 
     /**
      * Find frame containing declaration.
      * @param frame The parent frame to searching in.
      * @param name IDENT ast of the declaration to find.
      * @param lookForMethod whether we are looking for a method name.
      * @return AbstractFrame containing declaration or null.
      */
     private static AbstractFrame findFrame(AbstractFrame frame, DetailAST name,
             boolean lookForMethod) {
         return frame.getIfContains(name, lookForMethod);
     }
 
     /**
      * Check that token is related to Definition tokens.
      * @param parentType token Type.
      * @return true if token is related to Definition Tokens.
      */
     private static boolean isDeclarationToken(int parentType) {
         return DECLARATION_TOKENS.contains(parentType);
     }
 
     /**
      * Check that token is related to assign tokens.
      * @param tokenType token type.
      * @return true if token is related to assign tokens.
      */
     private static boolean isAssignToken(int tokenType) {
         return ASSIGN_TOKENS.contains(tokenType);
     }
 
     /**
      * Check that token is related to compound assign tokens.
      * @param tokenType token type.
      * @return true if token is related to compound assign tokens.
      */
     private static boolean isCompoundAssignToken(int tokenType) {
         return COMPOUND_ASSIGN_TOKENS.contains(tokenType);
     }
 
     /**
      * Gets the name of the nearest parent ClassFrame.
      * @return the name of the nearest parent ClassFrame.
      */
     private String getNearestClassFrameName() {
-        AbstractFrame frame = current;
+        AbstractFrame frame = current.peek();
         while (frame.getType() != FrameType.CLASS_FRAME) {
             frame = frame.getParent();
         }
         return frame.getFrameName();
     }
 
     /**
      * Checks if the token is a Lambda parameter.
      * @param ast the {@code DetailAST} value of the token to be checked
      * @return true if the token is a Lambda parameter
      */
     private static boolean isLambdaParameter(DetailAST ast) {
         DetailAST parent;
         for (parent = ast.getParent(); parent != null; parent = parent.getParent()) {
             if (parent.getType() == TokenTypes.LAMBDA) {
                 break;
             }
         }
         final boolean isLambdaParameter;
         if (parent == null) {
             isLambdaParameter = false;
         }
         else if (ast.getType() == TokenTypes.PARAMETER_DEF) {
             isLambdaParameter = true;
         }
         else {
             final DetailAST lambdaParameters = parent.findFirstToken(TokenTypes.PARAMETERS);
             if (lambdaParameters == null) {
                 isLambdaParameter = parent.getFirstChild().getText().equals(ast.getText());
             }
             else {
                 isLambdaParameter = TokenUtils.findFirstTokenByPredicate(lambdaParameters,
                     paramDef -> {
                         final DetailAST param = paramDef.findFirstToken(TokenTypes.IDENT);
                         return param != null && param.getText().equals(ast.getText());
                     }).isPresent();
             }
         }
         return isLambdaParameter;
     }
 
     /** An AbstractFrame type. */
     private enum FrameType {
         /** Class frame type. */
         CLASS_FRAME,
         /** Constructor frame type. */
         CTOR_FRAME,
         /** Method frame type. */
         METHOD_FRAME,
         /** Block frame type. */
