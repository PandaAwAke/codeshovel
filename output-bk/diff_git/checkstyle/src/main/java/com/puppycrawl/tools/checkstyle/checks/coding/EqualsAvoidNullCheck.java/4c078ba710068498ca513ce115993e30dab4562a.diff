diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
index 2f3ec751b..371fd5163 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java
@@ -120,114 +120,114 @@ public class EqualsAvoidNullCheck extends Check {
     @Override
     public void visitToken(final DetailAST methodCall) {
         final DetailAST dot = methodCall.getFirstChild();
         if (dot.getType() != TokenTypes.DOT) {
             return;
         }
 
         final DetailAST objCalledOn = dot.getFirstChild();
         if (isStringLiteral(objCalledOn)) {
             return;
         }
 
 
         final DetailAST method = objCalledOn.getNextSibling();
         final DetailAST expr = dot.getNextSibling().getFirstChild();
 
         if ("equals".equals(method.getText())
             && containsOneArgument(methodCall) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_AVOID_NULL);
         }
 
         if (!ignoreEqualsIgnoreCase
             && "equalsIgnoreCase".equals(method.getText())
             && containsOneArgument(methodCall) && containsAllSafeTokens(expr)) {
             log(methodCall.getLineNo(), methodCall.getColumnNo(),
                 MSG_EQUALS_IGNORE_CASE_AVOID_NULL);
         }
     }
 
     /**
      * Verify that method call has one argument.
      *
      * @param methodCall METHOD_CALL DetailAST
      * @return true if method call has one argument.
      */
     private static boolean containsOneArgument(DetailAST methodCall) {
         final DetailAST elist = methodCall.findFirstToken(TokenTypes.ELIST);
         return elist.getChildCount() == 1;
     }
 
     /**
      * checks for calling equals on String literal and
      * anon object which cannot be null
      * Also, checks if calling using strange inner class
      * syntax outter.inner.equals(otherObj) by looking
      * for the dot operator which cannot be improved
      * @param objCalledOn object AST
      * @return if it is string literal
      */
-    private boolean isStringLiteral(DetailAST objCalledOn) {
+    private static boolean isStringLiteral(DetailAST objCalledOn) {
         return objCalledOn.getType() == TokenTypes.STRING_LITERAL
                 || objCalledOn.getType() == TokenTypes.LITERAL_NEW
                 || objCalledOn.getType() == TokenTypes.DOT;
     }
 
     /**
      * <p>
      * Looks for all "safe" Token combinations in the argument
      * expression branch.
      * </p>
      *
      * <p>
      * See class documentation for details on autoboxing's affect
      * on this method implementation.
      * </p>
      *
      * @param expr the argument expression
      * @return - true if any child matches the set of tokens, false if not
      */
-    private boolean containsAllSafeTokens(final DetailAST expr) {
+    private static boolean containsAllSafeTokens(final DetailAST expr) {
         DetailAST arg = expr.getFirstChild();
 
         if (arg.branchContains(TokenTypes.METHOD_CALL)) {
             return false;
         }
         arg = skipVariableAssign(arg);
 
         //Plus assignment can have ill affects
         //do not want to recommend moving expression
         //See example:
         //String s = "SweetString";
         //s.equals(s += "SweetString"); //false
         //s = "SweetString";
         //(s += "SweetString").equals(s); //true
         //arg = skipVariablePlusAssign(arg);
 
         //must be just String literals to return true
         return !arg.branchContains(TokenTypes.PLUS_ASSIGN)
                 && !arg.branchContains(TokenTypes.IDENT);
     }
 
     /**
      * Skips over an inner assign portion of an argument expression.
      * @param currentAST current token in the argument expression
      * @return the next relevant token
      */
-    private DetailAST skipVariableAssign(final DetailAST currentAST) {
+    private static DetailAST skipVariableAssign(final DetailAST currentAST) {
         if (currentAST.getType() == TokenTypes.ASSIGN
                 && currentAST.getFirstChild().getType() == TokenTypes.IDENT) {
             return currentAST.getFirstChild().getNextSibling();
         }
         return currentAST;
     }
 
     /**
      * Whether to ignore checking {@code String.equalsIgnoreCase(String)}.
      * @param newValue whether to ignore checking
      *    {@code String.equalsIgnoreCase(String)}.
      */
     public void setIgnoreEqualsIgnoreCase(boolean newValue) {
         ignoreEqualsIgnoreCase = newValue;
     }
 }
