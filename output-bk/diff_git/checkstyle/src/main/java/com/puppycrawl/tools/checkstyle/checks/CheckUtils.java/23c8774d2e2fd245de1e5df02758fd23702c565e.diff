diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
index 4919999c0..4ce49b764 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/CheckUtils.java
@@ -74,103 +74,109 @@ public final class CheckUtils {
         if (!"equals".equals(name)) {
             return false;
         }
 
         // one parameter?
         final DetailAST paramsNode = ast.findFirstToken(TokenTypes.PARAMETERS);
         return paramsNode.getChildCount() == 1;
     }
 
     /**
      * Returns whether a token represents an ELSE as part of an ELSE / IF set.
      * @param ast the token to check
      * @return whether it is
      */
     public static boolean isElseIf(DetailAST ast) {
         final DetailAST parentAST = ast.getParent();
 
         return ast.getType() == TokenTypes.LITERAL_IF
             && (isElse(parentAST) || isElseWithCurlyBraces(parentAST));
     }
 
     /**
      * Returns whether a token represents an ELSE.
      * @param ast the token to check
      * @return whether the token represents an ELSE
      */
     private static boolean isElse(DetailAST ast) {
         return ast.getType() == TokenTypes.LITERAL_ELSE;
     }
 
     /**
      * Returns whether a token represents an SLIST as part of an ELSE
      * statement.
      * @param ast the token to check
      * @return whether the toke does represent an SLIST as part of an ELSE
      */
     private static boolean isElseWithCurlyBraces(DetailAST ast) {
         return ast.getType() == TokenTypes.SLIST
             && ast.getChildCount() == 2
             && isElse(ast.getParent());
     }
 
     /**
      * Creates {@code FullIdent} for given type node.
      * @param typeAST a type node.
      * @return {@code FullIdent} for given type.
      */
     public static FullIdent createFullType(DetailAST typeAST) {
         final DetailAST arrayDeclAST =
             typeAST.findFirstToken(TokenTypes.ARRAY_DECLARATOR);
+        final FullIdent fullType;
 
-        return createFullTypeNoArrays(arrayDeclAST == null ? typeAST
-                                                           : arrayDeclAST);
+        if (arrayDeclAST == null) {
+            fullType = createFullTypeNoArrays(typeAST);
+        }
+        else {
+            fullType = createFullTypeNoArrays(arrayDeclAST);
+        }
+        return fullType;
     }
 
     /**
      * @param typeAST a type node (no array)
      * @return {@code FullIdent} for given type.
      */
     private static FullIdent createFullTypeNoArrays(DetailAST typeAST) {
         return FullIdent.createFullIdent(typeAST.getFirstChild());
     }
 
     /**
      * Returns the value represented by the specified string of the specified
      * type. Returns 0 for types other than float, double, int, and long.
      * @param text the string to be parsed.
      * @param type the token type of the text. Should be a constant of
      * {@link TokenTypes}.
      * @return the double value represented by the string argument.
      */
     public static double parseDouble(String text, int type) {
         String txt = text.replaceAll("_", "");
         double result = 0;
         switch (type) {
             case TokenTypes.NUM_FLOAT:
             case TokenTypes.NUM_DOUBLE:
                 result = Double.parseDouble(txt);
                 break;
             case TokenTypes.NUM_INT:
             case TokenTypes.NUM_LONG:
                 int radix = BASE_10;
                 if (txt.startsWith("0x") || txt.startsWith("0X")) {
                     radix = BASE_16;
                     txt = txt.substring(2);
                 }
                 else if (txt.charAt(0) == '0') {
                     radix = BASE_8;
                     txt = txt.substring(1);
                 }
                 if (Utils.endsWithChar(txt, 'L') || Utils.endsWithChar(txt, 'l')) {
                     txt = txt.substring(0, txt.length() - 1);
                 }
                 if (!txt.isEmpty()) {
                     if (type == TokenTypes.NUM_INT) {
                         result = parseInt(txt, radix);
                     }
                     else {
                         result = parseLong(txt, radix);
                     }
                 }
                 break;
             default:
