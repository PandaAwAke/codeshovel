diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index 6f98fd9fb..4af507144 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -102,100 +102,112 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
      * controls whether to allow documented exceptions that are not declared if
      * they are a subclass of java.lang.RuntimeException.
      */
     private boolean mAllowUndeclaredRTE;
 
     /**
      * Allows validating throws tags.
      */
     private boolean mValidateThrows;
 
     /**
      * controls whether to allow documented exceptions that are subclass of one
      * of declared exception. Defaults to false (backward compatibility).
      */
     private boolean mAllowThrowsTagsForSubclasses;
 
     /**
      * controls whether to ignore errors when a method has parameters but does
      * not have matching param tags in the javadoc. Defaults to false.
      */
     private boolean mAllowMissingParamTags;
 
     /**
      * controls whether to ignore errors when a method declares that it throws
      * exceptions but does not have matching throws tags in the javadoc.
      * Defaults to false.
      */
     private boolean mAllowMissingThrowsTags;
 
     /**
      * controls whether to ignore errors when a method returns non-void type
      * but does not have a return tag in the javadoc. Defaults to false.
      */
     private boolean mAllowMissingReturnTag;
 
     /**
      * Controls whether to ignore errors when there is no javadoc. Defaults to
      * false.
      */
     private boolean mAllowMissingJavadoc;
 
     /**
      * Controls whether to allow missing Javadoc on accessor methods for
      * properties (setters and getters).
      */
     private boolean mAllowMissingPropertyJavadoc;
 
     /** List of annotations that could allow missed documentation. */
     private List<String> mAllowedAnnotations = Arrays.asList("Override");
 
+    /** Method names that match this pattern do not require javadoc blocks. */
+    private Pattern mIgnoreMethodNamesRegex;
+
+    /**
+     * Set regex for matching method names to ignore.
+     * @param aRegex regex for matching method names.
+     */
+    public void setIgnoreMethodNamesRegex(String aRegex)
+    {
+        mIgnoreMethodNamesRegex = Utils.createPattern(aRegex);
+    }
+
     /**
      * Sets minimal amount of lines in method.
      * @param aValue user's value.
      */
     public void setMinLineCount(int aValue)
     {
         mMinLineCount = aValue;
     }
 
     /**
      * Allow validating throws tag.
      * @param aValue user's value.
      */
     public void setValidateThrows(boolean aValue)
     {
         mValidateThrows = aValue;
     }
 
     /**
      * Sets list of annotations.
      * @param aAnnotations user's value.
      */
     public void setAllowedAnnotations(String aAnnotations)
     {
         final List<String> annotations = new ArrayList<String>();
         for (String annotation : aAnnotations.split(", ")) {
             annotations.add(annotation);
         }
         mAllowedAnnotations = annotations;
     }
 
     /**
      * Set the scope.
      *
      * @param aFrom a <code>String</code> value
      */
     public void setScope(String aFrom)
     {
         mScope = Scope.getInstance(aFrom);
     }
 
     /**
      * Set the excludeScope.
      *
      * @param aScope a <code>String</code> value
      */
     public void setExcludeScope(String aScope)
     {
         mExcludeScope = Scope.getInstance(aScope);
     }
@@ -347,101 +359,122 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck
                 return true;
             }
             annotationNode = annotationNode.getNextSibling();
         }
         return false;
     }
 
     /**
      * Some javadoc.
      * @param aMethodDef Some javadoc.
      * @return Some javadoc.
      */
     private int getMethodsNumberOfLine(DetailAST aMethodDef)
     {
         int numberOfLines;
         final DetailAST lcurly = aMethodDef.getLastChild();
         final DetailAST rcurly = lcurly.getLastChild();
 
         if (lcurly.getFirstChild() == rcurly) {
             numberOfLines = 1;
         }
         else {
             numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;
         }
         return numberOfLines;
     }
 
     @Override
     protected final void logLoadError(Token aIdent)
     {
         logLoadErrorImpl(aIdent.getLineNo(), aIdent.getColumnNo(),
             "javadoc.classInfo",
             JavadocTagInfo.THROWS.getText(), aIdent.getText());
     }
 
     /**
      * The JavadocMethodCheck is about to report a missing Javadoc.
      * This hook can be used by derived classes to allow a missing javadoc
      * in some situations.  The default implementation checks
      * <code>allowMissingJavadoc</code> and
      * <code>allowMissingPropertyJavadoc</code> properties, do not forget
      * to call <code>super.isMissingJavadocAllowed(aAST)</code> in case
      * you want to keep this logic.
      * @param aAST the tree node for the method or constructor.
      * @return True if this method or constructor doesn't need Javadoc.
      */
     protected boolean isMissingJavadocAllowed(final DetailAST aAST)
     {
         return mAllowMissingJavadoc
             || (mAllowMissingPropertyJavadoc
-                && (isSetterMethod(aAST) || isGetterMethod(aAST)));
+                && (isSetterMethod(aAST) || isGetterMethod(aAST)))
+            || matchesSkipRegex(aAST);
+    }
+
+    /**
+     * Checks if the given method name matches the regex. In that case
+     * we skip enforcement of javadoc for this method
+     * @param aMethodDef {@link TokenTypes#METHOD_DEF METHOD_DEF}
+     * @return true if given method name matches the regex.
+     */
+    private boolean matchesSkipRegex(DetailAST aMethodDef)
+    {
+        if (mIgnoreMethodNamesRegex != null) {
+            final DetailAST ident = aMethodDef.findFirstToken(TokenTypes.IDENT);
+            final String methodName = ident.getText();
+
+            final Matcher matcher = mIgnoreMethodNamesRegex.matcher(methodName);
+            if (matcher.matches()) {
+                return true;
+            }
+        }
+        return false;
     }
 
     /**
      * Whether we should check this node.
      *
      * @param aAST a given node.
      * @param aScope the scope of the node.
      * @return whether we should check a given node.
      */
     private boolean shouldCheck(final DetailAST aAST, final Scope aScope)
     {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(aAST);
 
         return aScope.isIn(mScope)
                 && surroundingScope.isIn(mScope)
                 && ((mExcludeScope == null) || !aScope.isIn(mExcludeScope)
                     || !surroundingScope.isIn(mExcludeScope));
     }
 
     /**
      * Checks the Javadoc for a method.
      *
      * @param aAST the token for the method
      * @param aComment the Javadoc comment
      */
     private void checkComment(DetailAST aAST, TextBlock aComment)
     {
         final List<JavadocTag> tags = getMethodTags(aComment);
 
         if (hasShortCircuitTag(aAST, tags)) {
             return;
         }
 
         Iterator<JavadocTag> it = tags.iterator();
         if (aAST.getType() != TokenTypes.ANNOTATION_FIELD_DEF) {
             // Check for inheritDoc
             boolean hasInheritDocTag = false;
             while (it.hasNext() && !hasInheritDocTag) {
                 hasInheritDocTag |= (it.next()).isInheritDocTag();
             }
 
             checkParamTags(tags, aAST, !hasInheritDocTag);
             checkThrowsTags(tags, getThrows(aAST), !hasInheritDocTag);
             if (isFunction(aAST)) {
                 checkReturnTag(tags, aAST.getLineNo(), !hasInheritDocTag);
             }
         }
 
         // Dump out all unused tags
         it = tags.iterator();
