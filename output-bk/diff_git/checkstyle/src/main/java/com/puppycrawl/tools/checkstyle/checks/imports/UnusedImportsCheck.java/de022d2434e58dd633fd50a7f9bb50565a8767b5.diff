diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
index 72a64d2b1..868450b89 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java
@@ -54,107 +54,105 @@ public class UnusedImportsCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "import.unused";
 
     /** Regex to match class names. */
     private static final Pattern CLASS_NAME = Pattern.compile(
            "((:?[\\p{L}_$][\\p{L}\\p{N}_$]*\\.)*[\\p{L}_$][\\p{L}\\p{N}_$]*)");
     /** Regex to match the first class name. */
     private static final Pattern FIRST_CLASS_NAME = Pattern.compile(
            "^" + CLASS_NAME);
     /** Regex to match argument names. */
     private static final Pattern ARGUMENT_NAME = Pattern.compile(
            "[(,]\\s*" + CLASS_NAME.pattern());
 
     /** Suffix for the star import. */
     private static final String STAR_IMPORT_SUFFIX = ".*";
 
     /** Set of the imports. */
     private final Set<FullIdent> imports = Sets.newHashSet();
 
     /** Set of references - possibly to imports or other things. */
     private final Set<String> referenced = Sets.newHashSet();
 
     /** Flag to indicate when time to start collecting references. */
     private boolean collect;
     /** Flag whether to process Javadoc comments. */
     private boolean processJavadoc = true;
 
     /**
      * Sets whether to process JavaDoc or not.
      *
      * @param value Flag for processing JavaDoc.
      */
     public void setProcessJavadoc(boolean value) {
         processJavadoc = value;
     }
 
     @Override
     public void beginTree(DetailAST rootAST) {
         collect = false;
         imports.clear();
         referenced.clear();
     }
 
     @Override
     public void finishTree(DetailAST rootAST) {
         // loop over all the imports to see if referenced.
-        for (final FullIdent imp : imports) {
-            if (!referenced.contains(CommonUtils.baseClassName(imp.getText()))) {
-                log(imp.getLineNo(),
-                    imp.getColumnNo(),
-                    MSG_KEY, imp.getText());
-            }
-        }
+        imports.stream()
+            .filter(imp -> !referenced.contains(CommonUtils.baseClassName(imp.getText())))
+            .forEach(imp -> log(imp.getLineNo(),
+                imp.getColumnNo(),
+                MSG_KEY, imp.getText()));
     }
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.IMPORT,
             TokenTypes.STATIC_IMPORT,
             // Definitions that may contain Javadoc...
             TokenTypes.PACKAGE_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public int[] getRequiredTokens() {
         return getDefaultTokens();
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return new int[] {
             TokenTypes.IDENT,
             TokenTypes.IMPORT,
             TokenTypes.STATIC_IMPORT,
             // Definitions that may contain Javadoc...
             TokenTypes.PACKAGE_DEF,
             TokenTypes.ANNOTATION_DEF,
             TokenTypes.ANNOTATION_FIELD_DEF,
             TokenTypes.ENUM_DEF,
             TokenTypes.ENUM_CONSTANT_DEF,
             TokenTypes.CLASS_DEF,
             TokenTypes.INTERFACE_DEF,
             TokenTypes.METHOD_DEF,
             TokenTypes.CTOR_DEF,
             TokenTypes.VARIABLE_DEF,
         };
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.IDENT) {
@@ -191,109 +189,102 @@ public class UnusedImportsCheck extends AbstractCheck {
         }
     }
 
     /**
      * Collects the details of imports.
      * @param ast node containing the import details
      */
     private void processImport(DetailAST ast) {
         final FullIdent name = FullIdent.createFullIdentBelow(ast);
         if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {
             imports.add(name);
         }
     }
 
     /**
      * Collects the details of static imports.
      * @param ast node containing the static import details
      */
     private void processStaticImport(DetailAST ast) {
         final FullIdent name =
             FullIdent.createFullIdent(
                 ast.getFirstChild().getNextSibling());
         if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {
             imports.add(name);
         }
     }
 
     /**
      * Collects references made in Javadoc comments.
      * @param ast node to inspect for Javadoc
      */
     private void collectReferencesFromJavadoc(DetailAST ast) {
         final FileContents contents = getFileContents();
         final int lineNo = ast.getLineNo();
         final TextBlock textBlock = contents.getJavadocBefore(lineNo);
         if (textBlock != null) {
             referenced.addAll(collectReferencesFromJavadoc(textBlock));
         }
     }
 
     /**
      * Process a javadoc {@link TextBlock} and return the set of classes
      * referenced within.
      * @param textBlock The javadoc block to parse
      * @return a set of classes referenced in the javadoc block
      */
     private static Set<String> collectReferencesFromJavadoc(TextBlock textBlock) {
         final Set<String> references = new HashSet<>();
         // process all the @link type tags
         // INLINE tags inside BLOCKs get hidden when using ALL
-        for (final JavadocTag tag
-                : getValidTags(textBlock, JavadocUtils.JavadocTagType.INLINE)) {
-            if (tag.canReferenceImports()) {
-                references.addAll(processJavadocTag(tag));
-            }
-        }
+        getValidTags(textBlock, JavadocUtils.JavadocTagType.INLINE).stream()
+            .filter(JavadocTag::canReferenceImports)
+            .forEach(tag -> references.addAll(processJavadocTag(tag)));
         // process all the @throws type tags
-        for (final JavadocTag tag
-                : getValidTags(textBlock, JavadocUtils.JavadocTagType.BLOCK)) {
-            if (tag.canReferenceImports()) {
-                references.addAll(
-                        matchPattern(tag.getFirstArg(), FIRST_CLASS_NAME));
-            }
-        }
+        getValidTags(textBlock, JavadocUtils.JavadocTagType.BLOCK).stream()
+            .filter(JavadocTag::canReferenceImports)
+            .forEach(tag -> references.addAll(matchPattern(tag.getFirstArg(), FIRST_CLASS_NAME)));
         return references;
     }
 
     /**
      * Returns the list of valid tags found in a javadoc {@link TextBlock}.
      * @param cmt The javadoc block to parse
      * @param tagType The type of tags we're interested in
      * @return the list of tags
      */
     private static List<JavadocTag> getValidTags(TextBlock cmt,
             JavadocUtils.JavadocTagType tagType) {
         return JavadocUtils.getJavadocTags(cmt, tagType).getValidTags();
     }
 
     /**
      * Returns a list of references found in a javadoc {@link JavadocTag}.
      * @param tag The javadoc tag to parse
      * @return A list of references found in this tag
      */
     private static Set<String> processJavadocTag(JavadocTag tag) {
         final Set<String> references = new HashSet<>();
         final String identifier = tag.getFirstArg().trim();
         for (Pattern pattern : new Pattern[]
         {FIRST_CLASS_NAME, ARGUMENT_NAME}) {
             references.addAll(matchPattern(identifier, pattern));
         }
         return references;
     }
 
     /**
      * Extracts a list of texts matching a {@link Pattern} from a
      * {@link String}.
      * @param identifier The String to match the pattern against
      * @param pattern The Pattern used to extract the texts
      * @return A list of texts which matched the pattern
      */
     private static Set<String> matchPattern(String identifier, Pattern pattern) {
         final Set<String> references = new HashSet<>();
         final Matcher matcher = pattern.matcher(identifier);
         while (matcher.find()) {
             references.add(matcher.group(1));
         }
         return references;
     }
 }
