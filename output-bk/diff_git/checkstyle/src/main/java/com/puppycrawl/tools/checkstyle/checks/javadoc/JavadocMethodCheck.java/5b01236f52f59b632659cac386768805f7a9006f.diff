diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
index e2ec45176..4a18bfb97 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java
@@ -512,188 +512,212 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
      * @param tags the list of Javadoc tags associated with the construct
      * @return true if the construct has a short circuit tag.
      */
     private boolean hasShortCircuitTag(final DetailAST ast,
             final List<JavadocTag> tags) {
         // Check if it contains {@inheritDoc} tag
         if (tags.size() != 1
                 || !tags.get(0).isInheritDocTag()) {
             return false;
         }
 
         // Invalid if private, a constructor, or a static method
         if (!JavadocTagInfo.INHERIT_DOC.isValidOn(ast)) {
             log(ast, MSG_INVALID_INHERIT_DOC);
         }
 
         return true;
     }
 
     /**
      * Returns the scope for the method/constructor at the specified AST. If
      * the method is in an interface or annotation block, the scope is assumed
      * to be public.
      *
      * @param ast the token of the method/constructor
      * @return the scope of the method/constructor
      */
     private static Scope calculateScope(final DetailAST ast) {
         final DetailAST mods = ast.findFirstToken(TokenTypes.MODIFIERS);
         final Scope declaredScope = ScopeUtils.getScopeFromMods(mods);
 
         if (ScopeUtils.inInterfaceOrAnnotationBlock(ast)) {
             return Scope.PUBLIC;
         }
         else {
             return declaredScope;
         }
     }
 
     /**
      * Returns the tags in a javadoc comment. Only finds throws, exception,
      * param, return and see tags.
      *
      * @param comment the Javadoc comment
      * @return the tags found
      */
     private static List<JavadocTag> getMethodTags(TextBlock comment) {
         final String[] lines = comment.getText();
         final List<JavadocTag> tags = Lists.newArrayList();
         int currentLine = comment.getStartLineNo() - 1;
+        final int startColumnNumber = comment.getStartColNo();
 
         for (int i = 0; i < lines.length; i++) {
             currentLine++;
             final Matcher javadocArgMatcher =
                 MATCH_JAVADOC_ARG.matcher(lines[i]);
             final Matcher javadocNoargMatcher =
                 MATCH_JAVADOC_NOARG.matcher(lines[i]);
             final Matcher noargCurlyMatcher =
                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);
             final Matcher argMultilineStart =
                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);
             final Matcher noargMultilineStart =
                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);
 
             if (javadocArgMatcher.find()) {
-                int col = javadocArgMatcher.start(1) - 1;
-                if (i == 0) {
-                    col += comment.getStartColNo();
-                }
-                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher
-                        .group(1), javadocArgMatcher.group(2)));
+                final int col = calculateTagColumn(javadocArgMatcher, i, startColumnNumber);
+                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),
+                        javadocArgMatcher.group(2)));
             }
             else if (javadocNoargMatcher.find()) {
-                int col = javadocNoargMatcher.start(1) - 1;
-                if (i == 0) {
-                    col += comment.getStartColNo();
-                }
-                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher
-                        .group(1)));
+                final int col = calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);
+                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));
             }
             else if (noargCurlyMatcher.find()) {
-                int col = noargCurlyMatcher.start(1) - 1;
-                if (i == 0) {
-                    col += comment.getStartColNo();
-                }
-                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher
-                        .group(1)));
+                final int col = calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);
+                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));
             }
             else if (argMultilineStart.find()) {
-                final String p1 = argMultilineStart.group(1);
-                final String p2 = argMultilineStart.group(2);
-                int col = argMultilineStart.start(1) - 1;
-                if (i == 0) {
-                    col += comment.getStartColNo();
-                }
-
-                // Look for the rest of the comment if all we saw was
-                // the tag and the name. Stop when we see '*/' (end of
-                // Javadoc), '@' (start of next tag), or anything that's
-                // not whitespace or '*' characters.
-                int remIndex = i + 1;
-                while (remIndex < lines.length) {
-                    final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
-                            .matcher(lines[remIndex]);
-                    if (multilineCont.find()) {
-                        remIndex = lines.length;
-                        final String lFin = multilineCont.group(1);
-                        if (!lFin.equals(NEXT_TAG)
-                            && !lFin.equals(END_JAVADOC)) {
-                            tags.add(new JavadocTag(currentLine, col, p1, p2));
-                        }
-                    }
-                    remIndex++;
-                }
+                final int col = calculateTagColumn(argMultilineStart, i, startColumnNumber);
+                tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));
             }
             else if (noargMultilineStart.find()) {
-                final String p1 = noargMultilineStart.group(1);
-                final int col = noargMultilineStart.start(1) - 1;
-
-                // Look for the rest of the comment if all we saw was
-                // the tag and the name. Stop when we see '*/' (end of
-                // Javadoc), '@' (start of next tag), or anything that's
-                // not whitespace or '*' characters.
-                int remIndex = i + 1;
-                while (remIndex < lines.length) {
-                    final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
-                            .matcher(lines[remIndex]);
-                    multilineCont.find();
-                    remIndex = lines.length;
-                    final String lFin = multilineCont.group(1);
-                    if (!lFin.equals(NEXT_TAG)
-                        && !lFin.equals(END_JAVADOC)) {
-                        tags.add(new JavadocTag(currentLine, col, p1));
-                    }
-                    remIndex++;
+                tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));
+            }
+        }
+        return tags;
+    }
+
+    /**
+     * Calculates column number using Javadoc tag matcher.
+     * @param javadocTagMatcher found javadoc tag matcher
+     * @param lineNumber line number of Javadoc tag in comment
+     * @param startColumnNumber column number of Javadoc comment beginning
+     * @return column number
+     */
+    private static int calculateTagColumn(Matcher javadocTagMatcher,
+            int lineNumber, int startColumnNumber) {
+        int col = javadocTagMatcher.start(1) - 1;
+        if (lineNumber == 0) {
+            col += startColumnNumber;
+        }
+        return col;
+    }
+
+    /**
+     * Gets multiline Javadoc tags with arguments.
+     * @param argMultilineStart javadoc tag Matcher
+     * @param column column number of Javadoc tag
+     * @param lines comment text lines
+     * @param lineIndex line number that contains the javadoc tag
+     * @param tagLine javadoc tag line number in file
+     * @return javadoc tags with arguments
+     */
+    private static List<JavadocTag> getMultilineArgTags(final Matcher argMultilineStart,
+            final int column, final String[] lines, final int lineIndex, final int tagLine) {
+        final List<JavadocTag> tags = new ArrayList<>();
+        final String p1 = argMultilineStart.group(1);
+        final String p2 = argMultilineStart.group(2);
+        int remIndex = lineIndex + 1;
+        while (remIndex < lines.length) {
+            final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);
+            if (multilineCont.find()) {
+                remIndex = lines.length;
+                final String lFin = multilineCont.group(1);
+                if (!lFin.equals(NEXT_TAG)
+                    && !lFin.equals(END_JAVADOC)) {
+                    tags.add(new JavadocTag(tagLine, column, p1, p2));
                 }
             }
+            remIndex++;
+        }
+        return tags;
+    }
+
+    /**
+     * Gets multiline Javadoc tags with no arguments.
+     * @param noargMultilineStart javadoc tag Matcher
+     * @param lines comment text lines
+     * @param lineIndex line number that contains the javadoc tag
+     * @param tagLine javadoc tag line number in file
+     * @return javadoc tags with no arguments
+     */
+    private static List<JavadocTag> getMultilineNoArgTags(final Matcher noargMultilineStart,
+            final String[] lines, final int lineIndex, final int tagLine) {
+        final String p1 = noargMultilineStart.group(1);
+        final int col = noargMultilineStart.start(1) - 1;
+        final List<JavadocTag> tags = new ArrayList<>();
+        int remIndex = lineIndex + 1;
+        while (remIndex < lines.length) {
+            final Matcher multilineCont = MATCH_JAVADOC_MULTILINE_CONT
+                    .matcher(lines[remIndex]);
+            multilineCont.find();
+            remIndex = lines.length;
+            final String lFin = multilineCont.group(1);
+            if (!lFin.equals(NEXT_TAG)
+                && !lFin.equals(END_JAVADOC)) {
+                tags.add(new JavadocTag(tagLine, col, p1));
+            }
+            remIndex++;
         }
+
         return tags;
     }
 
     /**
      * Computes the parameter nodes for a method.
      *
      * @param ast the method node.
      * @return the list of parameter nodes for ast.
      */
     private static List<DetailAST> getParameters(DetailAST ast) {
         final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
         final List<DetailAST> retVal = Lists.newArrayList();
 
         DetailAST child = params.getFirstChild();
         while (child != null) {
             if (child.getType() == TokenTypes.PARAMETER_DEF) {
                 final DetailAST ident = child.findFirstToken(TokenTypes.IDENT);
                 retVal.add(ident);
             }
             child = child.getNextSibling();
         }
         return retVal;
     }
 
     /**
      * Computes the exception nodes for a method.
      *
      * @param ast the method node.
      * @return the list of exception nodes for ast.
      */
     private List<ExceptionInfo> getThrows(DetailAST ast) {
         final List<ExceptionInfo> retVal = Lists.newArrayList();
         final DetailAST throwsAST = ast
                 .findFirstToken(TokenTypes.LITERAL_THROWS);
         if (throwsAST != null) {
             DetailAST child = throwsAST.getFirstChild();
             while (child != null) {
                 if (child.getType() == TokenTypes.IDENT
                         || child.getType() == TokenTypes.DOT) {
                     final FullIdent fi = FullIdent.createFullIdent(child);
                     final ExceptionInfo ei = new ExceptionInfo(createClassInfo(new Token(fi),
                             getCurrentClassName()));
                     retVal.add(ei);
                 }
                 child = child.getNextSibling();
             }
         }
         return retVal;
     }
 
@@ -802,129 +826,126 @@ public class JavadocMethodCheck extends AbstractTypeAwareCheck {
      * @param lineNo the line number of the expected tag
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkReturnTag(List<JavadocTag> tags, int lineNo,
         boolean reportExpectedTags) {
         // Loop over tags finding return tags. After the first one, report an
         // error.
         boolean found = false;
         final ListIterator<JavadocTag> it = tags.listIterator();
         while (it.hasNext()) {
             final JavadocTag jt = it.next();
             if (jt.isReturnTag()) {
                 if (found) {
                     log(jt.getLineNo(), jt.getColumnNo(),
                         MSG_DUPLICATE_TAG,
                         JavadocTagInfo.RETURN.getText());
                 }
                 found = true;
                 it.remove();
             }
         }
 
         // Handle there being no @return tags :- unless
         // the user has chosen to suppress these problems
         if (!found && !allowMissingReturnTag && reportExpectedTags) {
             log(lineNo, MSG_RETURN_EXPECTED);
         }
     }
 
     /**
      * Checks a set of tags for matching throws.
      *
      * @param tags the tags to check
      * @param throwsList the throws to check
      * @param reportExpectedTags whether we should report if do not find
      *            expected tag
      */
     private void checkThrowsTags(List<JavadocTag> tags,
             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {
         // Loop over the tags, checking to see they exist in the throws.
         // The foundThrows used for performance only
         final Set<String> foundThrows = Sets.newHashSet();
         final ListIterator<JavadocTag> tagIt = tags.listIterator();
         while (tagIt.hasNext()) {
             final JavadocTag tag = tagIt.next();
 
             if (!tag.isThrowsTag()) {
                 continue;
             }
-
             tagIt.remove();
 
             // Loop looking for matching throw
             final String documentedEx = tag.getFirstArg();
             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag
                     .getColumnNo());
             final AbstractClassInfo documentedCI = createClassInfo(token,
                     getCurrentClassName());
-
             final boolean found = foundThrows.contains(documentedEx)
                     || isInThrows(throwsList, documentedCI, foundThrows);
 
             // Handle extra JavadocTag.
             if (!found) {
                 boolean reqd = true;
                 if (allowUndeclaredRTE) {
                     reqd = !isUnchecked(documentedCI.getClazz());
                 }
 
                 if (reqd && validateThrows) {
                     log(tag.getLineNo(), tag.getColumnNo(),
                         MSG_UNUSED_TAG,
                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());
 
                 }
             }
         }
-
         // Now dump out all throws without tags :- unless
         // the user has chosen to suppress these problems
         if (!allowMissingThrowsTags && reportExpectedTags) {
             for (ExceptionInfo ei : throwsList) {
                 if (!ei.isFound()) {
                     final Token fi = ei.getName();
                     log(fi.getLineNo(), fi.getColumnNo(),
                         MSG_EXCPECTED_TAG,
                         JavadocTagInfo.THROWS.getText(), fi.getText());
                 }
             }
         }
     }
 
     /**
      * Verifies that documented exception is in throws.
      *
      * @param throwsList list of throws
      * @param documentedCI documented exception class info
      * @param foundThrows previously found throws
      * @return true if documented exception is in throws.
      */
     private boolean isInThrows(List<ExceptionInfo> throwsList,
             AbstractClassInfo documentedCI, Set<String> foundThrows) {
         boolean found = false;
         ExceptionInfo foundException = null;
 
         // First look for matches on the exception name
         ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();
         while (!found && throwIt.hasNext()) {
             final ExceptionInfo ei = throwIt.next();
 
             if (ei.getName().getText().equals(
                     documentedCI.getName().getText())) {
                 found = true;
                 foundException = ei;
             }
         }
 
         // Now match on the exception type
         throwIt = throwsList.listIterator();
         while (!found && throwIt.hasNext()) {
             final ExceptionInfo ei = throwIt.next();
 
             if (documentedCI.getClazz() == ei.getClazz()) {
                 found = true;
                 foundException = ei;
             }
             else if (allowThrowsTagsForSubclasses) {
                 found = isSubclass(documentedCI.getClazz(), ei.getClazz());
