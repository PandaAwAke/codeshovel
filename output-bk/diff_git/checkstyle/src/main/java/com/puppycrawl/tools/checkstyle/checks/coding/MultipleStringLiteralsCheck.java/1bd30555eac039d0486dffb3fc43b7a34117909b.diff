diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
index e0b100a18..fdf70f79f 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java
@@ -45,143 +45,143 @@ public class MultipleStringLiteralsCheck extends Check
      */
     public static final String MSG_KEY = "multiple.string.literal";
 
     /**
      * The found strings and their positions.
      * {@code <String, ArrayList>}, with the ArrayList containing StringInfo
      * objects.
      */
     private final Map<String, List<StringInfo>> stringMap = Maps.newHashMap();
 
     /**
      * Marks the TokenTypes where duplicate strings should be ignored.
      */
     private final BitSet ignoreOccurrenceContext = new BitSet();
 
     /**
      * The allowed number of string duplicates in a file before an error is
      * generated.
      */
     private int allowedDuplicates = 1;
 
     /**
      * Sets the maximum allowed duplicates of a string.
      * @param allowedDuplicates The maximum number of duplicates.
      */
     public void setAllowedDuplicates(int allowedDuplicates)
     {
         this.allowedDuplicates = allowedDuplicates;
     }
 
     /**
      * Pattern for matching ignored strings.
      */
     private Pattern pattern;
 
     /**
      * Construct an instance with default values.
      */
     public MultipleStringLiteralsCheck()
     {
         setIgnoreStringsRegexp("^\"\"$");
         ignoreOccurrenceContext.set(TokenTypes.ANNOTATION);
     }
 
     /**
      * Sets regexp pattern for ignored strings.
      * @param ignoreStringsRegexp regexp pattern for ignored strings
      */
     public void setIgnoreStringsRegexp(String ignoreStringsRegexp)
     {
-        if ((ignoreStringsRegexp != null)
-            && (ignoreStringsRegexp.length() > 0))
+        if (ignoreStringsRegexp != null
+            && ignoreStringsRegexp.length() > 0)
         {
             pattern = Utils.getPattern(ignoreStringsRegexp);
         }
         else {
             pattern = null;
         }
     }
 
     /**
      * Adds a set of tokens the check is interested in.
      * @param strRep the string representation of the tokens interested in
      */
     public final void setIgnoreOccurrenceContext(String[] strRep)
     {
         ignoreOccurrenceContext.clear();
         for (final String s : strRep) {
             final int type = TokenTypes.getTokenId(s);
             ignoreOccurrenceContext.set(type);
         }
     }
 
     @Override
     public int[] getDefaultTokens()
     {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     @Override
     public int[] getAcceptableTokens()
     {
         return new int[] {TokenTypes.STRING_LITERAL};
     }
 
     @Override
     public void visitToken(DetailAST ast)
     {
         if (isInIgnoreOccurrenceContext(ast)) {
             return;
         }
         final String currentString = ast.getText();
-        if ((pattern == null) || !pattern.matcher(currentString).find()) {
+        if (pattern == null || !pattern.matcher(currentString).find()) {
             List<StringInfo> hitList = stringMap.get(currentString);
             if (hitList == null) {
                 hitList = Lists.newArrayList();
                 stringMap.put(currentString, hitList);
             }
             final int line = ast.getLineNo();
             final int col = ast.getColumnNo();
             hitList.add(new StringInfo(line, col));
         }
     }
 
     /**
      * Analyses the path from the AST root to a given AST for occurrences
      * of the token types in {@link #ignoreOccurrenceContext}.
      *
      * @param ast the node from where to start searching towards the root node
      * @return whether the path from the root node to ast contains one of the
      * token type in {@link #ignoreOccurrenceContext}.
      */
     private boolean isInIgnoreOccurrenceContext(DetailAST ast)
     {
         for (DetailAST token = ast;
              token.getParent() != null;
              token = token.getParent())
         {
             final int type = token.getType();
             if (ignoreOccurrenceContext.get(type)) {
                 return true;
             }
         }
         return false;
     }
 
     @Override
     public void beginTree(DetailAST rootAST)
     {
         super.beginTree(rootAST);
         stringMap.clear();
     }
 
     @Override
     public void finishTree(DetailAST rootAST)
     {
         final Set<String> keys = stringMap.keySet();
         for (String key : keys) {
             final List<StringInfo> hits = stringMap.get(key);
             if (hits.size() > allowedDuplicates) {
                 final StringInfo firstFinding = hits.get(0);
                 final int line = firstFinding.getLine();
                 final int col = firstFinding.getCol();
