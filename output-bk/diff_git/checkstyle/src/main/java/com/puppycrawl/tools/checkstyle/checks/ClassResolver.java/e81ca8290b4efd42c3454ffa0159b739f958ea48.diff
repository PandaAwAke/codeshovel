diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
index 1a10f282a..33e1cc709 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/ClassResolver.java
@@ -47,115 +47,115 @@ public class ClassResolver {
      * Creates a new {@code ClassResolver} instance.
      *
      * @param loader the ClassLoader to load classes with.
      * @param pkg the name of the package the class may belong to
      * @param imports set of imports to check if the class belongs to
      */
     public ClassResolver(ClassLoader loader, String pkg, Set<String> imports) {
         this.loader = loader;
         this.pkg = pkg;
         this.imports = new HashSet<>(imports);
         this.imports.add("java.lang.*");
     }
 
     /**
      * Attempts to resolve the Class for a specified name. The algorithm is
      * to check:
      * - fully qualified name
      * - explicit imports
      * - enclosing package
      * - star imports
      * @param name name of the class to resolve
      * @param currentClass name of current class (for inner classes).
      * @return the resolved class
      * @throws ClassNotFoundException if unable to resolve the class
      */
     public Class<?> resolve(String name, String currentClass)
         throws ClassNotFoundException {
         // See if the class is full qualified
         Class<?> clazz = resolveQualifiedName(name);
         if (clazz != null) {
             return clazz;
         }
 
         // try matching explicit imports
         for (String imp : imports) {
             // Very important to add the "." in the check below. Otherwise you
             // when checking for "DataException", it will match on
             // "SecurityDataException". This has been the cause of a very
             // difficult bug to resolve!
             if (imp.endsWith(PERIOD + name)) {
                 clazz = resolveQualifiedName(imp);
                 if (clazz != null) {
                     return clazz;
                 }
 
             }
         }
 
         // See if in the package
         if (pkg != null && !pkg.isEmpty()) {
-            clazz = resolveQualifiedName(pkg + PERIOD + name);
-            if (clazz != null) {
-                return clazz;
+            final Class<?> classFromQualifiedName = resolveQualifiedName(pkg + PERIOD + name);
+            if (classFromQualifiedName != null) {
+                return classFromQualifiedName;
             }
         }
 
         // see if inner class of this class
-        clazz = resolveInnerClass(name, currentClass);
-        if (clazz != null) {
-            return clazz;
+        final Class<?> innerClass = resolveInnerClass(name, currentClass);
+        if (innerClass != null) {
+            return innerClass;
         }
 
-        clazz = resolveByStarImports(name);
-        if (clazz != null) {
-            return clazz;
+        final Class<?> classFromStarImport = resolveByStarImports(name);
+        if (classFromStarImport != null) {
+            return classFromStarImport;
         }
 
         // Giving up, the type is unknown, so load the class to generate an
         // exception
         return safeLoad(name);
     }
 
     /**
      * See if inner class of this class
      * @param name name of the search Class to search
      * @param currentClass class where search in
      * @return class if found , or null if not resolved
      * @throws ClassNotFoundException  if an error occurs
      */
     private Class<?> resolveInnerClass(String name, String currentClass)
             throws ClassNotFoundException {
         Class<?> clazz = null;
         if (!currentClass.isEmpty()) {
             String innerClass = currentClass + DOLLAR_SIGN + name;
 
             if (!pkg.isEmpty()) {
                 innerClass = pkg + PERIOD + innerClass;
             }
 
             if (isLoadable(innerClass)) {
                 clazz = safeLoad(innerClass);
             }
         }
         return clazz;
     }
 
     /**
      * Try star imports
      * @param name name of the Class to search
      * @return  class if found , or null if not resolved
      */
     private Class<?> resolveByStarImports(String name) {
         Class<?> clazz = null;
         for (String imp : imports) {
             if (imp.endsWith(".*")) {
                 final String fqn = imp.substring(0, imp.lastIndexOf('.') + 1)
                     + name;
                 clazz = resolveQualifiedName(fqn);
                 if (clazz != null) {
                     break;
                 }
             }
         }
         return clazz;
     }
