diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
index 8ba5207b4..a9f475b0c 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java
@@ -188,104 +188,104 @@ public abstract class AbstractClassCouplingCheck extends Check {
      * Incapsulates information about class coupling.
      *
      * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
      * @author o_sukhodolsky
      */
     private class Context {
         /**
          * Set of referenced classes.
          * Sorted by name for predictable error messages in unit tests.
          */
         private final Set<String> referencedClassNames = Sets.newTreeSet();
         /** Own class name. */
         private final String className;
         /* Location of own class. (Used to log violations) */
         /** Line number of class definition. */
         private final int lineNo;
         /** Column number of class definition. */
         private final int columnNo;
 
         /**
          * Create new context associated with given class.
          * @param className name of the given class.
          * @param lineNo line of class definition.
          * @param columnNo column of class definition.
          */
         public Context(String className, int lineNo, int columnNo) {
             this.className = className;
             this.lineNo = lineNo;
             this.columnNo = columnNo;
         }
 
         /**
          * Visits throws clause and collects all exceptions we throw.
          * @param literalThrows throws to process.
          */
         public void visitLiteralThrows(DetailAST literalThrows) {
             for (DetailAST childAST = literalThrows.getFirstChild();
                  childAST != null;
                  childAST = childAST.getNextSibling()) {
                 if (childAST.getType() != TokenTypes.COMMA) {
                     addReferencedClassName(childAST);
                 }
             }
         }
 
         /**
          * Visits type.
          * @param ast type to process.
          */
         public void visitType(DetailAST ast) {
-            final String className = CheckUtils.createFullType(ast).getText();
-            context.addReferencedClassName(className);
+            final String fullTypeName = CheckUtils.createFullType(ast).getText();
+            context.addReferencedClassName(fullTypeName);
         }
 
         /**
          * Visits NEW.
          * @param ast NEW to process.
          */
         public void visitLiteralNew(DetailAST ast) {
             context.addReferencedClassName(ast.getFirstChild());
         }
 
         /**
          * Adds new referenced class.
          * @param ast a node which represents referenced class.
          */
         private void addReferencedClassName(DetailAST ast) {
-            final String className = FullIdent.createFullIdent(ast).getText();
-            addReferencedClassName(className);
+            final String fullIdentName = FullIdent.createFullIdent(ast).getText();
+            addReferencedClassName(fullIdentName);
         }
 
         /**
          * Adds new referenced class.
-         * @param className class name of the referenced class.
+         * @param referencedClassName class name of the referenced class.
          */
-        private void addReferencedClassName(String className) {
-            if (isSignificant(className)) {
-                referencedClassNames.add(className);
+        private void addReferencedClassName(String referencedClassName) {
+            if (isSignificant(referencedClassName)) {
+                referencedClassNames.add(referencedClassName);
             }
         }
 
         /** Checks if coupling less than allowed or not. */
         public void checkCoupling() {
             referencedClassNames.remove(className);
             referencedClassNames.remove(packageName + "." + className);
 
             if (referencedClassNames.size() > max) {
                 log(lineNo, columnNo, getLogMessageId(),
                         referencedClassNames.size(), getMax(),
                         referencedClassNames.toString());
             }
         }
 
         /**
          * Checks if given class shouldn't be ignored and not from java.lang.
-         * @param className class to check.
+         * @param candidateClassName class to check.
          * @return true if we should count this class.
          */
-        private boolean isSignificant(String className) {
-            return !excludedClasses.contains(className)
-                    && !className.startsWith("java.lang.");
+        private boolean isSignificant(String candidateClassName) {
+            return !excludedClasses.contains(candidateClassName)
+                    && !candidateClassName.startsWith("java.lang.");
         }
     }
 }
