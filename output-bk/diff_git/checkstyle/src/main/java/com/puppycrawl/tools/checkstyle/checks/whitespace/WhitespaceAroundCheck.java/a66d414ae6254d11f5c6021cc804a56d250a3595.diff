diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
index c361c1d87..972d97541 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java
@@ -92,100 +92,101 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  *
  * <pre>
  * &lt;module name="WhitespaceAround"&gt;
  *     &lt;property name="tokens"
  *               value="ASSIGN,DIV_ASSIGN,PLUS_ASSIGN,MINUS_ASSIGN,STAR_ASSIGN,MOD_ASSIGN,SR_ASSIGN,BSR_ASSIGN,SL_ASSIGN,BXOR_ASSIGN,BOR_ASSIGN,BAND_ASSIGN"/&gt;
  * &lt;/module&gt;
  * </pre>
  *
  * <p>In addition, this check can be configured to allow empty methods, types,
  * for, while, do-while loops and constructor bodies.
  * For example:
  *
  * <pre>{@code
  * public MyClass() {}      // empty constructor
  * public void func() {}    // empty method
  * public interface Foo {} // empty interface
  * public class Foo {} // empty class
  * public enum Foo {} // empty enum
  * MyClass c = new MyClass() {}; // empty anonymous class
  * while (i = 1) {} // empty while loop
  * for (int i = 1; i &gt; 1; i++) {} // empty for loop
  * do {} while (i = 1); // empty do-while loop
  * public @interface Beta {} // empty annotation type
  * }</pre>
  *
  * <p>To configure the check to allow empty method blocks use
  *
  * <pre>   &lt;property name="allowEmptyMethods" value="true" /&gt;</pre>
  *
  * <p>To configure the check to allow empty constructor blocks use
  *
  * <pre>   &lt;property name="allowEmptyConstructors" value="true" /&gt;</pre>
  *
  * <p>To configure the check to allow empty type blocks use
  *
  * <pre>   &lt;property name="allowEmptyTypes" value="true" /&gt;</pre>
  *
  * <p>To configure the check to allow empty loop blocks use
  *
  * <pre>   &lt;property name="allowEmptyLoops" value="true" /&gt;</pre>
  *
  * <p>Also, this check can be configured to ignore the colon in an enhanced for
  * loop. The colon in an enhanced for loop is ignored by default
  *
  * <p>To configure the check to ignore the colon
  *
  * <pre>   &lt;property name="ignoreEnhancedForColon" value="true" /&gt;</pre>
  *
  * @author Oliver Burn
  * @author maxvetrenko
+ * @author Andrei Selkin
  */
 public class WhitespaceAroundCheck extends Check {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_PRECEDED = "ws.notPreceded";
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String WS_NOT_FOLLOWED = "ws.notFollowed";
 
     /** Whether or not empty constructor bodies are allowed. */
     private boolean allowEmptyConstructors;
     /** Whether or not empty method bodies are allowed. */
     private boolean allowEmptyMethods;
     /** Whether or not empty classes, enums and interfaces are allowed. */
     private boolean allowEmptyTypes;
     /** Whether or not empty loops are allowed. */
     private boolean allowEmptyLoops;
     /** Whether or not to ignore a colon in a enhanced for loop. */
     private boolean ignoreEnhancedForColon = true;
 
     @Override
     public int[] getDefaultTokens() {
         return new int[] {
             TokenTypes.ASSIGN,
             TokenTypes.BAND,
             TokenTypes.BAND_ASSIGN,
             TokenTypes.BOR,
             TokenTypes.BOR_ASSIGN,
             TokenTypes.BSR,
             TokenTypes.BSR_ASSIGN,
             TokenTypes.BXOR,
             TokenTypes.BXOR_ASSIGN,
             TokenTypes.COLON,
             TokenTypes.DIV,
             TokenTypes.DIV_ASSIGN,
             TokenTypes.DO_WHILE,
             TokenTypes.EQUAL,
             TokenTypes.GE,
             TokenTypes.GT,
             TokenTypes.LAND,
             TokenTypes.LCURLY,
             TokenTypes.LE,
             TokenTypes.LITERAL_CATCH,
             TokenTypes.LITERAL_DO,
@@ -343,101 +344,101 @@ public class WhitespaceAroundCheck extends Check {
         }
 
         if (after >= line.length()) {
             return;
         }
 
         final char nextChar = line.charAt(after);
         if (!Character.isWhitespace(nextChar)
             // Check for "return;"
             && !(currentType == TokenTypes.LITERAL_RETURN
                 && ast.getFirstChild().getType() == TokenTypes.SEMI)
             && !isAnonymousInnerClassEnd(currentType, nextChar)) {
 
             log(ast.getLineNo(), ast.getColumnNo() + ast.getText().length(),
                     WS_NOT_FOLLOWED, ast.getText());
         }
     }
 
     /**
      * Check for "})" or "};" or "},". Happens with anon-inners
      * @param currentType token
      * @param nextChar next symbol
      * @return true is that is end of anon inner class
      */
     private static boolean isAnonymousInnerClassEnd(int currentType, char nextChar) {
         return currentType == TokenTypes.RCURLY
             && (nextChar == ')'
                 || nextChar == ';'
                 || nextChar == ','
                 || nextChar == '.');
     }
 
     /**
      * Is ast not a target of Check.
      * @param ast ast
      * @param currentType type of ast
      * @return true is ok to skip validation
      */
     private boolean isNotRelevantSituation(DetailAST ast, int currentType) {
         final int parentType = ast.getParent().getType();
         final boolean starImport = currentType == TokenTypes.STAR
                 && parentType == TokenTypes.DOT;
         final boolean slistInsideCaseGroup = currentType == TokenTypes.SLIST
                 && parentType == TokenTypes.CASE_GROUP;
 
         final boolean starImportOrSlistInsideCaseGroup = starImport || slistInsideCaseGroup;
         final boolean colonOfCaseOrDefaultOrForEach =
                 isColonOfCaseOrDefault(currentType, parentType)
                 || isColonOfForEach(currentType, parentType);
         final boolean emptyBlockOrType = isEmptyBlock(ast, parentType)
-                || allowEmptyTypes && isEmptyType(ast, parentType);
+                || allowEmptyTypes && isEmptyType(ast);
 
         return starImportOrSlistInsideCaseGroup
                 || colonOfCaseOrDefaultOrForEach
                 || emptyBlockOrType
                 || isArrayInitialization(currentType, parentType);
     }
 
     /**
      * Is empty block.
      * @param ast ast
      * @param parentType parent
      * @return true is block is empty
      */
     private boolean isEmptyBlock(DetailAST ast, int parentType) {
         return isEmptyMethodBlock(ast, parentType)
                 || isEmptyCtorBlock(ast, parentType)
                 || isEmptyLoop(ast, parentType);
     }
 
     /**
      * Tests if a given {@code DetailAST} is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   public void myMethod(int val) {}</pre>
      * </p>
      * In the above, the method body is an empty block ("{}").
      *
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @param match the parent token type we're looking to match.
      * @return {@code true} if {@code ast} makes up part of an
      *         empty block contained under a {@code match} token type
      *         node.
      */
     private static boolean isEmptyBlock(DetailAST ast, int parentType, int match) {
         final int type = ast.getType();
         if (type == TokenTypes.RCURLY) {
             final DetailAST grandParent = ast.getParent().getParent();
             return parentType == TokenTypes.SLIST
                 && grandParent.getType() == match;
         }
 
         return type == TokenTypes.SLIST
             && parentType == match
             && ast.getFirstChild().getType() == TokenTypes.RCURLY;
     }
 
     /**
      * Whether colon belongs to cases or defaults.
      * @param currentType current
@@ -478,61 +479,65 @@ public class WhitespaceAroundCheck extends Check {
     /**
      * Test if the given {@code DetailAST} is part of an allowed empty
      * method block.
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty method block.
      */
     private boolean isEmptyMethodBlock(DetailAST ast, int parentType) {
         return allowEmptyMethods
             && isEmptyBlock(ast, parentType, TokenTypes.METHOD_DEF);
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an allowed empty
      * constructor (ctor) block.
      * @param ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty constructor block.
      */
     private boolean isEmptyCtorBlock(DetailAST ast, int parentType) {
         return allowEmptyConstructors
             && isEmptyBlock(ast, parentType, TokenTypes.CTOR_DEF);
     }
 
     /**
      *
      * @param ast ast the {@code DetailAST} to test.
      * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         allowed empty loop block.
      */
     private boolean isEmptyLoop(DetailAST ast, int parentType) {
         return allowEmptyLoops
             && (isEmptyBlock(ast, parentType, TokenTypes.LITERAL_FOR)
                     || isEmptyBlock(ast,
                             parentType, TokenTypes.LITERAL_WHILE)
                             || isEmptyBlock(ast,
                                     parentType, TokenTypes.LITERAL_DO));
     }
 
     /**
      * Test if the given {@code DetailAST} is part of an empty block.
      * An example empty block might look like the following
      * <p>
      * <pre>   class Foo {}</pre>
      * </p>
      *
      * @param ast ast the {@code DetailAST} to test.
-     * @param parentType the token type of {@code ast}'s parent.
      * @return {@code true} if {@code ast} makes up part of an
      *         empty block contained under a {@code match} token type
      *         node.
      */
-    private static boolean isEmptyType(DetailAST ast, int parentType) {
+    private static boolean isEmptyType(DetailAST ast) {
         final int type = ast.getType();
-        return (type == TokenTypes.RCURLY || type == TokenTypes.LCURLY)
-                && parentType == TokenTypes.OBJBLOCK;
+        final DetailAST nextSibling = ast.getNextSibling();
+        final DetailAST previousSibling = ast.getPreviousSibling();
+        return type == TokenTypes.LCURLY
+                && nextSibling.getType() == TokenTypes.RCURLY
+            || type == TokenTypes.RCURLY
+                && previousSibling != null
+                && previousSibling.getType() == TokenTypes.LCURLY;
     }
 }
