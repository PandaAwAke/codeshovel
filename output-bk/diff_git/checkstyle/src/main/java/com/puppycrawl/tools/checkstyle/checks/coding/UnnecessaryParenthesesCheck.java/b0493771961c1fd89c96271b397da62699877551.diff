diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
index 59ae414a6..22c8e0083 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java
@@ -223,102 +223,100 @@ public class UnnecessaryParenthesesCheck extends AbstractCheck {
                     log(ast, MSG_STRING,
                         chopString(ast.getText()));
                 }
                 else {
                     log(ast, MSG_LITERAL, ast.getText());
                 }
             }
             // The rhs of an assignment surrounded by parentheses.
             else if (isInTokenList(type, ASSIGNMENTS)) {
                 assignDepth++;
                 final DetailAST last = ast.getLastChild();
                 if (last.getType() == TokenTypes.RPAREN) {
                     log(ast, MSG_ASSIGN);
                 }
             }
         }
     }
 
     @Override
     public void leaveToken(DetailAST ast) {
         final int type = ast.getType();
         final DetailAST parent = ast.getParent();
 
         // shouldn't process assign in annotation pairs
         if (type != TokenTypes.ASSIGN
             || parent.getType() != TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR) {
             // An expression is surrounded by parentheses.
             if (type == TokenTypes.EXPR) {
 
                 // If 'parentToSkip' == 'ast', then we've already logged a
                 // warning about an immediate child node in visitToken, so we don't
                 // need to log another one here.
 
                 if (parentToSkip != ast && isExprSurrounded(ast)) {
                     if (assignDepth >= 1) {
                         log(ast, MSG_ASSIGN);
                     }
                     else if (ast.getParent().getType() == TokenTypes.LITERAL_RETURN) {
                         log(ast, MSG_RETURN);
                     }
                     else {
                         log(ast, MSG_EXPR);
                     }
                 }
 
                 parentToSkip = null;
             }
             else if (isInTokenList(type, ASSIGNMENTS)) {
                 assignDepth--;
             }
-
-            super.leaveToken(ast);
         }
     }
 
     /**
      * Tests if the given {@code DetailAST} is surrounded by parentheses.
      * In short, does {@code ast} have a previous sibling whose type is
      * {@code TokenTypes.LPAREN} and a next sibling whose type is {@code
      * TokenTypes.RPAREN}.
      * @param ast the {@code DetailAST} to check if it is surrounded by
      *        parentheses.
      * @return {@code true} if {@code ast} is surrounded by
      *         parentheses.
      */
     private static boolean isSurrounded(DetailAST ast) {
         // if previous sibling is left parenthesis,
         // next sibling can't be other than right parenthesis
         final DetailAST prev = ast.getPreviousSibling();
         return prev != null && prev.getType() == TokenTypes.LPAREN;
     }
 
     /**
      * Tests if the given expression node is surrounded by parentheses.
      * @param ast a {@code DetailAST} whose type is
      *        {@code TokenTypes.EXPR}.
      * @return {@code true} if the expression is surrounded by
      *         parentheses.
      */
     private static boolean isExprSurrounded(DetailAST ast) {
         return ast.getFirstChild().getType() == TokenTypes.LPAREN;
     }
 
     /**
      * Tests if the given lambda node has a single parameter, no defined type, and is surrounded
      * by parentheses.
      * @param ast a {@code DetailAST} whose type is
      *        {@code TokenTypes.LAMBDA}.
      * @return {@code true} if the lambda has a single parameter, no defined type, and is
      *         surrounded by parentheses.
      */
     private static boolean isLambdaSingleParameterSurrounded(DetailAST ast) {
         final DetailAST firstChild = ast.getFirstChild();
         return firstChild.getType() == TokenTypes.LPAREN
                 && firstChild.getNextSibling().getChildCount(TokenTypes.PARAMETER_DEF) == 1
                 && firstChild.getNextSibling().getFirstChild().findFirstToken(TokenTypes.TYPE)
                         .getChildCount() == 0;
     }
 
     /**
      * Check if the given token type can be found in an array of token types.
      * @param type the token type.
