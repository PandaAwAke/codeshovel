diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtils.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtils.java
index b8eeb8591..5b3b11c44 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtils.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtils.java
@@ -57,91 +57,91 @@ public final class InlineTagUtils {
 
     /** Prevent instantiation. */
     private InlineTagUtils() {
     }
 
     /**
      * Extract inline Javadoc tags from the given comment.
      * @param lines The Javadoc comment (as lines).
      * @return The extracted inline Javadoc tags.
      */
     public static List<TagInfo> extractInlineTags(String... lines) {
         for (String line : lines) {
             if (line.contains(LINE_FEED) || line.contains(CARRIAGE_RETURN)) {
                 throw new IllegalArgumentException("comment lines cannot contain newlines");
             }
         }
 
         final String commentText = convertLinesToString(lines);
         final Matcher inlineTagMatcher = INLINE_TAG_PATTERN.matcher(commentText);
 
         final List<TagInfo> tags = new ArrayList<>();
 
         while (inlineTagMatcher.find()) {
             final String tagName = inlineTagMatcher.group(1);
 
             // Remove the leading asterisks (in case the tag spans a line) and collapse
             // the whitespace.
             String matchedTagValue = inlineTagMatcher.group(2);
             matchedTagValue = removeLeadingJavaDoc(matchedTagValue);
             matchedTagValue = collapseWhitespace(matchedTagValue);
 
             final String tagValue = matchedTagValue;
 
             final int startIndex = inlineTagMatcher.start(1);
             final LineColumn position = getLineColumnOfIndex(commentText,
                 // correct start index offset
                 startIndex - 1);
 
             tags.add(new TagInfo(tagName, tagValue, position));
         }
 
         return tags;
     }
 
     /**
      * Convert array of string to single String.
      * @param lines A number of lines, in order.
      * @return The lines, joined together with newlines, as a single string.
      */
     private static String convertLinesToString(String... lines) {
-        final StringBuilder builder = new StringBuilder();
+        final StringBuilder builder = new StringBuilder(1024);
         for (String line : lines) {
             builder.append(line);
             builder.append(LINE_FEED);
         }
         return builder.toString();
     }
 
     /**
      * Get LineColumn from string till index.
      * @param source Source string.
      * @param index An index into the string.
      * @return A position in the source representing what line and column that index appears on.
      */
     private static LineColumn getLineColumnOfIndex(String source, int index) {
         final String precedingText = source.subSequence(0, index).toString();
         final String[] precedingLines = NEWLINE_PATTERN.split(precedingText);
         final String lastLine = precedingLines[precedingLines.length - 1];
         return new LineColumn(precedingLines.length, lastLine.length());
     }
 
     /**
      * Collapse whitespaces.
      * @param str Source string.
      * @return The given string with all whitespace collapsed.
      */
     private static String collapseWhitespace(String str) {
         final Matcher matcher = WHITESPACE_PATTERN.matcher(str);
         return matcher.replaceAll(" ").trim();
     }
 
     /**
      * Remove leading JavaDoc.
      * @param source A string to remove leading Javadoc from.
      * @return The given string with leading Javadoc "*" characters from each line removed.
      */
     private static String removeLeadingJavaDoc(String source) {
         final Matcher matcher = JAVADOC_PREFIX_PATTERN.matcher(source);
         return matcher.replaceAll("");
     }
 }
