diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
index a268a6719..157598978 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java
@@ -181,141 +181,141 @@ public class RightCurlyCheck extends Check {
             return;
         }
 
         final String violation;
         if (shouldStartLine) {
             final String targetSourceLine = getLines()[rcurly.getLineNo() - 1];
             violation = validate(details, option, true, targetSourceLine);
         }
         else {
             violation = validate(details, option, false, "");
         }
 
         if (!violation.isEmpty()) {
             log(rcurly, violation, "}", rcurly.getColumnNo() + 1);
         }
     }
 
     /**
      * Does general validation.
      * @param details for validation.
      * @param bracePolicy for placing the right curly brace.
      * @param shouldStartLine do we need to check if right curly starts line.
      * @param targetSourceLine line that we need to check if shouldStartLine is true.
      * @return violation message or empty string
      *     if there was not violation during validation.
      */
     private static String validate(Details details, RightCurlyOption bracePolicy,
                                    boolean shouldStartLine, String targetSourceLine) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         final boolean shouldCheckLastRcurly = details.shouldCheckLastRcurly;
         String violation = "";
 
         if (bracePolicy == RightCurlyOption.SAME
                 && !hasLineBreakBefore(rcurly)
                 && lcurly.getLineNo() != rcurly.getLineNo()) {
             violation = MSG_KEY_LINE_BREAK_BEFORE;
         }
         else if (shouldCheckLastRcurly) {
             if (rcurly.getLineNo() == nextToken.getLineNo()) {
                 violation = MSG_KEY_LINE_ALONE;
             }
         }
         else if (shouldBeOnSameLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_SAME;
         }
         else if (shouldBeAloneOnLine(bracePolicy, details)) {
             violation = MSG_KEY_LINE_ALONE;
         }
-        else if (shouldStartLine && !startsLine(details, targetSourceLine)) {
+        else if (shouldStartLine && !isOnStartOfLine(details, targetSourceLine)) {
             violation = MSG_KEY_LINE_NEW;
         }
         return violation;
     }
 
     /**
      * Checks that a right curly should be on the same line as the next statement.
      * @param bracePolicy option for placing the right curly brace
      * @param details Details for validation
      * @return true if a right curly should be alone on a line.
      */
     private static boolean shouldBeOnSameLine(RightCurlyOption bracePolicy, Details details) {
         return bracePolicy == RightCurlyOption.SAME
                 && details.rcurly.getLineNo() != details.nextToken.getLineNo();
     }
 
     /**
      * Checks that a right curly should be alone on a line.
      * @param bracePolicy option for placing the right curly brace
      * @param details Details for validation
      * @return true if a right curly should be alone on a line.
      */
     private static boolean shouldBeAloneOnLine(RightCurlyOption bracePolicy, Details details) {
         return bracePolicy == RightCurlyOption.ALONE
                 && !isAloneOnLine(details)
                 && !isEmptyBody(details.lcurly)
                 || bracePolicy == RightCurlyOption.ALONE_OR_SINGLELINE
                 && !isAloneOnLine(details)
                 && !isSingleLineBlock(details)
                 && !isAnonInnerClassInit(details.lcurly)
                 && !isEmptyBody(details.lcurly);
     }
 
     /**
      * Whether right curly brace starts target source line.
      * @param details Details of right curly brace for validation
      * @param targetSourceLine source line to check
      * @return true if right curly brace starts target source line.
      */
-    private static boolean startsLine(Details details, String targetSourceLine) {
+    private static boolean isOnStartOfLine(Details details, String targetSourceLine) {
         return CommonUtils.hasWhitespaceBefore(details.rcurly.getColumnNo(), targetSourceLine)
                 || details.lcurly.getLineNo() == details.rcurly.getLineNo();
     }
 
     /**
      * Checks whether right curly is alone on a line.
      * @param details for validation.
      * @return true if right curly is alone on a line.
      */
     private static boolean isAloneOnLine(Details details) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         return rcurly.getLineNo() != lcurly.getLineNo()
             && rcurly.getLineNo() != nextToken.getLineNo();
     }
 
     /**
      * Checks whether block has a single-line format.
      * @param details for validation.
      * @return true if block has single-line format.
      */
     private static boolean isSingleLineBlock(Details details) {
         final DetailAST rcurly = details.rcurly;
         final DetailAST lcurly = details.lcurly;
         final DetailAST nextToken = details.nextToken;
         return rcurly.getLineNo() == lcurly.getLineNo()
             && rcurly.getLineNo() != nextToken.getLineNo();
     }
 
     /**
      * Checks whether lcurly is in anonymous inner class initialization.
      * @param lcurly left curly token.
      * @return true if lcurly begins anonymous inner class initialization.
      */
     private static boolean isAnonInnerClassInit(DetailAST lcurly) {
         final Scope surroundingScope = ScopeUtils.getSurroundingScope(lcurly);
         return surroundingScope.ordinal() == Scope.ANONINNER.ordinal();
     }
 
     /**
      * Collects validation details.
      * @param ast detail ast.
      * @return object that contain all details to make a validation.
      */
     private static Details getDetails(DetailAST ast) {
         // Attempt to locate the tokens to do the check
         boolean shouldCheckLastRcurly = false;
         DetailAST rcurly = null;
         DetailAST lcurly;
