diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java
index 93bbbb26d..2736626ba 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java
@@ -31,115 +31,113 @@ import com.puppycrawl.tools.checkstyle.api.TokenTypes;
  * from validation as current class cannot change signature of these methods.
  * </p>
  * <p>
  * Rationale:
  * Exceptions form part of a methods interface. Declaring
  * a method to throw too many differently rooted
  * exceptions makes exception handling onerous and leads
  * to poor programming practices such as catch
  * (Exception). 4 is the empirical value which is based
  * on reports that we had for the ThrowsCountCheck over big projects
  * such as OpenJDK. This check also forces developers to put exceptions
  * into a hierarchy such that in the simplest
  * case, only one type of exception need be checked for by
  * a caller but allows any sub-classes to be caught
  * specifically if necessary. For more information on rules
  * for the exceptions and their issues, see Effective Java:
  * Programming Language Guide Second Edition
  * by Joshua Bloch pages 264-273.
  * </p>
  * <p>
  * <b>ignorePrivateMethods</b> - allows to skip private methods as they do
  * not cause problems for other classes.
  * </p>
  * @author <a href="mailto:simon@redhillconsulting.com.au">Simon Harris</a>
  */
 @StatelessCheck
 public final class ThrowsCountCheck extends AbstractCheck {
 
     /**
      * A key is pointing to the warning message text in "messages.properties"
      * file.
      */
     public static final String MSG_KEY = "throws.count";
 
     /** Default value of max property. */
     private static final int DEFAULT_MAX = 4;
 
     /** Whether private methods must be ignored. **/
     private boolean ignorePrivateMethods = true;
 
     /** Maximum allowed throws statements. */
     private int max;
 
     /** Creates new instance of the check. */
     public ThrowsCountCheck() {
         max = DEFAULT_MAX;
     }
 
     @Override
     public int[] getDefaultTokens() {
-        return new int[] {
-            TokenTypes.LITERAL_THROWS,
-        };
+        return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
-        return getDefaultTokens();
+        return new int[] {
+            TokenTypes.LITERAL_THROWS,
+        };
     }
 
     @Override
     public int[] getAcceptableTokens() {
-        return new int[] {
-            TokenTypes.LITERAL_THROWS,
-        };
+        return getRequiredTokens();
     }
 
     /**
      * Sets whether private methods must be ignored.
      * @param ignorePrivateMethods whether private methods must be ignored.
      */
     public void setIgnorePrivateMethods(boolean ignorePrivateMethods) {
         this.ignorePrivateMethods = ignorePrivateMethods;
     }
 
     /**
      * Setter for max property.
      * @param max maximum allowed throws statements.
      */
     public void setMax(int max) {
         this.max = max;
     }
 
     @Override
     public void visitToken(DetailAST ast) {
         if (ast.getType() == TokenTypes.LITERAL_THROWS) {
             visitLiteralThrows(ast);
         }
         else {
             throw new IllegalStateException(ast.toString());
         }
     }
 
     /**
      * Checks number of throws statements.
      * @param ast throws for check.
      */
     private void visitLiteralThrows(DetailAST ast) {
         if ((!ignorePrivateMethods || !isInPrivateMethod(ast))
                 && !isOverriding(ast)) {
             // Account for all the commas!
             final int count = (ast.getChildCount() + 1) / 2;
             if (count > max) {
                 log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY,
                     count, max);
             }
         }
     }
 
     /**
      * Check if a method has annotation @Override.
      * @param ast throws, which is being checked.
      * @return true, if a method has annotation @Override.
      */
     private static boolean isOverriding(DetailAST ast) {
