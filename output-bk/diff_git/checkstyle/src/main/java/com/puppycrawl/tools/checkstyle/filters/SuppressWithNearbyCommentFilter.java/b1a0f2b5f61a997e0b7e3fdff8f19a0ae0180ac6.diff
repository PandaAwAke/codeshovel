diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
index fa1b1fdc4..ddf5bf685 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java
@@ -273,126 +273,139 @@ public class SuppressWithNearbyCommentFilter
         final Tag tag = new Tag(text, line, this);
         tags.add(tag);
     }
 
     /**
      * A Tag holds a suppression comment and its location.
      */
     public static class Tag {
         /** The text of the tag. */
         private final String text;
 
         /** The first line where warnings may be suppressed. */
         private final int firstLine;
 
         /** The last line where warnings may be suppressed. */
         private final int lastLine;
 
         /** The parsed check regexp, expanded for the text of this tag. */
         private final Pattern tagCheckRegexp;
 
         /** The parsed message regexp, expanded for the text of this tag. */
         private final Pattern tagMessageRegexp;
 
         /**
          * Constructs a tag.
          * @param text the text of the suppression.
          * @param line the line number.
          * @param filter the {@code SuppressWithNearbyCommentFilter} with the context
          * @throws IllegalArgumentException if unable to parse expanded text.
          */
         public Tag(String text, int line, SuppressWithNearbyCommentFilter filter) {
             this.text = text;
 
             //Expand regexp for check and message
             //Does not intern Patterns with Utils.getPattern()
             String format = "";
             try {
                 format = CommonUtils.fillTemplateWithStringsByRegexp(
                         filter.checkFormat, text, filter.commentFormat);
                 tagCheckRegexp = Pattern.compile(format);
                 if (filter.messageFormat == null) {
                     tagMessageRegexp = null;
                 }
                 else {
                     format = CommonUtils.fillTemplateWithStringsByRegexp(
                             filter.messageFormat, text, filter.commentFormat);
                     tagMessageRegexp = Pattern.compile(format);
                 }
                 format = CommonUtils.fillTemplateWithStringsByRegexp(
                         filter.influenceFormat, text, filter.commentFormat);
-                final int influence;
-                try {
-                    if (CommonUtils.startsWithChar(format, '+')) {
-                        format = format.substring(1);
-                    }
-                    influence = Integer.parseInt(format);
-                }
-                catch (final NumberFormatException ex) {
-                    throw new IllegalArgumentException("unable to parse influence from '" + text
-                            + "' using " + filter.influenceFormat, ex);
+
+                if (CommonUtils.startsWithChar(format, '+')) {
+                    format = format.substring(1);
                 }
+                final int influence = parseInfluence(format, filter.influenceFormat, text);
+
                 if (influence >= 1) {
                     firstLine = line;
                     lastLine = line + influence;
                 }
                 else {
                     firstLine = line + influence;
                     lastLine = line;
                 }
             }
             catch (final PatternSyntaxException ex) {
                 throw new IllegalArgumentException(
                     "unable to parse expanded comment " + format, ex);
             }
         }
 
+        /**
+         * Gets influence from suppress filter influence format param.
+         *
+         * @param format          influence format to parse
+         * @param influenceFormat raw influence format
+         * @param text            text of the suppression
+         * @return parsed influence
+         */
+        private static int parseInfluence(String format, String influenceFormat, String text) {
+            try {
+                return Integer.parseInt(format);
+            }
+            catch (final NumberFormatException ex) {
+                throw new IllegalArgumentException("unable to parse influence from '" + text
+                        + "' using " + influenceFormat, ex);
+            }
+        }
+
         @Override
         public boolean equals(Object other) {
             if (this == other) {
                 return true;
             }
             if (other == null || getClass() != other.getClass()) {
                 return false;
             }
             final Tag tag = (Tag) other;
             return Objects.equals(firstLine, tag.firstLine)
                     && Objects.equals(lastLine, tag.lastLine)
                     && Objects.equals(text, tag.text)
                     && Objects.equals(tagCheckRegexp, tag.tagCheckRegexp)
                     && Objects.equals(tagMessageRegexp, tag.tagMessageRegexp);
         }
 
         @Override
         public int hashCode() {
             return Objects.hash(text, firstLine, lastLine, tagCheckRegexp, tagMessageRegexp);
         }
 
         /**
          * Determines whether the source of an audit event
          * matches the text of this tag.
          * @param event the {@code AuditEvent} to check.
          * @return true if the source of event matches the text of this tag.
          */
         public boolean isMatch(AuditEvent event) {
             final int line = event.getLine();
             boolean match = false;
 
             if (line >= firstLine && line <= lastLine) {
                 final Matcher tagMatcher = tagCheckRegexp.matcher(event.getSourceName());
 
                 if (tagMatcher.find()) {
                     match = true;
                 }
                 else if (tagMessageRegexp == null) {
                     if (event.getModuleId() != null) {
                         final Matcher idMatcher = tagCheckRegexp.matcher(event.getModuleId());
                         match = idMatcher.find();
                     }
                 }
                 else {
                     final Matcher messageMatcher = tagMessageRegexp.matcher(event.getMessage());
                     match = messageMatcher.find();
                 }
             }
             return match;
         }
