diff --git a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
index 6190587b3..d80bb2cd5 100644
--- a/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
+++ b/src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java
@@ -254,101 +254,101 @@ public final class AnnotationUseStyleCheck extends AbstractCheck {
 
     /**
      * Closing parens option.
      * @see #setClosingParens(String)
      */
     private ClosingParens closingParens = ClosingParens.NEVER;
 
     /**
      * Sets the ElementStyle from a string.
      *
      * @param style string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setElementStyle(final String style) {
         elementStyle = getOption(ElementStyle.class, style);
     }
 
     /**
      * Sets the TrailingArrayComma from a string.
      *
      * @param comma string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setTrailingArrayComma(final String comma) {
         trailingArrayComma = getOption(TrailingArrayComma.class, comma);
     }
 
     /**
      * Sets the ClosingParens from a string.
      *
      * @param parens string representation
      * @throws ConversionException if cannot convert string.
      */
     public void setClosingParens(final String parens) {
         closingParens = getOption(ClosingParens.class, parens);
     }
 
     /**
      * Retrieves an {@link Enum Enum} type from a @{link String String}.
      * @param <T> the enum type
      * @param enumClass the enum class
      * @param value the string representing the enum
      * @return the enum type
      */
     private static <T extends Enum<T>> T getOption(final Class<T> enumClass,
         final String value) {
         try {
             return Enum.valueOf(enumClass, value.trim().toUpperCase(Locale.ENGLISH));
         }
         catch (final IllegalArgumentException iae) {
-            throw new ConversionException("unable to parse " + value, iae);
+            throw new IllegalArgumentException("unable to parse " + value, iae);
         }
     }
 
     @Override
     public int[] getDefaultTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public int[] getRequiredTokens() {
         return new int[] {
             TokenTypes.ANNOTATION,
         };
     }
 
     @Override
     public int[] getAcceptableTokens() {
         return getRequiredTokens();
     }
 
     @Override
     public void visitToken(final DetailAST ast) {
         checkStyleType(ast);
         checkCheckClosingParens(ast);
         checkTrailingComma(ast);
     }
 
     /**
      * Checks to see if the
      * {@link ElementStyle AnnotationElementStyle}
      * is correct.
      *
      * @param annotation the annotation token
      */
     private void checkStyleType(final DetailAST annotation) {
 
         switch (elementStyle) {
             case COMPACT_NO_ARRAY:
                 checkCompactNoArrayStyle(annotation);
                 break;
             case COMPACT:
                 checkCompactStyle(annotation);
                 break;
             case EXPANDED:
                 checkExpandedStyle(annotation);
                 break;
             case IGNORE:
             default:
                 break;
         }
