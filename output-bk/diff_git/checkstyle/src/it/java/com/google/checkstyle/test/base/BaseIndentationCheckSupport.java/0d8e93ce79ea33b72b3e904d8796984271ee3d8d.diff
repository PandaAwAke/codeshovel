diff --git a/src/it/java/com/google/checkstyle/test/base/BaseIndentationCheckSupport.java b/src/it/java/com/google/checkstyle/test/base/BaseIndentationCheckSupport.java
index e7e6640b2..52479b5a5 100644
--- a/src/it/java/com/google/checkstyle/test/base/BaseIndentationCheckSupport.java
+++ b/src/it/java/com/google/checkstyle/test/base/BaseIndentationCheckSupport.java
@@ -79,101 +79,101 @@ public class BaseIndentationCheckSupport extends BaseCheckTestSupport {
 
                     if (actualIndent != indentInComment) {
                         throw new IllegalStateException(String.format(Locale.ROOT,
                                         "File \"%1$s\" has incorrect indentation in comment."
                                                         + "Line %2$d: comment:%3$d, actual:%4$d.",
                                         aFileName,
                                         lineNumber,
                                         indentInComment,
                                         actualIndent));
                     }
 
                     if (isWarnComment(comment)) {
                         result.add(lineNumber);
                     }
 
                     if (!isCommentConsistent(comment)) {
                         throw new IllegalStateException(String.format(Locale.ROOT,
                                         "File \"%1$s\" has inconsistent comment on line %2$d",
                                         aFileName,
                                         lineNumber));
                     }
                 }
                 else if (NONEMPTY_LINE_REGEX.matcher(line).matches()) {
                     throw new IllegalStateException(String.format(Locale.ROOT,
                                     "File \"%1$s\" has no indentation comment or its format "
                                                     + "malformed. Error on line: %2$d(%3$s)",
                                     aFileName,
                                     lineNumber,
                                     line));
                 }
                 lineNumber++;
             }
         }
         return result.toArray(new Integer[result.size()]);
     }
 
     private static int getIndentFromComment(String comment) {
         final Matcher match = GET_INDENT_FROM_COMMENT_REGEX.matcher(comment);
         match.matches();
         return Integer.parseInt(match.group(1));
     }
 
     private static boolean isWarnComment(String comment) {
         return comment.endsWith(" warn");
     }
 
     private static boolean isCommentConsistent(String comment) {
         final int indentInComment = getIndentFromComment(comment);
         final boolean isWarnComment = isWarnComment(comment);
 
-        boolean result;
+        final boolean result;
         final CommentType type = getCommentType(comment);
         switch (type) {
             case MULTILEVEL:
                 result = isMultiLevelCommentConsistent(comment, indentInComment, isWarnComment);
                 break;
 
             case SINGLE_LEVEL:
                 result = isSingleLevelCommentConsistent(comment, indentInComment, isWarnComment);
                 break;
 
             case NON_STRICT_LEVEL:
                 result = isNonStrictCommentConsistent(comment, indentInComment, isWarnComment);
                 break;
 
             case UNKNOWN:
                 throw new IllegalArgumentException("Cannot determine comment consistent");
 
             default:
                 throw new IllegalStateException("Cannot determine comment is consistent");
 
         }
         return result;
     }
 
     private static boolean isNonStrictCommentConsistent(String comment,
             int indentInComment, boolean isWarnComment) {
         final Matcher nonStrictLevelMatch = NON_STRICT_LEVEL_COMMENT_REGEX.matcher(comment);
         nonStrictLevelMatch.matches();
         final int expectedMinimalIndent = Integer.parseInt(nonStrictLevelMatch.group(1));
 
         return indentInComment >= expectedMinimalIndent && !isWarnComment
                 || indentInComment < expectedMinimalIndent && isWarnComment;
     }
 
     private static boolean isSingleLevelCommentConsistent(String comment,
             int indentInComment, boolean isWarnComment) {
         final Matcher singleLevelMatch = SINGLE_LEVEL_COMMENT_REGEX.matcher(comment);
         singleLevelMatch.matches();
         final int expectedLevel = Integer.parseInt(singleLevelMatch.group(1));
 
         return expectedLevel == indentInComment && !isWarnComment
                 || expectedLevel != indentInComment && isWarnComment;
     }
 
     private static boolean isMultiLevelCommentConsistent(String comment,
             int indentInComment, boolean isWarnComment) {
         final Matcher multilevelMatch = MULTILEVEL_COMMENT_REGEX.matcher(comment);
         multilevelMatch.matches();
         final String[] levels = multilevelMatch.group(1).split(",");
         final String indentInCommentStr = String.valueOf(indentInComment);
