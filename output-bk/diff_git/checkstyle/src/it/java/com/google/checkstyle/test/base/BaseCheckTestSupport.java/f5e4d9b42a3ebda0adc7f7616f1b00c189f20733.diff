diff --git a/src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java b/src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java
index f35f19e19..227e5b94c 100644
--- a/src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java
+++ b/src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java
@@ -81,117 +81,118 @@ public abstract class BaseCheckTestSupport
     protected static String getPath(String aFilename)
         throws IOException
     {
         return new File("src/main/java/com/google/checkstyle/test/filebasic/" + aFilename).getCanonicalPath();
     }
 
     protected static String getSrcPath(String aFilename) throws IOException
     {
 
         return new File("src/test/java/com/puppycrawl/tools/checkstyle/" + aFilename).getCanonicalPath();
     }
 
     protected void verify(Configuration aConfig, String aFileName, String[] aExpected, Integer... aWarnsExpected)
             throws Exception
     {
         verify(createChecker(aConfig), aFileName, aFileName, aExpected, aWarnsExpected);
     }
 
     protected void verify(Checker aC, String aFileName, String[] aExpected, Integer... aWarnsExpected)
             throws Exception
     {
         verify(aC, aFileName, aFileName, aExpected, aWarnsExpected);
     }
 
     private void verify(Checker aC,
             String aProcessedFilename,
             String aMessageFileName,
             String[] aExpected, Integer... aWarnsExpected)
         throws Exception
     {
         verify(aC,
             new File[] {new File(aProcessedFilename)},
             aMessageFileName, aExpected, aWarnsExpected);
     }
 
     void verify(Checker aC,
             File[] aProcessedFiles,
             String aMessageFileName,
             String[] aExpected,
             Integer... aWarnsExpected)
         throws Exception
     {
         stream.flush();
         final List<File> theFiles = Lists.newArrayList();
         Collections.addAll(theFiles, aProcessedFiles);
         final int errs = aC.process(theFiles);
 
         // process each of the lines
         final ByteArrayInputStream localStream =
             new ByteArrayInputStream(stream.toByteArray());
-        final LineNumberReader lnr =
-            new LineNumberReader(new InputStreamReader(localStream, StandardCharsets.UTF_8));
-
-        for (int i = 0; i < aExpected.length; i++) {
-            final String expected = aMessageFileName + ":" + aExpected[i];
-            String actual = lnr.readLine();
-            assertEquals("error message " + i, expected, actual);
-            String parseInt = removeDeviceFromPathOnWindows(actual);
-            parseInt = parseInt.substring(parseInt.indexOf(':') + 1);
-            parseInt = parseInt.substring(0, parseInt.indexOf(':'));
-            int lineNumber = Integer.parseInt(parseInt);
-			Integer integer = Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;
-            assertEquals("error message " + i, (long) integer, lineNumber);
+        try (final LineNumberReader lnr = new LineNumberReader(
+                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {
+
+            for (int i = 0; i < aExpected.length; i++) {
+                final String expected = aMessageFileName + ":" + aExpected[i];
+                String actual = lnr.readLine();
+                assertEquals("error message " + i, expected, actual);
+                String parseInt = removeDeviceFromPathOnWindows(actual);
+                parseInt = parseInt.substring(parseInt.indexOf(':') + 1);
+                parseInt = parseInt.substring(0, parseInt.indexOf(':'));
+                int lineNumber = Integer.parseInt(parseInt);
+                Integer integer = Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;
+                assertEquals("error message " + i, (long) integer, lineNumber);
+            }
+
+            assertEquals("unexpected output: " + lnr.readLine(),
+                    aExpected.length, errs);
         }
-
-        assertEquals("unexpected output: " + lnr.readLine(),
-                     aExpected.length, errs);
         aC.destroy();
     }
 
     /**
      * Gets the check message 'as is' from appropriate 'messages.properties'
      * file.
      *
      * @param messageKey
      *            the key of message in 'messages.properties' file.
      */
     protected String getCheckMessage(Class<? extends AbstractViolationReporter> aClass,
             String messageKey)
     {
         Properties pr = new Properties();
         try {
             pr.load(aClass.getResourceAsStream("messages.properties"));
         }
         catch (IOException ignored) {
             return null;
         }
         return pr.getProperty(messageKey);
     }
 
     /**
      * Gets the check message 'as is' from appropriate 'messages.properties' file.
      * @param messageKey the key of message in 'messages.properties' file.
      * @param arguments the arguments of message in 'messages.properties' file.
      */
     protected String getCheckMessage(Class<? extends AbstractViolationReporter> aClass,
             String messageKey, Object... arguments) {
         return format(getCheckMessage(aClass, messageKey), arguments);
     }
 
     /**
      * Gets the check message 'as is' from appropriate 'messages.properties' file.
      * @param messageKey the key of message in 'messages.properties' file.
      * @param arguments the arguments of message in 'messages.properties' file.
      */
     protected String getCheckMessage(Map<String, String> messages, String messageKey, Object... arguments)
    {
        for (Map.Entry<String, String> entry : messages.entrySet()) {
            if (messageKey.equals(entry.getKey())) {
                return format(entry.getValue(), arguments);
            }
        }
        return null;
    }
 
    private static String removeDeviceFromPathOnWindows(String path) {
        String os = System.getProperty("os.name", "Unix");
