diff --git a/src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java b/src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java
index 95b4d0107..f2e82c97b 100644
--- a/src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java
+++ b/src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java
@@ -239,115 +239,109 @@ public abstract class AbstractModuleTestSupport extends AbstractPathTestSupport
     protected final void verify(Checker checker,
             File[] processedFiles,
             String messageFileName,
             String[] expected,
             Integer... warnsExpected)
             throws Exception {
         stream.flush();
         final List<File> theFiles = new ArrayList<>();
         Collections.addAll(theFiles, processedFiles);
         final List<Integer> theWarnings = new ArrayList<>();
         Collections.addAll(theWarnings, warnsExpected);
         final int errs = checker.process(theFiles);
 
         // process each of the lines
         final ByteArrayInputStream inputStream =
                 new ByteArrayInputStream(stream.toByteArray());
         try (LineNumberReader lnr = new LineNumberReader(
                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
             int previousLineNumber = 0;
             for (int i = 0; i < expected.length; i++) {
                 final String expectedResult = messageFileName + ":" + expected[i];
                 final String actual = lnr.readLine();
                 assertEquals("error message " + i, expectedResult, actual);
 
                 String parseInt = removeDeviceFromPathOnWindows(actual);
                 parseInt = parseInt.substring(parseInt.indexOf(':') + 1);
                 parseInt = parseInt.substring(0, parseInt.indexOf(':'));
                 final int lineNumber = Integer.parseInt(parseInt);
                 assertTrue("input file is expected to have a warning comment on line number "
                         + lineNumber, previousLineNumber == lineNumber
                             || theWarnings.remove((Integer) lineNumber));
                 previousLineNumber = lineNumber;
             }
 
             assertEquals("unexpected output: " + lnr.readLine(),
                     expected.length, errs);
             assertEquals("unexpected warnings " + theWarnings, 0, theWarnings.size());
         }
 
         checker.destroy();
     }
 
     /**
      * Gets the check message 'as is' from appropriate 'messages.properties'
      * file.
      *
      * @param aClass The package the message is located in.
      * @param messageKey the key of message in 'messages.properties' file.
      * @param arguments  the arguments of message in 'messages.properties' file.
      * @return The message of the check with the arguments applied.
+     * @throws IOException if there is a problem loading the property file.
      */
     protected static String getCheckMessage(Class<? extends AbstractViolationReporter> aClass,
-            String messageKey, Object... arguments) {
-        String checkMessage;
-        try {
-            final Properties pr = new Properties();
-            pr.load(aClass.getResourceAsStream("messages.properties"));
-            final MessageFormat formatter = new MessageFormat(pr.getProperty(messageKey),
-                    Locale.ROOT);
-            checkMessage = formatter.format(arguments);
-        }
-        catch (IOException ex) {
-            checkMessage = null;
-        }
-        return checkMessage;
+            String messageKey, Object... arguments) throws IOException {
+        final Properties pr = new Properties();
+        pr.load(aClass.getResourceAsStream("messages.properties"));
+        final MessageFormat formatter = new MessageFormat(pr.getProperty(messageKey),
+                Locale.ROOT);
+        return formatter.format(arguments);
     }
 
     /**
      * Gets the check message 'as is' from appropriate 'messages.properties' file.
      * @param messages The map of messages to scan.
      * @param messageKey the key of message in 'messages.properties' file.
      * @param arguments the arguments of message in 'messages.properties' file.
      * @return The message of the check with the arguments applied.
      */
     protected static String getCheckMessage(Map<String, String> messages, String messageKey,
             Object... arguments) {
         String checkMessage = null;
         for (Map.Entry<String, String> entry : messages.entrySet()) {
             if (messageKey.equals(entry.getKey())) {
                 final MessageFormat formatter = new MessageFormat(entry.getValue(), Locale.ROOT);
                 checkMessage = formatter.format(arguments);
                 break;
             }
         }
         return checkMessage;
     }
 
     /**
      * Returns {@link Configuration} instance for the given module name.
      * This implementation uses {@link AbstractModuleTestSupport#getConfiguration()} method inside.
      * @param moduleName module name.
      * @return {@link Configuration} instance for the given module name.
      * @throws CheckstyleException if exception occurs during configuration loading.
      */
     protected static Configuration getModuleConfig(String moduleName) throws CheckstyleException {
         return getModuleConfig(moduleName, null);
     }
 
     /**
      * Returns {@link Configuration} instance for the given module name.
      * This implementation uses {@link AbstractModuleTestSupport#getConfiguration()} method inside.
      * @param moduleName module name.
      * @param moduleId module id.
      * @return {@link Configuration} instance for the given module name.
      * @throws CheckstyleException if exception occurs during configuration loading.
      */
     protected static Configuration getModuleConfig(String moduleName, String moduleId)
             throws CheckstyleException {
         final Configuration result;
         final List<Configuration> configs = getModuleConfigs(moduleName);
         if (configs.size() == 1) {
             result = configs.get(0);
         }
         else if (moduleId == null) {
             throw new IllegalStateException("multiple instances of the same Module are detected");
