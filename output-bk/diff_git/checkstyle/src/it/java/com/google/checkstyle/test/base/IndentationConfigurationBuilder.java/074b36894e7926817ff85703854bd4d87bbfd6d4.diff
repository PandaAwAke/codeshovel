diff --git a/src/it/java/com/google/checkstyle/test/base/IndentationConfigurationBuilder.java b/src/it/java/com/google/checkstyle/test/base/IndentationConfigurationBuilder.java
index 4be8921b7..e8727684e 100644
--- a/src/it/java/com/google/checkstyle/test/base/IndentationConfigurationBuilder.java
+++ b/src/it/java/com/google/checkstyle/test/base/IndentationConfigurationBuilder.java
@@ -80,75 +80,75 @@ public class IndentationConfigurationBuilder extends ConfigurationBuilder
                                         aFileName,
                                         lineNumber));
                     }
                 }
                 else if (NONEMPTY_LINE_REGEX.matcher(line).matches()) {
                     throw new IllegalStateException(String.format(
                                     "File \"%1$s\" has no indentation comment or its format "
                                                     + "malformed. Error on line: %2$d(%3$s)",
                                     aFileName,
                                     lineNumber,
                                     line));
                 }
                 lineNumber++;
             }
         }
         return result.toArray(new Integer[result.size()]);
     }
 
     private static int getIndentFromComment(String comment)
     {
         final Matcher match = GET_INDENT_FROM_COMMENT_REGEX.matcher(comment);
         match.matches();
         return Integer.parseInt(match.group(1));
     }
 
     private static boolean isWarnComment(String comment)
     {
         return comment.endsWith(" warn");
     }
 
     private static boolean isCommentConsistent(String comment)
     {
         final int indentInComment = getIndentFromComment(comment);
         final boolean isWarnComment = isWarnComment(comment);
 
         Matcher match = MULTILEVEL_COMMENT_REGEX.matcher(comment);
         if (match.matches()) {
             final String[] levels = match.group(1).split(",");
             final String indentInCommentStr = String.valueOf(indentInComment);
             final boolean containsActualLevel =
                             Arrays.asList(levels).contains(indentInCommentStr);
 
             return containsActualLevel && !isWarnComment
                     || !containsActualLevel && isWarnComment;
         }
 
         match = SINGLELEVEL_COMMENT_REGEX.matcher(comment);
         if (match.matches()) {
             final int expectedLevel = Integer.parseInt(match.group(1));
 
-            return (expectedLevel == indentInComment) && !isWarnComment
-                    || (expectedLevel != indentInComment) && isWarnComment;
+            return expectedLevel == indentInComment && !isWarnComment
+                    || expectedLevel != indentInComment && isWarnComment;
         }
 
         match = NONSTRICT_LEVEL_COMMENT_REGEX.matcher(comment);
         if (match.matches()) {
             final int expectedMinimalIndent = Integer.parseInt(match.group(1));
 
-            return (indentInComment >= expectedMinimalIndent) && !isWarnComment
-                    || (indentInComment < expectedMinimalIndent) && isWarnComment;
+            return indentInComment >= expectedMinimalIndent && !isWarnComment
+                    || indentInComment < expectedMinimalIndent && isWarnComment;
         }
 
         throw new IllegalArgumentException();
     }
 
     private static int getLineStart(String line, final int tabWidth)
     {
         for (int index = 0; index < line.length(); ++index) {
             if (!Character.isWhitespace(line.charAt(index))) {
                 return Utils.lengthExpandedTabs(line, index, tabWidth);
             }
         }
         return 0;
     }
 }
\ No newline at end of file
