diff --git a/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java b/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java
index 58e95cfc002..17d885e21bc 100644
--- a/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java
+++ b/buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java
@@ -22,100 +22,104 @@ package org.elasticsearch.test;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Modifier;
 import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 /**
  * Checks that all tests in a directory are named according to our naming conventions. This is important because tests that do not follow
  * our conventions aren't run by gradle. This was once a glorious unit test but now that Elasticsearch is a multi-module project it must be
  * a class with a main method so gradle can call it for each project. This has the advantage of allowing gradle to calculate when it is
  * {@code UP-TO-DATE} so it can be skipped if the compiled classes haven't changed. This is useful on large modules for which checking all
  * the modules can be slow.
  */
 public class NamingConventionsCheck {
     public static void main(String[] args) throws IOException {
         Class<?> testClass = null;
         Class<?> integTestClass = null;
         String rootPathList = null;
         boolean skipIntegTestsInDisguise = false;
         boolean checkMainClasses = false;
         for (int i = 0; i < args.length; i++) {
             String arg = args[i];
             switch (arg) {
                 case "--test-class":
                     testClass = loadClassWithoutInitializing(args[++i]);
                     break;
                 case "--integ-test-class":
                     integTestClass = loadClassWithoutInitializing(args[++i]);
                     break;
                 case "--skip-integ-tests-in-disguise":
                     skipIntegTestsInDisguise = true;
                     break;
                 case "--main":
                     checkMainClasses = true;
                     break;
                 case "--":
                     rootPathList = args[++i];
                     break;
                 default:
                     fail("unsupported argument '" + arg + "'");
             }
         }
+        if (rootPathList == null) {
+            fail("No paths provided");
+            return;
+        }
 
         NamingConventionsCheck check = new NamingConventionsCheck(testClass, integTestClass);
         for (String rootDir : rootPathList.split(Pattern.quote(File.pathSeparator))) {
             Path rootPath = Paths.get(rootDir);
             if (checkMainClasses) {
                 check.checkMain(rootPath);
             } else {
                 check.checkTests(rootPath, skipIntegTestsInDisguise);
             }
         }
 
         // Now we should have no violations
         int exitCode  = 0 ;
         exitCode += countAndPrintViolations(
                 "Not all subclasses of " + check.testClass.getSimpleName()
                     + " match the naming convention. Concrete classes must end with [Tests]",
                 check.missingSuffix) ;
         exitCode += countAndPrintViolations(
             "Classes ending with [Tests] are abstract or interfaces",
             check.notRunnable
         );
         exitCode += countAndPrintViolations(
             "Found inner classes that are tests, which are excluded from the test runner",
             check.innerClasses
         );
         exitCode += countAndPrintViolations(
             "Pure Unit-Test found must subclass [" + check.testClass.getSimpleName() + "]",
             check.pureUnitTest
         );
         exitCode += countAndPrintViolations(
             "Classes ending with [Tests] must subclass [" + check.testClass.getSimpleName() + "]",
             check.notImplementing
         );
         exitCode += countAndPrintViolations(
                 "Classes ending with [Tests] or [IT] or extending [" +
                     check.testClass.getSimpleName() + "] must be in src/test/java",
                 check.testsInMain
         );
         if (skipIntegTestsInDisguise == false) {
             exitCode += countAndPrintViolations("Subclasses of " + check.integTestClass.getSimpleName() +
                         " should end with IT as they are integration tests",
                     check.integTestsInDisguise
                 );
         }
         System.exit(exitCode);
     }
 
     private final Set<Class<?>> notImplementing = new HashSet<>();
     private final Set<Class<?>> pureUnitTest = new HashSet<>();
     private final Set<Class<?>> missingSuffix = new HashSet<>();
