diff --git a/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
index 17485d024ae..7d3c47f9615 100644
--- a/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
+++ b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
@@ -1,79 +1,80 @@
 /*
  * Licensed to Elasticsearch under one or more contributor
  * license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright
  * ownership. Elasticsearch licenses this file to you under
  * the Apache License, Version 2.0 (the "License"); you may
  * not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
 package org.apache.lucene.queries;
 
 import com.google.common.primitives.Ints;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.InPlaceMergeSorter;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 
 /**
  * BlendedTermQuery can be used to unify term statistics across
  * one or more fields in the index. A common problem with structured
  * documents is that a term that is significant in on field might not be
  * significant in other fields like in a scenario where documents represent
  * users with a "first_name" and a "second_name". When someone searches
  * for "simon" it will very likely get "paul simon" first since "simon" is a
  * an uncommon last name ie. has a low document frequency. This query
  * tries to "lie" about the global statistics like document frequency as well
  * total term frequency to rank based on the estimated statistics.
  * <p>
  * While aggregating the total term frequency is trivial since it
  * can be summed up not every {@link org.apache.lucene.search.similarities.Similarity}
  * makes use of this statistic. The document frequency which is used in the
  * {@link org.apache.lucene.search.similarities.DefaultSimilarity}
  * can only be estimated as an lower-bound since it is a document based statistic. For
  * the document frequency the maximum frequency across all fields per term is used
  * which is the minimum number of documents the terms occurs in.
  * </p>
  */
 // TODO maybe contribute to Lucene
 public abstract class BlendedTermQuery extends Query {
 
     private final Term[] terms;
     private final float[] boosts;
 
     public BlendedTermQuery(Term[] terms, float[] boosts) {
         if (terms == null || terms.length == 0) {
             throw new IllegalArgumentException("terms must not be null or empty");
         }
         if (boosts != null && boosts.length != terms.length) {
             throw new IllegalArgumentException("boosts must have the same size as terms");
         }
         this.terms = terms;
         this.boosts = boosts;
     }
 
     @Override
@@ -252,120 +253,128 @@ public abstract class BlendedTermQuery extends Query {
         builder.append("])");
         builder.append(ToStringUtils.boost(getBoost()));
         return builder.toString();
     }
 
     private volatile Term[] equalTerms = null;
 
     private Term[] equalsTerms() {
         if (terms.length == 1) {
             return terms;
         }
         if (equalTerms == null) {
             // sort the terms to make sure equals and hashCode are consistent
             // this should be a very small cost and equivalent to a HashSet but less object creation
             final Term[] t = new Term[terms.length];
             System.arraycopy(terms, 0, t, 0, terms.length);
             ArrayUtil.timSort(t);
             equalTerms = t;
         }
         return equalTerms;
 
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         if (!super.equals(o)) return false;
 
         BlendedTermQuery that = (BlendedTermQuery) o;
         if (!Arrays.equals(equalsTerms(), that.equalsTerms())) return false;
 
         return true;
     }
 
     @Override
     public int hashCode() {
         int result = super.hashCode();
         result = 31 * result + Arrays.hashCode(equalsTerms());
         return result;
     }
 
     public static BlendedTermQuery booleanBlendedQuery(Term[] terms, final boolean disableCoord) {
         return booleanBlendedQuery(terms, null, disableCoord);
     }
 
     public static BlendedTermQuery booleanBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord) {
         return new BlendedTermQuery(terms, boosts) {
             @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
-                BooleanQuery query = new BooleanQuery(disableCoord);
+                BooleanQuery.Builder query = new BooleanQuery.Builder();
+                query.setDisableCoord(disableCoord);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     query.add(termQuery, BooleanClause.Occur.SHOULD);
                 }
-                return query;
+                return query.build();
             }
         };
     }
 
     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {
         return new BlendedTermQuery(terms, boosts) {
             @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
-                BooleanQuery query = new BooleanQuery(true);
-                BooleanQuery high = new BooleanQuery(disableCoord);
-                BooleanQuery low = new BooleanQuery(disableCoord);
+                BooleanQuery.Builder highBuilder = new BooleanQuery.Builder();
+                highBuilder.setDisableCoord(disableCoord);
+                BooleanQuery.Builder lowBuilder = new BooleanQuery.Builder();
+                lowBuilder.setDisableCoord(disableCoord);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     if ((maxTermFrequency >= 1f && docFreqs[i] > maxTermFrequency)
                             || (docFreqs[i] > (int) Math.ceil(maxTermFrequency
                             * (float) maxDoc))) {
-                        high.add(termQuery, BooleanClause.Occur.SHOULD);
+                        highBuilder.add(termQuery, BooleanClause.Occur.SHOULD);
                     } else {
-                        low.add(termQuery, BooleanClause.Occur.SHOULD);
+                        lowBuilder.add(termQuery, BooleanClause.Occur.SHOULD);
                     }
                 }
+                BooleanQuery high = highBuilder.build();
+                BooleanQuery low = lowBuilder.build();
                 if (low.clauses().isEmpty()) {
+                    BooleanQuery.Builder queryBuilder = new BooleanQuery.Builder();
+                    queryBuilder.setDisableCoord(disableCoord);
                     for (BooleanClause booleanClause : high) {
-                        booleanClause.setOccur(BooleanClause.Occur.MUST);
+                        queryBuilder.add(booleanClause.getQuery(), Occur.MUST);
                     }
-                    return high;
+                    return queryBuilder.build();
                 } else if (high.clauses().isEmpty()) {
                     return low;
                 } else {
-                    query.add(high, BooleanClause.Occur.SHOULD);
-                    query.add(low, BooleanClause.Occur.MUST);
-                    return query;
+                    return new BooleanQuery.Builder()
+                        .setDisableCoord(true)
+                        .add(high, BooleanClause.Occur.SHOULD)
+                        .add(low, BooleanClause.Occur.MUST)
+                        .build();
                 }
             }
         };
     }
 
     public static BlendedTermQuery dismaxBlendedQuery(Term[] terms, final float tieBreakerMultiplier) {
         return dismaxBlendedQuery(terms, null, tieBreakerMultiplier);
     }
 
     public static BlendedTermQuery dismaxBlendedQuery(Term[] terms, final float[] boosts, final float tieBreakerMultiplier) {
         return new BlendedTermQuery(terms, boosts) {
             @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
                 DisjunctionMaxQuery query = new DisjunctionMaxQuery(tieBreakerMultiplier);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     query.add(termQuery);
                 }
                 return query;
             }
         };
     }
 }
