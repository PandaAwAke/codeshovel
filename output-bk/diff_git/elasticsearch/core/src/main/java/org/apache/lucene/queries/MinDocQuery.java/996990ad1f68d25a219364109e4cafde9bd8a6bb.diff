diff --git a/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java
index e882e727429..0fed8316a05 100644
--- a/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java
+++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java
@@ -46,100 +46,109 @@ public final class MinDocQuery extends Query {
     /** Sole constructor. */
     public MinDocQuery(int minDoc) {
         this(minDoc, null);
     }
 
     MinDocQuery(int minDoc, Object readerId) {
         this.minDoc = minDoc;
         this.readerId = readerId;
     }
 
     @Override
     public int hashCode() {
         return Objects.hash(classHash(), minDoc, readerId);
     }
 
     @Override
     public boolean equals(Object obj) {
         if (sameClassAs(obj) == false) {
             return false;
         }
         MinDocQuery that = (MinDocQuery) obj;
         return minDoc == that.minDoc && Objects.equals(readerId, that.readerId);
     }
 
     @Override
     public Query rewrite(IndexReader reader) throws IOException {
         if (Objects.equals(reader.getContext().id(), readerId) == false) {
             return new MinDocQuery(minDoc, reader.getContext().id());
         }
         return this;
     }
 
     @Override
     public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
         if (readerId == null) {
             throw new IllegalStateException("Rewrite first");
         } else if (Objects.equals(searcher.getIndexReader().getContext().id(), readerId) == false) {
             throw new IllegalStateException("Executing against a different reader than the query has been rewritten against");
         }
         return new ConstantScoreWeight(this, boost) {
             @Override
             public Scorer scorer(LeafReaderContext context) throws IOException {
                 final int maxDoc = context.reader().maxDoc();
                 if (context.docBase + maxDoc <= minDoc) {
                     return null;
                 }
                 final int segmentMinDoc = Math.max(0, minDoc - context.docBase);
                 final DocIdSetIterator disi = new MinDocIterator(segmentMinDoc, maxDoc);
                 return new ConstantScoreScorer(this, score(), disi);
             }
+
+            @Override
+            public boolean isCacheable(LeafReaderContext ctx) {
+                // Let's not cache this query, the cached iterator would use more memory
+                // and be slower anyway.
+                // Also, matches in a given segment depend on the other segments, which
+                // makes it a bad candidate for per-segment caching.
+                return false;
+            }
         };
     }
 
     static class MinDocIterator extends DocIdSetIterator {
         final int segmentMinDoc;
         final int maxDoc;
         int doc = -1;
 
         MinDocIterator(int segmentMinDoc, int maxDoc) {
             this.segmentMinDoc = segmentMinDoc;
             this.maxDoc = maxDoc;
         }
 
         @Override
         public int docID() {
             return doc;
         }
 
         @Override
         public int nextDoc() throws IOException {
             return advance(doc + 1);
         }
 
         @Override
         public int advance(int target) throws IOException {
             assert target > doc;
             if (doc == -1) {
                 // skip directly to minDoc
                 doc = Math.max(target, segmentMinDoc);
             } else {
                 doc = target;
             }
             if (doc >= maxDoc) {
                 doc = NO_MORE_DOCS;
             }
             return doc;
         }
 
         @Override
         public long cost() {
             return maxDoc - segmentMinDoc;
         }
     }
 
 
     @Override
     public String toString(String field) {
         return "MinDocQuery(minDoc=" + minDoc  + ")";
     }
 }
