diff --git a/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
index 4e24944ffac..564f780b8ed 100644
--- a/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
+++ b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
@@ -190,100 +190,104 @@ public abstract class BlendedTermQuery extends Query {
         TermContext newTermContext = new TermContext(termContext.topReaderContext);
         List<LeafReaderContext> leaves = termContext.topReaderContext.leaves();
         final int len;
         if (leaves == null) {
             len = 1;
         } else {
             len = leaves.size();
         }
         int df = termContext.docFreq();
         long ttf = sumTTF;
         for (int i = 0; i < len; i++) {
             TermState termState = termContext.get(i);
             if (termState == null) {
                 continue;
             }
             newTermContext.register(termState, i, df, ttf);
             df = 0;
             ttf = 0;
         }
         return newTermContext;
     }
 
     private static TermContext adjustDF(TermContext ctx, int newDocFreq) {
         // Use a value of ttf that is consistent with the doc freq (ie. gte)
         long newTTF;
         if (ctx.totalTermFreq() < 0) {
             newTTF = -1;
         } else {
             newTTF = Math.max(ctx.totalTermFreq(), newDocFreq);
         }
         List<LeafReaderContext> leaves = ctx.topReaderContext.leaves();
         final int len;
         if (leaves == null) {
             len = 1;
         } else {
             len = leaves.size();
         }
         TermContext newCtx = new TermContext(ctx.topReaderContext);
         for (int i = 0; i < len; ++i) {
             TermState termState = ctx.get(i);
             if (termState == null) {
                 continue;
             }
             newCtx.register(termState, i, newDocFreq, newTTF);
             newDocFreq = 0;
             newTTF = 0;
         }
         return newCtx;
     }
 
+    public List<Term> getTerms() {
+        return Arrays.asList(terms);
+    }
+
     @Override
     public String toString(String field) {
         StringBuilder builder = new StringBuilder("blended(terms:[");
         for (int i = 0; i < terms.length; ++i) {
             builder.append(terms[i]);
             float boost = 1f;
             if (boosts != null) {
                 boost = boosts[i];
             }
             if (boost != 1f) {
                 builder.append('^').append(boost);
             }
             builder.append(", ");
         }
         if (terms.length > 0) {
             builder.setLength(builder.length() - 2);
         }
         builder.append("])");
         return builder.toString();
     }
 
     private volatile Term[] equalTerms = null;
 
     private Term[] equalsTerms() {
         if (terms.length == 1) {
             return terms;
         }
         if (equalTerms == null) {
             // sort the terms to make sure equals and hashCode are consistent
             // this should be a very small cost and equivalent to a HashSet but less object creation
             final Term[] t = new Term[terms.length];
             System.arraycopy(terms, 0, t, 0, terms.length);
             ArrayUtil.timSort(t);
             equalTerms = t;
         }
         return equalTerms;
 
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (!super.equals(o)) return false;
 
         BlendedTermQuery that = (BlendedTermQuery) o;
         return Arrays.equals(equalsTerms(), that.equalsTerms());
     }
 
     @Override
     public int hashCode() {
