diff --git a/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java
index 37e1f7a6df1..e1a78ac3b8c 100644
--- a/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java
+++ b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java
@@ -57,76 +57,77 @@ public class CustomFieldQuery extends FieldQuery {
         highlightFilters.remove();
     }
 
     @Override
     void flatten(Query sourceQuery, IndexReader reader, Collection<Query> flatQueries) throws IOException {
         if (sourceQuery instanceof SpanTermQuery) {
             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries);
         } else if (sourceQuery instanceof ConstantScoreQuery) {
             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries);
         } else if (sourceQuery instanceof FunctionScoreQuery) {
             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);
         } else if (sourceQuery instanceof FilteredQuery) {
             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);
             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);
         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {
             flatten(sourceQuery.rewrite(reader), reader, flatQueries);
         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {
             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);
         } else if (sourceQuery instanceof MultiPhraseQuery) {
             MultiPhraseQuery q = ((MultiPhraseQuery) sourceQuery);
             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);
         } else if (sourceQuery instanceof BlendedTermQuery) {
             final BlendedTermQuery blendedTermQuery = (BlendedTermQuery) sourceQuery;
             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries);
         } else {
             super.flatten(sourceQuery, reader, flatQueries);
         }
     }
     
     private void convertMultiPhraseQuery(int currentPos, int[] termsIdx, MultiPhraseQuery orig, List<Term[]> terms, int[] pos, IndexReader reader, Collection<Query> flatQueries) throws IOException {
         if (currentPos == 0) {
             // if we have more than 16 terms 
             int numTerms = 0;
             for (Term[] currentPosTerm : terms) {
                 numTerms += currentPosTerm.length;
             }
             if (numTerms > 16) {
                 for (Term[] currentPosTerm : terms) {
                     for (Term term : currentPosTerm) {
                         super.flatten(new TermQuery(term), reader, flatQueries);    
                     }
                 }
                 return;
             }
         }
         /*
          * we walk all possible ways and for each path down the MPQ we create a PhraseQuery this is what FieldQuery supports.
          * It seems expensive but most queries will pretty small.
          */
         if (currentPos == terms.size()) {
-            PhraseQuery query = new PhraseQuery();
-            query.setBoost(orig.getBoost());
-            query.setSlop(orig.getSlop());
+            PhraseQuery.Builder queryBuilder = new PhraseQuery.Builder();
+            queryBuilder.setSlop(orig.getSlop());
             for (int i = 0; i < termsIdx.length; i++) {
-                query.add(terms.get(i)[termsIdx[i]], pos[i]);
+                queryBuilder.add(terms.get(i)[termsIdx[i]], pos[i]);
             }
+            PhraseQuery query = queryBuilder.build();
+            query.setBoost(orig.getBoost());
             this.flatten(query, reader, flatQueries);
         } else {
             Term[] t = terms.get(currentPos);
             for (int i = 0; i < t.length; i++) {
                 termsIdx[currentPos] = i;
                 convertMultiPhraseQuery(currentPos+1, termsIdx, orig, terms, pos, reader, flatQueries);
             }
         }
     }
     
     void flatten(Filter sourceFilter, IndexReader reader, Collection<Query> flatQueries) throws IOException {
         Boolean highlight = highlightFilters.get();
         if (highlight == null || highlight.equals(Boolean.FALSE)) {
             return;
         }
         if (sourceFilter instanceof QueryWrapperFilter) {
             flatten(((QueryWrapperFilter) sourceFilter).getQuery(), reader, flatQueries);
         }
     }
 }
