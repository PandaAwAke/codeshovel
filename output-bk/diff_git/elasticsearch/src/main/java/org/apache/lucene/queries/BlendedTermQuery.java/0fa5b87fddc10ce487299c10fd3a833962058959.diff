diff --git a/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java b/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
index 50f54731970..49646720e1d 100644
--- a/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
+++ b/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java
@@ -192,119 +192,122 @@ public abstract class BlendedTermQuery extends Query {
     @Override
     public void extractTerms(Set<Term> terms) {
         for (Term term : this.terms) {
             terms.add(term);
         }
     }
 
     private volatile Term[] equalTerms = null;
 
     private Term[] equalsTerms() {
         if (terms.length == 1) {
             return terms;
         }
         if (equalTerms == null) {
             // sort the terms to make sure equals and hashCode are consistent
             // this should be a very small cost and equivalent to a HashSet but less object creation
             final Term[] t = new Term[terms.length];
             System.arraycopy(terms, 0, t, 0, terms.length);
             ArrayUtil.timSort(t);
             equalTerms = t;
         }
         return equalTerms;
 
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         if (!super.equals(o)) return false;
 
         BlendedTermQuery that = (BlendedTermQuery) o;
         if (!Arrays.equals(equalsTerms(), that.equalsTerms())) return false;
 
         return true;
     }
 
     @Override
     public int hashCode() {
         int result = super.hashCode();
         result = 31 * result + Arrays.hashCode(equalsTerms());
         return result;
     }
 
     public static BlendedTermQuery booleanBlendedQuery(Term[] terms, final boolean disableCoord) {
         return booleanBlendedQuery(terms, null, disableCoord);
     }
 
     public static BlendedTermQuery booleanBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord) {
         return new BlendedTermQuery(terms) {
+            @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
                 BooleanQuery query = new BooleanQuery(disableCoord);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     query.add(termQuery, BooleanClause.Occur.SHOULD);
                 }
                 return query;
             }
         };
     }
 
     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {
         return new BlendedTermQuery(terms) {
+            @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
                 BooleanQuery query = new BooleanQuery(true);
                 BooleanQuery high = new BooleanQuery(disableCoord);
                 BooleanQuery low = new BooleanQuery(disableCoord);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     if ((maxTermFrequency >= 1f && docFreqs[i] > maxTermFrequency)
                             || (docFreqs[i] > (int) Math.ceil(maxTermFrequency
                             * (float) maxDoc))) {
                         high.add(termQuery, BooleanClause.Occur.SHOULD);
                     } else {
                         low.add(termQuery, BooleanClause.Occur.SHOULD);
                     }
                 }
                 if (low.clauses().isEmpty()) {
                     for (BooleanClause booleanClause : high) {
                         booleanClause.setOccur(BooleanClause.Occur.MUST);
                     }
                     return high;
                 } else if (high.clauses().isEmpty()) {
                     return low;
                 } else {
                     query.add(high, BooleanClause.Occur.SHOULD);
                     query.add(low, BooleanClause.Occur.MUST);
                     return query;
                 }
             }
         };
     }
 
     public static BlendedTermQuery dismaxBlendedQuery(Term[] terms, final float tieBreakerMultiplier) {
         return dismaxBlendedQuery(terms, null, tieBreakerMultiplier);
     }
 
     public static BlendedTermQuery dismaxBlendedQuery(Term[] terms, final float[] boosts, final float tieBreakerMultiplier) {
         return new BlendedTermQuery(terms) {
+            @Override
             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {
                 DisjunctionMaxQuery query = new DisjunctionMaxQuery(tieBreakerMultiplier);
                 for (int i = 0; i < terms.length; i++) {
                     TermQuery termQuery = new TermQuery(terms[i], ctx[i]);
                     if (boosts != null) {
                         termQuery.setBoost(boosts[i]);
                     }
                     query.add(termQuery);
                 }
                 return query;
             }
         };
     }
 }
