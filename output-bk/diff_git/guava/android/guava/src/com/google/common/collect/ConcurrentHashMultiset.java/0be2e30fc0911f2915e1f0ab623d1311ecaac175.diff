diff --git a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index 8473e8c78..adb2f7fb6 100644
--- a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -470,101 +470,101 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
 
       @Override
       public boolean removeAll(Collection<?> c) {
         return standardRemoveAll(c);
       }
     };
   }
 
   /** @deprecated Internal method, use {@link #entrySet()}. */
   @Deprecated
   @Override
   public Set<Multiset.Entry<E>> createEntrySet() {
     return new EntrySet();
   }
 
   @Override
   int distinctElements() {
     return countMap.size();
   }
 
   @Override
   public boolean isEmpty() {
     return countMap.isEmpty();
   }
 
   @Override
   Iterator<Entry<E>> entryIterator() {
     // AbstractIterator makes this fairly clean, but it doesn't support remove(). To support
     // remove(), we create an AbstractIterator, and then use ForwardingIterator to delegate to it.
     final Iterator<Entry<E>> readOnlyIterator =
         new AbstractIterator<Entry<E>>() {
           private final Iterator<Map.Entry<E, AtomicInteger>> mapEntries =
               countMap.entrySet().iterator();
 
           @Override
           protected Entry<E> computeNext() {
             while (true) {
               if (!mapEntries.hasNext()) {
                 return endOfData();
               }
               Map.Entry<E, AtomicInteger> mapEntry = mapEntries.next();
               int count = mapEntry.getValue().get();
               if (count != 0) {
                 return Multisets.immutableEntry(mapEntry.getKey(), count);
               }
             }
           }
         };
 
     return new ForwardingIterator<Entry<E>>() {
-      private Entry<E> last;
+      @NullableDecl private Entry<E> last;
 
       @Override
       protected Iterator<Entry<E>> delegate() {
         return readOnlyIterator;
       }
 
       @Override
       public Entry<E> next() {
         last = super.next();
         return last;
       }
 
       @Override
       public void remove() {
         checkRemove(last != null);
         ConcurrentHashMultiset.this.setCount(last.getElement(), 0);
         last = null;
       }
     };
   }
 
   @Override
   public Iterator<E> iterator() {
     return Multisets.iteratorImpl(this);
   }
 
   @Override
   public void clear() {
     countMap.clear();
   }
 
   @WeakOuter
   private class EntrySet extends AbstractMultiset<E>.EntrySet {
     @Override
     ConcurrentHashMultiset<E> multiset() {
       return ConcurrentHashMultiset.this;
     }
 
     /*
      * Note: the superclass toArray() methods assume that size() gives a correct
      * answer, which ours does not.
      */
 
     @Override
     public Object[] toArray() {
       return snapshot().toArray();
     }
 
     @Override
     public <T> T[] toArray(T[] array) {
