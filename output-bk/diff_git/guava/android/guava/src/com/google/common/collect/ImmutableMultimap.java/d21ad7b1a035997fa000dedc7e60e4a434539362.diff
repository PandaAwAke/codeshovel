diff --git a/android/guava/src/com/google/common/collect/ImmutableMultimap.java b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
index 4b3e8472e..3e43b60d0 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
@@ -490,217 +490,220 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
   @Override
   Map<K, Collection<V>> createAsMap() {
     throw new AssertionError("should never be called");
   }
 
   /** Returns an immutable collection of all key-value pairs in the multimap. */
   @Override
   public ImmutableCollection<Entry<K, V>> entries() {
     return (ImmutableCollection<Entry<K, V>>) super.entries();
   }
 
   @Override
   ImmutableCollection<Entry<K, V>> createEntries() {
     return new EntryCollection<>(this);
   }
 
   private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {
     @Weak final ImmutableMultimap<K, V> multimap;
 
     EntryCollection(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
     }
 
     @Override
     public UnmodifiableIterator<Entry<K, V>> iterator() {
       return multimap.entryIterator();
     }
 
     @Override
     boolean isPartialView() {
       return multimap.isPartialView();
     }
 
     @Override
     public int size() {
       return multimap.size();
     }
 
     @Override
     public boolean contains(Object object) {
       if (object instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) object;
         return multimap.containsEntry(entry.getKey(), entry.getValue());
       }
       return false;
     }
 
     private static final long serialVersionUID = 0;
   }
 
-  private abstract class Itr<T> extends UnmodifiableIterator<T> {
-    final Iterator<Entry<K, Collection<V>>> mapIterator = asMap().entrySet().iterator();
-    K key = null;
-    Iterator<V> valueIterator = Iterators.emptyIterator();
-
-    abstract T output(K key, V value);
-
-    @Override
-    public boolean hasNext() {
-      return mapIterator.hasNext() || valueIterator.hasNext();
-    }
+  @Override
+  UnmodifiableIterator<Entry<K, V>> entryIterator() {
+    return new UnmodifiableIterator<Entry<K, V>>() {
+      final Iterator<? extends Entry<K, ? extends ImmutableCollection<V>>> asMapItr =
+          map.entrySet().iterator();
+      K currentKey = null;
+      Iterator<V> valueItr = Iterators.emptyIterator();
 
-    @Override
-    public T next() {
-      if (!valueIterator.hasNext()) {
-        Entry<K, Collection<V>> mapEntry = mapIterator.next();
-        key = mapEntry.getKey();
-        valueIterator = mapEntry.getValue().iterator();
+      @Override
+      public boolean hasNext() {
+        return valueItr.hasNext() || asMapItr.hasNext();
       }
-      return output(key, valueIterator.next());
-    }
-  }
 
-  @Override
-  UnmodifiableIterator<Entry<K, V>> entryIterator() {
-    return new Itr<Entry<K, V>>() {
       @Override
-      Entry<K, V> output(K key, V value) {
-        return Maps.immutableEntry(key, value);
+      public Entry<K, V> next() {
+        if (!valueItr.hasNext()) {
+          Entry<K, ? extends ImmutableCollection<V>> entry = asMapItr.next();
+          currentKey = entry.getKey();
+          valueItr = entry.getValue().iterator();
+        }
+        return Maps.immutableEntry(currentKey, valueItr.next());
       }
     };
   }
 
   /**
    * Returns an immutable multiset containing all the keys in this multimap, in the same order and
    * with the same frequencies as they appear in this multimap; to get only a single occurrence of
    * each key, use {@link #keySet}.
    */
   @Override
   public ImmutableMultiset<K> keys() {
     return (ImmutableMultiset<K>) super.keys();
   }
 
   @Override
   ImmutableMultiset<K> createKeys() {
     return new Keys();
   }
 
   @SuppressWarnings("serial") // Uses writeReplace, not default serialization
   @WeakOuter
   class Keys extends ImmutableMultiset<K> {
     @Override
     public boolean contains(@NullableDecl Object object) {
       return containsKey(object);
     }
 
     @Override
     public int count(@NullableDecl Object element) {
       Collection<V> values = map.get(element);
       return (values == null) ? 0 : values.size();
     }
 
     @Override
     public ImmutableSet<K> elementSet() {
       return keySet();
     }
 
     @Override
     public int size() {
       return ImmutableMultimap.this.size();
     }
 
     @Override
     Multiset.Entry<K> getEntry(int index) {
       Map.Entry<K, ? extends Collection<V>> entry = map.entrySet().asList().get(index);
       return Multisets.immutableEntry(entry.getKey(), entry.getValue().size());
     }
 
     @Override
     boolean isPartialView() {
       return true;
     }
 
     // We can't label this with @Override, because it doesn't override anything
     // in the GWT emulated version.
     Object writeReplace() {
       return new KeysSerializedForm(ImmutableMultimap.this);
     }
   }
   
   private static final class KeysSerializedForm implements Serializable {
     final ImmutableMultimap<?, ?> multimap;
 
     KeysSerializedForm(ImmutableMultimap<?, ?> multimap) {
       this.multimap = multimap;
     }
 
     Object readResolve() {
       return multimap.keys();
     }
   }
 
   /**
    * Returns an immutable collection of the values in this multimap. Its iterator traverses the
    * values for the first key, the values for the second key, and so on.
    */
   @Override
   public ImmutableCollection<V> values() {
     return (ImmutableCollection<V>) super.values();
   }
 
   @Override
   ImmutableCollection<V> createValues() {
     return new Values<>(this);
   }
 
   @Override
   UnmodifiableIterator<V> valueIterator() {
-    return new Itr<V>() {
+    return new UnmodifiableIterator<V>() {
+      Iterator<? extends ImmutableCollection<V>> valueCollectionItr = map.values().iterator();
+      Iterator<V> valueItr = Iterators.emptyIterator();
+
       @Override
-      V output(K key, V value) {
-        return value;
+      public boolean hasNext() {
+        return valueItr.hasNext() || valueCollectionItr.hasNext();
+      }
+
+      @Override
+      public V next() {
+        if (!valueItr.hasNext()) {
+          valueItr = valueCollectionItr.next().iterator();
+        }
+        return valueItr.next();
       }
     };
   }
 
   private static final class Values<K, V> extends ImmutableCollection<V> {
     @Weak private final transient ImmutableMultimap<K, V> multimap;
 
     Values(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
     }
 
     @Override
     public boolean contains(@NullableDecl Object object) {
       return multimap.containsValue(object);
     }
 
     @Override
     public UnmodifiableIterator<V> iterator() {
       return multimap.valueIterator();
     }
 
     @GwtIncompatible // not present in emulated superclass
     @Override
     int copyIntoArray(Object[] dst, int offset) {
       for (ImmutableCollection<V> valueCollection : multimap.map.values()) {
         offset = valueCollection.copyIntoArray(dst, offset);
       }
       return offset;
     }
 
     @Override
     public int size() {
       return multimap.size();
     }
 
     @Override
     boolean isPartialView() {
       return true;
     }
 
     private static final long serialVersionUID = 0;
   }
 
   private static final long serialVersionUID = 0;
 }
