diff --git a/android/guava/src/com/google/common/collect/ImmutableMultiset.java b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
index 171b2f73f..f831871a9 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultiset.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
@@ -1,80 +1,81 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.Multiset.Entry;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * A {@link Multiset} whose contents will never change, with many other important properties
  * detailed at {@link ImmutableCollection}.
  *
  * <p><b>Grouped iteration.</b> In all current implementations, duplicate elements always appear
  * consecutively when iterating. Elements iterate in order by the <i>first</i> appearance of that
  * element when the multiset was created.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained"> immutable collections</a>.
  *
  * @author Jared Levy
  * @author Louis Wasserman
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializationDependencies<E>
     implements Multiset<E> {
   /** Returns the empty immutable multiset. */
   @SuppressWarnings("unchecked") // all supported methods are covariant
   public static <E> ImmutableMultiset<E> of() {
     return (ImmutableMultiset<E>) RegularImmutableMultiset.EMPTY;
   }
 
   /**
    * Returns an immutable multiset containing a single element.
    *
    * @throws NullPointerException if {@code element} is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") // generic array created but never written
   public static <E> ImmutableMultiset<E> of(E element) {
     return copyFromElements(element);
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in order.
    *
    * @throws NullPointerException if any element is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") //
   public static <E> ImmutableMultiset<E> of(E e1, E e2) {
     return copyFromElements(e1, e2);
   }
 
   /**
@@ -140,101 +141,101 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any of {@code elements} is null
    */
   public static <E> ImmutableMultiset<E> copyOf(Iterable<? extends E> elements) {
     if (elements instanceof ImmutableMultiset) {
       @SuppressWarnings("unchecked") // all supported methods are covariant
       ImmutableMultiset<E> result = (ImmutableMultiset<E>) elements;
       if (!result.isPartialView()) {
         return result;
       }
     }
 
     ImmutableMultiset.Builder<E> builder =
         new ImmutableMultiset.Builder<E>(Multisets.inferDistinctElements(elements));
     builder.addAll(elements);
     return builder.build();
   }
 
   private static <E> ImmutableMultiset<E> copyFromElements(E... elements) {
     return new ImmutableMultiset.Builder<E>().add(elements).build();
   }
 
   static <E> ImmutableMultiset<E> copyFromEntries(
       Collection<? extends Entry<? extends E>> entries) {
     ImmutableMultiset.Builder<E> builder = new ImmutableMultiset.Builder<E>(entries.size());
     for (Entry<? extends E> entry : entries) {
       builder.addCopies(entry.getElement(), entry.getCount());
     }
     return builder.build();
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any of {@code elements} is null
    */
   public static <E> ImmutableMultiset<E> copyOf(Iterator<? extends E> elements) {
     return new ImmutableMultiset.Builder<E>().addAll(elements).build();
   }
 
   ImmutableMultiset() {}
 
   @Override
   public UnmodifiableIterator<E> iterator() {
     final Iterator<Entry<E>> entryIterator = entrySet().iterator();
     return new UnmodifiableIterator<E>() {
       int remaining;
-      E element;
+      @MonotonicNonNullDecl E element;
 
       @Override
       public boolean hasNext() {
         return (remaining > 0) || entryIterator.hasNext();
       }
 
       @Override
       public E next() {
         if (remaining <= 0) {
           Entry<E> entry = entryIterator.next();
           element = entry.getElement();
           remaining = entry.getCount();
         }
         remaining--;
         return element;
       }
     };
   }
 
   @LazyInit private transient ImmutableList<E> asList;
 
   @Override
   public ImmutableList<E> asList() {
     ImmutableList<E> result = asList;
     return (result == null) ? asList = super.asList() : result;
   }
 
   @Override
   public boolean contains(@NullableDecl Object object) {
     return count(object) > 0;
   }
 
   /**
    * Guaranteed to throw an exception and leave the collection unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
   @Deprecated
   @Override
   public final int add(E element, int occurrences) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the collection unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
