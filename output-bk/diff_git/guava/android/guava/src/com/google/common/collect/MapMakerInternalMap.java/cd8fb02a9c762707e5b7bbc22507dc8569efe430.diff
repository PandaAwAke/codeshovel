diff --git a/android/guava/src/com/google/common/collect/MapMakerInternalMap.java b/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
index 55cf85e1b..b1ef4f1b0 100644
--- a/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
+++ b/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
@@ -1,72 +1,73 @@
 /*
  * Copyright (C) 2009 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Equivalence;
+import com.google.common.collect.MapMaker.Dummy;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.Weak;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.AbstractCollection;
 import java.util.AbstractMap;
 import java.util.AbstractSet;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 
 /**
  * The concurrent hash map implementation built by {@link MapMaker}.
  *
  * <p>This implementation is heavily derived from revision 1.96 of <a
  * href="http://tinyurl.com/ConcurrentHashMap">ConcurrentHashMap.java</a>.
  *
  * @param <K> the type of the keys in the map
  * @param <V> the type of the values in the map
  * @param <E> the type of the {@link InternalEntry} entry implementation used internally
  * @param <S> the type of the {@link Segment} entry implementation used internally
  * @author Bob Lee
  * @author Charles Fry
  * @author Doug Lea ({@code ConcurrentHashMap})
  */
 // TODO(kak/cpovirk): Consider removing @CanIgnoreReturnValue from this class.
 @GwtIncompatible
 @SuppressWarnings("GuardedBy") // TODO(b/35466881): Fix or suppress.
 class MapMakerInternalMap<
         K,
         V,
         E extends MapMakerInternalMap.InternalEntry<K, V, E>,
         S extends MapMakerInternalMap.Segment<K, V, E, S>>
@@ -145,128 +146,160 @@ class MapMakerInternalMap<
   final transient Segment<K, V, E, S>[] segments;
 
   /** The concurrency level. */
   final int concurrencyLevel;
 
   /** Strategy for comparing keys. */
   final Equivalence<Object> keyEquivalence;
 
   /** Strategy for handling entries and segments in a type-safe and efficient manner. */
   final transient InternalEntryHelper<K, V, E, S> entryHelper;
 
   /**
    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.
    */
   private MapMakerInternalMap(MapMaker builder, InternalEntryHelper<K, V, E, S> entryHelper) {
     concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);
 
     keyEquivalence = builder.getKeyEquivalence();
     this.entryHelper = entryHelper;
 
     int initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);
 
     // Find power-of-two sizes best matching arguments. Constraints:
     // (segmentCount > concurrencyLevel)
     int segmentShift = 0;
     int segmentCount = 1;
     while (segmentCount < concurrencyLevel) {
       ++segmentShift;
       segmentCount <<= 1;
     }
     this.segmentShift = 32 - segmentShift;
     segmentMask = segmentCount - 1;
 
     this.segments = newSegmentArray(segmentCount);
 
     int segmentCapacity = initialCapacity / segmentCount;
     if (segmentCapacity * segmentCount < initialCapacity) {
       ++segmentCapacity;
     }
 
     int segmentSize = 1;
     while (segmentSize < segmentCapacity) {
       segmentSize <<= 1;
     }
 
     for (int i = 0; i < this.segments.length; ++i) {
       this.segments[i] = createSegment(segmentSize, MapMaker.UNSET_INT);
     }
   }
 
+  /** Returns a fresh {@link MapMakerInternalMap} as specified by the given {@code builder}. */
   static <K, V> MapMakerInternalMap<K, V, ? extends InternalEntry<K, V, ?>, ?> create(
       MapMaker builder) {
     if (builder.getKeyStrength() == Strength.STRONG
         && builder.getValueStrength() == Strength.STRONG) {
       return new MapMakerInternalMap<
           K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>>(
           builder, StrongKeyStrongValueEntry.Helper.<K, V>instance());
     }
     if (builder.getKeyStrength() == Strength.STRONG
         && builder.getValueStrength() == Strength.WEAK) {
       return new MapMakerInternalMap<
           K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>>(
           builder, StrongKeyWeakValueEntry.Helper.<K, V>instance());
     }
     if (builder.getKeyStrength() == Strength.WEAK
         && builder.getValueStrength() == Strength.STRONG) {
       return new MapMakerInternalMap<
           K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>>(
           builder, WeakKeyStrongValueEntry.Helper.<K, V>instance());
     }
     if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.WEAK) {
       return new MapMakerInternalMap<
           K, V, WeakKeyWeakValueEntry<K, V>, WeakKeyWeakValueSegment<K, V>>(
           builder, WeakKeyWeakValueEntry.Helper.<K, V>instance());
     }
     throw new AssertionError();
   }
 
+  /**
+   * Returns a fresh {@link MapMakerInternalMap} with {@link MapMaker.Dummy} values but otherwise as
+   * specified by the given {@code builder}. The returned {@link MapMakerInternalMap} will be
+   * optimized to saved memory. Since {@link MapMaker.Dummy} is a singleton, we don't need to store
+   * any values at all. Because of this optimization, {@code build.getValueStrength()} must
+   * be {@link Strength#STRONG}.
+   *
+   * <p>This method is intended to only be used by the internal implementation of {@link Interners},
+   * since a map of dummy values is the exact use case there.
+   */
+  static <K>
+      MapMakerInternalMap<K, Dummy, ? extends InternalEntry<K, Dummy, ?>, ?> createWithDummyValues(
+          MapMaker builder) {
+    if (builder.getKeyStrength() == Strength.STRONG
+        && builder.getValueStrength() == Strength.STRONG) {
+      return new MapMakerInternalMap<
+          K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>>(
+          builder, StrongKeyDummyValueEntry.Helper.<K>instance());
+    }
+    if (builder.getKeyStrength() == Strength.WEAK
+        && builder.getValueStrength() == Strength.STRONG) {
+      return new MapMakerInternalMap<
+          K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>>(
+          builder, WeakKeyDummyValueEntry.Helper.<K>instance());
+    }
+    if (builder.getValueStrength() == Strength.WEAK) {
+      throw new IllegalArgumentException("Map cannot have both weak and dummy values");
+    }
+    throw new AssertionError();
+  }
+
   enum Strength {
     STRONG {
       @Override
       Equivalence<Object> defaultEquivalence() {
         return Equivalence.equals();
       }
     },
 
     WEAK {
       @Override
       Equivalence<Object> defaultEquivalence() {
         return Equivalence.identity();
       }
     };
 
     /**
      * Returns the default equivalence strategy used to compare and hash keys or values referenced
      * at this strength. This strategy will be used unless the user explicitly specifies an
      * alternate strategy.
      */
     abstract Equivalence<Object> defaultEquivalence();
   }
 
   /**
    * A helper object for operating on {@link InternalEntry} instances in a type-safe and efficient
    * manner.
    *
    * <p>For each of the four combinations of strong/weak key and strong/weak value, there are
    * corresponding {@link InternalEntry}, {@link Segment}, and {@link InternalEntryHelper}
    * implementations.
    *
    * @param <K> the type of the key in each entry
    * @param <V> the type of the value in each entry
    * @param <E> the type of the {@link InternalEntry} entry implementation
    * @param <S> the type of the {@link Segment} entry implementation
    */
   interface InternalEntryHelper<
       K, V, E extends InternalEntry<K, V, E>, S extends Segment<K, V, E, S>> {
     /** The strength of the key type in each entry. */
     Strength keyStrength();
 
     /** The strength of the value type in each entry. */
     Strength valueStrength();
 
     /** Returns a freshly created segment, typed at the {@code S} type. */
     S newSegment(MapMakerInternalMap<K, V, E, S> map, int initialCapacity, int maxSegmentSize);
 
     /**
      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment}.
      */
@@ -506,128 +539,283 @@ class MapMakerInternalMap<
         return (Helper<K, V>) INSTANCE;
       }
 
       @Override
       public Strength keyStrength() {
         return Strength.STRONG;
       }
 
       @Override
       public Strength valueStrength() {
         return Strength.WEAK;
       }
 
       @Override
       public StrongKeyWeakValueSegment<K, V> newSegment(
           MapMakerInternalMap<K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>>
               map,
           int initialCapacity,
           int maxSegmentSize) {
         return new StrongKeyWeakValueSegment<K, V>(map, initialCapacity, maxSegmentSize);
       }
 
       @Override
       public StrongKeyWeakValueEntry<K, V> copy(
           StrongKeyWeakValueSegment<K, V> segment,
           StrongKeyWeakValueEntry<K, V> entry,
           @Nullable StrongKeyWeakValueEntry<K, V> newNext) {
         if (Segment.isCollected(entry)) {
           return null;
         }
         return entry.copy(segment.queueForValues, newNext);
       }
 
       @Override
       public void setValue(
           StrongKeyWeakValueSegment<K, V> segment, StrongKeyWeakValueEntry<K, V> entry, V value) {
         entry.setValue(value, segment.queueForValues);
       }
 
       @Override
       public StrongKeyWeakValueEntry<K, V> newEntry(
           StrongKeyWeakValueSegment<K, V> segment,
           K key,
           int hash,
           @Nullable StrongKeyWeakValueEntry<K, V> next) {
         return new StrongKeyWeakValueEntry<K, V>(key, hash, next);
       }
     }
   }
 
+  /** Concrete implementation of {@link InternalEntry} for strong keys and {@link Dummy} values. */
+  static final class StrongKeyDummyValueEntry<K>
+      extends AbstractStrongKeyEntry<K, Dummy, StrongKeyDummyValueEntry<K>>
+      implements StrongValueEntry<K, Dummy, StrongKeyDummyValueEntry<K>> {
+    StrongKeyDummyValueEntry(K key, int hash, @Nullable StrongKeyDummyValueEntry<K> next) {
+      super(key, hash, next);
+    }
+
+    @Override
+    public Dummy getValue() {
+      return Dummy.VALUE;
+    }
+
+    void setValue(Dummy value) {}
+
+    StrongKeyDummyValueEntry<K> copy(StrongKeyDummyValueEntry<K> newNext) {
+      return new StrongKeyDummyValueEntry<K>(this.key, this.hash, newNext);
+    }
+
+    /**
+     * Concrete implementation of {@link InternalEntryHelper} for strong keys and {@link Dummy}
+     * values.
+     */
+    static final class Helper<K>
+        implements InternalEntryHelper<
+            K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>> {
+      private static final Helper<?> INSTANCE = new Helper<Object>();
+
+      @SuppressWarnings("unchecked")
+      static <K> Helper<K> instance() {
+        return (Helper<K>) INSTANCE;
+      }
+
+      @Override
+      public Strength keyStrength() {
+        return Strength.STRONG;
+      }
+
+      @Override
+      public Strength valueStrength() {
+        return Strength.STRONG;
+      }
+
+      @Override
+      public StrongKeyDummyValueSegment<K> newSegment(
+          MapMakerInternalMap<K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>>
+              map,
+          int initialCapacity,
+          int maxSegmentSize) {
+        return new StrongKeyDummyValueSegment<K>(map, initialCapacity, maxSegmentSize);
+      }
+
+      @Override
+      public StrongKeyDummyValueEntry<K> copy(
+          StrongKeyDummyValueSegment<K> segment,
+          StrongKeyDummyValueEntry<K> entry,
+          @Nullable StrongKeyDummyValueEntry<K> newNext) {
+        return entry.copy(newNext);
+      }
+
+      @Override
+      public void setValue(
+          StrongKeyDummyValueSegment<K> segment, StrongKeyDummyValueEntry<K> entry, Dummy value) {}
+
+      @Override
+      public StrongKeyDummyValueEntry<K> newEntry(
+          StrongKeyDummyValueSegment<K> segment,
+          K key,
+          int hash,
+          @Nullable StrongKeyDummyValueEntry<K> next) {
+        return new StrongKeyDummyValueEntry<K>(key, hash, next);
+      }
+    }
+  }
+
   /** Base class for {@link InternalEntry} implementations for weak keys. */
   abstract static class AbstractWeakKeyEntry<K, V, E extends InternalEntry<K, V, E>>
       extends WeakReference<K> implements InternalEntry<K, V, E> {
     final int hash;
     final E next;
 
     AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable E next) {
       super(key, queue);
       this.hash = hash;
       this.next = next;
     }
 
     @Override
     public K getKey() {
       return get();
     }
 
     @Override
     public int getHash() {
       return hash;
     }
 
     @Override
     public E getNext() {
       return next;
     }
   }
 
+  /** Concrete implementation of {@link InternalEntry} for weak keys and {@link Dummy} values. */
+  static final class WeakKeyDummyValueEntry<K>
+      extends AbstractWeakKeyEntry<K, Dummy, WeakKeyDummyValueEntry<K>>
+      implements StrongValueEntry<K, Dummy, WeakKeyDummyValueEntry<K>> {
+    WeakKeyDummyValueEntry(
+        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyDummyValueEntry<K> next) {
+      super(queue, key, hash, next);
+    }
+
+    @Override
+    public Dummy getValue() {
+      return Dummy.VALUE;
+    }
+
+    void setValue(Dummy value) {}
+
+    WeakKeyDummyValueEntry<K> copy(
+        ReferenceQueue<K> queueForKeys, WeakKeyDummyValueEntry<K> newNext) {
+      return new WeakKeyDummyValueEntry<K>(queueForKeys, getKey(), this.hash, newNext);
+    }
+
+    /**
+     * Concrete implementation of {@link InternalEntryHelper} for weak keys and {@link Dummy}
+     * values.
+     */
+    static final class Helper<K>
+        implements InternalEntryHelper<
+            K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> {
+      private static final Helper<?> INSTANCE = new Helper<Object>();
+
+      @SuppressWarnings("unchecked")
+      static <K> Helper<K> instance() {
+        return (Helper<K>) INSTANCE;
+      }
+
+      @Override
+      public Strength keyStrength() {
+        return Strength.WEAK;
+      }
+
+      @Override
+      public Strength valueStrength() {
+        return Strength.STRONG;
+      }
+
+      @Override
+      public WeakKeyDummyValueSegment<K> newSegment(
+          MapMakerInternalMap<K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> map,
+          int initialCapacity,
+          int maxSegmentSize) {
+        return new WeakKeyDummyValueSegment<K>(map, initialCapacity, maxSegmentSize);
+      }
+
+      @Override
+      public WeakKeyDummyValueEntry<K> copy(
+          WeakKeyDummyValueSegment<K> segment,
+          WeakKeyDummyValueEntry<K> entry,
+          @Nullable WeakKeyDummyValueEntry<K> newNext) {
+        if (entry.getKey() == null) {
+          // key collected
+          return null;
+        }
+        return entry.copy(segment.queueForKeys, newNext);
+      }
+
+      @Override
+      public void setValue(
+          WeakKeyDummyValueSegment<K> segment, WeakKeyDummyValueEntry<K> entry, Dummy value) {}
+
+      @Override
+      public WeakKeyDummyValueEntry<K> newEntry(
+          WeakKeyDummyValueSegment<K> segment,
+          K key,
+          int hash,
+          @Nullable WeakKeyDummyValueEntry<K> next) {
+        return new WeakKeyDummyValueEntry<K>(segment.queueForKeys, key, hash, next);
+      }
+    }
+  }
+
   /** Concrete implementation of {@link InternalEntry} for weak keys and strong values. */
   static final class WeakKeyStrongValueEntry<K, V>
       extends AbstractWeakKeyEntry<K, V, WeakKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, WeakKeyStrongValueEntry<K, V>> {
     @Nullable private volatile V value = null;
 
     WeakKeyStrongValueEntry(
         ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
     @Override
     @Nullable
     public V getValue() {
       return value;
     }
 
     void setValue(V value) {
       this.value = value;
     }
 
     WeakKeyStrongValueEntry<K, V> copy(
         ReferenceQueue<K> queueForKeys, WeakKeyStrongValueEntry<K, V> newNext) {
       WeakKeyStrongValueEntry<K, V> newEntry =
           new WeakKeyStrongValueEntry<K, V>(queueForKeys, getKey(), this.hash, newNext);
       newEntry.setValue(value);
       return newEntry;
     }
 
     /** Concrete implementation of {@link InternalEntryHelper} for weak keys and strong values. */
     static final class Helper<K, V>
         implements InternalEntryHelper<
             K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>> {
       private static final Helper<?, ?> INSTANCE = new Helper<Object, Object>();
 
       @SuppressWarnings("unchecked")
       static <K, V> Helper<K, V> instance() {
         return (Helper<K, V>) INSTANCE;
       }
 
       @Override
       public Strength keyStrength() {
         return Strength.WEAK;
       }
 
       @Override
       public Strength valueStrength() {
         return Strength.STRONG;
       }
 
@@ -1878,100 +2066,123 @@ class MapMakerInternalMap<
     }
 
     @Override
     ReferenceQueue<V> getValueReferenceQueueForTesting() {
       return queueForValues;
     }
 
     @SuppressWarnings("unchecked")
     @Override
     public StrongKeyWeakValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (StrongKeyWeakValueEntry<K, V>) entry;
     }
 
     @Override
     public WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> getWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e) {
       return castForTesting(e).getValueReference();
     }
 
     @Override
     public WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> newWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e, V value) {
       return new WeakValueReferenceImpl<K, V, StrongKeyWeakValueEntry<K, V>>(
           queueForValues, value, castForTesting(e));
     }
 
     @Override
     public void setWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e,
         WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference) {
       StrongKeyWeakValueEntry<K, V> entry = castForTesting(e);
       @SuppressWarnings("unchecked")
       WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> newValueReference =
           (WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>>) valueReference;
       WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> previous = entry.valueReference;
       entry.valueReference = newValueReference;
       previous.clear();
     }
 
     @Override
     void maybeDrainReferenceQueues() {
       drainValueReferenceQueue(queueForValues);
     }
 
     @Override
     void maybeClearReferenceQueues() {
       clearReferenceQueue(queueForValues);
     }
   }
 
+  /** Concrete implementation of {@link Segment} for strong keys and {@link Dummy} values. */
+  static final class StrongKeyDummyValueSegment<K>
+      extends Segment<K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>> {
+    StrongKeyDummyValueSegment(
+        MapMakerInternalMap<K, Dummy, StrongKeyDummyValueEntry<K>, StrongKeyDummyValueSegment<K>>
+            map,
+        int initialCapacity,
+        int maxSegmentSize) {
+      super(map, initialCapacity, maxSegmentSize);
+    }
+
+    @Override
+    StrongKeyDummyValueSegment<K> self() {
+      return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public StrongKeyDummyValueEntry<K> castForTesting(InternalEntry<K, Dummy, ?> entry) {
+      return (StrongKeyDummyValueEntry<K>) entry;
+    }
+  }
+
   /** Concrete implementation of {@link Segment} for weak keys and strong values. */
   static final class WeakKeyStrongValueSegment<K, V>
       extends Segment<K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>> {
     private final ReferenceQueue<K> queueForKeys = new ReferenceQueue<K>();
 
     WeakKeyStrongValueSegment(
         MapMakerInternalMap<K, V, WeakKeyStrongValueEntry<K, V>, WeakKeyStrongValueSegment<K, V>>
             map,
         int initialCapacity,
         int maxSegmentSize) {
       super(map, initialCapacity, maxSegmentSize);
     }
 
     @Override
     WeakKeyStrongValueSegment<K, V> self() {
       return this;
     }
 
     @Override
     ReferenceQueue<K> getKeyReferenceQueueForTesting() {
       return queueForKeys;
     }
 
     @SuppressWarnings("unchecked")
     @Override
     public WeakKeyStrongValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (WeakKeyStrongValueEntry<K, V>) entry;
     }
 
     @Override
     void maybeDrainReferenceQueues() {
       drainKeyReferenceQueue(queueForKeys);
     }
 
     @Override
     void maybeClearReferenceQueues() {
       clearReferenceQueue(queueForKeys);
     }
   }
 
   /** Concrete implementation of {@link Segment} for weak keys and weak values. */
   static final class WeakKeyWeakValueSegment<K, V>
       extends Segment<K, V, WeakKeyWeakValueEntry<K, V>, WeakKeyWeakValueSegment<K, V>> {
     private final ReferenceQueue<K> queueForKeys = new ReferenceQueue<K>();
     private final ReferenceQueue<V> queueForValues = new ReferenceQueue<V>();
 
     WeakKeyWeakValueSegment(
         MapMakerInternalMap<K, V, WeakKeyWeakValueEntry<K, V>, WeakKeyWeakValueSegment<K, V>> map,
         int initialCapacity,
         int maxSegmentSize) {
@@ -1990,100 +2201,139 @@ class MapMakerInternalMap<
 
     @Override
     ReferenceQueue<V> getValueReferenceQueueForTesting() {
       return queueForValues;
     }
 
     @SuppressWarnings("unchecked")
     @Override
     public WeakKeyWeakValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (WeakKeyWeakValueEntry<K, V>) entry;
     }
 
     @Override
     public WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> getWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e) {
       return (castForTesting(e)).getValueReference();
     }
 
     @Override
     public WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> newWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e, V value) {
       return new WeakValueReferenceImpl<K, V, WeakKeyWeakValueEntry<K, V>>(
           queueForValues, value, castForTesting(e));
     }
 
     @Override
     public void setWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e,
         WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference) {
       WeakKeyWeakValueEntry<K, V> entry = castForTesting(e);
       @SuppressWarnings("unchecked")
       WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> newValueReference =
           (WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>>) valueReference;
       WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> previous = entry.valueReference;
       entry.valueReference = newValueReference;
       previous.clear();
     }
 
     @Override
     void maybeDrainReferenceQueues() {
       drainKeyReferenceQueue(queueForKeys);
       drainValueReferenceQueue(queueForValues);
     }
 
     @Override
     void maybeClearReferenceQueues() {
       clearReferenceQueue(queueForKeys);
     }
   }
 
+  /** Concrete implementation of {@link Segment} for weak keys and {@link Dummy} values. */
+  static final class WeakKeyDummyValueSegment<K>
+      extends Segment<K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> {
+    private final ReferenceQueue<K> queueForKeys = new ReferenceQueue<K>();
+
+    WeakKeyDummyValueSegment(
+        MapMakerInternalMap<K, Dummy, WeakKeyDummyValueEntry<K>, WeakKeyDummyValueSegment<K>> map,
+        int initialCapacity,
+        int maxSegmentSize) {
+      super(map, initialCapacity, maxSegmentSize);
+    }
+
+    @Override
+    WeakKeyDummyValueSegment<K> self() {
+      return this;
+    }
+
+    @Override
+    ReferenceQueue<K> getKeyReferenceQueueForTesting() {
+      return queueForKeys;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public WeakKeyDummyValueEntry<K> castForTesting(InternalEntry<K, Dummy, ?> entry) {
+      return (WeakKeyDummyValueEntry<K>) entry;
+    }
+
+    @Override
+    void maybeDrainReferenceQueues() {
+      drainKeyReferenceQueue(queueForKeys);
+    }
+
+    @Override
+    void maybeClearReferenceQueues() {
+      clearReferenceQueue(queueForKeys);
+    }
+  }
+
   static final class CleanupMapTask implements Runnable {
     final WeakReference<MapMakerInternalMap<?, ?, ?, ?>> mapReference;
 
     public CleanupMapTask(MapMakerInternalMap<?, ?, ?, ?> map) {
       this.mapReference = new WeakReference<MapMakerInternalMap<?, ?, ?, ?>>(map);
     }
 
     @Override
     public void run() {
       MapMakerInternalMap<?, ?, ?, ?> map = mapReference.get();
       if (map == null) {
         throw new CancellationException();
       }
 
       for (Segment<?, ?, ?, ?> segment : map.segments) {
         segment.runCleanup();
       }
     }
   }
 
   @VisibleForTesting
   Strength keyStrength() {
     return entryHelper.keyStrength();
   }
 
   @VisibleForTesting
   Strength valueStrength() {
     return entryHelper.valueStrength();
   }
 
   @VisibleForTesting
   Equivalence<Object> valueEquivalence() {
     return entryHelper.valueStrength().defaultEquivalence();
   }
 
   // ConcurrentMap methods
 
   @Override
   public boolean isEmpty() {
     /*
      * Sum per-segment modCounts to avoid mis-reporting when elements are concurrently added and
      * removed in one segment while checking another, in which case the table was never actually
      * empty at any point. (The sum ensures accuracy up through at least 1<<31 per-segment
      * modifications before recheck.)  Method containsValue() uses similar constructions for
      * stability checks.
      */
     long sum = 0L;
     Segment<K, V, E, S>[] segments = this.segments;
     for (int i = 0; i < segments.length; ++i) {
       if (segments[i].count != 0) {
