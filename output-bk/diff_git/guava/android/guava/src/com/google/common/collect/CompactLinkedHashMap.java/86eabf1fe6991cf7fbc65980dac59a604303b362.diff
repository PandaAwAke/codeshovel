diff --git a/android/guava/src/com/google/common/collect/CompactLinkedHashMap.java b/android/guava/src/com/google/common/collect/CompactLinkedHashMap.java
index e2b2d970e..02ca3d44e 100644
--- a/android/guava/src/com/google/common/collect/CompactLinkedHashMap.java
+++ b/android/guava/src/com/google/common/collect/CompactLinkedHashMap.java
@@ -77,101 +77,101 @@ class CompactLinkedHashMap<K, V> extends CompactHashMap<K, V> {
    */
   @VisibleForTesting @MonotonicNonNullDecl transient long[] links;
 
   /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;
 
   /**
    * Pointer to the last node in the linked list, or {@code ENDPOINT} if there are no entries.
    */
   private transient int lastEntry;
 
   private final boolean accessOrder;
 
   CompactLinkedHashMap() {
     this(DEFAULT_SIZE);
   }
 
   CompactLinkedHashMap(int expectedSize) {
     this(expectedSize, DEFAULT_LOAD_FACTOR, false);
   }
 
   CompactLinkedHashMap(int expectedSize, float loadFactor, boolean accessOrder) {
     super(expectedSize, loadFactor);
     this.accessOrder = accessOrder;
   }
 
   @Override
   void init(int expectedSize, float loadFactor) {
     super.init(expectedSize, loadFactor);
     firstEntry = ENDPOINT;
     lastEntry = ENDPOINT;
     links = new long[expectedSize];
     Arrays.fill(links, UNSET);
   }
 
   private int getPredecessor(int entry) {
     return (int) (links[entry] >>> 32);
   }
 
   @Override
   int getSuccessor(int entry) {
     return (int) links[entry];
   }
 
   private void setSuccessor(int entry, int succ) {
     long succMask = (~0L) >>> 32;
     links[entry] = (links[entry] & ~succMask) | (succ & succMask);
   }
 
   private void setPredecessor(int entry, int pred) {
-    long predMask = (~0L) << 32;
+    long predMask = ~0L << 32;
     links[entry] = (links[entry] & ~predMask) | ((long) pred << 32);
   }
 
   private void setSucceeds(int pred, int succ) {
     if (pred == ENDPOINT) {
       firstEntry = succ;
     } else {
       setSuccessor(pred, succ);
     }
     if (succ == ENDPOINT) {
       lastEntry = pred;
     } else {
       setPredecessor(succ, pred);
     }
   }
 
   @Override
   void insertEntry(int entryIndex, K key, V value, int hash) {
     super.insertEntry(entryIndex, key, value, hash);
     setSucceeds(lastEntry, entryIndex);
     setSucceeds(entryIndex, ENDPOINT);
   }
 
   @Override
   void accessEntry(int index) {
     if (accessOrder) {
       // delete from previous position...
       setSucceeds(getPredecessor(index), getSuccessor(index));
       // ...and insert at the end.
       setSucceeds(lastEntry, index);
       setSucceeds(index, ENDPOINT);
       modCount++;
     }
   }
 
   @Override
   void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
     setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
     if (dstIndex < srcIndex) {
       setSucceeds(getPredecessor(srcIndex), dstIndex);
       setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
     super.moveLastEntry(dstIndex);
   }
 
   @Override
   void resizeEntries(int newCapacity) {
     super.resizeEntries(newCapacity);
     links = Arrays.copyOf(links, newCapacity);
