diff --git a/android/guava/src/com/google/common/collect/FluentIterable.java b/android/guava/src/com/google/common/collect/FluentIterable.java
index 36e6c6588..2a510ef0c 100644
--- a/android/guava/src/com/google/common/collect/FluentIterable.java
+++ b/android/guava/src/com/google/common/collect/FluentIterable.java
@@ -1,77 +1,76 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.SortedSet;
 import javax.annotation.Nullable;
 
 /**
  * An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=
  * "https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description"
  * >streams library</a> in a slightly different way.
  *
  * <p>The following types of methods are provided:
  *
  * <ul>
  * <li>chaining methods which return a new {@code FluentIterable} based in some way on the contents
  *     of the current one (for example {@link #transform})
  * <li>element extraction methods which facilitate the retrieval of certain elements (for example
  *     {@link #last})
  * <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example
  *     {@link #anyMatch})
  * <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or
  *     array (for example {@link #toList})
  * </ul>
  *
  * <p>Several lesser-used features are currently available only as static methods on the {@link
  * Iterables} class.
  *
  * <a name="streams"></a>
  * <h3>Comparison to streams</h3>
  *
  * <p>Starting with Java 8, the core Java class libraries provide a new "Streams" library (in {@code
  * java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key
  * differences include:
  *
  * <ul>
  * <li>A stream is <i>single-use</i>; it becomes invalid as soon as any "terminal operation" such as
  *     {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream} contains
  *     all the right method <i>signatures</i> to implement {@link Iterable}, it does not actually do
  *     so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other hand, is
  *     multiple-use, and does implement {@link Iterable}.
  * <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},
  *     {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for
  *     parallelizing stream operations.
  * <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are
  *     noted in the method descriptions below.
  * <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which is
  *     strongly recommended.
  * <li>Streams are standard Java, not requiring a third-party dependency (but do render your code
@@ -144,192 +143,208 @@ public abstract class FluentIterable<E> implements Iterable<E> {
         : new FluentIterable<E>(iterable) {
           @Override
           public Iterator<E> iterator() {
             return iterable.iterator();
           }
         };
   }
 
   /**
    * Returns a fluent iterable containing {@code elements} in the specified order.
    *
    * <p>The returned iterable is an unmodifiable view of the input array.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[])
    * Stream.of(T...)}.
    *
    * @since 20.0 (since 18.0 as an overload of {@code of})
    */
   @Beta
   public static <E> FluentIterable<E> from(E[] elements) {
     return from(Arrays.asList(elements));
   }
 
   /**
    * Construct a fluent iterable from another fluent iterable. This is obviously never necessary,
    * but is intended to help call out cases where one migration from {@code Iterable} to
    * {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.
    *
    * @deprecated instances of {@code FluentIterable} don't need to be converted to
    *     {@code FluentIterable}
    */
   @Deprecated
   public static <E> FluentIterable<E> from(FluentIterable<E> iterable) {
     return checkNotNull(iterable);
   }
 
   /**
    * Returns a fluent iterable that combines two iterables. The returned iterable has an iterator
    * that traverses the elements in {@code a}, followed by the elements in {@code b}. The source
    * iterators are not polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#concat}.
    *
    * @since 20.0
    */
   @Beta
   public static <T> FluentIterable<T> concat(Iterable<? extends T> a, Iterable<? extends T> b) {
-    return concat(Arrays.asList(checkNotNull(a), checkNotNull(b)));
+    return concatNoDefensiveCopy(a, b);
   }
 
   /**
    * Returns a fluent iterable that combines three iterables. The returned iterable has an iterator
    * that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
    * the elements in {@code c}. The source iterators are not polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the
    * advice in {@link #concat(Iterable...)}.
    *
    * @since 20.0
    */
   @Beta
   public static <T> FluentIterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {
-    return concat(Arrays.asList(checkNotNull(a), checkNotNull(b), checkNotNull(c)));
+    return concatNoDefensiveCopy(a, b, c);
   }
 
   /**
    * Returns a fluent iterable that combines four iterables. The returned iterable has an iterator
    * that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
    * the elements in {@code c}, followed by the elements in {@code d}. The source iterators are not
    * polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the
    * advice in {@link #concat(Iterable...)}.
    *
    * @since 20.0
    */
   @Beta
   public static <T> FluentIterable<T> concat(
       Iterable<? extends T> a,
       Iterable<? extends T> b,
       Iterable<? extends T> c,
       Iterable<? extends T> d) {
-    return concat(
-        Arrays.asList(checkNotNull(a), checkNotNull(b), checkNotNull(c), checkNotNull(d)));
+    return concatNoDefensiveCopy(a, b, c, d);
   }
 
   /**
    * Returns a fluent iterable that combines several iterables. The returned iterable has an
    * iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
    * are not polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>{@code Stream} equivalent:</b> to concatenate an arbitrary number of streams, use {@code
    * Stream.of(stream1, stream2, ...).flatMap(s -> s)}. If the sources are iterables, use {@code
    * Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}.
    *
    * @throws NullPointerException if any of the provided iterables is {@code null}
    * @since 20.0
    */
   @Beta
   public static <T> FluentIterable<T> concat(Iterable<? extends T>... inputs) {
-    List<Iterable<? extends T>> list = new ArrayList<>(inputs.length);
+    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
+  }
+
+  /** Concatenates a varargs array of iterables without making a defensive copy of the array. */
+  private static <T> FluentIterable<T> concatNoDefensiveCopy(
+      final Iterable<? extends T>... inputs) {
     for (Iterable<? extends T> input : inputs) {
-      list.add(checkNotNull(input));
+      checkNotNull(input);
     }
-    return concat(list);
+    return new FluentIterable<T>() {
+      @Override
+      public Iterator<T> iterator() {
+        return Iterators.concat(
+            /* lazily generate the iterators on each input only as needed */
+            new AbstractIndexedListIterator<Iterator<? extends T>>(inputs.length) {
+              @Override
+              public Iterator<? extends T> get(int i) {
+                return inputs[i].iterator();
+              }
+            });
+      }
+    };
   }
 
   /**
    * Returns a fluent iterable that combines several iterables. The returned iterable has an
    * iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
    * are not polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it. The methods of the returned iterable may throw {@code
    * NullPointerException} if any of the input iterators is {@code null}.
    *
    * <p><b>{@code Stream} equivalent:</b> {@code streamOfStreams.flatMap(s -> s)} or {@code
    * streamOfIterables.flatMap(Streams::stream)}. (See {@link Streams#stream}.)
    *
    * @since 20.0
    */
   @Beta
   public static <T> FluentIterable<T> concat(
       final Iterable<? extends Iterable<? extends T>> inputs) {
     checkNotNull(inputs);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
-        return Iterators.concat(Iterables.transform(inputs, Iterables.<T>toIterator()).iterator());
+        return Iterators.concat(Iterators.transform(inputs.iterator(), Iterables.<T>toIterator()));
       }
     };
   }
 
   /**
    * Returns a fluent iterable containing no elements.
    *
    * <p><b>{@code Stream} equivalent:</b> {@code Stream.empty()}.
    *
    * @since 20.0
    */
   @Beta
   public static <E> FluentIterable<E> of() {
     return FluentIterable.from(ImmutableList.<E>of());
   }
 
   /**
    * Returns a fluent iterable containing {@code elements} in the specified order.
    *
    * <p>The returned iterable is modifiable, but modifications do not affect the input array.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[])
    * Stream.of(T...)}.
    *
    * @deprecated Use {@link #from(Object[])} instead (but note the differences in mutability). This
    *     method will be removed in Guava release 21.0.
    * @since 18.0
    */
   @Beta
   @Deprecated
   public static <E> FluentIterable<E> of(E[] elements) {
     return from(Lists.newArrayList(elements));
   }
 
   /**
    * Returns a fluent iterable containing the specified elements in order.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[])
    * Stream.of(T...)}.
    *
    * @since 20.0
    */
   @Beta
   public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {
     return from(Lists.asList(element, elements));
   }
 
   /**
    * Returns a string representation of this fluent iterable, with the format {@code [e1, e2, ...,
    * en]}.
