diff --git a/android/guava/src/com/google/common/collect/Iterators.java b/android/guava/src/com/google/common/collect/Iterators.java
index ae58e9c3f..4da4e26e5 100644
--- a/android/guava/src/com/google/common/collect/Iterators.java
+++ b/android/guava/src/com/google/common/collect/Iterators.java
@@ -1,75 +1,72 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Predicates.equalTo;
-import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.instanceOf;
-import static com.google.common.base.Predicates.not;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import javax.annotation.Nullable;
 
 /**
  * This class contains static utility methods that operate on or return objects
  * of type {@link Iterator}. Except as noted, each method has a corresponding
  * {@link Iterable}-based method in the {@link Iterables} class.
  *
  * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators
  * produced in this class are <i>lazy</i>, which means that they only advance
  * the backing iteration when absolutely necessary.
  *
  * <p>See the Guava User Guide section on <a href=
  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables">
  * {@code Iterators}</a>.
  *
  * @author Kevin Bourrillion
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(emulated = true)
 public final class Iterators {
   private Iterators() {}
 
   /**
    * Returns the empty iterator.
    *
    * <p>The {@link Iterable} equivalent of this method is {@link
@@ -337,101 +334,107 @@ public final class Iterators {
    *     elements.  The state of the iterator is unspecified.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this?
   @Nullable
   public static <T> T getOnlyElement(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
   }
 
   /**
    * Copies an iterator's elements into an array. The iterator will be left
    * exhausted: its {@code hasNext()} method will return {@code false}.
    *
    * @param iterator the iterator to copy
    * @param type the type of the elements
    * @return a newly-allocated array into which all the elements of the iterator
    *         have been copied
    */
   @GwtIncompatible // Array.newInstance(Class, int)
   public static <T> T[] toArray(Iterator<? extends T> iterator, Class<T> type) {
     List<T> list = Lists.newArrayList(iterator);
     return Iterables.toArray(list, type);
   }
 
   /**
    * Adds all elements in {@code iterator} to {@code collection}. The iterator
    * will be left exhausted: its {@code hasNext()} method will return
    * {@code false}.
    *
    * @return {@code true} if {@code collection} was modified as a result of this
    *         operation
    */
   @CanIgnoreReturnValue
   public static <T> boolean addAll(Collection<T> addTo, Iterator<? extends T> iterator) {
     checkNotNull(addTo);
     checkNotNull(iterator);
     boolean wasModified = false;
     while (iterator.hasNext()) {
       wasModified |= addTo.add(iterator.next());
     }
     return wasModified;
   }
 
   /**
    * Returns the number of elements in the specified iterator that equal the
    * specified object. The iterator will be left exhausted: its
    * {@code hasNext()} method will return {@code false}.
    *
    * @see Collections#frequency
    */
   public static int frequency(Iterator<?> iterator, @Nullable Object element) {
-    return size(filter(iterator, equalTo(element)));
+    int count = 0;
+    while (contains(iterator, element)) {
+      // Since it lives in the same class, we know contains gets to the element and then stops,
+      // though that isn't currently publicly documented.
+      count++;
+    }
+    return count;
   }
 
   /**
    * Returns an iterator that cycles indefinitely over the elements of {@code
    * iterable}.
    *
    * <p>The returned iterator supports {@code remove()} if the provided iterator
    * does. After {@code remove()} is called, subsequent cycles omit the removed
    * element, which is no longer in {@code iterable}. The iterator's
    * {@code hasNext()} method returns {@code true} until {@code iterable} is
    * empty.
    *
    * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
    * infinite loop. You should use an explicit {@code break} or be certain that
    * you will eventually remove all the elements.
    */
   public static <T> Iterator<T> cycle(final Iterable<T> iterable) {
     checkNotNull(iterable);
     return new Iterator<T>() {
       Iterator<T> iterator = emptyModifiableIterator();
 
       @Override
       public boolean hasNext() {
         /*
          * Don't store a new Iterator until we know the user can't remove() the last returned
          * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating
          * the new one. The result is a ConcurrentModificationException or other bad behavior.
          *
          * (If we decide that we really, really hate allocating two Iterators per cycle instead of
          * one, we can optimistically store the new Iterator and then be willing to throw it out if
          * the user calls remove().)
          */
         return iterator.hasNext() || iterable.iterator().hasNext();
       }
 
       @Override
       public T next() {
         if (!iterator.hasNext()) {
           iterator = iterable.iterator();
           if (!iterator.hasNext()) {
             throw new NoSuchElementException();
           }
         }
         return iterator.next();
       }
 
       @Override
       public void remove() {
         iterator.remove();
       }
@@ -629,135 +632,158 @@ public final class Iterators {
       }
     };
   }
 
   /**
    * Returns a view of {@code unfiltered} containing all elements that are of
    * the type {@code desiredType}.
    */
   @SuppressWarnings("unchecked") // can cast to <T> because non-Ts are removed
   @GwtIncompatible // Class.isInstance
   public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType) {
     return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));
   }
 
   /**
    * Returns {@code true} if one or more elements returned by {@code iterator}
    * satisfy the given predicate.
    */
   public static <T> boolean any(Iterator<T> iterator, Predicate<? super T> predicate) {
     return indexOf(iterator, predicate) != -1;
   }
 
   /**
    * Returns {@code true} if every element returned by {@code iterator}
    * satisfies the given predicate. If {@code iterator} is empty, {@code true}
    * is returned.
    */
   public static <T> boolean all(Iterator<T> iterator, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     while (iterator.hasNext()) {
       T element = iterator.next();
       if (!predicate.apply(element)) {
         return false;
       }
     }
     return true;
   }
 
   /**
    * Returns the first element in {@code iterator} that satisfies the given
    * predicate; use this method only when such an element is known to exist. If
    * no such element is found, the iterator will be left exhausted: its {@code
    * hasNext()} method will return {@code false}. If it is possible that
    * <i>no</i> element will match, use {@link #tryFind} or {@link
    * #find(Iterator, Predicate, Object)} instead.
    *
    * @throws NoSuchElementException if no element in {@code iterator} matches
    *     the given predicate
    */
   public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate) {
-    return filter(iterator, predicate).next();
+    checkNotNull(iterator);
+    checkNotNull(predicate);
+    while (iterator.hasNext()) {
+      T t = iterator.next();
+      if (predicate.apply(t)) {
+        return t;
+      }
+    }
+    throw new NoSuchElementException();
   }
 
   /**
    * Returns the first element in {@code iterator} that satisfies the given
    * predicate. If no such element is found, {@code defaultValue} will be
    * returned from this method and the iterator will be left exhausted: its
    * {@code hasNext()} method will return {@code false}. Note that this can
    * usually be handled more naturally using {@code
    * tryFind(iterator, predicate).or(defaultValue)}.
    *
    * @since 7.0
    */
   @Nullable
   public static <T> T find(
       Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue) {
-    return getNext(filter(iterator, predicate), defaultValue);
+    checkNotNull(iterator);
+    checkNotNull(predicate);
+    while (iterator.hasNext()) {
+      T t = iterator.next();
+      if (predicate.apply(t)) {
+        return t;
+      }
+    }
+    return defaultValue;
   }
 
   /**
    * Returns an {@link Optional} containing the first element in {@code
    * iterator} that satisfies the given predicate, if such an element exists. If
    * no such element is found, an empty {@link Optional} will be returned from
    * this method and the iterator will be left exhausted: its {@code
    * hasNext()} method will return {@code false}.
    *
    * <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code
    * null}. If {@code null} is matched in {@code iterator}, a
    * NullPointerException will be thrown.
    *
    * @since 11.0
    */
   public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate) {
-    UnmodifiableIterator<T> filteredIterator = filter(iterator, predicate);
-    return filteredIterator.hasNext() ? Optional.of(filteredIterator.next()) : Optional.<T>absent();
+    checkNotNull(iterator);
+    checkNotNull(predicate);
+    while (iterator.hasNext()) {
+      T t = iterator.next();
+      if (predicate.apply(t)) {
+        return Optional.of(t);
+      }
+    }
+    return Optional.absent();
   }
 
   /**
    * Returns the index in {@code iterator} of the first element that satisfies
    * the provided {@code predicate}, or {@code -1} if the Iterator has no such
    * elements.
    *
    * <p>More formally, returns the lowest index {@code i} such that
    * {@code predicate.apply(Iterators.get(iterator, i))} returns {@code true},
    * or {@code -1} if there is no such index.
    *
    * <p>If -1 is returned, the iterator will be left exhausted: its
    * {@code hasNext()} method will return {@code false}.  Otherwise,
    * the iterator will be set to the element which satisfies the
    * {@code predicate}.
    *
    * @since 2.0
    */
   public static <T> int indexOf(Iterator<T> iterator, Predicate<? super T> predicate) {
     checkNotNull(predicate, "predicate");
     for (int i = 0; iterator.hasNext(); i++) {
       T current = iterator.next();
       if (predicate.apply(current)) {
         return i;
       }
     }
     return -1;
   }
 
   /**
    * Returns a view containing the result of applying {@code function} to each
    * element of {@code fromIterator}.
    *
    * <p>The returned iterator supports {@code remove()} if {@code fromIterator}
    * does. After a successful {@code remove()} call, {@code fromIterator} no
    * longer contains the corresponding element.
    */
   public static <F, T> Iterator<T> transform(
       final Iterator<F> fromIterator, final Function<? super F, ? extends T> function) {
     checkNotNull(function);
     return new TransformedIterator<F, T>(fromIterator) {
       @Override
       T transform(F from) {
         return function.apply(from);
       }
     };
   }
 
   /**
    * Advances {@code iterator} {@code position + 1} times, returning the
