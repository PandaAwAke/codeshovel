diff --git a/android/guava/src/com/google/common/base/Preconditions.java b/android/guava/src/com/google/common/base/Preconditions.java
index fe5ba7566..c46aa359c 100644
--- a/android/guava/src/com/google/common/base/Preconditions.java
+++ b/android/guava/src/com/google/common/base/Preconditions.java
@@ -101,102 +101,100 @@ import javax.annotation.Nullable;
  *
  * <p>See the Guava User Guide on <a
  * href="https://github.com/google/guava/wiki/PreconditionsExplained">using {@code
  * Preconditions}</a>.
  *
  * @author Kevin Bourrillion
  * @since 2.0
  */
 @GwtCompatible
 public final class Preconditions {
   private Preconditions() {}
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * @param expression a boolean expression
    * @throws IllegalArgumentException if {@code expression} is false
    */
   public static void checkArgument(boolean expression) {
     if (!expression) {
       throw new IllegalArgumentException();
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * @param expression a boolean expression
    * @param errorMessage the exception message to use if the check fails; will be converted to a
    *     string using {@link String#valueOf(Object)}
    * @throws IllegalArgumentException if {@code expression} is false
    */
   public static void checkArgument(boolean expression, @Nullable Object errorMessage) {
     if (!expression) {
       throw new IllegalArgumentException(String.valueOf(errorMessage));
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * @param expression a boolean expression
    * @param errorMessageTemplate a template for the exception message should the check fail. The
    *     message is formed by replacing each {@code %s} placeholder in the template with an
    *     argument. These are matched by position - the first {@code %s} gets {@code
    *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
    *     square braces. Unmatched placeholders will be left as-is.
    * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
    *     are converted to strings using {@link String#valueOf(Object)}.
    * @throws IllegalArgumentException if {@code expression} is false
-   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or
-   *     {@code errorMessageArgs} is null (don't let this happen)
    */
   public static void checkArgument(
       boolean expression,
       @Nullable String errorMessageTemplate,
       @Nullable Object... errorMessageArgs) {
     if (!expression) {
       throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving one or more parameters to the calling method.
    *
    * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
    */
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1) {
@@ -426,102 +424,100 @@ public final class Preconditions {
       @Nullable Object p3,
       @Nullable Object p4) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * @param expression a boolean expression
    * @throws IllegalStateException if {@code expression} is false
    * @see Verify#verify Verify.verify()
    */
   public static void checkState(boolean expression) {
     if (!expression) {
       throw new IllegalStateException();
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * @param expression a boolean expression
    * @param errorMessage the exception message to use if the check fails; will be converted to a
    *     string using {@link String#valueOf(Object)}
    * @throws IllegalStateException if {@code expression} is false
    * @see Verify#verify Verify.verify()
    */
   public static void checkState(boolean expression, @Nullable Object errorMessage) {
     if (!expression) {
       throw new IllegalStateException(String.valueOf(errorMessage));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * @param expression a boolean expression
    * @param errorMessageTemplate a template for the exception message should the check fail. The
    *     message is formed by replacing each {@code %s} placeholder in the template with an
    *     argument. These are matched by position - the first {@code %s} gets {@code
    *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
    *     square braces. Unmatched placeholders will be left as-is.
    * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
    *     are converted to strings using {@link String#valueOf(Object)}.
    * @throws IllegalStateException if {@code expression} is false
-   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or
-   *     {@code errorMessageArgs} is null (don't let this happen)
    * @see Verify#verify Verify.verify()
    */
   public static void checkState(
       boolean expression,
       @Nullable String errorMessageTemplate,
       @Nullable Object... errorMessageArgs) {
     if (!expression) {
       throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * <p>See {@link #checkState(boolean, String, Object...)} for details.
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * <p>See {@link #checkState(boolean, String, Object...)} for details.
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
    *
    * <p>See {@link #checkState(boolean, String, Object...)} for details.
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
   }
 
   /**
    * Ensures the truth of an expression involving the state of the calling instance, but not
    * involving any parameters to the calling method.
@@ -779,101 +775,100 @@ public final class Preconditions {
    * @param reference an object reference
    * @return the non-null reference that was validated
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T reference) {
     if (reference == null) {
       throw new NullPointerException();
     }
     return reference;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * @param reference an object reference
    * @param errorMessage the exception message to use if the check fails; will be converted to a
    *     string using {@link String#valueOf(Object)}
    * @return the non-null reference that was validated
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T reference, @Nullable Object errorMessage) {
     if (reference == null) {
       throw new NullPointerException(String.valueOf(errorMessage));
     }
     return reference;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * @param reference an object reference
    * @param errorMessageTemplate a template for the exception message should the check fail. The
    *     message is formed by replacing each {@code %s} placeholder in the template with an
    *     argument. These are matched by position - the first {@code %s} gets {@code
    *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
    *     square braces. Unmatched placeholders will be left as-is.
    * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
    *     are converted to strings using {@link String#valueOf(Object)}.
    * @return the non-null reference that was validated
    * @throws NullPointerException if {@code reference} is null
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       T reference, @Nullable String errorMessageTemplate, @Nullable Object... errorMessageArgs) {
     if (reference == null) {
-      // If either of these parameters is null, the right thing happens anyway
       throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
     }
     return reference;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
     return obj;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
     return obj;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
     return obj;
   }
 
   /**
    * Ensures that an object reference passed as a parameter to the calling method is not null.
    *
    * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
    */
   @CanIgnoreReturnValue
@@ -1242,87 +1237,90 @@ public final class Preconditions {
     }
     return index;
   }
 
   private static String badPositionIndex(int index, int size, String desc) {
     if (index < 0) {
       return format("%s (%s) must not be negative", desc, index);
     } else if (size < 0) {
       throw new IllegalArgumentException("negative size: " + size);
     } else { // index > size
       return format("%s (%s) must not be greater than size (%s)", desc, index, size);
     }
   }
 
   /**
    * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
    * or string of size {@code size}, and are in order. A position index may range from zero to
    * {@code size}, inclusive.
    *
    * @param start a user-supplied index identifying a starting position in an array, list or string
    * @param end a user-supplied index identifying a ending position in an array, list or string
    * @param size the size of that array, list or string
    * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
    *     or if {@code end} is less than {@code start}
    * @throws IllegalArgumentException if {@code size} is negative
    */
   public static void checkPositionIndexes(int start, int end, int size) {
     // Carefully optimized for execution by hotspot (explanatory comment above)
     if (start < 0 || end < start || end > size) {
       throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
     }
   }
 
   private static String badPositionIndexes(int start, int end, int size) {
     if (start < 0 || start > size) {
       return badPositionIndex(start, size, "start index");
     }
     if (end < 0 || end > size) {
       return badPositionIndex(end, size, "end index");
     }
     // end < start
     return format("end index (%s) must not be less than start index (%s)", end, start);
   }
 
   /**
    * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
    * position: the first {@code %s} gets {@code args[0]}, etc. If there are more arguments than
    * placeholders, the unmatched arguments will be appended to the end of the formatted message in
    * square braces.
    *
-   * @param template a non-null string containing 0 or more {@code %s} placeholders.
+   * @param template a string containing 0 or more {@code %s} placeholders. null is treated as
+   *     "null".
    * @param args the arguments to be substituted into the message template. Arguments are converted
    *     to strings using {@link String#valueOf(Object)}. Arguments can be null.
    */
   // Note that this is somewhat-improperly used from Verify.java as well.
-  static String format(String template, @Nullable Object... args) {
+  static String format(@Nullable String template, @Nullable Object... args) {
     template = String.valueOf(template); // null -> "null"
 
+    args = args == null ? new Object[]{"(Object[])null"} : args;
+
     // start substituting the arguments into the '%s' placeholders
     StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
     int templateStart = 0;
     int i = 0;
     while (i < args.length) {
       int placeholderStart = template.indexOf("%s", templateStart);
       if (placeholderStart == -1) {
         break;
       }
       builder.append(template, templateStart, placeholderStart);
       builder.append(args[i++]);
       templateStart = placeholderStart + 2;
     }
     builder.append(template, templateStart, template.length());
 
     // if we run out of placeholders, append the extra args in square braces
     if (i < args.length) {
       builder.append(" [");
       builder.append(args[i++]);
       while (i < args.length) {
         builder.append(", ");
         builder.append(args[i++]);
       }
       builder.append(']');
     }
 
     return builder.toString();
   }
 }
