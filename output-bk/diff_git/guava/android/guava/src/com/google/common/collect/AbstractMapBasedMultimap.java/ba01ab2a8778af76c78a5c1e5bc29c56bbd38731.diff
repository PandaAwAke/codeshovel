diff --git a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
index bb91e40c6..efb2b95b2 100644
--- a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
+++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
@@ -1,73 +1,75 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.collect.AbstractMultimap.Entries;
+import com.google.common.collect.AbstractMultimap.EntrySet;
 import com.google.common.collect.Maps.ViewCachingAbstractMap;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NavigableMap;
 import java.util.NavigableSet;
 import java.util.RandomAccess;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.SortedSet;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map
  * that associates each key with a collection of values. All methods of {@link Multimap} are
  * supported, including those specified as optional in the interface.
  *
  * <p>To implement a multimap, a subclass must define the method {@link #createCollection()}, which
  * creates an empty collection of values for a key.
  *
  * <p>The multimap constructor takes a map that has a single entry for each distinct key. When you
  * insert a key-value pair with a key that isn't already in the multimap, {@code
  * AbstractMapBasedMultimap} calls {@link #createCollection()} to create the collection of values
  * for that key. The subclass should not call {@link #createCollection()} directly, and a new
  * instance should be created every time the method is called.
  *
  * <p>For example, the subclass could pass a {@link java.util.TreeMap} during construction, and
  * {@link #createCollection()} could return a {@link java.util.TreeSet}, in which case the
  * multimap's iterators would propagate through the keys and values in sorted order.
  *
  * <p>Keys and values may be null, as long as the underlying collection classes support null
  * elements.
  *
  * <p>The collections created by {@link #createCollection()} may or may not allow duplicates. If the
  * collection, such as a {@link Set}, does not support duplicates, an added key-value pair will
  * replace an existing pair with the same key and value, if such a pair is present. With collections
  * like {@link List} that allow duplicates, the collection will keep the existing key-value pairs
  * while adding a new pair.
  *
  * <p>This class is not threadsafe when any concurrent operations update the multimap, even if the
  * underlying map and {@link #createCollection()} method return threadsafe classes. Concurrent read
@@ -1128,129 +1130,148 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
     K key;
     Collection<V> collection;
     Iterator<V> valueIterator;
 
     Itr() {
       keyIterator = map.entrySet().iterator();
       key = null;
       collection = null;
       valueIterator = Iterators.emptyModifiableIterator();
     }
 
     abstract T output(K key, V value);
 
     @Override
     public boolean hasNext() {
       return keyIterator.hasNext() || valueIterator.hasNext();
     }
 
     @Override
     public T next() {
       if (!valueIterator.hasNext()) {
         Entry<K, Collection<V>> mapEntry = keyIterator.next();
         key = mapEntry.getKey();
         collection = mapEntry.getValue();
         valueIterator = collection.iterator();
       }
       return output(key, valueIterator.next());
     }
 
     @Override
     public void remove() {
       valueIterator.remove();
       if (collection.isEmpty()) {
         keyIterator.remove();
       }
       totalSize--;
     }
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values for one key, followed
    * by the values of a second key, and so on.
    */
   @Override
   public Collection<V> values() {
     return super.values();
   }
 
+  @Override
+  Collection<V> createValues() {
+    return new Values();
+  }
+
   @Override
   Iterator<V> valueIterator() {
     return new Itr<V>() {
       @Override
       V output(K key, V value) {
         return value;
       }
     };
   }
 
   /*
    * TODO(kevinb): should we copy this javadoc to each concrete class, so that
    * classes like LinkedHashMultimap that need to say something different are
    * still able to {@inheritDoc} all the way from Multimap?
    */
 
+  @Override
+  Multiset<K> createKeys() {
+    return new Multimaps.Keys<K, V>(this);
+  }
+
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values for one key, followed
    * by the values of a second key, and so on.
    *
    * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
    * time the entry is returned by a method call to the collection or its iterator.
    */
   @Override
   public Collection<Entry<K, V>> entries() {
     return super.entries();
   }
+  
+  @Override
+  Collection<Entry<K, V>> createEntries() {
+    if (this instanceof SetMultimap) {
+      return new EntrySet();
+    } else {
+      return new Entries();
+    }
+  }
 
   /**
    * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and
    * {@code values().iterator()}. The default behavior, which traverses the values for one key, the
    * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}
    * implementations.
    *
    * @return an iterator across map entries
    */
   @Override
   Iterator<Entry<K, V>> entryIterator() {
     return new Itr<Entry<K, V>>() {
       @Override
       Entry<K, V> output(K key, V value) {
         return Maps.immutableEntry(key, value);
       }
     };
   }
 
   @Override
   Map<K, Collection<V>> createAsMap() {
     if (map instanceof NavigableMap) {
       return new NavigableAsMap((NavigableMap<K, Collection<V>>) map);
     } else if (map instanceof SortedMap) {
       return new SortedAsMap((SortedMap<K, Collection<V>>) map);
     } else {
       return new AsMap(map);
     }
   }
 
   @WeakOuter
   private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     /**
      * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a
      * SortedAsMap.
      */
     final transient Map<K, Collection<V>> submap;
 
     AsMap(Map<K, Collection<V>> submap) {
       this.submap = submap;
     }
 
     @Override
     protected Set<Entry<K, Collection<V>>> createEntrySet() {
       return new AsMapEntries();
     }
 
     // The following methods are included for performance.
 
     @Override
