diff --git a/android/guava/src/com/google/common/collect/ImmutableMap.java b/android/guava/src/com/google/common/collect/ImmutableMap.java
index e59eaecf9..7dbc085b0 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMap.java
@@ -86,127 +86,127 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys are provided
    */
   public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     return RegularImmutableMap.create(3, new Object[] {k1, v1, k2, v2, k3, v3});
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys are provided
    */
   public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     checkEntryNotNull(k4, v4);
     return RegularImmutableMap.create(4, new Object[] {k1, v1, k2, v2, k3, v3, k4, v4});
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys are provided
    */
   public static <K, V> ImmutableMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     checkEntryNotNull(k4, v4);
     checkEntryNotNull(k5, v5);
     return RegularImmutableMap.create(5, new Object[] {k1, v1, k2, v2, k3, v3, k4, v4, k5, v5});
   }
 
   // looking for of() with > 5 entries? Use the builder instead.
 
   /**
    * Verifies that {@code key} and {@code value} are non-null, and returns a new
    * immutable entry with those values.
    * <p>A call to {@link Map.Entry#setValue} on the returned entry will always
    * throw {@link UnsupportedOperationException}.
    */
   static <K, V> Entry<K, V> entryOf(K key, V value) {
     checkEntryNotNull(key, value);
-    return new AbstractMap.SimpleImmutableEntry<K, V>(key, value);
+    return new AbstractMap.SimpleImmutableEntry<>(key, value);
   }
 
   /**
    * Returns a new builder. The generated builder is equivalent to the builder created by the {@link
    * Builder} constructor.
    */
   public static <K, V> Builder<K, V> builder() {
-    return new Builder<K, V>();
+    return new Builder<>();
   }
 
   /**
    * Returns a new builder, expecting the specified number of entries to be added.
    *
    * <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link
    * Builder#build} is called, the builder is likely to perform better than an unsized {@link
    * #builder()} would have.
    *
    * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
    * but not exactly, the number of entries added to the builder.
    * 
    * @since 24.0
    */
   @Beta
   public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
-    return new Builder<K, V>(expectedSize);
+    return new Builder<>(expectedSize);
   }
 
   static void checkNoConflict(
       boolean safe, String conflictDescription, Entry<?, ?> entry1, Entry<?, ?> entry2) {
     if (!safe) {
       throw new IllegalArgumentException(
           "Multiple entries with same " + conflictDescription + ": " + entry1 + " and " + entry2);
     }
   }
 
   /**
    * A builder for creating immutable map instances, especially {@code public
    * static final} maps ("constant maps"). Example: <pre>   {@code
    *
    * static final ImmutableMap<String, Integer> WORD_TO_INT =
    *     new ImmutableMap.Builder<String, Integer>()
    *         .put("one", 1)
    *         .put("two", 2)
    *         .put("three", 3)
    *         .build();
    * }</pre>
    *
    * <p>For <i>small</i> immutable maps, the {@code ImmutableMap.of()} methods are even more
    * convenient.
    *
    * <p>By default, a {@code Builder} will generate maps that iterate over entries in the order
    * they were inserted into the builder, equivalently to {@code LinkedHashMap}.  For example, in
    * the above example, {@code WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in
    * the order {@code "one"=1, "two"=2, "three"=3}, and {@code keySet()} and {@code values()}
    * respect the same order.   If you want a different order, consider using 
    * {@link ImmutableSortedMap} to sort by keys, or call {@link #orderEntriesByValue(Comparator)}, 
    * which changes this builder to sort entries by value.
    *
    * <p>Builder instances can be reused - it is safe to call {@link #build}
    * multiple times to build multiple maps in series. Each map is a superset of
    * the maps created before it.
    *
    * @since 2.0
    */
   public static class Builder<K, V> {
     Comparator<? super V> valueComparator;
     Object[] alternatingKeysAndValues;
     int size;
     boolean entriesUsed;
 
     /**
      * Creates a new builder. The returned builder is equivalent to the builder generated by {@link
      * ImmutableMap#builder}.
      */
     public Builder() {
