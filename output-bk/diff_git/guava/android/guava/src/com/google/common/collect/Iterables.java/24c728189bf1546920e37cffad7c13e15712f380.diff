diff --git a/android/guava/src/com/google/common/collect/Iterables.java b/android/guava/src/com/google/common/collect/Iterables.java
index 45f44066b..b36c999c0 100644
--- a/android/guava/src/com/google/common/collect/Iterables.java
+++ b/android/guava/src/com/google/common/collect/Iterables.java
@@ -1,78 +1,79 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.RandomAccess;
 import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
  * An assortment of mainly legacy static utility methods that operate on or return objects of type
  * {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method
  * in the {@link Iterators} class.
  *
  * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed
  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for
  * comparisons. This class is not being deprecated, but we gently encourage you to migrate to
  * streams.
  *
  * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class
  * are <i>lazy</i>, which means that their iterators only advance the backing iteration when
  * absolutely necessary.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables"> {@code
  * Iterables}</a>.
  *
  * @author Kevin Bourrillion
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(emulated = true)
 public final class Iterables {
   private Iterables() {}
 
   /** Returns an unmodifiable view of {@code iterable}. */
   public static <T> Iterable<T> unmodifiableIterable(final Iterable<? extends T> iterable) {
     checkNotNull(iterable);
     if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {
       @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
       Iterable<T> result = (Iterable<T>) iterable;
       return result;
     }
     return new UnmodifiableIterable<>(iterable);
   }
 
   /**
    * Simply returns its argument.
@@ -467,101 +468,101 @@ public final class Iterables {
    * Combines three iterables into a single iterable. The returned iterable has an iterator that
    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the
    * elements in {@code c}. The source iterators are not polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Streams.concat(a, b, c)}.
    */
   public static <T> Iterable<T> concat(
       Iterable<? extends T> a, Iterable<? extends T> b, Iterable<? extends T> c) {
     return FluentIterable.concat(a, b, c);
   }
 
   /**
    * Combines four iterables into a single iterable. The returned iterable has an iterator that
    * traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the
    * elements in {@code c}, followed by the elements in {@code d}. The source iterators are not
    * polled until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Streams.concat(a, b, c, d)}.
    */
   public static <T> Iterable<T> concat(
       Iterable<? extends T> a,
       Iterable<? extends T> b,
       Iterable<? extends T> c,
       Iterable<? extends T> d) {
     return FluentIterable.concat(a, b, c, d);
   }
 
   /**
    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that
    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled
    * until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it.
    *
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * Streams.concat(...)}.
    *
    * @throws NullPointerException if any of the provided iterables is null
    */
   @SafeVarargs
   public static <T> Iterable<T> concat(Iterable<? extends T>... inputs) {
-    return concat(ImmutableList.copyOf(inputs));
+    return FluentIterable.concat(inputs);
   }
 
   /**
    * Combines multiple iterables into a single iterable. The returned iterable has an iterator that
    * traverses the elements of each iterable in {@code inputs}. The input iterators are not polled
    * until necessary.
    *
    * <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
    * iterator supports it. The methods of the returned iterable may throw {@code
    * NullPointerException} if any of the input iterators is null.
    *
    * <p><b>Java 8 users:</b> The {@code Stream} equivalent of this method is {@code
    * streamOfStreams.flatMap(s -> s)}.
    */
   public static <T> Iterable<T> concat(Iterable<? extends Iterable<? extends T>> inputs) {
     return FluentIterable.concat(inputs);
   }
 
   /**
    * Divides an iterable into unmodifiable sublists of the given size (the final
    * iterable may be smaller). For example, partitioning an iterable containing
    * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
    * [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of
    * three and two elements, all in the original order.
    *
    * <p>Iterators returned by the returned iterable do not support the {@link
    * Iterator#remove()} method. The returned lists implement {@link
    * RandomAccess}, whether or not the input list does.
    *
    * <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link
    * Lists#partition(List, int)} instead.
    *
    * @param iterable the iterable to return a partitioned view of
    * @param size the desired size of each partition (the last may be smaller)
    * @return an iterable of unmodifiable lists containing the elements of {@code
    *     iterable} divided into partitions
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
   public static <T> Iterable<List<T>> partition(final Iterable<T> iterable, final int size) {
     checkNotNull(iterable);
     checkArgument(size > 0);
     return new FluentIterable<List<T>>() {
       @Override
       public Iterator<List<T>> iterator() {
         return Iterators.partition(iterable.iterator(), size);
       }
     };
   }
 
   /**
@@ -577,110 +578,106 @@ public final class Iterables {
    * @param iterable the iterable to return a partitioned view of
    * @param size the desired size of each partition
    * @return an iterable of unmodifiable lists containing the elements of {@code
    *     iterable} divided into partitions (the final iterable may have
    *     trailing null elements)
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
   public static <T> Iterable<List<T>> paddedPartition(final Iterable<T> iterable, final int size) {
     checkNotNull(iterable);
     checkArgument(size > 0);
     return new FluentIterable<List<T>>() {
       @Override
       public Iterator<List<T>> iterator() {
         return Iterators.paddedPartition(iterable.iterator(), size);
       }
     };
   }
 
   /**
    * Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate
    * {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.
    */
   public static <T> Iterable<T> filter(
       final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue) {
     checkNotNull(unfiltered);
     checkNotNull(retainIfTrue);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
         return Iterators.filter(unfiltered.iterator(), retainIfTrue);
       }
     };
   }
 
   /**
    * Returns a view of {@code unfiltered} containing all elements that are of the type {@code
    * desiredType}. The returned iterable's iterator does not support {@code remove()}.
    *
    * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.
    * This does perform a little more work than necessary, so another option is to insert an
    * unchecked cast at some later point:
    *
    * <pre>
    * {@code @SuppressWarnings("unchecked") // safe because of ::isInstance check
    * ImmutableList<NewType> result =
    *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}
    * </pre>
    */
+  @SuppressWarnings("unchecked")
   @GwtIncompatible // Class.isInstance
   public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType) {
     checkNotNull(unfiltered);
     checkNotNull(desiredType);
-    return new FluentIterable<T>() {
-      @Override
-      public Iterator<T> iterator() {
-        return Iterators.filter(unfiltered.iterator(), desiredType);
-      }
-    };
+    return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));
   }
 
   /**
    * Returns {@code true} if any element in {@code iterable} satisfies the predicate.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.
    */
   public static <T> boolean any(Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.any(iterable.iterator(), predicate);
   }
 
   /**
    * Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code
    * iterable} is empty, {@code true} is returned.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.
    */
   public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.all(iterable.iterator(), predicate);
   }
 
   /**
    * Returns the first element in {@code iterable} that satisfies the given
    * predicate; use this method only when such an element is known to exist. If
    * it is possible that <i>no</i> element will match, use {@link #tryFind} or
    * {@link #find(Iterable, Predicate, Object)} instead.
    *
    * <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}
    *
    * @throws NoSuchElementException if no element in {@code iterable} matches
    *     the given predicate
    */
   public static <T> T find(Iterable<T> iterable, Predicate<? super T> predicate) {
     return Iterators.find(iterable.iterator(), predicate);
   }
 
   /**
    * Returns the first element in {@code iterable} that satisfies the given
    * predicate, or {@code defaultValue} if none found. Note that this can
    * usually be handled more naturally using {@code
    * tryFind(iterable, predicate).or(defaultValue)}.
    *
    * <p><b>{@code Stream} equivalent:</b>
    * {@code stream.filter(predicate).findFirst().orElse(defaultValue)}
    *
    * @since 7.0
    */
   @Nullable
   public static <T> T find(
       Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue) {
@@ -846,214 +843,195 @@ public final class Iterables {
    * <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}
    *
    * @param defaultValue the value to return if {@code iterable} is empty
    * @return the last element of {@code iterable} or the default value
    * @since 3.0
    */
   @Nullable
   public static <T> T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     if (iterable instanceof Collection) {
       Collection<? extends T> c = Collections2.cast(iterable);
       if (c.isEmpty()) {
         return defaultValue;
       } else if (iterable instanceof List) {
         return getLastInNonemptyList(Lists.cast(iterable));
       }
     }
 
     return Iterators.getLast(iterable.iterator(), defaultValue);
   }
 
   private static <T> T getLastInNonemptyList(List<T> list) {
     return list.get(list.size() - 1);
   }
 
   /**
    * Returns a view of {@code iterable} that skips its first
    * {@code numberToSkip} elements. If {@code iterable} contains fewer than
    * {@code numberToSkip} elements, the returned iterable skips all of its
    * elements.
    *
    * <p>Modifications to the underlying {@link Iterable} before a call to
    * {@code iterator()} are reflected in the returned iterator. That is, the
    * iterator skips the first {@code numberToSkip} elements that exist when the
    * {@code Iterator} is created, not when {@code skip()} is called.
    *
    * <p>The returned iterable's iterator supports {@code remove()} if the
    * iterator of the underlying iterable supports it. Note that it is
    * <i>not</i> possible to delete the last skipped element by immediately
    * calling {@code remove()} on that iterator, as the {@code Iterator}
    * contract states that a call to {@code remove()} before a call to
    * {@code next()} will throw an {@link IllegalStateException}.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}
    *
    * @since 3.0
    */
   public static <T> Iterable<T> skip(final Iterable<T> iterable, final int numberToSkip) {
     checkNotNull(iterable);
     checkArgument(numberToSkip >= 0, "number to skip cannot be negative");
 
-    if (iterable instanceof List) {
-      final List<T> list = (List<T>) iterable;
-      return new FluentIterable<T>() {
-        @Override
-        public Iterator<T> iterator() {
-          // TODO(kevinb): Support a concurrently modified collection?
-          int toSkip = Math.min(list.size(), numberToSkip);
-          return list.subList(toSkip, list.size()).iterator();
-        }
-      };
-    }
-
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
+        if (iterable instanceof List) {
+          final List<T> list = (List<T>) iterable;
+          int toSkip = Math.min(list.size(), numberToSkip);
+          return list.subList(toSkip, list.size()).iterator();
+        }
         final Iterator<T> iterator = iterable.iterator();
 
         Iterators.advance(iterator, numberToSkip);
 
         /*
          * We can't just return the iterator because an immediate call to its
          * remove() method would remove one of the skipped elements instead of
          * throwing an IllegalStateException.
          */
         return new Iterator<T>() {
           boolean atStart = true;
 
           @Override
           public boolean hasNext() {
             return iterator.hasNext();
           }
 
           @Override
           public T next() {
             T result = iterator.next();
             atStart = false; // not called if next() fails
             return result;
           }
 
           @Override
           public void remove() {
             checkRemove(!atStart);
             iterator.remove();
           }
         };
       }
     };
   }
 
   /**
    * Returns a view of {@code iterable} containing its first {@code limitSize}
    * elements. If {@code iterable} contains fewer than {@code limitSize}
    * elements, the returned view contains all of its elements. The returned
    * iterable's iterator supports {@code remove()} if {@code iterable}'s
    * iterator does.
    *
    * <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}
    *
    * @param iterable the iterable to limit
    * @param limitSize the maximum number of elements in the returned iterable
    * @throws IllegalArgumentException if {@code limitSize} is negative
    * @since 3.0
    */
   public static <T> Iterable<T> limit(final Iterable<T> iterable, final int limitSize) {
     checkNotNull(iterable);
     checkArgument(limitSize >= 0, "limit is negative");
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
         return Iterators.limit(iterable.iterator(), limitSize);
       }
     };
   }
 
   /**
    * Returns a view of the supplied iterable that wraps each generated
    * {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.
    *
    * <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will
    * get entries from {@link Queue#remove()} since {@link Queue}'s iteration
    * order is undefined.  Calling {@link Iterator#hasNext()} on a generated
    * iterator from the returned iterable may cause an item to be immediately
    * dequeued for return on a subsequent call to {@link Iterator#next()}.
    *
    * @param iterable the iterable to wrap
    * @return a view of the supplied iterable that wraps each generated iterator
    *     through {@link Iterators#consumingIterator(Iterator)}; for queues,
    *     an iterable that generates iterators that return and consume the
    *     queue's elements in queue order
    *
    * @see Iterators#consumingIterator(Iterator)
    * @since 2.0
    */
   public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable) {
-    if (iterable instanceof Queue) {
-      return new FluentIterable<T>() {
-        @Override
-        public Iterator<T> iterator() {
-          return new ConsumingQueueIterator<>((Queue<T>) iterable);
-        }
-
-        @Override
-        public String toString() {
-          return "Iterables.consumingIterable(...)";
-        }
-      };
-    }
-
     checkNotNull(iterable);
 
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
-        return Iterators.consumingIterator(iterable.iterator());
+        return (iterable instanceof Queue)
+            ? new ConsumingQueueIterator<>((Queue<T>) iterable)
+            : Iterators.consumingIterator(iterable.iterator());
       }
 
       @Override
       public String toString() {
         return "Iterables.consumingIterable(...)";
       }
     };
   }
 
   // Methods only in Iterables, not in Iterators
 
   /**
    * Determines if the given iterable contains no elements.
    *
    * <p>There is no precise {@link Iterator} equivalent to this method, since
    * one can only ask an iterator whether it has any elements <i>remaining</i>
    * (which one does using {@link Iterator#hasNext}).
    *
    * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}
    *
    * @return {@code true} if the iterable contains no elements
    */
   public static boolean isEmpty(Iterable<?> iterable) {
     if (iterable instanceof Collection) {
       return ((Collection<?>) iterable).isEmpty();
     }
     return !iterable.iterator().hasNext();
   }
 
   /**
    * Returns an iterable over the merged contents of all given
    * {@code iterables}. Equivalent entries will not be de-duplicated.
    *
    * <p>Callers must ensure that the source {@code iterables} are in
    * non-descending order as this method does not sort its input.
    *
    * <p>For any equivalent elements across all {@code iterables}, it is
    * undefined which element is returned first.
    *
    * @since 11.0
    */
   @Beta
   public static <T> Iterable<T> mergeSorted(
       final Iterable<? extends Iterable<? extends T>> iterables,
       final Comparator<? super T> comparator) {
     checkNotNull(iterables, "iterables");
     checkNotNull(comparator, "comparator");
     Iterable<T> iterable =
         new FluentIterable<T>() {
           @Override
