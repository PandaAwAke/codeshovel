diff --git a/android/guava/src/com/google/common/collect/LinkedListMultimap.java b/android/guava/src/com/google/common/collect/LinkedListMultimap.java
index c595bd824..5bc1a9540 100644
--- a/android/guava/src/com/google/common/collect/LinkedListMultimap.java
+++ b/android/guava/src/com/google/common/collect/LinkedListMultimap.java
@@ -671,100 +671,105 @@ public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V>
    *
    * <p>If the multimap is modified while an iteration over the list is in progress (except through
    * the iterator's own {@code add}, {@code set} or {@code remove} operations) the results of the
    * iteration are undefined.
    *
    * <p>The returned list is not serializable and does not have random access.
    */
   @Override
   public List<V> get(final @NullableDecl K key) {
     return new AbstractSequentialList<V>() {
       @Override
       public int size() {
         KeyList<K, V> keyList = keyToKeyList.get(key);
         return (keyList == null) ? 0 : keyList.count;
       }
 
       @Override
       public ListIterator<V> listIterator(int index) {
         return new ValueForKeyIterator(key, index);
       }
     };
   }
 
   @Override
   Set<K> createKeySet() {
     @WeakOuter
     class KeySetImpl extends Sets.ImprovedAbstractSet<K> {
       @Override
       public int size() {
         return keyToKeyList.size();
       }
 
       @Override
       public Iterator<K> iterator() {
         return new DistinctKeyIterator();
       }
 
       @Override
       public boolean contains(Object key) { // for performance
         return containsKey(key);
       }
 
       @Override
       public boolean remove(Object o) { // for performance
         return !LinkedListMultimap.this.removeAll(o).isEmpty();
       }
     }
     return new KeySetImpl();
   }
 
+  @Override
+  Multiset<K> createKeys() {
+    return new Multimaps.Keys<K, V>(this);
+  }
+
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values in the order they
    * were added to the multimap. Because the values may have duplicates and follow the insertion
    * ordering, this method returns a {@link List}, instead of the {@link Collection} specified in
    * the {@link ListMultimap} interface.
    */
   @Override
   public List<V> values() {
     return (List<V>) super.values();
   }
 
   @Override
   List<V> createValues() {
     @WeakOuter
     class ValuesImpl extends AbstractSequentialList<V> {
       @Override
       public int size() {
         return size;
       }
 
       @Override
       public ListIterator<V> listIterator(int index) {
         final NodeIterator nodeItr = new NodeIterator(index);
         return new TransformedListIterator<Entry<K, V>, V>(nodeItr) {
           @Override
           V transform(Entry<K, V> entry) {
             return entry.getValue();
           }
 
           @Override
           public void set(V value) {
             nodeItr.setValue(value);
           }
         };
       }
     }
     return new ValuesImpl();
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the entries in the order they
    * were added to the multimap. Because the entries may have duplicates and follow the insertion
    * ordering, this method returns a {@link List}, instead of the {@link Collection} specified in
    * the {@link ListMultimap} interface.
    *
    * <p>An entry's {@link Entry#getKey} method always returns the same key, regardless of what
