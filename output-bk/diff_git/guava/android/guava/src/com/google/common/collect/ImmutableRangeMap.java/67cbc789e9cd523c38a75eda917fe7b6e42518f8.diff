diff --git a/android/guava/src/com/google/common/collect/ImmutableRangeMap.java b/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
index 6f57e96a0..3f6d7ad8d 100644
--- a/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
@@ -79,101 +79,101 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
 
   /**
    * Returns a new builder for an immutable range map.
    */
   public static <K extends Comparable<?>, V> Builder<K, V> builder() {
     return new Builder<K, V>();
   }
 
   /**
    * A builder for immutable range maps. Overlapping ranges are prohibited.
    */
   public static final class Builder<K extends Comparable<?>, V> {
     private final List<Map.Entry<Range<K>, V>> entries;
 
     public Builder() {
       this.entries = Lists.newArrayList();
     }
 
     /**
      * Associates the specified range with the specified value.
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
     @CanIgnoreReturnValue
     public Builder<K, V> put(Range<K> range, V value) {
       checkNotNull(range);
       checkNotNull(value);
       checkArgument(!range.isEmpty(), "Range must not be empty, but was %s", range);
       entries.add(Maps.immutableEntry(range, value));
       return this;
     }
 
     /**
      * Copies all associations from the specified range map into this builder.
      */
     @CanIgnoreReturnValue
     public Builder<K, V> putAll(RangeMap<K, ? extends V> rangeMap) {
       for (Entry<Range<K>, ? extends V> entry : rangeMap.asMapOfRanges().entrySet()) {
         put(entry.getKey(), entry.getValue());
       }
       return this;
     }
 
     /**
      * Returns an {@code ImmutableRangeMap} containing the associations previously added to this
      * builder.
      *
      * @throws IllegalArgumentException if any two ranges inserted into this builder overlap
      */
     public ImmutableRangeMap<K, V> build() {
-      Collections.sort(entries, Range.RANGE_LEX_ORDERING.onKeys());
+      Collections.sort(entries, Range.<K>rangeLexOrdering().onKeys());
       ImmutableList.Builder<Range<K>> rangesBuilder =
           new ImmutableList.Builder<Range<K>>(entries.size());
       ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());
       for (int i = 0; i < entries.size(); i++) {
         Range<K> range = entries.get(i).getKey();
         if (i > 0) {
           Range<K> prevRange = entries.get(i - 1).getKey();
           if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {
             throw new IllegalArgumentException(
                 "Overlapping ranges: range " + prevRange + " overlaps with entry " + range);
           }
         }
         rangesBuilder.add(range);
         valuesBuilder.add(entries.get(i).getValue());
       }
       return new ImmutableRangeMap<K, V>(rangesBuilder.build(), valuesBuilder.build());
     }
   }
 
   private final transient ImmutableList<Range<K>> ranges;
   private final transient ImmutableList<V> values;
 
   ImmutableRangeMap(ImmutableList<Range<K>> ranges, ImmutableList<V> values) {
     this.ranges = ranges;
     this.values = values;
   }
 
   @Override
   @Nullable
   public V get(K key) {
     int index =
         SortedLists.binarySearch(
             ranges,
             Range.<K>lowerBoundFn(),
             Cut.belowValue(key),
             KeyPresentBehavior.ANY_PRESENT,
             KeyAbsentBehavior.NEXT_LOWER);
     if (index == -1) {
       return null;
     } else {
       Range<K> range = ranges.get(index);
       return range.contains(key) ? values.get(index) : null;
     }
   }
 
   @Override
   @Nullable
   public Map.Entry<Range<K>, V> getEntry(K key) {
     int index =
         SortedLists.binarySearch(
@@ -219,112 +219,112 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void putCoalescing(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void putAll(RangeMap<K, V> rangeMap) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void clear() {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void remove(Range<K> range) {
     throw new UnsupportedOperationException();
   }
 
   @Override
   public ImmutableMap<Range<K>, V> asMapOfRanges() {
     if (ranges.isEmpty()) {
       return ImmutableMap.of();
     }
     RegularImmutableSortedSet<Range<K>> rangeSet =
-        new RegularImmutableSortedSet<Range<K>>(ranges, Range.RANGE_LEX_ORDERING);
+        new RegularImmutableSortedSet<Range<K>>(ranges, Range.<K>rangeLexOrdering());
     return new ImmutableSortedMap<Range<K>, V>(rangeSet, values);
   }
 
   @Override
   public ImmutableMap<Range<K>, V> asDescendingMapOfRanges() {
     if (ranges.isEmpty()) {
       return ImmutableMap.of();
     }
     RegularImmutableSortedSet<Range<K>> rangeSet =
         new RegularImmutableSortedSet<Range<K>>(
-            ranges.reverse(), Range.RANGE_LEX_ORDERING.reverse());
+            ranges.reverse(), Range.<K>rangeLexOrdering().reverse());
     return new ImmutableSortedMap<Range<K>, V>(rangeSet, values.reverse());
   }
 
   @Override
   public ImmutableRangeMap<K, V> subRangeMap(final Range<K> range) {
     if (checkNotNull(range).isEmpty()) {
       return ImmutableRangeMap.of();
     } else if (ranges.isEmpty() || range.encloses(span())) {
       return this;
     }
     int lowerIndex =
         SortedLists.binarySearch(
             ranges,
             Range.<K>upperBoundFn(),
             range.lowerBound,
             KeyPresentBehavior.FIRST_AFTER,
             KeyAbsentBehavior.NEXT_HIGHER);
     int upperIndex =
         SortedLists.binarySearch(
             ranges,
             Range.<K>lowerBoundFn(),
             range.upperBound,
             KeyPresentBehavior.ANY_PRESENT,
             KeyAbsentBehavior.NEXT_HIGHER);
     if (lowerIndex >= upperIndex) {
       return ImmutableRangeMap.of();
     }
     final int off = lowerIndex;
     final int len = upperIndex - lowerIndex;
     ImmutableList<Range<K>> subRanges =
         new ImmutableList<Range<K>>() {
           @Override
           public int size() {
             return len;
           }
 
           @Override
           public Range<K> get(int index) {
             checkElementIndex(index, len);
             if (index == 0 || index == len - 1) {
               return ranges.get(index + off).intersection(range);
             } else {
               return ranges.get(index + off);
             }
           }
 
           @Override
           boolean isPartialView() {
             return true;
           }
