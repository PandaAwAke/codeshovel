diff --git a/android/guava/src/com/google/common/collect/HashBiMap.java b/android/guava/src/com/google/common/collect/HashBiMap.java
index d2ce96b68..771ca014c 100644
--- a/android/guava/src/com/google/common/collect/HashBiMap.java
+++ b/android/guava/src/com/google/common/collect/HashBiMap.java
@@ -1,723 +1,1061 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.CollectPreconditions.checkNonnegative;
-import static com.google.common.collect.CollectPreconditions.checkRemove;
-import static com.google.common.collect.Hashing.smearedHash;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
-import com.google.common.collect.Maps.IteratorBasedAbstractMap;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.AbstractMap;
+import java.util.AbstractSet;
 import java.util.Arrays;
 import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
  * A {@link BiMap} backed by two hash tables. This implementation allows null keys and values. A
  * {@code HashBiMap} and its inverse are both serializable.
  *
  * <p>This implementation guarantees insertion-based iteration order of its keys.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap"> {@code BiMap} </a>.
  *
  * @author Louis Wasserman
  * @author Mike Bostock
  * @since 2.0
  */
-@GwtCompatible(emulated = true)
-public final class HashBiMap<K, V> extends IteratorBasedAbstractMap<K, V>
-    implements BiMap<K, V>, Serializable {
+@GwtCompatible
+public final class HashBiMap<K, V> extends AbstractMap<K, V> implements BiMap<K, V>, Serializable {
 
-  /**
-   * Returns a new, empty {@code HashBiMap} with the default initial capacity (16).
-   */
+  /** Returns a new, empty {@code HashBiMap} with the default initial capacity (16). */
   public static <K, V> HashBiMap<K, V> create() {
     return create(16);
   }
 
   /**
    * Constructs a new, empty bimap with the specified expected size.
    *
    * @param expectedSize the expected number of entries
    * @throws IllegalArgumentException if the specified expected size is negative
    */
   public static <K, V> HashBiMap<K, V> create(int expectedSize) {
     return new HashBiMap<>(expectedSize);
   }
 
   /**
    * Constructs a new bimap containing initial values from {@code map}. The bimap is created with an
    * initial capacity sufficient to hold the mappings in the specified map.
    */
   public static <K, V> HashBiMap<K, V> create(Map<? extends K, ? extends V> map) {
     HashBiMap<K, V> bimap = create(map.size());
     bimap.putAll(map);
     return bimap;
   }
 
-  private static final class BiEntry<K, V> extends ImmutableEntry<K, V> {
-    final int keyHash;
-    final int valueHash;
+  private static final int ABSENT = -1;
+  private static final int ENDPOINT = -2;
+
+  /** Maps an "entry" to the key of that entry. */
+  transient K[] keys;
+  /** Maps an "entry" to the value of that entry. */
+  transient V[] values;
+
+  transient int size;
+  transient int modCount;
+  /** Maps a bucket to the "entry" of its first element. */
+  private transient int[] hashTableKToV;
+  /** Maps a bucket to the "entry" of its first element. */
+  private transient int[] hashTableVToK;
+  /** Maps an "entry" to the "entry" that follows it in its bucket. */
+  private transient int[] nextInBucketKToV;
+  /** Maps an "entry" to the "entry" that follows it in its bucket. */
+  private transient int[] nextInBucketVToK;
+  /** The "entry" of the first element in insertion order. */
+  private transient int firstInInsertionOrder;
+  /** The "entry" of the last element in insertion order. */
+  private transient int lastInInsertionOrder;
+  /** Maps an "entry" to the "entry" that precedes it in insertion order. */
+  private transient int[] prevInInsertionOrder;
+  /** Maps an "entry" to the "entry" that follows it in insertion order. */
+  private transient int[] nextInInsertionOrder;
 
-    @Nullable BiEntry<K, V> nextInKToVBucket;
-    @Nullable BiEntry<K, V> nextInVToKBucket;
+  private HashBiMap(int expectedSize) {
+    init(expectedSize);
+  }
 
-    @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
-    @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
+  @SuppressWarnings("unchecked")
+  void init(int expectedSize) {
+    CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
+    int tableSize = Hashing.closedTableSize(expectedSize, 1.0);
+    size = 0;
 
-    BiEntry(K key, int keyHash, V value, int valueHash) {
-      super(key, value);
-      this.keyHash = keyHash;
-      this.valueHash = valueHash;
-    }
-  }
+    keys = (K[]) new Object[expectedSize];
+    values = (V[]) new Object[expectedSize];
 
-  private static final double LOAD_FACTOR = 1.0;
+    hashTableKToV = createFilledWithAbsent(tableSize);
+    hashTableVToK = createFilledWithAbsent(tableSize);
+    nextInBucketKToV = createFilledWithAbsent(expectedSize);
+    nextInBucketVToK = createFilledWithAbsent(expectedSize);
 
-  private transient BiEntry<K, V>[] hashTableKToV;
-  private transient BiEntry<K, V>[] hashTableVToK;
-  private transient BiEntry<K, V> firstInKeyInsertionOrder;
-  private transient BiEntry<K, V> lastInKeyInsertionOrder;
-  private transient int size;
-  private transient int mask;
-  private transient int modCount;
+    firstInInsertionOrder = ENDPOINT;
+    lastInInsertionOrder = ENDPOINT;
 
-  private HashBiMap(int expectedSize) {
-    init(expectedSize);
+    prevInInsertionOrder = createFilledWithAbsent(expectedSize);
+    nextInInsertionOrder = createFilledWithAbsent(expectedSize);
+  }
+
+  /** Returns an int array of the specified size, filled with ABSENT. */
+  private static int[] createFilledWithAbsent(int size) {
+    int[] array = new int[size];
+    Arrays.fill(array, ABSENT);
+    return array;
+  }
+
+  /** Equivalent to {@code Arrays.copyOf(array, newSize)}, save that the new elements are ABSENT. */
+  private static int[] expandAndFillWithAbsent(int[] array, int newSize) {
+    int oldSize = array.length;
+    int[] result = Arrays.copyOf(array, newSize);
+    Arrays.fill(result, oldSize, newSize, ABSENT);
+    return result;
   }
 
-  private void init(int expectedSize) {
-    checkNonnegative(expectedSize, "expectedSize");
-    int tableSize = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
-    this.hashTableKToV = createTable(tableSize);
-    this.hashTableVToK = createTable(tableSize);
-    this.firstInKeyInsertionOrder = null;
-    this.lastInKeyInsertionOrder = null;
-    this.size = 0;
-    this.mask = tableSize - 1;
-    this.modCount = 0;
+  @Override
+  public int size() {
+    return size;
   }
 
   /**
-   * Finds and removes {@code entry} from the bucket linked lists in both the
-   * key-to-value direction and the value-to-key direction.
+   * Ensures that all of the internal structures in the HashBiMap are ready for this many elements.
    */
-  private void delete(BiEntry<K, V> entry) {
-    int keyBucket = entry.keyHash & mask;
-    BiEntry<K, V> prevBucketEntry = null;
-    for (BiEntry<K, V> bucketEntry = hashTableKToV[keyBucket];
-        true;
-        bucketEntry = bucketEntry.nextInKToVBucket) {
-      if (bucketEntry == entry) {
-        if (prevBucketEntry == null) {
-          hashTableKToV[keyBucket] = entry.nextInKToVBucket;
-        } else {
-          prevBucketEntry.nextInKToVBucket = entry.nextInKToVBucket;
-        }
-        break;
-      }
-      prevBucketEntry = bucketEntry;
-    }
-
-    int valueBucket = entry.valueHash & mask;
-    prevBucketEntry = null;
-    for (BiEntry<K, V> bucketEntry = hashTableVToK[valueBucket];
-        true;
-        bucketEntry = bucketEntry.nextInVToKBucket) {
-      if (bucketEntry == entry) {
-        if (prevBucketEntry == null) {
-          hashTableVToK[valueBucket] = entry.nextInVToKBucket;
-        } else {
-          prevBucketEntry.nextInVToKBucket = entry.nextInVToKBucket;
-        }
-        break;
-      }
-      prevBucketEntry = bucketEntry;
-    }
-
-    if (entry.prevInKeyInsertionOrder == null) {
-      firstInKeyInsertionOrder = entry.nextInKeyInsertionOrder;
-    } else {
-      entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry.nextInKeyInsertionOrder;
+  private void ensureCapacity(int minCapacity) {
+    if (nextInBucketKToV.length < minCapacity) {
+      int oldCapacity = nextInBucketKToV.length;
+      int newCapacity = ImmutableCollection.Builder.expandedCapacity(oldCapacity, minCapacity);
+
+      keys = Arrays.copyOf(keys, newCapacity);
+      values = Arrays.copyOf(values, newCapacity);
+      nextInBucketKToV = expandAndFillWithAbsent(nextInBucketKToV, newCapacity);
+      nextInBucketVToK = expandAndFillWithAbsent(nextInBucketVToK, newCapacity);
+      prevInInsertionOrder = expandAndFillWithAbsent(prevInInsertionOrder, newCapacity);
+      nextInInsertionOrder = expandAndFillWithAbsent(nextInInsertionOrder, newCapacity);
     }
 
-    if (entry.nextInKeyInsertionOrder == null) {
-      lastInKeyInsertionOrder = entry.prevInKeyInsertionOrder;
-    } else {
-      entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry.prevInKeyInsertionOrder;
+    if (hashTableKToV.length < minCapacity) {
+      int newTableSize = Hashing.closedTableSize(minCapacity, 1.0);
+      hashTableKToV = createFilledWithAbsent(newTableSize);
+      hashTableVToK = createFilledWithAbsent(newTableSize);
+
+      for (int entryToRehash = 0; entryToRehash < size; entryToRehash++) {
+        int keyHash = Hashing.smearedHash(keys[entryToRehash]);
+        int keyBucket = bucket(keyHash);
+        nextInBucketKToV[entryToRehash] = hashTableKToV[keyBucket];
+        hashTableKToV[keyBucket] = entryToRehash;
+
+        int valueHash = Hashing.smearedHash(values[entryToRehash]);
+        int valueBucket = bucket(valueHash);
+        nextInBucketVToK[entryToRehash] = hashTableVToK[valueBucket];
+        hashTableVToK[valueBucket] = entryToRehash;
+      }
     }
-
-    size--;
-    modCount++;
   }
 
-  private void insert(BiEntry<K, V> entry, @Nullable BiEntry<K, V> oldEntryForKey) {
-    int keyBucket = entry.keyHash & mask;
-    entry.nextInKToVBucket = hashTableKToV[keyBucket];
-    hashTableKToV[keyBucket] = entry;
+  /**
+   * Returns the bucket (in either the K-to-V or V-to-K tables) where elements with the specified
+   * hash could be found, if present, or could be inserted.
+   */
+  private int bucket(int hash) {
+    return hash & (hashTableKToV.length - 1);
+  }
 
-    int valueBucket = entry.valueHash & mask;
-    entry.nextInVToKBucket = hashTableVToK[valueBucket];
-    hashTableVToK[valueBucket] = entry;
+  /** Given a key, returns the index of the entry in the tables, or ABSENT if not found. */
+  int findEntryByKey(@Nullable Object key) {
+    return findEntryByKey(key, Hashing.smearedHash(key));
+  }
 
-    if (oldEntryForKey == null) {
-      entry.prevInKeyInsertionOrder = lastInKeyInsertionOrder;
-      entry.nextInKeyInsertionOrder = null;
-      if (lastInKeyInsertionOrder == null) {
-        firstInKeyInsertionOrder = entry;
-      } else {
-        lastInKeyInsertionOrder.nextInKeyInsertionOrder = entry;
-      }
-      lastInKeyInsertionOrder = entry;
-    } else {
-      entry.prevInKeyInsertionOrder = oldEntryForKey.prevInKeyInsertionOrder;
-      if (entry.prevInKeyInsertionOrder == null) {
-        firstInKeyInsertionOrder = entry;
-      } else {
-        entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry;
-      }
-      entry.nextInKeyInsertionOrder = oldEntryForKey.nextInKeyInsertionOrder;
-      if (entry.nextInKeyInsertionOrder == null) {
-        lastInKeyInsertionOrder = entry;
-      } else {
-        entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry;
-      }
-    }
+  /**
+   * Given a key and its hash, returns the index of the entry in the tables, or ABSENT if not found.
+   */
+  int findEntryByKey(@Nullable Object key, int keyHash) {
+    return findEntry(key, keyHash, hashTableKToV, nextInBucketKToV, keys);
+  }
 
-    size++;
-    modCount++;
+  /** Given a value, returns the index of the entry in the tables, or ABSENT if not found. */
+  int findEntryByValue(@Nullable Object value) {
+    return findEntryByValue(value, Hashing.smearedHash(value));
   }
 
-  private BiEntry<K, V> seekByKey(@Nullable Object key, int keyHash) {
-    for (BiEntry<K, V> entry = hashTableKToV[keyHash & mask];
-        entry != null;
-        entry = entry.nextInKToVBucket) {
-      if (keyHash == entry.keyHash && Objects.equal(key, entry.key)) {
-        return entry;
-      }
-    }
-    return null;
+  /**
+   * Given a value and its hash, returns the index of the entry in the tables, or ABSENT if not
+   * found.
+   */
+  int findEntryByValue(@Nullable Object value, int valueHash) {
+    return findEntry(value, valueHash, hashTableVToK, nextInBucketVToK, values);
   }
 
-  private BiEntry<K, V> seekByValue(@Nullable Object value, int valueHash) {
-    for (BiEntry<K, V> entry = hashTableVToK[valueHash & mask];
-        entry != null;
-        entry = entry.nextInVToKBucket) {
-      if (valueHash == entry.valueHash && Objects.equal(value, entry.value)) {
+  int findEntry(
+      @Nullable Object o, int oHash, int[] hashTable, int[] nextInBucket, Object[] array) {
+    for (int entry = hashTable[bucket(oHash)]; entry != ABSENT; entry = nextInBucket[entry]) {
+      if (Objects.equal(array[entry], o)) {
         return entry;
       }
     }
-    return null;
+    return ABSENT;
   }
 
   @Override
   public boolean containsKey(@Nullable Object key) {
-    return seekByKey(key, smearedHash(key)) != null;
+    return findEntryByKey(key) != ABSENT;
   }
 
   @Override
   public boolean containsValue(@Nullable Object value) {
-    return seekByValue(value, smearedHash(value)) != null;
+    return findEntryByValue(value) != ABSENT;
   }
 
-  @Nullable
   @Override
+  @Nullable
   public V get(@Nullable Object key) {
-    return Maps.valueOrNull(seekByKey(key, smearedHash(key)));
+    int entry = findEntryByKey(key);
+    return (entry == ABSENT) ? null : values[entry];
+  }
+
+  @Nullable
+  K getInverse(@Nullable Object value) {
+    int entry = findEntryByValue(value);
+    return (entry == ABSENT) ? null : keys[entry];
   }
 
-  @CanIgnoreReturnValue
   @Override
+  @CanIgnoreReturnValue
   public V put(@Nullable K key, @Nullable V value) {
     return put(key, value, false);
   }
 
-  @CanIgnoreReturnValue
   @Override
+  @Nullable
+  @CanIgnoreReturnValue
   public V forcePut(@Nullable K key, @Nullable V value) {
     return put(key, value, true);
   }
 
-  private V put(@Nullable K key, @Nullable V value, boolean force) {
-    int keyHash = smearedHash(key);
-    int valueHash = smearedHash(value);
-
-    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
-    if (oldEntryForKey != null
-        && valueHash == oldEntryForKey.valueHash
-        && Objects.equal(value, oldEntryForKey.value)) {
-      return value;
-    }
-
-    BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
-    if (oldEntryForValue != null) {
-      if (force) {
-        delete(oldEntryForValue);
+  @Nullable
+  V put(@Nullable K key, @Nullable V value, boolean force) {
+    int keyHash = Hashing.smearedHash(key);
+    int entryForKey = findEntryByKey(key, keyHash);
+    if (entryForKey != ABSENT) {
+      V oldValue = values[entryForKey];
+      if (Objects.equal(oldValue, value)) {
+        return value;
       } else {
-        throw new IllegalArgumentException("value already present: " + value);
+        replaceValueInEntry(entryForKey, value, force);
+        return oldValue;
       }
     }
 
-    BiEntry<K, V> newEntry = new BiEntry<>(key, keyHash, value, valueHash);
-    if (oldEntryForKey != null) {
-      delete(oldEntryForKey);
-      insert(newEntry, oldEntryForKey);
-      oldEntryForKey.prevInKeyInsertionOrder = null;
-      oldEntryForKey.nextInKeyInsertionOrder = null;
-      rehashIfNecessary();
-      return oldEntryForKey.value;
+    int valueHash = Hashing.smearedHash(value);
+    int valueEntry = findEntryByValue(value, valueHash);
+    if (force) {
+      if (valueEntry != ABSENT) {
+        removeEntryValueHashKnown(valueEntry, valueHash);
+      }
     } else {
-      insert(newEntry, null);
-      rehashIfNecessary();
-      return null;
+      checkArgument(valueEntry == ABSENT, "Value already present: %s", value);
     }
+
+    ensureCapacity(size + 1);
+    keys[size] = key;
+    values[size] = value;
+
+    insertIntoTableKToV(size, keyHash);
+    insertIntoTableVToK(size, valueHash);
+
+    setSucceeds(lastInInsertionOrder, size);
+    setSucceeds(size, ENDPOINT);
+    size++;
+    modCount++;
+    return null;
   }
 
   @Nullable
-  private K putInverse(@Nullable V value, @Nullable K key, boolean force) {
-    int valueHash = smearedHash(value);
-    int keyHash = smearedHash(key);
-
-    BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
-    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
-    if (oldEntryForValue != null
-        && keyHash == oldEntryForValue.keyHash
-        && Objects.equal(key, oldEntryForValue.key)) {
-      return key;
-    } else if (oldEntryForKey != null && !force) {
-      throw new IllegalArgumentException("key already present: " + key);
+  K putInverse(@Nullable V value, @Nullable K key, boolean force) {
+    int valueHash = Hashing.smearedHash(value);
+    int entryForValue = findEntryByValue(value, valueHash);
+    if (entryForValue != ABSENT) {
+      K oldKey = keys[entryForValue];
+      if (Objects.equal(oldKey, key)) {
+        return key;
+      } else {
+        replaceKeyInEntry(entryForValue, key, force);
+        return oldKey;
+      }
     }
 
-    /*
-     * The ordering here is important: if we deleted the key entry and then the value entry,
-     * the key entry's prev or next pointer might point to the dead value entry, and when we
-     * put the new entry in the key entry's position in iteration order, it might invalidate
-     * the linked list.
-     */
-
-    if (oldEntryForValue != null) {
-      delete(oldEntryForValue);
+    int predecessor = lastInInsertionOrder;
+    int keyHash = Hashing.smearedHash(key);
+    int keyEntry = findEntryByKey(key, keyHash);
+    if (force) {
+      if (keyEntry != ABSENT) {
+        predecessor = prevInInsertionOrder[keyEntry];
+        removeEntryKeyHashKnown(keyEntry, keyHash);
+      }
+    } else {
+      checkArgument(keyEntry == ABSENT, "Key already present: %s", key);
     }
 
-    if (oldEntryForKey != null) {
-      delete(oldEntryForKey);
+    // insertion point for new entry is after predecessor
+    // note predecessor must still be a valid entry: either we deleted an entry that was *not*
+    // predecessor, or we didn't delete anything
+
+    ensureCapacity(size + 1);
+    keys[size] = key;
+    values[size] = value;
+
+    insertIntoTableKToV(size, keyHash);
+    insertIntoTableVToK(size, valueHash);
+
+    int successor =
+        (predecessor == ENDPOINT) ? firstInInsertionOrder : nextInInsertionOrder[predecessor];
+    setSucceeds(predecessor, size);
+    setSucceeds(size, successor);
+    size++;
+    modCount++;
+    return null;
+  }
+
+  /**
+   * Updates the pointers of the insertion order linked list so that {@code next} follows {@code
+   * prev}. {@code ENDPOINT} represents either the first or last entry in the entire map (as
+   * appropriate).
+   */
+  private void setSucceeds(int prev, int next) {
+    if (prev == ENDPOINT) {
+      firstInInsertionOrder = next;
+    } else {
+      nextInInsertionOrder[prev] = next;
     }
+    if (next == ENDPOINT) {
+      lastInInsertionOrder = prev;
+    } else {
+      prevInInsertionOrder[next] = prev;
+    }
+  }
 
-    BiEntry<K, V> newEntry = new BiEntry<>(key, keyHash, value, valueHash);
-    insert(newEntry, oldEntryForKey);
+  /**
+   * Updates the K-to-V hash table to include the entry at the specified index, which is assumed to
+   * have not yet been added.
+   */
+  private void insertIntoTableKToV(int entry, int keyHash) {
+    checkArgument(entry != ABSENT);
+    int keyBucket = bucket(keyHash);
+    nextInBucketKToV[entry] = hashTableKToV[keyBucket];
+    hashTableKToV[keyBucket] = entry;
+  }
+
+  /**
+   * Updates the V-to-K hash table to include the entry at the specified index, which is assumed to
+   * have not yet been added.
+   */
+  private void insertIntoTableVToK(int entry, int valueHash) {
+    checkArgument(entry != ABSENT);
+    int valueBucket = bucket(valueHash);
+    nextInBucketVToK[entry] = hashTableVToK[valueBucket];
+    hashTableVToK[valueBucket] = entry;
+  }
 
-    if (oldEntryForKey != null) {
-      oldEntryForKey.prevInKeyInsertionOrder = null;
-      oldEntryForKey.nextInKeyInsertionOrder = null;
+  /**
+   * Updates the K-to-V hash table to remove the entry at the specified index, which is assumed to
+   * be present. Does not update any other data structures.
+   */
+  private void deleteFromTableKToV(int entry, int keyHash) {
+    checkArgument(entry != ABSENT);
+    int keyBucket = bucket(keyHash);
+
+    if (hashTableKToV[keyBucket] == entry) {
+      hashTableKToV[keyBucket] = nextInBucketKToV[entry];
+      nextInBucketKToV[entry] = ABSENT;
+      return;
     }
-    if (oldEntryForValue != null) {
-      oldEntryForValue.prevInKeyInsertionOrder = null;
-      oldEntryForValue.nextInKeyInsertionOrder = null;
+
+    int prevInBucket = hashTableKToV[keyBucket];
+    for (int entryInBucket = nextInBucketKToV[prevInBucket];
+        entryInBucket != ABSENT;
+        entryInBucket = nextInBucketKToV[entryInBucket]) {
+      if (entryInBucket == entry) {
+        nextInBucketKToV[prevInBucket] = nextInBucketKToV[entry];
+        nextInBucketKToV[entry] = ABSENT;
+        return;
+      }
+      prevInBucket = entryInBucket;
     }
-    rehashIfNecessary();
-    return Maps.keyOrNull(oldEntryForValue);
+    throw new AssertionError("Expected to find entry with key " + keys[entry]);
   }
 
-  private void rehashIfNecessary() {
-    BiEntry<K, V>[] oldKToV = hashTableKToV;
-    if (Hashing.needsResizing(size, oldKToV.length, LOAD_FACTOR)) {
-      int newTableSize = oldKToV.length * 2;
+  /**
+   * Updates the V-to-K hash table to remove the entry at the specified index, which is assumed to
+   * be present. Does not update any other data structures.
+   */
+  private void deleteFromTableVToK(int entry, int valueHash) {
+    checkArgument(entry != ABSENT);
+    int valueBucket = bucket(valueHash);
+
+    if (hashTableVToK[valueBucket] == entry) {
+      hashTableVToK[valueBucket] = nextInBucketVToK[entry];
+      nextInBucketVToK[entry] = ABSENT;
+      return;
+    }
 
-      this.hashTableKToV = createTable(newTableSize);
-      this.hashTableVToK = createTable(newTableSize);
-      this.mask = newTableSize - 1;
-      this.size = 0;
+    int prevInBucket = hashTableVToK[valueBucket];
+    for (int entryInBucket = nextInBucketVToK[prevInBucket];
+        entryInBucket != ABSENT;
+        entryInBucket = nextInBucketVToK[entryInBucket]) {
+      if (entryInBucket == entry) {
+        nextInBucketVToK[prevInBucket] = nextInBucketVToK[entry];
+        nextInBucketVToK[entry] = ABSENT;
+        return;
+      }
+      prevInBucket = entryInBucket;
+    }
+    throw new AssertionError("Expected to find entry with value " + values[entry]);
+  }
 
-      for (BiEntry<K, V> entry = firstInKeyInsertionOrder;
-          entry != null;
-          entry = entry.nextInKeyInsertionOrder) {
-        insert(entry, entry);
+  /**
+   * Updates the specified entry to point to the new value: removes the old value from the V-to-K
+   * mapping and puts the new one in. The entry does not move in the insertion order of the bimap.
+   */
+  private void replaceValueInEntry(int entry, @Nullable V newValue, boolean force) {
+    checkArgument(entry != ABSENT);
+    int newValueHash = Hashing.smearedHash(newValue);
+    int newValueIndex = findEntryByValue(newValue, newValueHash);
+    if (newValueIndex != ABSENT) {
+      if (force) {
+        removeEntryValueHashKnown(newValueIndex, newValueHash);
+        if (entry == size) { // this entry got moved to newValueIndex
+          entry = newValueIndex;
+        }
+      } else {
+        throw new IllegalArgumentException("Value already present in map: " + newValue);
       }
-      this.modCount++;
     }
+    // we do *not* update insertion order, and it isn't a structural modification!
+    deleteFromTableVToK(entry, Hashing.smearedHash(values[entry]));
+    values[entry] = newValue;
+    insertIntoTableVToK(entry, newValueHash);
   }
 
-  @SuppressWarnings("unchecked")
-  private BiEntry<K, V>[] createTable(int length) {
-    return new BiEntry[length];
+  /**
+   * Updates the specified entry to point to the new value: removes the old value from the V-to-K
+   * mapping and puts the new one in. The entry is moved to the end of the insertion order, or to
+   * the position of the new key if it was previously present.
+   */
+  private void replaceKeyInEntry(int entry, @Nullable K newKey, boolean force) {
+    checkArgument(entry != ABSENT);
+    int newKeyHash = Hashing.smearedHash(newKey);
+    int newKeyIndex = findEntryByKey(newKey, newKeyHash);
+
+    int newPredecessor = lastInInsertionOrder;
+    int newSuccessor = ENDPOINT;
+    if (newKeyIndex != ABSENT) {
+      if (force) {
+        newPredecessor = prevInInsertionOrder[newKeyIndex];
+        newSuccessor = nextInInsertionOrder[newKeyIndex];
+        removeEntryKeyHashKnown(newKeyIndex, newKeyHash);
+        if (entry == size) { // this entry got moved to newKeyIndex
+          entry = newKeyIndex;
+        }
+      } else {
+        throw new IllegalArgumentException("Key already present in map: " + newKey);
+      }
+    }
+    if (newPredecessor == entry) {
+      newPredecessor = prevInInsertionOrder[entry];
+    } else if (newPredecessor == size) {
+      newPredecessor = newKeyIndex;
+    }
+
+    if (newSuccessor == entry) {
+      newSuccessor = nextInInsertionOrder[entry];
+    } else if (newSuccessor == size) {
+      newSuccessor = newKeyIndex;
+    }
+
+    int oldPredecessor = prevInInsertionOrder[entry];
+    int oldSuccessor = nextInInsertionOrder[entry];
+    setSucceeds(oldPredecessor, oldSuccessor); // remove from insertion order linked list
+
+    deleteFromTableKToV(entry, Hashing.smearedHash(keys[entry]));
+    keys[entry] = newKey;
+    insertIntoTableKToV(entry, Hashing.smearedHash(newKey));
+
+    // insert into insertion order linked list, usually at the end
+    setSucceeds(newPredecessor, entry);
+    setSucceeds(entry, newSuccessor);
   }
 
-  @CanIgnoreReturnValue
   @Override
+  @Nullable
+  @CanIgnoreReturnValue
   public V remove(@Nullable Object key) {
-    BiEntry<K, V> entry = seekByKey(key, smearedHash(key));
-    if (entry == null) {
+    int keyHash = Hashing.smearedHash(key);
+    int entry = findEntryByKey(key, keyHash);
+    if (entry == ABSENT) {
       return null;
     } else {
-      delete(entry);
-      entry.prevInKeyInsertionOrder = null;
-      entry.nextInKeyInsertionOrder = null;
-      return entry.value;
+      @Nullable V value = values[entry];
+      removeEntryKeyHashKnown(entry, keyHash);
+      return value;
     }
   }
 
-  @Override
-  public void clear() {
-    size = 0;
-    Arrays.fill(hashTableKToV, null);
-    Arrays.fill(hashTableVToK, null);
-    firstInKeyInsertionOrder = null;
-    lastInKeyInsertionOrder = null;
-    modCount++;
+  @Nullable
+  K removeInverse(@Nullable Object value) {
+    int valueHash = Hashing.smearedHash(value);
+    int entry = findEntryByValue(value, valueHash);
+    if (entry == ABSENT) {
+      return null;
+    } else {
+      @Nullable K key = keys[entry];
+      removeEntryValueHashKnown(entry, valueHash);
+      return key;
+    }
   }
 
-  @Override
-  public int size() {
-    return size;
+  /** Removes the entry at the specified index with no additional data. */
+  void removeEntry(int entry) {
+    removeEntryKeyHashKnown(entry, Hashing.smearedHash(keys[entry]));
   }
 
-  abstract class Itr<T> implements Iterator<T> {
-    BiEntry<K, V> next = firstInKeyInsertionOrder;
-    BiEntry<K, V> toRemove = null;
-    int expectedModCount = modCount;
+  /** Removes the entry at the specified index, given the hash of its key. */
+  void removeEntryKeyHashKnown(int entry, int keyHash) {
+    removeEntry(entry, keyHash, Hashing.smearedHash(values[entry]));
+  }
 
-    @Override
-    public boolean hasNext() {
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
+  /** Removes the entry at the specified index, given the hash of its value. */
+  void removeEntryValueHashKnown(int entry, int valueHash) {
+    removeEntry(entry, Hashing.smearedHash(keys[entry]), valueHash);
+  }
+
+  /** Removes the entry at the specified index, given the hash of its key and value. */
+  private void removeEntry(int entry, int keyHash, int valueHash) {
+    checkArgument(entry != ABSENT);
+    deleteFromTableKToV(entry, keyHash);
+    deleteFromTableVToK(entry, valueHash);
+
+    int oldPredecessor = prevInInsertionOrder[entry];
+    int oldSuccessor = nextInInsertionOrder[entry];
+    setSucceeds(oldPredecessor, oldSuccessor);
+
+    moveEntryToIndex(size - 1, entry);
+    keys[size - 1] = null;
+    values[size - 1] = null;
+    size--;
+    modCount++;
+  }
+
+  /**
+   * Moves the entry previously positioned at {@code src} to {@code dest}. Assumes the entry
+   * previously at {@code src} has already been removed from the data structures.
+   */
+  private void moveEntryToIndex(int src, int dest) {
+    if (src == dest) {
+      return;
+    }
+    int predecessor = prevInInsertionOrder[src];
+    int successor = nextInInsertionOrder[src];
+    setSucceeds(predecessor, dest);
+    setSucceeds(dest, successor);
+
+    K key = keys[src];
+    V value = values[src];
+
+    keys[dest] = key;
+    values[dest] = value;
+
+    // update pointers in hashTableKToV
+    int keyHash = Hashing.smearedHash(key);
+    int keyBucket = bucket(keyHash);
+    if (hashTableKToV[keyBucket] == src) {
+      hashTableKToV[keyBucket] = dest;
+    } else {
+      int prevInBucket = hashTableKToV[keyBucket];
+      for (int entryInBucket = nextInBucketKToV[prevInBucket];
+          /* should never reach end */ ;
+          entryInBucket = nextInBucketKToV[entryInBucket]) {
+        if (entryInBucket == src) {
+          nextInBucketKToV[prevInBucket] = dest;
+          break;
+        }
+        prevInBucket = entryInBucket;
       }
-      return next != null;
     }
+    nextInBucketKToV[dest] = nextInBucketKToV[src];
+    nextInBucketKToV[src] = ABSENT;
+
+    // update pointers in hashTableVToK
+    int valueHash = Hashing.smearedHash(value);
+    int valueBucket = bucket(valueHash);
+    if (hashTableVToK[valueBucket] == src) {
+      hashTableVToK[valueBucket] = dest;
+    } else {
+      int prevInBucket = hashTableVToK[valueBucket];
+      for (int entryInBucket = nextInBucketVToK[prevInBucket];
+          /* should never reach end*/ ;
+          entryInBucket = nextInBucketVToK[entryInBucket]) {
+        if (entryInBucket == src) {
+          nextInBucketVToK[prevInBucket] = dest;
+          break;
+        }
+        prevInBucket = entryInBucket;
+      }
+    }
+    nextInBucketVToK[dest] = nextInBucketVToK[src];
+    nextInBucketVToK[src] = ABSENT;
+  }
+
+  @Override
+  public void clear() {
+    Arrays.fill(keys, 0, size, null);
+    Arrays.fill(values, 0, size, null);
+    Arrays.fill(hashTableKToV, ABSENT);
+    Arrays.fill(hashTableVToK, ABSENT);
+    Arrays.fill(nextInBucketKToV, 0, size, ABSENT);
+    Arrays.fill(nextInBucketVToK, 0, size, ABSENT);
+    Arrays.fill(prevInInsertionOrder, 0, size, ABSENT);
+    Arrays.fill(nextInInsertionOrder, 0, size, ABSENT);
+    size = 0;
+    firstInInsertionOrder = ENDPOINT;
+    lastInInsertionOrder = ENDPOINT;
+    modCount++;
+  }
+
+  /** Shared supertype of keySet, values, entrySet, and inverse.entrySet. */
+  abstract class View<T> extends AbstractSet<T> {
+    abstract T forEntry(int entry);
 
     @Override
-    public T next() {
-      if (!hasNext()) {
-        throw new NoSuchElementException();
-      }
+    public Iterator<T> iterator() {
+      return new Iterator<T>() {
+        private int index = firstInInsertionOrder;
+        private int indexToRemove = ABSENT;
+        private int expectedModCount = modCount;
+
+        // Calls to setValue on inverse entries can move already-visited entries to the end.
+        // Make sure we don't visit those.
+        private int remaining = size;
+
+        private void checkForComodification() {
+          if (modCount != expectedModCount) {
+            throw new ConcurrentModificationException();
+          }
+        }
+
+        @Override
+        public boolean hasNext() {
+          checkForComodification();
+          return index != ENDPOINT && remaining > 0;
+        }
+
+        @Override
+        public T next() {
+          if (!hasNext()) {
+            throw new NoSuchElementException();
+          }
+          T result = forEntry(index);
+          indexToRemove = index;
+          index = nextInInsertionOrder[index];
+          remaining--;
+          return result;
+        }
 
-      BiEntry<K, V> entry = next;
-      next = entry.nextInKeyInsertionOrder;
-      toRemove = entry;
-      return output(entry);
+        @Override
+        public void remove() {
+          checkForComodification();
+          CollectPreconditions.checkRemove(indexToRemove != ABSENT);
+          removeEntry(indexToRemove);
+          if (index == size) {
+            index = indexToRemove;
+          }
+          indexToRemove = ABSENT;
+          expectedModCount = modCount;
+        }
+      };
     }
 
     @Override
-    public void remove() {
-      if (modCount != expectedModCount) {
-        throw new ConcurrentModificationException();
-      }
-      checkRemove(toRemove != null);
-      delete(toRemove);
-      expectedModCount = modCount;
-      toRemove = null;
+    public int size() {
+      return size;
     }
 
-    abstract T output(BiEntry<K, V> entry);
+    @Override
+    public void clear() {
+      HashBiMap.this.clear();
+    }
   }
 
+  private transient Set<K> keySet;
+
   @Override
   public Set<K> keySet() {
-    return new KeySet();
+    Set<K> result = keySet;
+    return (result == null) ? keySet = new KeySet() : result;
   }
 
-  @WeakOuter
-  private final class KeySet extends Maps.KeySet<K, V> {
-    KeySet() {
-      super(HashBiMap.this);
+  final class KeySet extends View<K> {
+    @Override
+    K forEntry(int entry) {
+      return keys[entry];
     }
 
     @Override
-    public Iterator<K> iterator() {
-      return new Itr<K>() {
-        @Override
-        K output(BiEntry<K, V> entry) {
-          return entry.key;
-        }
-      };
+    public boolean contains(@Nullable Object o) {
+      return HashBiMap.this.containsKey(o);
     }
 
     @Override
     public boolean remove(@Nullable Object o) {
-      BiEntry<K, V> entry = seekByKey(o, smearedHash(o));
-      if (entry == null) {
-        return false;
-      } else {
-        delete(entry);
-        entry.prevInKeyInsertionOrder = null;
-        entry.nextInKeyInsertionOrder = null;
+      int oHash = Hashing.smearedHash(o);
+      int entry = findEntryByKey(o, oHash);
+      if (entry != ABSENT) {
+        removeEntryKeyHashKnown(entry, oHash);
         return true;
+      } else {
+        return false;
       }
     }
   }
 
+  private transient Set<V> valueSet;
+
   @Override
   public Set<V> values() {
-    return inverse().keySet();
+    Set<V> result = valueSet;
+    return (result == null) ? valueSet = new ValueSet() : result;
   }
 
-  @Override
-  Iterator<Entry<K, V>> entryIterator() {
-    return new Itr<Entry<K, V>>() {
-      @Override
-      Entry<K, V> output(BiEntry<K, V> entry) {
-        return new MapEntry(entry);
+  final class ValueSet extends View<V> {
+    @Override
+    V forEntry(int entry) {
+      return values[entry];
+    }
+
+    @Override
+    public boolean contains(@Nullable Object o) {
+      return HashBiMap.this.containsValue(o);
+    }
+
+    @Override
+    public boolean remove(@Nullable Object o) {
+      int oHash = Hashing.smearedHash(o);
+      int entry = findEntryByValue(o, oHash);
+      if (entry != ABSENT) {
+        removeEntryValueHashKnown(entry, oHash);
+        return true;
+      } else {
+        return false;
       }
+    }
+  }
 
-      class MapEntry extends AbstractMapEntry<K, V> {
-        BiEntry<K, V> delegate;
+  private transient Set<Entry<K, V>> entrySet;
 
-        MapEntry(BiEntry<K, V> entry) {
-          this.delegate = entry;
-        }
+  @Override
+  public Set<Entry<K, V>> entrySet() {
+    Set<Entry<K, V>> result = entrySet;
+    return (result == null) ? entrySet = new EntrySet() : result;
+  }
 
-        @Override
-        public K getKey() {
-          return delegate.key;
-        }
+  final class EntrySet extends View<Entry<K, V>> {
+    @Override
+    public boolean contains(@Nullable Object o) {
+      if (o instanceof Entry) {
+        Entry<?, ?> e = (Entry<?, ?>) o;
+        @Nullable Object k = e.getKey();
+        @Nullable Object v = e.getValue();
+        int eIndex = findEntryByKey(k);
+        return eIndex != ABSENT && Objects.equal(v, values[eIndex]);
+      }
+      return false;
+    }
 
-        @Override
-        public V getValue() {
-          return delegate.value;
+    @Override
+    @CanIgnoreReturnValue
+    public boolean remove(@Nullable Object o) {
+      if (o instanceof Entry) {
+        Entry<?, ?> e = (Entry<?, ?>) o;
+        @Nullable Object k = e.getKey();
+        @Nullable Object v = e.getValue();
+        int kHash = Hashing.smearedHash(k);
+        int eIndex = findEntryByKey(k, kHash);
+        if (eIndex != ABSENT && Objects.equal(v, values[eIndex])) {
+          removeEntryKeyHashKnown(eIndex, kHash);
+          return true;
         }
+      }
+      return false;
+    }
 
-        @Override
-        public V setValue(V value) {
-          V oldValue = delegate.value;
-          int valueHash = smearedHash(value);
-          if (valueHash == delegate.valueHash && Objects.equal(value, oldValue)) {
-            return value;
-          }
-          checkArgument(seekByValue(value, valueHash) == null, "value already present: %s", value);
-          delete(delegate);
-          BiEntry<K, V> newEntry = new BiEntry<>(delegate.key, delegate.keyHash, value, valueHash);
-          insert(newEntry, delegate);
-          delegate.prevInKeyInsertionOrder = null;
-          delegate.nextInKeyInsertionOrder = null;
-          expectedModCount = modCount;
-          if (toRemove == delegate) {
-            toRemove = newEntry;
-          }
-          delegate = newEntry;
-          return oldValue;
-        }
+    @Override
+    Entry<K, V> forEntry(int entry) {
+      return new EntryForKey(entry);
+    }
+  }
+
+  /**
+   * An {@code Entry} implementation that attempts to follow its key around the map -- that is, if
+   * the key is moved, deleted, or reinserted, it will account for that -- while not doing any extra
+   * work if the key has not moved.
+   */
+  final class EntryForKey extends AbstractMapEntry<K, V> {
+    @Nullable final K key;
+    int index;
+
+    EntryForKey(int index) {
+      this.key = keys[index];
+      this.index = index;
+    }
+
+    void updateIndex() {
+      if (index == ABSENT || index > size || !Objects.equal(keys[index], key)) {
+        index = findEntryByKey(key);
+      }
+    }
+
+    @Override
+    public K getKey() {
+      return key;
+    }
+
+    @Override
+    @Nullable
+    public V getValue() {
+      updateIndex();
+      return (index == ABSENT) ? null : values[index];
+    }
+
+    @Override
+    public V setValue(V value) {
+      updateIndex();
+      if (index == ABSENT) {
+        return HashBiMap.this.put(key, value);
+      }
+      V oldValue = values[index];
+      if (Objects.equal(oldValue, value)) {
+        return value;
       }
-    };
+      replaceValueInEntry(index, value, false);
+      return oldValue;
+    }
   }
 
-  @RetainedWith
   private transient BiMap<V, K> inverse;
 
   @Override
   public BiMap<V, K> inverse() {
-    return (inverse == null) ? inverse = new Inverse() : inverse;
+    BiMap<V, K> result = inverse;
+    return (result == null) ? inverse = new Inverse<K, V>(this) : result;
   }
 
-  private final class Inverse extends AbstractMap<V, K> implements BiMap<V, K>, Serializable {
-    BiMap<K, V> forward() {
-      return HashBiMap.this;
+  static class Inverse<K, V> extends AbstractMap<V, K> implements BiMap<V, K>, Serializable {
+    private final HashBiMap<K, V> forward;
+
+    Inverse(HashBiMap<K, V> forward) {
+      this.forward = forward;
     }
 
     @Override
     public int size() {
-      return size;
+      return forward.size;
     }
 
     @Override
-    public void clear() {
-      forward().clear();
+    public boolean containsKey(@Nullable Object key) {
+      return forward.containsValue(key);
     }
 
     @Override
-    public boolean containsKey(@Nullable Object value) {
-      return forward().containsValue(value);
+    @Nullable
+    public K get(@Nullable Object key) {
+      return forward.getInverse(key);
     }
 
     @Override
-    public K get(@Nullable Object value) {
-      return Maps.keyOrNull(seekByValue(value, smearedHash(value)));
+    public boolean containsValue(@Nullable Object value) {
+      return forward.containsKey(value);
     }
 
     @Override
+    @Nullable
+    @CanIgnoreReturnValue
     public K put(@Nullable V value, @Nullable K key) {
-      return putInverse(value, key, false);
+      return forward.putInverse(value, key, false);
     }
 
     @Override
+    @Nullable
+    @CanIgnoreReturnValue
     public K forcePut(@Nullable V value, @Nullable K key) {
-      return putInverse(value, key, true);
+      return forward.putInverse(value, key, true);
+    }
+
+    @Override
+    public BiMap<K, V> inverse() {
+      return forward;
     }
 
     @Override
+    @Nullable
+    @CanIgnoreReturnValue
     public K remove(@Nullable Object value) {
-      BiEntry<K, V> entry = seekByValue(value, smearedHash(value));
-      if (entry == null) {
-        return null;
-      } else {
-        delete(entry);
-        entry.prevInKeyInsertionOrder = null;
-        entry.nextInKeyInsertionOrder = null;
-        return entry.key;
-      }
+      return forward.removeInverse(value);
     }
 
     @Override
-    public BiMap<K, V> inverse() {
-      return forward();
+    public void clear() {
+      forward.clear();
     }
 
     @Override
     public Set<V> keySet() {
-      return new InverseKeySet();
+      return forward.values();
     }
 
-    @WeakOuter
-    private final class InverseKeySet extends Maps.KeySet<V, K> {
-      InverseKeySet() {
-        super(Inverse.this);
-      }
+    @Override
+    public Set<K> values() {
+      return forward.keySet();
+    }
 
-      @Override
-      public boolean remove(@Nullable Object o) {
-        BiEntry<K, V> entry = seekByValue(o, smearedHash(o));
-        if (entry == null) {
-          return false;
-        } else {
-          delete(entry);
-          return true;
-        }
-      }
+    private transient Set<Entry<V, K>> inverseEntrySet;
 
-      @Override
-      public Iterator<V> iterator() {
-        return new Itr<V>() {
-          @Override
-          V output(BiEntry<K, V> entry) {
-            return entry.value;
-          }
-        };
+    @Override
+    public Set<Entry<V, K>> entrySet() {
+      Set<Entry<V, K>> result = inverseEntrySet;
+      return (result == null) ? inverseEntrySet = forward.new InverseEntrySet() : result;
+    }
+
+    @GwtIncompatible("serialization")
+    private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
+      in.defaultReadObject();
+      this.forward.inverse = this;
+    }
+  }
+
+  class InverseEntrySet extends View<Entry<V, K>> {
+    @Override
+    public boolean contains(@Nullable Object o) {
+      if (o instanceof Entry) {
+        Entry<?, ?> e = (Entry<?, ?>) o;
+        Object v = e.getKey();
+        Object k = e.getValue();
+        int eIndex = findEntryByValue(v);
+        return eIndex != ABSENT && Objects.equal(keys[eIndex], k);
       }
+      return false;
     }
 
     @Override
-    public Set<K> values() {
-      return forward().keySet();
+    public boolean remove(Object o) {
+      if (o instanceof Entry) {
+        Entry<?, ?> e = (Entry<?, ?>) o;
+        Object v = e.getKey();
+        Object k = e.getValue();
+        int vHash = Hashing.smearedHash(v);
+        int eIndex = findEntryByValue(v, vHash);
+        if (eIndex != ABSENT && Objects.equal(keys[eIndex], k)) {
+          removeEntryValueHashKnown(eIndex, vHash);
+          return true;
+        }
+      }
+      return false;
     }
 
     @Override
-    public Set<Entry<V, K>> entrySet() {
-      return new Maps.EntrySet<V, K>() {
+    Entry<V, K> forEntry(int entry) {
+      return new EntryForValue(entry);
+    }
+  }
 
-        @Override
-        Map<V, K> map() {
-          return Inverse.this;
-        }
+  /**
+   * An {@code Entry} implementation that attempts to follow its value around the map -- that is, if
+   * the value is moved, deleted, or reinserted, it will account for that -- while not doing any
+   * extra work if the value has not moved.
+   */
+  final class EntryForValue extends AbstractMapEntry<V, K> {
+    final V value;
+    int index;
 
-        @Override
-        public Iterator<Entry<V, K>> iterator() {
-          return new Itr<Entry<V, K>>() {
-            @Override
-            Entry<V, K> output(BiEntry<K, V> entry) {
-              return new InverseEntry(entry);
-            }
-
-            class InverseEntry extends AbstractMapEntry<V, K> {
-              BiEntry<K, V> delegate;
-
-              InverseEntry(BiEntry<K, V> entry) {
-                this.delegate = entry;
-              }
-
-              @Override
-              public V getKey() {
-                return delegate.value;
-              }
-
-              @Override
-              public K getValue() {
-                return delegate.key;
-              }
-
-              @Override
-              public K setValue(K key) {
-                K oldKey = delegate.key;
-                int keyHash = smearedHash(key);
-                if (keyHash == delegate.keyHash && Objects.equal(key, oldKey)) {
-                  return key;
-                }
-                checkArgument(seekByKey(key, keyHash) == null, "value already present: %s", key);
-                delete(delegate);
-                BiEntry<K, V> newEntry =
-                    new BiEntry<>(key, keyHash, delegate.value, delegate.valueHash);
-                delegate = newEntry;
-                insert(newEntry, null);
-                expectedModCount = modCount;
-                // This is safe because entries can only get bumped up to earlier in the iteration,
-                // so they can't get revisited.
-                return oldKey;
-              }
-            }
-          };
-        }
-      };
+    EntryForValue(int index) {
+      this.value = values[index];
+      this.index = index;
     }
 
-    Object writeReplace() {
-      return new InverseSerializedForm<>(HashBiMap.this);
+    private void updateIndex() {
+      if (index == ABSENT || index > size || !Objects.equal(value, values[index])) {
+        index = findEntryByValue(value);
+      }
     }
-  }
 
-  private static final class InverseSerializedForm<K, V> implements Serializable {
-    private final HashBiMap<K, V> bimap;
+    @Override
+    public V getKey() {
+      return value;
+    }
 
-    InverseSerializedForm(HashBiMap<K, V> bimap) {
-      this.bimap = bimap;
+    @Override
+    public K getValue() {
+      updateIndex();
+      return (index == ABSENT) ? null : keys[index];
     }
 
-    Object readResolve() {
-      return bimap.inverse();
+    @Override
+    public K setValue(K key) {
+      updateIndex();
+      if (index == ABSENT) {
+        return HashBiMap.this.putInverse(value, key, false);
+      }
+      K oldKey = keys[index];
+      if (Objects.equal(oldKey, key)) {
+        return key;
+      }
+      replaceKeyInEntry(index, key, false);
+      return oldKey;
     }
   }
 
   /**
    * @serialData the number of entries, first key, first value, second key, second value, and so on.
    */
   @GwtIncompatible // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMap(this, stream);
   }
 
   @GwtIncompatible // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    init(16);
     int size = Serialization.readCount(stream);
+    init(16); // resist hostile attempts to allocate gratuitous heap
     Serialization.populateMap(this, stream, size);
   }
-
-  @GwtIncompatible // Not needed in emulated source
-  private static final long serialVersionUID = 0;
 }
