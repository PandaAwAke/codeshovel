diff --git a/android/guava/src/com/google/common/collect/HashBiMap.java b/android/guava/src/com/google/common/collect/HashBiMap.java
index 53cb700ce..d2ce96b68 100644
--- a/android/guava/src/com/google/common/collect/HashBiMap.java
+++ b/android/guava/src/com/google/common/collect/HashBiMap.java
@@ -260,124 +260,135 @@ public final class HashBiMap<K, V> extends IteratorBasedAbstractMap<K, V>
     return put(key, value, false);
   }
 
   @CanIgnoreReturnValue
   @Override
   public V forcePut(@Nullable K key, @Nullable V value) {
     return put(key, value, true);
   }
 
   private V put(@Nullable K key, @Nullable V value, boolean force) {
     int keyHash = smearedHash(key);
     int valueHash = smearedHash(value);
 
     BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
     if (oldEntryForKey != null
         && valueHash == oldEntryForKey.valueHash
         && Objects.equal(value, oldEntryForKey.value)) {
       return value;
     }
 
     BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
     if (oldEntryForValue != null) {
       if (force) {
         delete(oldEntryForValue);
       } else {
         throw new IllegalArgumentException("value already present: " + value);
       }
     }
 
     BiEntry<K, V> newEntry = new BiEntry<>(key, keyHash, value, valueHash);
     if (oldEntryForKey != null) {
       delete(oldEntryForKey);
       insert(newEntry, oldEntryForKey);
       oldEntryForKey.prevInKeyInsertionOrder = null;
       oldEntryForKey.nextInKeyInsertionOrder = null;
       rehashIfNecessary();
       return oldEntryForKey.value;
     } else {
       insert(newEntry, null);
       rehashIfNecessary();
       return null;
     }
   }
 
   @Nullable
   private K putInverse(@Nullable V value, @Nullable K key, boolean force) {
     int valueHash = smearedHash(value);
     int keyHash = smearedHash(key);
 
     BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
+    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
     if (oldEntryForValue != null
         && keyHash == oldEntryForValue.keyHash
         && Objects.equal(key, oldEntryForValue.key)) {
       return key;
+    } else if (oldEntryForKey != null && !force) {
+      throw new IllegalArgumentException("key already present: " + key);
     }
 
-    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
-    if (oldEntryForKey != null) {
-      if (force) {
-        delete(oldEntryForKey);
-      } else {
-        throw new IllegalArgumentException("value already present: " + key);
-      }
-    }
+    /*
+     * The ordering here is important: if we deleted the key entry and then the value entry,
+     * the key entry's prev or next pointer might point to the dead value entry, and when we
+     * put the new entry in the key entry's position in iteration order, it might invalidate
+     * the linked list.
+     */
 
     if (oldEntryForValue != null) {
       delete(oldEntryForValue);
     }
+
+    if (oldEntryForKey != null) {
+      delete(oldEntryForKey);
+    }
+
     BiEntry<K, V> newEntry = new BiEntry<>(key, keyHash, value, valueHash);
     insert(newEntry, oldEntryForKey);
+
     if (oldEntryForKey != null) {
       oldEntryForKey.prevInKeyInsertionOrder = null;
       oldEntryForKey.nextInKeyInsertionOrder = null;
     }
+    if (oldEntryForValue != null) {
+      oldEntryForValue.prevInKeyInsertionOrder = null;
+      oldEntryForValue.nextInKeyInsertionOrder = null;
+    }
     rehashIfNecessary();
     return Maps.keyOrNull(oldEntryForValue);
   }
 
   private void rehashIfNecessary() {
     BiEntry<K, V>[] oldKToV = hashTableKToV;
     if (Hashing.needsResizing(size, oldKToV.length, LOAD_FACTOR)) {
       int newTableSize = oldKToV.length * 2;
 
       this.hashTableKToV = createTable(newTableSize);
       this.hashTableVToK = createTable(newTableSize);
       this.mask = newTableSize - 1;
       this.size = 0;
 
       for (BiEntry<K, V> entry = firstInKeyInsertionOrder;
           entry != null;
           entry = entry.nextInKeyInsertionOrder) {
         insert(entry, entry);
       }
       this.modCount++;
     }
   }
 
   @SuppressWarnings("unchecked")
   private BiEntry<K, V>[] createTable(int length) {
     return new BiEntry[length];
   }
 
   @CanIgnoreReturnValue
   @Override
   public V remove(@Nullable Object key) {
     BiEntry<K, V> entry = seekByKey(key, smearedHash(key));
     if (entry == null) {
       return null;
     } else {
       delete(entry);
       entry.prevInKeyInsertionOrder = null;
       entry.nextInKeyInsertionOrder = null;
       return entry.value;
     }
   }
 
   @Override
   public void clear() {
     size = 0;
     Arrays.fill(hashTableKToV, null);
     Arrays.fill(hashTableVToK, null);
     firstInKeyInsertionOrder = null;
     lastInKeyInsertionOrder = null;
     modCount++;
