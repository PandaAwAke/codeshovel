diff --git a/android/guava/src/com/google/common/base/Equivalence.java b/android/guava/src/com/google/common/base/Equivalence.java
index b699b1a75..aaf36c213 100644
--- a/android/guava/src/com/google/common/base/Equivalence.java
+++ b/android/guava/src/com/google/common/base/Equivalence.java
@@ -91,101 +91,101 @@ public abstract class Equivalence<T> {
    *     one execution of an application to another execution of the same application.
    * <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code y},
    *     if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i> necessary
    *     that the hash be distributable across <i>inequivalence</i>. If {@code equivalence(x, y)} is
    *     false, {@code hash(x) == hash(y)} may still be true.
    * <li>{@code hash(null)} is {@code 0}.
    * </ul>
    */
   public final int hash(@Nullable T t) {
     if (t == null) {
       return 0;
     }
     return doHash(t);
   }
 
   /**
    * Implemented by the user to return a hash code for {@code t}, subject to the requirements
    * specified in {@link #hash}.
    *
    * <p>This method should not be called except by {@link #hash}. When {@link #hash} calls this
    * method, {@code t} is guaranteed to be non-null.
    *
    * @since 10.0 (previously, subclasses would override hash())
    */
   @ForOverride
   protected abstract int doHash(T t);
 
   /**
    * Returns a new equivalence relation for {@code F} which evaluates equivalence by first applying
    * {@code function} to the argument, then evaluating using {@code this}. That is, for any pair of
    * non-null objects {@code x} and {@code y}, {@code
    * equivalence.onResultOf(function).equivalent(a, b)} is true if and only if {@code
    * equivalence.equivalent(function.apply(a), function.apply(b))} is true.
    *
    * <p>For example:
    *
    * <pre>   {@code
    *    Equivalence<Person> SAME_AGE = Equivalence.equals().onResultOf(GET_PERSON_AGE);}</pre>
    *
    * <p>{@code function} will never be invoked with a null value.
    *
    * <p>Note that {@code function} must be consistent according to {@code this} equivalence
    * relation. That is, invoking {@link Function#apply} multiple times for a given value must return
    * equivalent results. For example,
    * {@code Equivalence.identity().onResultOf(Functions.toStringFunction())} is broken because it's
    * not guaranteed that {@link Object#toString}) always returns the same string instance.
    *
    * @since 10.0
    */
   public final <F> Equivalence<F> onResultOf(Function<F, ? extends T> function) {
-    return new FunctionalEquivalence<F, T>(function, this);
+    return new FunctionalEquivalence<>(function, this);
   }
 
   /**
    * Returns a wrapper of {@code reference} that implements {@link Wrapper#equals(Object)
    * Object.equals()} such that {@code wrap(a).equals(wrap(b))} if and only if
    * {@code equivalent(a, b)}.
    *
    * @since 10.0
    */
   public final <S extends T> Wrapper<S> wrap(@Nullable S reference) {
     return new Wrapper<S>(this, reference);
   }
 
   /**
    * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an
    * {@link Equivalence}.
    *
    * <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}
    * that tests equivalence using their lengths:
    *
    * <pre>   {@code
    *   equiv.wrap("a").equals(equiv.wrap("b")) // true
    *   equiv.wrap("a").equals(equiv.wrap("hello")) // false}</pre>
    *
    * <p>Note in particular that an equivalence wrapper is never equal to the object it wraps.
    *
    * <pre>   {@code
    *   equiv.wrap(obj).equals(obj) // always false}</pre>
    *
    * @since 10.0
    */
   public static final class Wrapper<T> implements Serializable {
     private final Equivalence<? super T> equivalence;
     @Nullable private final T reference;
 
     private Wrapper(Equivalence<? super T> equivalence, @Nullable T reference) {
       this.equivalence = checkNotNull(equivalence);
       this.reference = reference;
     }
 
     /** Returns the (possibly null) reference wrapped by this instance. */
     @Nullable
     public T get() {
       return reference;
     }
 
     /**
      * Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped
      * references is {@code true} and both wrappers use the {@link Object#equals(Object) same}
      * equivalence.
