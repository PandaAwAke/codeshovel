diff --git a/android/guava/src/com/google/common/collect/ImmutableMap.java b/android/guava/src/com/google/common/collect/ImmutableMap.java
index 23da89269..f8d2ade49 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMap.java
@@ -453,100 +453,117 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
   @CanIgnoreReturnValue
   @Deprecated
   @Override
   public final V remove(Object o) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the map unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public final void putAll(Map<? extends K, ? extends V> map) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the map unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
 
   @Override
   public boolean isEmpty() {
     return size() == 0;
   }
 
   @Override
   public boolean containsKey(@Nullable Object key) {
     return get(key) != null;
   }
 
   @Override
   public boolean containsValue(@Nullable Object value) {
     return values().contains(value);
   }
 
   // Overriding to mark it Nullable
   @Override
   public abstract V get(@Nullable Object key);
 
+  /**
+   * {@inheritDoc}
+   *
+   * <p>See <a
+   * href="https://developer.android.com/reference/java/util/Map.html#getOrDefault%28java.lang.Object,%20V%29">{@code
+   * Map.getOrDefault}</a>.
+   *
+   * @since 23.5 (but since 21.0 in the JRE <a
+   *     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>).
+   *     Note that API Level 24 users can call this method with any version of Guava.
+   */
+  // @Override under Java 8 / API Level 24
+  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
+    V result = get(key);
+    return (result != null) ? result : defaultValue;
+  }
+
   @LazyInit private transient ImmutableSet<Entry<K, V>> entrySet;
 
   /**
    * Returns an immutable set of the mappings in this map.  The iteration order is specified by
    * the method used to create this map.  Typically, this is insertion order.
    */
   @Override
   public ImmutableSet<Entry<K, V>> entrySet() {
     ImmutableSet<Entry<K, V>> result = entrySet;
     return (result == null) ? entrySet = createEntrySet() : result;
   }
 
   abstract ImmutableSet<Entry<K, V>> createEntrySet();
 
   @LazyInit private transient ImmutableSet<K> keySet;
 
   /**
    * Returns an immutable set of the keys in this map, in the same order that they appear in
    * {@link #entrySet}.
    */
   @Override
   public ImmutableSet<K> keySet() {
     ImmutableSet<K> result = keySet;
     return (result == null) ? keySet = createKeySet() : result;
   }
 
   /*
    * This could have a good default implementation of return new ImmutableKeySet<K, V>(this),
    * but ProGuard can't figure out how to eliminate that default when RegularImmutableMap
    * overrides it.
    */
   abstract ImmutableSet<K> createKeySet();
 
   UnmodifiableIterator<K> keyIterator() {
     final UnmodifiableIterator<Entry<K, V>> entryIterator = entrySet().iterator();
     return new UnmodifiableIterator<K>() {
       @Override
       public boolean hasNext() {
         return entryIterator.hasNext();
       }
 
       @Override
       public K next() {
         return entryIterator.next().getKey();
       }
     };
   }
 
   @LazyInit private transient ImmutableCollection<V> values;
 
