diff --git a/android/guava/src/com/google/common/collect/ImmutableBiMap.java b/android/guava/src/com/google/common/collect/ImmutableBiMap.java
index 15a110dab..e495505df 100644
--- a/android/guava/src/com/google/common/collect/ImmutableBiMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableBiMap.java
@@ -3,183 +3,183 @@
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Map;
 
 /**
  * A {@link BiMap} whose contents will never change, with many other important properties detailed
  * at {@link ImmutableCollection}.
  *
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 public abstract class ImmutableBiMap<K, V> extends ImmutableMap<K, V> implements BiMap<K, V> {
 
   /**
    * Returns the empty bimap.
    */
   // Casting to any type is safe because the set will never hold any elements.
   @SuppressWarnings("unchecked")
   public static <K, V> ImmutableBiMap<K, V> of() {
     return (ImmutableBiMap<K, V>) RegularImmutableBiMap.EMPTY;
   }
 
   /**
    * Returns an immutable bimap containing a single entry.
    */
   public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1) {
     checkEntryNotNull(k1, v1);
-    return new RegularImmutableBiMap<K, V>(new Object[] {k1, v1}, 1);
+    return new RegularImmutableBiMap<>(new Object[] {k1, v1}, 1);
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys or values are added
    */
   public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     return new RegularImmutableBiMap<K, V>(new Object[] {k1, v1, k2, v2}, 2);
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys or values are added
    */
   public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     return new RegularImmutableBiMap<K, V>(
         new Object[] {k1, v1, k2, v2, k3, v3}, 3);
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys or values are added
    */
   public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     checkEntryNotNull(k4, v4);
     return new RegularImmutableBiMap<K, V>(
         new Object[] {k1, v1, k2, v2, k3, v3, k4, v4}, 4);
   }
 
   /**
    * Returns an immutable map containing the given entries, in order.
    *
    * @throws IllegalArgumentException if duplicate keys or values are added
    */
   public static <K, V> ImmutableBiMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
     checkEntryNotNull(k1, v1);
     checkEntryNotNull(k2, v2);
     checkEntryNotNull(k3, v3);
     checkEntryNotNull(k4, v4);
     checkEntryNotNull(k5, v5);
     return new RegularImmutableBiMap<K, V>(
         new Object[] {k1, v1, k2, v2, k3, v3, k4, v4, k5, v5}, 5);
   }
 
   // looking for of() with > 5 entries? Use the builder instead.
 
   /**
    * Returns a new builder. The generated builder is equivalent to the builder
    * created by the {@link Builder} constructor.
    */
   public static <K, V> Builder<K, V> builder() {
-    return new Builder<K, V>();
+    return new Builder<>();
   }
 
   /**
    * Returns a new builder, expecting the specified number of entries to be added.
    *
    * <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link
    * Builder#build} is called, the builder is likely to perform better than an unsized {@link
    * #builder()} would have.
    *
    * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
    * but not exactly, the number of entries added to the builder.
    * 
    * @since 24.0
    */
   @Beta
   public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
-    return new Builder<K, V>(expectedSize);
+    return new Builder<>(expectedSize);
   }
 
   /**
    * A builder for creating immutable bimap instances, especially {@code public
    * static final} bimaps ("constant bimaps"). Example: <pre>   {@code
    *
    *   static final ImmutableBiMap<String, Integer> WORD_TO_INT =
    *       new ImmutableBiMap.Builder<String, Integer>()
    *           .put("one", 1)
    *           .put("two", 2)
    *           .put("three", 3)
    *           .build();}</pre>
    *
    * <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods
    * are even more convenient.
    *
    * <p>By default, a {@code Builder} will generate bimaps that iterate over entries in the order
    * they were inserted into the builder.  For example, in the above example,
    * {@code WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order
    * {@code "one"=1, "two"=2, "three"=3}, and {@code keySet()} and {@code values()} respect the same
    * order. If you want a different order, consider using
    * {@link #orderEntriesByValue(Comparator)}, which changes this builder to sort
    * entries by value.
    *
    * <p>Builder instances can be reused - it is safe to call {@link #build}
    * multiple times to build multiple bimaps in series. Each bimap is a superset
    * of the bimaps created before it.
    *
    * @since 2.0
    */
   public static final class Builder<K, V> extends ImmutableMap.Builder<K, V> {
     /**
      * Creates a new builder. The returned builder is equivalent to the builder
      * generated by {@link ImmutableBiMap#builder}.
      */
     public Builder() {
       super();
     }
 
     Builder(int size) {
       super(size);
     }
     
     /**
      * Associates {@code key} with {@code value} in the built bimap. Duplicate
      * keys or values are not allowed, and will cause {@link #build} to fail.
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<K, V> put(K key, V value) {
