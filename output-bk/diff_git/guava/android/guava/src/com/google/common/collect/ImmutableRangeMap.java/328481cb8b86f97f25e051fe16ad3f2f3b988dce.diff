diff --git a/android/guava/src/com/google/common/collect/ImmutableRangeMap.java b/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
index 35a8e3ae6..5477fdf4b 100644
--- a/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableRangeMap.java
@@ -42,186 +42,186 @@ import javax.annotation.Nullable;
 @GwtIncompatible // NavigableMap
 public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K, V>, Serializable {
 
   private static final ImmutableRangeMap<Comparable<?>, Object> EMPTY =
       new ImmutableRangeMap<>(ImmutableList.<Range<Comparable<?>>>of(), ImmutableList.of());
 
   /**
    * Returns an empty immutable range map.
    */
   @SuppressWarnings("unchecked")
   public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of() {
     return (ImmutableRangeMap<K, V>) EMPTY;
   }
 
   /**
    * Returns an immutable range map mapping a single range to a single value.
    */
   public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of(Range<K> range, V value) {
     return new ImmutableRangeMap<>(ImmutableList.of(range), ImmutableList.of(value));
   }
 
   @SuppressWarnings("unchecked")
   public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> copyOf(
       RangeMap<K, ? extends V> rangeMap) {
     if (rangeMap instanceof ImmutableRangeMap) {
       return (ImmutableRangeMap<K, V>) rangeMap;
     }
     Map<Range<K>, ? extends V> map = rangeMap.asMapOfRanges();
     ImmutableList.Builder<Range<K>> rangesBuilder = new ImmutableList.Builder<>(map.size());
     ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(map.size());
     for (Entry<Range<K>, ? extends V> entry : map.entrySet()) {
       rangesBuilder.add(entry.getKey());
       valuesBuilder.add(entry.getValue());
     }
     return new ImmutableRangeMap<>(rangesBuilder.build(), valuesBuilder.build());
   }
 
   /**
    * Returns a new builder for an immutable range map.
    */
   public static <K extends Comparable<?>, V> Builder<K, V> builder() {
     return new Builder<>();
   }
 
   /**
    * A builder for immutable range maps. Overlapping ranges are prohibited.
    *
    * @since 14.0
    */
   public static final class Builder<K extends Comparable<?>, V> {
-    private final List<Map.Entry<Range<K>, V>> entries;
+    private final List<Entry<Range<K>, V>> entries;
 
     public Builder() {
       this.entries = Lists.newArrayList();
     }
 
     /**
      * Associates the specified range with the specified value.
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
     @CanIgnoreReturnValue
     public Builder<K, V> put(Range<K> range, V value) {
       checkNotNull(range);
       checkNotNull(value);
       checkArgument(!range.isEmpty(), "Range must not be empty, but was %s", range);
       entries.add(Maps.immutableEntry(range, value));
       return this;
     }
 
     /**
      * Copies all associations from the specified range map into this builder.
      */
     @CanIgnoreReturnValue
     public Builder<K, V> putAll(RangeMap<K, ? extends V> rangeMap) {
       for (Entry<Range<K>, ? extends V> entry : rangeMap.asMapOfRanges().entrySet()) {
         put(entry.getKey(), entry.getValue());
       }
       return this;
     }
 
     /**
      * Returns an {@code ImmutableRangeMap} containing the associations previously added to this
      * builder.
      *
      * @throws IllegalArgumentException if any two ranges inserted into this builder overlap
      */
     public ImmutableRangeMap<K, V> build() {
       Collections.sort(entries, Range.<K>rangeLexOrdering().onKeys());
       ImmutableList.Builder<Range<K>> rangesBuilder = new ImmutableList.Builder<>(entries.size());
       ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(entries.size());
       for (int i = 0; i < entries.size(); i++) {
         Range<K> range = entries.get(i).getKey();
         if (i > 0) {
           Range<K> prevRange = entries.get(i - 1).getKey();
           if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {
             throw new IllegalArgumentException(
                 "Overlapping ranges: range " + prevRange + " overlaps with entry " + range);
           }
         }
         rangesBuilder.add(range);
         valuesBuilder.add(entries.get(i).getValue());
       }
       return new ImmutableRangeMap<>(rangesBuilder.build(), valuesBuilder.build());
     }
   }
 
   private final transient ImmutableList<Range<K>> ranges;
   private final transient ImmutableList<V> values;
 
   ImmutableRangeMap(ImmutableList<Range<K>> ranges, ImmutableList<V> values) {
     this.ranges = ranges;
     this.values = values;
   }
 
   @Override
   @Nullable
   public V get(K key) {
     int index =
         SortedLists.binarySearch(
             ranges,
             Range.<K>lowerBoundFn(),
             Cut.belowValue(key),
             KeyPresentBehavior.ANY_PRESENT,
             KeyAbsentBehavior.NEXT_LOWER);
     if (index == -1) {
       return null;
     } else {
       Range<K> range = ranges.get(index);
       return range.contains(key) ? values.get(index) : null;
     }
   }
 
   @Override
   @Nullable
-  public Map.Entry<Range<K>, V> getEntry(K key) {
+  public Entry<Range<K>, V> getEntry(K key) {
     int index =
         SortedLists.binarySearch(
             ranges,
             Range.<K>lowerBoundFn(),
             Cut.belowValue(key),
             KeyPresentBehavior.ANY_PRESENT,
             KeyAbsentBehavior.NEXT_LOWER);
     if (index == -1) {
       return null;
     } else {
       Range<K> range = ranges.get(index);
       return range.contains(key) ? Maps.immutableEntry(range, values.get(index)) : null;
     }
   }
 
   @Override
   public Range<K> span() {
     if (ranges.isEmpty()) {
       throw new NoSuchElementException();
     }
     Range<K> firstRange = ranges.get(0);
     Range<K> lastRange = ranges.get(ranges.size() - 1);
     return Range.create(firstRange.lowerBound, lastRange.upperBound);
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void put(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void putCoalescing(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
 
   /**
