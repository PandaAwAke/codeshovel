diff --git a/android/guava/src/com/google/common/collect/AbstractBiMap.java b/android/guava/src/com/google/common/collect/AbstractBiMap.java
index a7b1cdb13..018299c23 100644
--- a/android/guava/src/com/google/common/collect/AbstractBiMap.java
+++ b/android/guava/src/com/google/common/collect/AbstractBiMap.java
@@ -54,101 +54,101 @@ abstract class AbstractBiMap<K, V> extends ForwardingMap<K, V>
   @RetainedWith
   transient AbstractBiMap<V, K> inverse;
 
   /** Package-private constructor for creating a map-backed bimap. */
   AbstractBiMap(Map<K, V> forward, Map<V, K> backward) {
     setDelegates(forward, backward);
   }
 
   /** Private constructor for inverse bimap. */
   private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {
     delegate = backward;
     inverse = forward;
   }
 
   @Override
   protected Map<K, V> delegate() {
     return delegate;
   }
 
   /**
    * Returns its input, or throws an exception if this is not a valid key.
    */
   @CanIgnoreReturnValue
   K checkKey(@Nullable K key) {
     return key;
   }
 
   /**
    * Returns its input, or throws an exception if this is not a valid value.
    */
   @CanIgnoreReturnValue
   V checkValue(@Nullable V value) {
     return value;
   }
 
   /**
    * Specifies the delegate maps going in each direction. Called by the
    * constructor and by subclasses during deserialization.
    */
   void setDelegates(Map<K, V> forward, Map<V, K> backward) {
     checkState(delegate == null);
     checkState(inverse == null);
     checkArgument(forward.isEmpty());
     checkArgument(backward.isEmpty());
     checkArgument(forward != backward);
     delegate = forward;
     inverse = makeInverse(backward);
   }
 
   AbstractBiMap<V, K> makeInverse(Map<V, K> backward) {
-    return new Inverse<V, K>(backward, this);
+    return new Inverse<>(backward, this);
   }
 
   void setInverse(AbstractBiMap<V, K> inverse) {
     this.inverse = inverse;
   }
 
   // Query Operations (optimizations)
 
   @Override
   public boolean containsValue(@Nullable Object value) {
     return inverse.containsKey(value);
   }
 
   // Modification Operations
 
   @CanIgnoreReturnValue
   @Override
   public V put(@Nullable K key, @Nullable V value) {
     return putInBothMaps(key, value, false);
   }
 
   @CanIgnoreReturnValue
   @Override
   public V forcePut(@Nullable K key, @Nullable V value) {
     return putInBothMaps(key, value, true);
   }
 
   private V putInBothMaps(@Nullable K key, @Nullable V value, boolean force) {
     checkKey(key);
     checkValue(value);
     boolean containedKey = containsKey(key);
     if (containedKey && Objects.equal(value, get(key))) {
       return value;
     }
     if (force) {
       inverse().remove(value);
     } else {
       checkArgument(!containsValue(value), "value already present: %s", value);
     }
     V oldValue = delegate.put(key, value);
     updateInverseMap(key, containedKey, oldValue, value);
     return oldValue;
   }
 
   private void updateInverseMap(K key, boolean containedKey, V oldValue, V newValue) {
     if (containedKey) {
       removeFromInverseMap(oldValue);
     }
     inverse.delegate.put(newValue, key);
   }
