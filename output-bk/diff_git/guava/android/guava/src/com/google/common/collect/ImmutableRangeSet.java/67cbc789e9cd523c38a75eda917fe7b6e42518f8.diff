diff --git a/android/guava/src/com/google/common/collect/ImmutableRangeSet.java b/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
index bceeaf49d..fb7b82288 100644
--- a/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
+++ b/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
@@ -232,110 +232,110 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void addAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void remove(Range<C> range) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void removeAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void removeAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
 
   @Override
   public ImmutableSet<Range<C>> asRanges() {
     if (ranges.isEmpty()) {
       return ImmutableSet.of();
     }
-    return new RegularImmutableSortedSet<Range<C>>(ranges, Range.RANGE_LEX_ORDERING);
+    return new RegularImmutableSortedSet<Range<C>>(ranges, Range.<C>rangeLexOrdering());
   }
 
   @Override
   public ImmutableSet<Range<C>> asDescendingSetOfRanges() {
     if (ranges.isEmpty()) {
       return ImmutableSet.of();
     }
     return new RegularImmutableSortedSet<Range<C>>(
-        ranges.reverse(), Range.RANGE_LEX_ORDERING.reverse());
+        ranges.reverse(), Range.<C>rangeLexOrdering().reverse());
   }
 
   @LazyInit
   private transient ImmutableRangeSet<C> complement;
 
   private final class ComplementRanges extends ImmutableList<Range<C>> {
     // True if the "positive" range set is empty or bounded below.
     private final boolean positiveBoundedBelow;
 
     // True if the "positive" range set is empty or bounded above.
     private final boolean positiveBoundedAbove;
 
     private final int size;
 
     ComplementRanges() {
       this.positiveBoundedBelow = ranges.get(0).hasLowerBound();
       this.positiveBoundedAbove = Iterables.getLast(ranges).hasUpperBound();
 
       int size = ranges.size() - 1;
       if (positiveBoundedBelow) {
         size++;
       }
       if (positiveBoundedAbove) {
         size++;
       }
       this.size = size;
     }
 
     @Override
     public int size() {
       return size;
     }
 
     @Override
     public Range<C> get(int index) {
       checkElementIndex(index, size);
 
       Cut<C> lowerBound;
       if (positiveBoundedBelow) {
         lowerBound = (index == 0) ? Cut.<C>belowAll() : ranges.get(index - 1).upperBound;
       } else {
         lowerBound = ranges.get(index).upperBound;
       }
 
       Cut<C> upperBound;
       if (positiveBoundedAbove && index == size - 1) {
         upperBound = Cut.<C>aboveAll();
       } else {
         upperBound = ranges.get(index + (positiveBoundedBelow ? 0 : 1)).lowerBound;
       }
@@ -717,101 +717,101 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
     }
 
     // TODO(lowasser): consider adding union, in addition to add, that does allow overlap
 
     /**
      * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,
      * but overlapping ranges will cause an exception when {@link #build()} is called.
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
     @CanIgnoreReturnValue
     public Builder<C> add(Range<C> range) {
       checkArgument(!range.isEmpty(), "range must not be empty, but was %s", range);
       ranges.add(range);
       return this;
     }
 
     /**
      * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted
      * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is
      * called.
      */
     @CanIgnoreReturnValue
     public Builder<C> addAll(RangeSet<C> ranges) {
       return addAll(ranges.asRanges());
     }
 
     /**
      * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be
      * merged, but overlapping ranges will cause an exception when {@link #build()} is called.
      *
      * @throws IllegalArgumentException if any inserted ranges are empty
      * @since 21.0
      */
     @CanIgnoreReturnValue
     public Builder<C> addAll(Iterable<Range<C>> ranges) {
       for (Range<C> range : ranges) {
         add(range);
       }
       return this;
     }
 
     /**
      * Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.
      *
      * @throws IllegalArgumentException if any input ranges have nonempty overlap
      */
     public ImmutableRangeSet<C> build() {
       ImmutableList.Builder<Range<C>> mergedRangesBuilder =
           new ImmutableList.Builder<Range<C>>(ranges.size());
-      Collections.sort(ranges, Range.RANGE_LEX_ORDERING);
+      Collections.sort(ranges, Range.<C>rangeLexOrdering());
       PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());
       while (peekingItr.hasNext()) {
         Range<C> range = peekingItr.next();
         while (peekingItr.hasNext()) {
           Range<C> nextRange = peekingItr.peek();
           if (range.isConnected(nextRange)) {
             checkArgument(
                 range.intersection(nextRange).isEmpty(),
                 "Overlapping ranges not permitted but found %s overlapping %s",
                 range,
                 nextRange);
             range = range.span(peekingItr.next());
           } else {
             break;
           }
         }
         mergedRangesBuilder.add(range);
       }
       ImmutableList<Range<C>> mergedRanges = mergedRangesBuilder.build();
       if (mergedRanges.isEmpty()) {
         return of();
       } else if (mergedRanges.size() == 1
           && Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {
         return all();
       } else {
         return new ImmutableRangeSet<C>(mergedRanges);
       }
     }
   }
 
   private static final class SerializedForm<C extends Comparable> implements Serializable {
     private final ImmutableList<Range<C>> ranges;
 
     SerializedForm(ImmutableList<Range<C>> ranges) {
       this.ranges = ranges;
     }
 
     Object readResolve() {
       if (ranges.isEmpty()) {
         return of();
       } else if (ranges.equals(ImmutableList.of(Range.all()))) {
         return all();
       } else {
         return new ImmutableRangeSet<C>(ranges);
       }
     }
   }
 
   Object writeReplace() {
     return new SerializedForm<C>(ranges);
