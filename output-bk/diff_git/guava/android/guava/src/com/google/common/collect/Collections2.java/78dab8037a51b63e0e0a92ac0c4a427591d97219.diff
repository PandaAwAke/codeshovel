diff --git a/android/guava/src/com/google/common/collect/Collections2.java b/android/guava/src/com/google/common/collect/Collections2.java
index 0c575ed44..5075c4e0c 100644
--- a/android/guava/src/com/google/common/collect/Collections2.java
+++ b/android/guava/src/com/google/common/collect/Collections2.java
@@ -1,72 +1,71 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
-import static com.google.common.math.LongMath.binomial;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.math.IntMath;
 import com.google.common.primitives.Ints;
 import java.util.AbstractCollection;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
  * Provides static methods for working with {@code Collection} instances.
  *
  * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed
  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for
  * comparisons. These methods are not being deprecated, but we gently encourage you to migrate to
  * streams.
  *
  * @author Chris Povirk
  * @author Mike Bostock
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible
 public final class Collections2 {
   private Collections2() {}
 
   /**
    * Returns the elements of {@code unfiltered} that satisfy a predicate. The
    * returned collection is a live view of {@code unfiltered}; changes to one
    * affect the other.
    *
    * <p>The resulting collection's iterator does not support {@code remove()},
    * but all other collection methods are supported. When given an element that
    * doesn't satisfy the predicate, the collection's {@code add()} and {@code
    * addAll()} methods throw an {@link IllegalArgumentException}. When methods
    * such as {@code removeAll()} and {@code clear()} are called on the filtered
    * collection, only elements that satisfy the filter will be removed from the
    * underlying collection.
    *
    * <p>The returned collection isn't threadsafe or serializable, even if
@@ -417,121 +416,117 @@ public final class Collections2 {
    *   // -> [2, 2, 1, 1]}</pre>
    *
    * <p><i>Notes:</i> This is an implementation of the algorithm for
    * Lexicographical Permutations Generation, described in Knuth's "The Art of
    * Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. The
    * iteration order follows the lexicographical order. This means that
    * the first permutation will be in ascending order, and the last will be in
    * descending order.
    *
    * <p>Elements that compare equal are considered equal and no new permutations
    * are created by swapping them.
    *
    * <p>An empty iterable has only one permutation, which is an empty list.
    *
    * @param elements the original iterable whose elements have to be permuted.
    * @param comparator a comparator for the iterable's elements.
    * @return an immutable {@link Collection} containing all the different
    *     permutations of the original iterable.
    * @throws NullPointerException If the specified iterable is null, has any
    *     null elements, or if the specified comparator is null.
    * @since 12.0
    */
   @Beta
   public static <E> Collection<List<E>> orderedPermutations(
       Iterable<E> elements, Comparator<? super E> comparator) {
     return new OrderedPermutationCollection<E>(elements, comparator);
   }
 
   private static final class OrderedPermutationCollection<E> extends AbstractCollection<List<E>> {
     final ImmutableList<E> inputList;
     final Comparator<? super E> comparator;
     final int size;
 
     OrderedPermutationCollection(Iterable<E> input, Comparator<? super E> comparator) {
       this.inputList = ImmutableList.sortedCopyOf(comparator, input);
       this.comparator = comparator;
       this.size = calculateSize(inputList, comparator);
     }
 
     /**
      * The number of permutations with repeated elements is calculated as
      * follows:
      * <ul>
      * <li>For an empty list, it is 1 (base case).</li>
      * <li>When r numbers are added to a list of n-r elements, the number of
      * permutations is increased by a factor of (n choose r).</li>
      * </ul>
      */
     private static <E> int calculateSize(
         List<E> sortedInputList, Comparator<? super E> comparator) {
-      long permutations = 1;
+      int permutations = 1;
       int n = 1;
       int r = 1;
       while (n < sortedInputList.size()) {
         int comparison = comparator.compare(sortedInputList.get(n - 1), sortedInputList.get(n));
         if (comparison < 0) {
           // We move to the next non-repeated element.
-          permutations *= binomial(n, r);
+          permutations = IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));
           r = 0;
-          if (!isPositiveInt(permutations)) {
+          if (permutations == Integer.MAX_VALUE) {
             return Integer.MAX_VALUE;
           }
         }
         n++;
         r++;
       }
-      permutations *= binomial(n, r);
-      if (!isPositiveInt(permutations)) {
-        return Integer.MAX_VALUE;
-      }
-      return (int) permutations;
+      return IntMath.saturatedMultiply(permutations, IntMath.binomial(n, r));
     }
 
     @Override
     public int size() {
       return size;
     }
 
     @Override
     public boolean isEmpty() {
       return false;
     }
 
     @Override
     public Iterator<List<E>> iterator() {
       return new OrderedPermutationIterator<E>(inputList, comparator);
     }
 
     @Override
     public boolean contains(@Nullable Object obj) {
       if (obj instanceof List) {
         List<?> list = (List<?>) obj;
         return isPermutation(inputList, list);
       }
       return false;
     }
 
     @Override
     public String toString() {
       return "orderedPermutationCollection(" + inputList + ")";
     }
   }
 
   private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
 
     List<E> nextPermutation;
     final Comparator<? super E> comparator;
 
     OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator) {
       this.nextPermutation = Lists.newArrayList(list);
       this.comparator = comparator;
     }
 
     @Override
     protected List<E> computeNext() {
       if (nextPermutation == null) {
         return endOfData();
       }
       ImmutableList<E> next = ImmutableList.copyOf(nextPermutation);
       calculateNextPermutation();
       return next;
@@ -662,55 +657,51 @@ public final class Collections2 {
       j = list.size() - 1;
       int s = 0;
 
       // Handle the special case of an empty list. Skip the calculation of the
       // next permutation.
       if (j == -1) {
         return;
       }
 
       while (true) {
         int q = c[j] + o[j];
         if (q < 0) {
           switchDirection();
           continue;
         }
         if (q == j + 1) {
           if (j == 0) {
             break;
           }
           s++;
           switchDirection();
           continue;
         }
 
         Collections.swap(list, j - c[j] + s, j - q + s);
         c[j] = q;
         break;
       }
     }
 
     void switchDirection() {
       o[j] = -o[j];
       j--;
     }
   }
 
   /**
    * Returns {@code true} if the second list is a permutation of the first.
    */
   private static boolean isPermutation(List<?> first, List<?> second) {
     return first.size() == second.size() && counts(first).equals(counts(second));
   }
   
   private static <E> Set<Multiset.Entry<E>> counts(Collection<E> collection) {
     AbstractObjectCountMap<E> map = new ObjectCountHashMap<>();
     for (E e : collection) {
       map.put(e, map.get(e) + 1);
     }
     return map.entrySet();
   }
-
-  private static boolean isPositiveInt(long n) {
-    return n >= 0 && n <= Integer.MAX_VALUE;
-  }
 }
