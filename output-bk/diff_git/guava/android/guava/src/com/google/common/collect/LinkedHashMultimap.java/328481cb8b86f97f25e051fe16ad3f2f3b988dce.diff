diff --git a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
index f09dee93d..f0ef8f556 100644
--- a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -1,87 +1,88 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
  * Implementation of {@code Multimap} that does not allow duplicate key-value
  * entries and that returns collections whose iterators follow the ordering in
  * which the data was added to the multimap.
  *
  * <p>The collections returned by {@code keySet}, {@code keys}, and {@code
  * asMap} iterate through the keys in the order they were first added to the
  * multimap. Similarly, {@code get}, {@code removeAll}, and {@code
  * replaceValues} return collections that iterate through the values in the
  * order they were added. The collections generated by {@code entries} and
  * {@code values} iterate across the key-value mappings in the order they were
  * added to the multimap.
  *
  * <p>The iteration ordering of the collections generated by {@code keySet},
  * {@code keys}, and {@code asMap} has a few subtleties. As long as the set of
  * keys remains unchanged, adding or removing mappings does not affect the key
  * iteration order. However, if you remove all values associated with a key and
  * then add the key back to the multimap, that key will come last in the key
  * iteration order.
  *
  * <p>The multimap does not store duplicate key-value pairs. Adding a new
  * key-value pair equal to an existing key-value pair has no effect.
  *
  * <p>Keys and values may be null. All optional multimap methods are supported,
  * and all returned views are modifiable.
  *
  * <p>This class is not threadsafe when any concurrent operations update the
  * multimap. Concurrent read operations will work correctly. To allow concurrent
  * update operations, wrap your multimap with a call to {@link
  * Multimaps#synchronizedSetMultimap}.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">
  * {@code Multimap}</a>.
  *
  * @author Jared Levy
  * @author Louis Wasserman
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 public final class LinkedHashMultimap<K, V>
     extends LinkedHashMultimapGwtSerializationDependencies<K, V> {
 
   /**
    * Creates a new, empty {@code LinkedHashMultimap} with the default initial
    * capacities.
@@ -241,101 +242,101 @@ public final class LinkedHashMultimap<K, V>
    *
    * @return a new {@code LinkedHashSet} containing a collection of values for
    *     one key
    */
   @Override
   Set<V> createCollection() {
     return new LinkedHashSet<V>(valueSetCapacity);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>Creates a decorated insertion-ordered set that also keeps track of the
    * order in which key-value pairs are added to the multimap.
    *
    * @param key key to associate with values in the collection
    * @return a new decorated set containing a collection of values for one key
    */
   @Override
   Collection<V> createCollection(K key) {
     return new ValueSet(key, valueSetCapacity);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>If {@code values} is not empty and the multimap already contains a
    * mapping for {@code key}, the {@code keySet()} ordering is unchanged.
    * However, the provided values always come last in the {@link #entries()} and
    * {@link #values()} iteration orderings.
    */
   @CanIgnoreReturnValue
   @Override
   public Set<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     return super.replaceValues(key, values);
   }
 
   /**
    * Returns a set of all key-value pairs. Changes to the returned set will
    * update the underlying multimap, and vice versa. The entries set does not
    * support the {@code add} or {@code addAll} operations.
    *
    * <p>The iterator generated by the returned set traverses the entries in the
    * order they were added to the multimap.
    *
    * <p>Each entry is an immutable snapshot of a key-value mapping in the
    * multimap, taken at the time the entry is returned by a method call to the
    * collection or its iterator.
    */
   @Override
-  public Set<Map.Entry<K, V>> entries() {
+  public Set<Entry<K, V>> entries() {
     return super.entries();
   }
 
   /**
    * Returns a view collection of all <i>distinct</i> keys contained in this
    * multimap. Note that the key set contains a key if and only if this multimap
    * maps that key to at least one value.
    *
    * <p>The iterator generated by the returned set traverses the keys in the
    * order they were first added to the multimap.
    *
    * <p>Changes to the returned set will update the underlying multimap, and
    * vice versa. However, <i>adding</i> to the returned set is not possible.
    */
   @Override
   public Set<K> keySet() {
     return super.keySet();
   }
 
   /**
    * Returns a collection of all values in the multimap. Changes to the returned
    * collection will update the underlying multimap, and vice versa.
    *
    * <p>The iterator generated by the returned collection traverses the values
    * in the order they were added to the multimap.
    */
   @Override
   public Collection<V> values() {
     return super.values();
   }
 
   @VisibleForTesting
   @WeakOuter
   final class ValueSet extends Sets.ImprovedAbstractSet<V> implements ValueSetLink<K, V> {
     /*
      * We currently use a fixed load factor of 1.0, a bit higher than normal to reduce memory
      * consumption.
      */
 
     private final K key;
     @VisibleForTesting ValueEntry<K, V>[] hashTable;
     private int size = 0;
     private int modCount = 0;
 
     // We use the set object itself as the end of the linked list, avoiding an unnecessary
     // entry object per key.
     private ValueSetLink<K, V> firstEntry;
     private ValueSetLink<K, V> lastEntry;
 
     ValueSet(K key, int expectedValues) {
@@ -469,136 +470,136 @@ public final class LinkedHashMultimap<K, V>
           ValueEntry<K, V> valueEntry = (ValueEntry<K, V>) entry;
           int bucket = valueEntry.smearedValueHash & mask;
           valueEntry.nextInValueBucket = hashTable[bucket];
           hashTable[bucket] = valueEntry;
         }
       }
     }
 
     @CanIgnoreReturnValue
     @Override
     public boolean remove(@Nullable Object o) {
       int smearedHash = Hashing.smearedHash(o);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> prev = null;
       for (ValueEntry<K, V> entry = hashTable[bucket];
           entry != null;
           prev = entry, entry = entry.nextInValueBucket) {
         if (entry.matchesValue(o, smearedHash)) {
           if (prev == null) {
             // first entry in the bucket
             hashTable[bucket] = entry.nextInValueBucket;
           } else {
             prev.nextInValueBucket = entry.nextInValueBucket;
           }
           deleteFromValueSet(entry);
           deleteFromMultimap(entry);
           size--;
           modCount++;
           return true;
         }
       }
       return false;
     }
 
     @Override
     public void clear() {
       Arrays.fill(hashTable, null);
       size = 0;
       for (ValueSetLink<K, V> entry = firstEntry;
           entry != this;
           entry = entry.getSuccessorInValueSet()) {
         ValueEntry<K, V> valueEntry = (ValueEntry<K, V>) entry;
         deleteFromMultimap(valueEntry);
       }
       succeedsInValueSet(this, this);
       modCount++;
     }
   }
 
   @Override
-  Iterator<Map.Entry<K, V>> entryIterator() {
-    return new Iterator<Map.Entry<K, V>>() {
+  Iterator<Entry<K, V>> entryIterator() {
+    return new Iterator<Entry<K, V>>() {
       ValueEntry<K, V> nextEntry = multimapHeaderEntry.successorInMultimap;
       ValueEntry<K, V> toRemove;
 
       @Override
       public boolean hasNext() {
         return nextEntry != multimapHeaderEntry;
       }
 
       @Override
-      public Map.Entry<K, V> next() {
+      public Entry<K, V> next() {
         if (!hasNext()) {
           throw new NoSuchElementException();
         }
         ValueEntry<K, V> result = nextEntry;
         toRemove = result;
         nextEntry = nextEntry.successorInMultimap;
         return result;
       }
 
       @Override
       public void remove() {
         checkRemove(toRemove != null);
         LinkedHashMultimap.this.remove(toRemove.getKey(), toRemove.getValue());
         toRemove = null;
       }
     };
   }
 
   @Override
   Iterator<V> valueIterator() {
     return Maps.valueIterator(entryIterator());
   }
 
   @Override
   public void clear() {
     super.clear();
     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
   }
 
   /**
    * @serialData the expected values per key, the number of distinct keys,
    * the number of entries, and the entries in order
    */
   @GwtIncompatible // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(keySet().size());
     for (K key : keySet()) {
       stream.writeObject(key);
     }
     stream.writeInt(size());
-    for (Map.Entry<K, V> entry : entries()) {
+    for (Entry<K, V> entry : entries()) {
       stream.writeObject(entry.getKey());
       stream.writeObject(entry.getValue());
     }
   }
 
   @GwtIncompatible // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     multimapHeaderEntry = new ValueEntry<>(null, null, 0, null);
     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
     valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
     int distinctKeys = stream.readInt();
     Map<K, Collection<V>> map = new LinkedHashMap<>();
     for (int i = 0; i < distinctKeys; i++) {
       @SuppressWarnings("unchecked")
       K key = (K) stream.readObject();
       map.put(key, createCollection(key));
     }
     int entries = stream.readInt();
     for (int i = 0; i < entries; i++) {
       @SuppressWarnings("unchecked")
       K key = (K) stream.readObject();
       @SuppressWarnings("unchecked")
       V value = (V) stream.readObject();
       map.get(key).add(value);
     }
     setMap(map);
   }
 
   @GwtIncompatible // java serialization not supported
   private static final long serialVersionUID = 1;
 }
