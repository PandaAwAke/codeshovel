diff --git a/android/guava/src/com/google/common/collect/ImmutableSetMultimap.java b/android/guava/src/com/google/common/collect/ImmutableSetMultimap.java
index 887a12e08..e43c81f79 100644
--- a/android/guava/src/com/google/common/collect/ImmutableSetMultimap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableSetMultimap.java
@@ -1,87 +1,86 @@
 /*
  * Copyright (C) 2009 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.MoreObjects;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
 import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 
 /**
  * A {@link SetMultimap} whose contents will never change, with many other important properties
  * detailed at {@link ImmutableCollection}.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">
  * immutable collections</a>.
  *
  * @author Mike Ward
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
     implements SetMultimap<K, V> {
 
   /** Returns the empty multimap. */
   // Casting is safe because the multimap will never hold any elements.
   @SuppressWarnings("unchecked")
   public static <K, V> ImmutableSetMultimap<K, V> of() {
     return (ImmutableSetMultimap<K, V>) EmptyImmutableSetMultimap.INSTANCE;
   }
 
   /**
    * Returns an immutable multimap containing a single entry.
    */
   public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1) {
     ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();
     builder.put(k1, v1);
     return builder.build();
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in order.
    * Repeated occurrences of an entry (according to {@link Object#equals}) after
    * the first are ignored.
    */
   public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1, K k2, V v2) {
     ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();
     builder.put(k1, v1);
     builder.put(k2, v2);
     return builder.build();
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in order.
    * Repeated occurrences of an entry (according to {@link Object#equals}) after
    * the first are ignored.
@@ -215,105 +214,105 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
 
     @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
       for (Entry<? extends K, ? extends Collection<? extends V>> entry :
           multimap.asMap().entrySet()) {
         putAll(entry.getKey(), entry.getValue());
       }
       return this;
     }
 
     /**
      * {@inheritDoc}
      *
      * @since 8.0
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
       this.keyComparator = checkNotNull(keyComparator);
       return this;
     }
 
     /**
      * Specifies the ordering of the generated multimap's values for each key.
      *
      * <p>If this method is called, the sets returned by the {@code get()}
      * method of the generated multimap and its {@link Multimap#asMap()} view
      * are {@link ImmutableSortedSet} instances. However, serialization does not
      * preserve that property, though it does maintain the key and value
      * ordering.
      *
      * @since 8.0
      */
     // TODO: Make serialization behavior consistent.
     @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
       super.orderValuesBy(valueComparator);
       return this;
     }
 
     /**
      * Returns a newly-created immutable set multimap.
      */
     @Override
     public ImmutableSetMultimap<K, V> build() {
       if (keyComparator != null) {
         Multimap<K, V> sortedCopy =
             MultimapBuilder.linkedHashKeys().linkedHashSetValues().<K, V>build();
-        List<Map.Entry<K, Collection<V>>> entries =
+        List<Entry<K, Collection<V>>> entries =
             Ordering.from(keyComparator)
                 .<K>onKeys()
                 .immutableSortedCopy(builderMultimap.asMap().entrySet());
-        for (Map.Entry<K, Collection<V>> entry : entries) {
+        for (Entry<K, Collection<V>> entry : entries) {
           sortedCopy.putAll(entry.getKey(), entry.getValue());
         }
         builderMultimap = sortedCopy;
       }
       return copyOf(builderMultimap, valueComparator);
     }
   }
 
   /**
    * Returns an immutable set multimap containing the same mappings as
    * {@code multimap}. The generated multimap's key and value orderings
    * correspond to the iteration ordering of the {@code multimap.asMap()} view.
    * Repeated occurrences of an entry in the multimap after the first are
    * ignored.
    *
    * <p>Despite the method name, this method attempts to avoid actually copying
    * the data when it is safe to do so. The exact circumstances under which a
    * copy will or will not be performed are undocumented and subject to change.
    *
    * @throws NullPointerException if any key or value in {@code multimap} is
    *     null
    */
   public static <K, V> ImmutableSetMultimap<K, V> copyOf(
       Multimap<? extends K, ? extends V> multimap) {
     return copyOf(multimap, null);
   }
 
   private static <K, V> ImmutableSetMultimap<K, V> copyOf(
       Multimap<? extends K, ? extends V> multimap, Comparator<? super V> valueComparator) {
     checkNotNull(multimap); // eager for GWT
     if (multimap.isEmpty() && valueComparator == null) {
       return of();
     }
 
     if (multimap instanceof ImmutableSetMultimap) {
       @SuppressWarnings("unchecked") // safe since multimap is not writable
       ImmutableSetMultimap<K, V> kvMultimap = (ImmutableSetMultimap<K, V>) multimap;
       if (!kvMultimap.isPartialView()) {
         return kvMultimap;
       }
     }
 
     ImmutableMap.Builder<K, ImmutableSet<V>> builder =
         new ImmutableMap.Builder<>(multimap.asMap().size());
     int size = 0;
 
     for (Entry<? extends K, ? extends Collection<? extends V>> entry :
         multimap.asMap().entrySet()) {
       K key = entry.getKey();
       Collection<? extends V> values = entry.getValue();
