diff --git a/android/guava/src/com/google/common/collect/Iterators.java b/android/guava/src/com/google/common/collect/Iterators.java
index ec18ad177..0653a666a 100644
--- a/android/guava/src/com/google/common/collect/Iterators.java
+++ b/android/guava/src/com/google/common/collect/Iterators.java
@@ -1296,128 +1296,150 @@ public final class Iterators {
    * An iterator that performs a lazy N-way merge, calculating the next value
    * each time the iterator is polled. This amortizes the sorting cost over the
    * iteration and requires less memory than sorting all elements at once.
    *
    * <p>Retrieving a single element takes approximately O(log(M)) time, where M
    * is the number of iterators. (Retrieving all elements takes approximately
    * O(N*log(M)) time, where N is the total number of elements.)
    */
   private static class MergingIterator<T> extends UnmodifiableIterator<T> {
     final Queue<PeekingIterator<T>> queue;
 
     public MergingIterator(
         Iterable<? extends Iterator<? extends T>> iterators,
         final Comparator<? super T> itemComparator) {
       // A comparator that's used by the heap, allowing the heap
       // to be sorted based on the top of each iterator.
       Comparator<PeekingIterator<T>> heapComparator =
           new Comparator<PeekingIterator<T>>() {
             @Override
             public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2) {
               return itemComparator.compare(o1.peek(), o2.peek());
             }
           };
 
       queue = new PriorityQueue<PeekingIterator<T>>(2, heapComparator);
 
       for (Iterator<? extends T> iterator : iterators) {
         if (iterator.hasNext()) {
           queue.add(Iterators.peekingIterator(iterator));
         }
       }
     }
 
     @Override
     public boolean hasNext() {
       return !queue.isEmpty();
     }
 
     @Override
     public T next() {
       PeekingIterator<T> nextIter = queue.remove();
       T next = nextIter.next();
       if (nextIter.hasNext()) {
         queue.add(nextIter);
       }
       return next;
     }
   }
 
   private static class ConcatenatedIterator<T> implements Iterator<T> {
+    /* The last iterator to return an element.  Calls to remove() go to this iterator. */
     private Iterator<? extends T> toRemove;
 
-    private Iterator<? extends T> iterator = emptyIterator();
+    /* The iterator currently returning elements. */
+    private Iterator<? extends T> iterator;
+
+    /*
+     * We track the "meta iterators," the iterators-of-iterators, below.  Usually, topMetaIterator
+     * is the only one in use, but if we encounter nested concatenations, we start a deque of
+     * meta-iterators rather than letting the nesting get arbitrarily deep.  This keeps each
+     * operation O(1).
+     */
+
+    private Iterator<? extends Iterator<? extends T>> topMetaIterator;
+
+    // Only becomes nonnull if we encounter nested concatenations.
+    @Nullable
     private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
 
     ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {
-      this.metaIterators = new ArrayDeque<>();
-      metaIterators.addFirst(checkNotNull(metaIterator));
+      iterator = emptyIterator();
+      topMetaIterator = checkNotNull(metaIterator);
+    }
+
+    // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
+    @Nullable
+    private Iterator<? extends Iterator<? extends T>> getTopMetaIterator() {
+      while (topMetaIterator == null || !topMetaIterator.hasNext()) {
+        if (metaIterators != null && !metaIterators.isEmpty()) {
+          topMetaIterator = metaIterators.removeFirst();
+        } else {
+          return null;
+        }
+      }
+      return topMetaIterator;
     }
 
     @Override
     public boolean hasNext() {
       while (!checkNotNull(iterator).hasNext()) {
         // this weird checkNotNull positioning appears required by our tests, which expect
         // both hasNext and next to throw NPE if an input iterator is null.
 
-        if (metaIterators.isEmpty()) {
+        topMetaIterator = getTopMetaIterator();
+        if (topMetaIterator == null) {
           return false;
         }
-        Iterator<? extends Iterator<? extends T>> topMeta = checkNotNull(metaIterators.getFirst());
 
-        if (!topMeta.hasNext()) {
-          metaIterators.removeFirst();
-          continue;
-        }
-        iterator = topMeta.next();
+        iterator = topMetaIterator.next();
 
         if (iterator instanceof ConcatenatedIterator) {
           // Instead of taking linear time in the number of nested concatenations, unpack
           // them into the queue
           @SuppressWarnings("unchecked")
           ConcatenatedIterator<T> topConcat = (ConcatenatedIterator<T>) iterator;
           iterator = topConcat.iterator;
-          metaIterators = smushTogether(topConcat.metaIterators, metaIterators);
-        }
-      }
-      return true;
-    }
 
-    private static <E> Deque<E> smushTogether(Deque<E> first, Deque<E> second) {
-      if (first.size() >= second.size()) {
-        while (!second.isEmpty()) {
-          first.addLast(second.removeFirst());
-        }
-        return first;
-      } else {
-        while (!first.isEmpty()) {
-          second.addFirst(first.removeLast());
+          // topConcat.topMetaIterator, then topConcat.metaIterators, then this.topMetaIterator,
+          // then this.metaIterators
+
+          if (this.metaIterators == null) {
+            this.metaIterators = new ArrayDeque<>();
+          }
+          this.metaIterators.addFirst(this.topMetaIterator);
+          if (topConcat.metaIterators != null) {
+            while (!topConcat.metaIterators.isEmpty()) {
+              this.metaIterators.addFirst(topConcat.metaIterators.removeLast());
+            }
+          }
+          this.topMetaIterator = topConcat.topMetaIterator;
         }
-        return second;
       }
+      return true;
     }
 
     @Override
     public T next() {
       if (hasNext()) {
         toRemove = iterator;
         return iterator.next();
       } else {
         throw new NoSuchElementException();
       }
     }
 
     @Override
     public void remove() {
       CollectPreconditions.checkRemove(toRemove != null);
       toRemove.remove();
       toRemove = null;
     }
   }
 
   /**
    * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557
    */
   static <T> ListIterator<T> cast(Iterator<T> iterator) {
     return (ListIterator<T>) iterator;
   }
 }
