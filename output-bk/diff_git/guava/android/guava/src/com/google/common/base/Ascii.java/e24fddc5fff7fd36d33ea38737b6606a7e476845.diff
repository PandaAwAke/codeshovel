diff --git a/android/guava/src/com/google/common/base/Ascii.java b/android/guava/src/com/google/common/base/Ascii.java
index 564230eff..0a8ec5075 100644
--- a/android/guava/src/com/google/common/base/Ascii.java
+++ b/android/guava/src/com/google/common/base/Ascii.java
@@ -1,85 +1,85 @@
 /*
  * Copyright (C) 2010 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
 
 /**
  * Static methods pertaining to ASCII characters (those in the range of values {@code 0x00} through
  * {@code 0x7F}), and to strings containing such characters.
  *
  * <p>ASCII utilities also exist in other classes of this package:
  *
  * <ul>
  *   <!-- TODO(kevinb): how can we make this not produce a warning when building gwt javadoc? -->
  *   <li>{@link Charsets#US_ASCII} specifies the {@code Charset} of ASCII characters.
  *   <li>{@link CharMatcher#ascii} matches ASCII characters and provides text processing methods
  *       which operate only on the ASCII characters of a string.
  * </ul>
  *
- * @author Craig Berry
+ * @author Catherine Berry
  * @author Gregory Kick
  * @since 7.0
  */
 @GwtCompatible
 public final class Ascii {
 
   private Ascii() {}
 
   /* The ASCII control characters, per RFC 20. */
   /**
    * Null ('\0'): The all-zeros character which may serve to accomplish time fill and media fill.
    * Normally used as a C string terminator.
    *
    * <p>Although RFC 20 names this as "Null", note that it is distinct from the C/C++ "NULL"
    * pointer.
    *
    * @since 8.0
    */
   public static final byte NUL = 0;
 
   /**
    * Start of Heading: A communication control character used at the beginning of a sequence of
    * characters which constitute a machine-sensible address or routing information. Such a sequence
    * is referred to as the "heading." An STX character has the effect of terminating a heading.
    *
    * @since 8.0
    */
   public static final byte SOH = 1;
 
   /**
    * Start of Text: A communication control character which precedes a sequence of characters that
    * is to be treated as an entity and entirely transmitted through to the ultimate destination.
    * Such a sequence is referred to as "text." STX may be used to terminate a sequence of characters
    * started by SOH.
    *
    * @since 8.0
    */
   public static final byte STX = 2;
 
   /**
    * End of Text: A communication control character used to terminate a sequence of characters
    * started with STX and transmitted as an entity.
    *
    * @since 8.0
    */
   public static final byte ETX = 3;
 
   /**
    * End of Transmission: A communication control character used to indicate the conclusion of a
    * transmission, which may have contained one or more texts and any associated headings.
@@ -348,194 +348,197 @@ public final class Ascii {
   public static final byte RS = 30;
 
   /**
    * Unit Separator: These four information separators may be used within data in optional fashion,
    * except that their hierarchical relationship shall be: FS is the most inclusive, then GS, then
    * RS, and US is least inclusive. (The content and length of a File, Group, Record, or Unit are
    * not specified.)
    *
    * @since 8.0
    */
   public static final byte US = 31;
 
   /**
    * Space: A normally non-printing graphic character used to separate words. It is also a format
    * effector which controls the movement of the printing position, one printing position forward.
    * (Applicable also to display devices.)
    *
    * @since 8.0
    */
   public static final byte SP = 32;
 
   /**
    * Alternate name for {@link #SP}.
    *
    * @since 8.0
    */
   public static final byte SPACE = 32;
 
   /**
    * Delete: This character is used primarily to "erase" or "obliterate" erroneous or unwanted
    * characters in perforated tape.
    *
    * @since 8.0
    */
   public static final byte DEL = 127;
 
   /**
    * The minimum value of an ASCII character.
    *
    * @since 9.0 (was type {@code int} before 12.0)
    */
   public static final char MIN = 0;
 
   /**
    * The maximum value of an ASCII character.
    *
    * @since 9.0 (was type {@code int} before 12.0)
    */
   public static final char MAX = 127;
 
+  /** A bit mask which selects the bit encoding ASCII character case. */
+  private static final char CASE_MASK = 0x20;
+
   /**
    * Returns a copy of the input string in which all {@linkplain #isUpperCase(char) uppercase ASCII
    * characters} have been converted to lowercase. All other characters are copied without
    * modification.
    */
   public static String toLowerCase(String string) {
     int length = string.length();
     for (int i = 0; i < length; i++) {
       if (isUpperCase(string.charAt(i))) {
         char[] chars = string.toCharArray();
         for (; i < length; i++) {
           char c = chars[i];
           if (isUpperCase(c)) {
-            chars[i] = (char) (c ^ 0x20);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
       }
     }
     return string;
   }
 
   /**
    * Returns a copy of the input character sequence in which all {@linkplain #isUpperCase(char)
    * uppercase ASCII characters} have been converted to lowercase. All other characters are copied
    * without modification.
    *
    * @since 14.0
    */
   public static String toLowerCase(CharSequence chars) {
     if (chars instanceof String) {
       return toLowerCase((String) chars);
     }
     char[] newChars = new char[chars.length()];
     for (int i = 0; i < newChars.length; i++) {
       newChars[i] = toLowerCase(chars.charAt(i));
     }
     return String.valueOf(newChars);
   }
 
   /**
    * If the argument is an {@linkplain #isUpperCase(char) uppercase ASCII character} returns the
    * lowercase equivalent. Otherwise returns the argument.
    */
   public static char toLowerCase(char c) {
-    return isUpperCase(c) ? (char) (c ^ 0x20) : c;
+    return isUpperCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
    * Returns a copy of the input string in which all {@linkplain #isLowerCase(char) lowercase ASCII
    * characters} have been converted to uppercase. All other characters are copied without
    * modification.
    */
   public static String toUpperCase(String string) {
     int length = string.length();
     for (int i = 0; i < length; i++) {
       if (isLowerCase(string.charAt(i))) {
         char[] chars = string.toCharArray();
         for (; i < length; i++) {
           char c = chars[i];
           if (isLowerCase(c)) {
-            chars[i] = (char) (c & 0x5f);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
       }
     }
     return string;
   }
 
   /**
    * Returns a copy of the input character sequence in which all {@linkplain #isLowerCase(char)
    * lowercase ASCII characters} have been converted to uppercase. All other characters are copied
    * without modification.
    *
    * @since 14.0
    */
   public static String toUpperCase(CharSequence chars) {
     if (chars instanceof String) {
       return toUpperCase((String) chars);
     }
     char[] newChars = new char[chars.length()];
     for (int i = 0; i < newChars.length; i++) {
       newChars[i] = toUpperCase(chars.charAt(i));
     }
     return String.valueOf(newChars);
   }
 
   /**
    * If the argument is a {@linkplain #isLowerCase(char) lowercase ASCII character} returns the
    * uppercase equivalent. Otherwise returns the argument.
    */
   public static char toUpperCase(char c) {
-    return isLowerCase(c) ? (char) (c & 0x5f) : c;
+    return isLowerCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
    * Indicates whether {@code c} is one of the twenty-six lowercase ASCII alphabetic characters
    * between {@code 'a'} and {@code 'z'} inclusive. All others (including non-ASCII characters)
    * return {@code false}.
    */
   public static boolean isLowerCase(char c) {
     // Note: This was benchmarked against the alternate expression "(char)(c - 'a') < 26" (Nov '13)
     // and found to perform at least as well, or better.
     return (c >= 'a') && (c <= 'z');
   }
 
   /**
    * Indicates whether {@code c} is one of the twenty-six uppercase ASCII alphabetic characters
    * between {@code 'A'} and {@code 'Z'} inclusive. All others (including non-ASCII characters)
    * return {@code false}.
    */
   public static boolean isUpperCase(char c) {
     return (c >= 'A') && (c <= 'Z');
   }
 
   /**
    * Truncates the given character sequence to the given maximum length. If the length of the
    * sequence is greater than {@code maxLength}, the returned string will be exactly {@code
    * maxLength} chars in length and will end with the given {@code truncationIndicator}. Otherwise,
    * the sequence will be returned as a string with no changes to the content.
    *
    * <p>Examples:
    *
    * <pre>{@code
    * Ascii.truncate("foobar", 7, "..."); // returns "foobar"
    * Ascii.truncate("foobar", 5, "..."); // returns "fo..."
    * }</pre>
    *
    * <p><b>Note:</b> This method <i>may</i> work with certain non-ASCII text but is not safe for use
    * with arbitrary Unicode text. It is mostly intended for use with text that is known to be safe
    * for use with it (such as all-ASCII text) and for simple debugging text. When using this method,
    * consider the following:
    *
    * <ul>
    *   <li>it may split surrogate pairs
    *   <li>it may split characters and combining characters
    *   <li>it does not consider word boundaries
    *   <li>if truncating for display to users, there are other considerations that must be taken
    *       into account
    *   <li>the appropriate truncation indicator may be locale-dependent
    *   <li>it is safe to use non-ASCII characters in the truncation indicator
    * </ul>
    *
@@ -580,53 +583,53 @@ public final class Ascii {
    *
    * <p>This method is significantly faster than {@link String#equalsIgnoreCase} and should be used
    * in preference if at least one of the parameters is known to contain only ASCII characters.
    *
    * <p>Note however that this method does not always behave identically to expressions such as:
    *
    * <ul>
    *   <li>{@code string.toUpperCase().equals("UPPER CASE ASCII")}
    *   <li>{@code string.toLowerCase().equals("lower case ascii")}
    * </ul>
    *
    * <p>due to case-folding of some non-ASCII characters (which does not occur in {@link
    * String#equalsIgnoreCase}). However in almost all cases that ASCII strings are used, the author
    * probably wanted the behavior provided by this method rather than the subtle and sometimes
    * surprising behavior of {@code toUpperCase()} and {@code toLowerCase()}.
    *
    * @since 16.0
    */
   public static boolean equalsIgnoreCase(CharSequence s1, CharSequence s2) {
     // Calling length() is the null pointer check (so do it before we can exit early).
     int length = s1.length();
     if (s1 == s2) {
       return true;
     }
     if (length != s2.length()) {
       return false;
     }
     for (int i = 0; i < length; i++) {
       char c1 = s1.charAt(i);
       char c2 = s2.charAt(i);
       if (c1 == c2) {
         continue;
       }
       int alphaIndex = getAlphaIndex(c1);
       // This was also benchmarked using '&' to avoid branching (but always evaluate the rhs),
       // however this showed no obvious improvement.
       if (alphaIndex < 26 && alphaIndex == getAlphaIndex(c2)) {
         continue;
       }
       return false;
     }
     return true;
   }
 
   /**
    * Returns the non-negative index value of the alpha character {@code c}, regardless of case. Ie,
    * 'a'/'A' returns 0 and 'z'/'Z' returns 25. Non-alpha characters return a value of 26 or greater.
    */
   private static int getAlphaIndex(char c) {
     // Fold upper-case ASCII to lower-case and make zero-indexed and unsigned (by casting to char).
-    return (char) ((c | 0x20) - 'a');
+    return (char) ((c | CASE_MASK) - 'a');
   }
 }
