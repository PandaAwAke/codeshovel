diff --git a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index 551cd5de5..8473e8c78 100644
--- a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -492,100 +492,105 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
     return countMap.isEmpty();
   }
 
   @Override
   Iterator<Entry<E>> entryIterator() {
     // AbstractIterator makes this fairly clean, but it doesn't support remove(). To support
     // remove(), we create an AbstractIterator, and then use ForwardingIterator to delegate to it.
     final Iterator<Entry<E>> readOnlyIterator =
         new AbstractIterator<Entry<E>>() {
           private final Iterator<Map.Entry<E, AtomicInteger>> mapEntries =
               countMap.entrySet().iterator();
 
           @Override
           protected Entry<E> computeNext() {
             while (true) {
               if (!mapEntries.hasNext()) {
                 return endOfData();
               }
               Map.Entry<E, AtomicInteger> mapEntry = mapEntries.next();
               int count = mapEntry.getValue().get();
               if (count != 0) {
                 return Multisets.immutableEntry(mapEntry.getKey(), count);
               }
             }
           }
         };
 
     return new ForwardingIterator<Entry<E>>() {
       private Entry<E> last;
 
       @Override
       protected Iterator<Entry<E>> delegate() {
         return readOnlyIterator;
       }
 
       @Override
       public Entry<E> next() {
         last = super.next();
         return last;
       }
 
       @Override
       public void remove() {
         checkRemove(last != null);
         ConcurrentHashMultiset.this.setCount(last.getElement(), 0);
         last = null;
       }
     };
   }
 
+  @Override
+  public Iterator<E> iterator() {
+    return Multisets.iteratorImpl(this);
+  }
+
   @Override
   public void clear() {
     countMap.clear();
   }
 
   @WeakOuter
   private class EntrySet extends AbstractMultiset<E>.EntrySet {
     @Override
     ConcurrentHashMultiset<E> multiset() {
       return ConcurrentHashMultiset.this;
     }
 
     /*
      * Note: the superclass toArray() methods assume that size() gives a correct
      * answer, which ours does not.
      */
 
     @Override
     public Object[] toArray() {
       return snapshot().toArray();
     }
 
     @Override
     public <T> T[] toArray(T[] array) {
       return snapshot().toArray(array);
     }
 
     private List<Multiset.Entry<E>> snapshot() {
       List<Multiset.Entry<E>> list = Lists.newArrayListWithExpectedSize(size());
       // Not Iterables.addAll(list, this), because that'll forward right back here.
       Iterators.addAll(list, iterator());
       return list;
     }
   }
 
   /** @serialData the ConcurrentMap of elements and their counts. */
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(countMap);
   }
 
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     ConcurrentMap<E, Integer> deserializedCountMap =
         (ConcurrentMap<E, Integer>) stream.readObject();
     FieldSettersHolder.COUNT_MAP_FIELD_SETTER.set(this, deserializedCountMap);
   }
 
   private static final long serialVersionUID = 1;
