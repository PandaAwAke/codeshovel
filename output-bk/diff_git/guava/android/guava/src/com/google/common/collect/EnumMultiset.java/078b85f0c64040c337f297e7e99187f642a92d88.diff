diff --git a/android/guava/src/com/google/common/collect/EnumMultiset.java b/android/guava/src/com/google/common/collect/EnumMultiset.java
index 6dedbc006..88026d2ad 100644
--- a/android/guava/src/com/google/common/collect/EnumMultiset.java
+++ b/android/guava/src/com/google/common/collect/EnumMultiset.java
@@ -1,83 +1,82 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Multiset implementation specialized for enum elements, supporting all single-element operations
  * in O(1).
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset"> {@code
  * Multiset}</a>.
  *
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(emulated = true)
 public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
     implements Serializable {
   /** Creates an empty {@code EnumMultiset}. */
   public static <E extends Enum<E>> EnumMultiset<E> create(Class<E> type) {
     return new EnumMultiset<E>(type);
   }
 
   /**
    * Creates a new {@code EnumMultiset} containing the specified elements.
    *
    * <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.
    *
    * @param elements the elements that the multiset should contain
    * @throws IllegalArgumentException if {@code elements} is empty
    */
   public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements) {
     Iterator<E> iterator = elements.iterator();
     checkArgument(iterator.hasNext(), "EnumMultiset constructor passed empty Iterable");
     EnumMultiset<E> multiset = new EnumMultiset<>(iterator.next().getDeclaringClass());
     Iterables.addAll(multiset, elements);
     return multiset;
   }
 
   /**
    * Returns a new {@code EnumMultiset} instance containing the given elements. Unlike {@link
    * EnumMultiset#create(Iterable)}, this method does not produce an exception on an empty iterable.
    *
    * @since 14.0
    */
   public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements, Class<E> type) {
     EnumMultiset<E> result = create(type);
     Iterables.addAll(result, elements);
     return result;
   }
 
   private transient Class<E> type;
@@ -200,111 +199,105 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
     return oldCount;
   }
 
   @Override
   public void clear() {
     Arrays.fill(counts, 0);
     size = 0;
     distinctElements = 0;
   }
 
   abstract class Itr<T> implements Iterator<T> {
     int index = 0;
     int toRemove = -1;
 
     abstract T output(int index);
 
     @Override
     public boolean hasNext() {
       for (; index < enumConstants.length; index++) {
         if (counts[index] > 0) {
           return true;
         }
       }
       return false;
     }
 
     @Override
     public T next() {
       if (!hasNext()) {
         throw new NoSuchElementException();
       }
       T result = output(index);
       toRemove = index;
       index++;
       return result;
     }
 
     @Override
     public void remove() {
       checkRemove(toRemove >= 0);
       if (counts[toRemove] > 0) {
         distinctElements--;
         size -= counts[toRemove];
         counts[toRemove] = 0;
       }
       toRemove = -1;
     }
   }
 
   @Override
-  Set<E> createElementSet() {
-    return new ElementSet() {
-
+  Iterator<E> elementIterator() {
+    return new Itr<E>() {
       @Override
-      public Iterator<E> iterator() {
-        return new Itr<E>() {
-          @Override
-          E output(int index) {
-            return enumConstants[index];
-          }
-        };
+      E output(int index) {
+        return enumConstants[index];
       }
     };
   }
 
   @Override
   Iterator<Entry<E>> entryIterator() {
     return new Itr<Entry<E>>() {
       @Override
       Entry<E> output(final int index) {
         return new Multisets.AbstractEntry<E>() {
           @Override
           public E getElement() {
             return enumConstants[index];
           }
 
           @Override
           public int getCount() {
             return counts[index];
           }
         };
       }
     };
   }
 
   @Override
   public Iterator<E> iterator() {
     return Multisets.iteratorImpl(this);
   }
 
   @GwtIncompatible // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeObject(type);
     Serialization.writeMultiset(this, stream);
   }
 
   /**
    * @serialData the {@code Class<E>} for the enum type, the number of distinct elements, the first
    *     element, its count, the second element, its count, and so on
    */
   @GwtIncompatible // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     @SuppressWarnings("unchecked") // reading data stored by writeObject
     Class<E> localType = (Class<E>) stream.readObject();
     type = localType;
     enumConstants = type.getEnumConstants();
     counts = new int[enumConstants.length];
     Serialization.populateMultiset(this, stream);
   }
