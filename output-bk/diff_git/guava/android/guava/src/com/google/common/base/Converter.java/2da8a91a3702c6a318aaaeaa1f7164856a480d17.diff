diff --git a/android/guava/src/com/google/common/base/Converter.java b/android/guava/src/com/google/common/base/Converter.java
index 1487cfc0f..867a04eb2 100644
--- a/android/guava/src/com/google/common/base/Converter.java
+++ b/android/guava/src/com/google/common/base/Converter.java
@@ -192,183 +192,183 @@ public abstract class Converter<A, B> implements Function<A, B> {
     }
   }
 
   /**
    * Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The
    * conversion is done lazily.
    *
    * <p>The returned iterable's iterator supports {@code remove()} if the input iterator does. After
    * a successful {@code remove()} call, {@code fromIterable} no longer contains the corresponding
    * element.
    */
   @CanIgnoreReturnValue
   public Iterable<B> convertAll(final Iterable<? extends A> fromIterable) {
     checkNotNull(fromIterable, "fromIterable");
     return new Iterable<B>() {
       @Override
       public Iterator<B> iterator() {
         return new Iterator<B>() {
           private final Iterator<? extends A> fromIterator = fromIterable.iterator();
 
           @Override
           public boolean hasNext() {
             return fromIterator.hasNext();
           }
 
           @Override
           public B next() {
             return convert(fromIterator.next());
           }
 
           @Override
           public void remove() {
             fromIterator.remove();
           }
         };
       }
     };
   }
 
   /**
    * Returns the reversed view of this converter, which converts {@code this.convert(a)} back to a
    * value roughly equivalent to {@code a}.
    *
    * <p>The returned converter is serializable if {@code this} converter is.
    *
    * <p><b>Note:</b> you should not override this method. It is non-final for legacy reasons.
    */
   @CanIgnoreReturnValue
   public Converter<B, A> reverse() {
     Converter<B, A> result = reverse;
-    return (result == null) ? reverse = new ReverseConverter<A, B>(this) : result;
+    return (result == null) ? reverse = new ReverseConverter<>(this) : result;
   }
 
   private static final class ReverseConverter<A, B> extends Converter<B, A>
       implements Serializable {
     final Converter<A, B> original;
 
     ReverseConverter(Converter<A, B> original) {
       this.original = original;
     }
 
     /*
      * These gymnastics are a little confusing. Basically this class has neither legacy nor
      * non-legacy behavior; it just needs to let the behavior of the backing converter shine
      * through. So, we override the correctedDo* methods, after which the do* methods should never
      * be reached.
      */
 
     @Override
     protected A doForward(B b) {
       throw new AssertionError();
     }
 
     @Override
     protected B doBackward(A a) {
       throw new AssertionError();
     }
 
     @Override
     @Nullable
     A correctedDoForward(@Nullable B b) {
       return original.correctedDoBackward(b);
     }
 
     @Override
     @Nullable
     B correctedDoBackward(@Nullable A a) {
       return original.correctedDoForward(a);
     }
 
     @Override
     public Converter<A, B> reverse() {
       return original;
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       if (object instanceof ReverseConverter) {
         ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;
         return this.original.equals(that.original);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return ~original.hashCode();
     }
 
     @Override
     public String toString() {
       return original + ".reverse()";
     }
 
     private static final long serialVersionUID = 0L;
   }
 
   /**
    * Returns a converter whose {@code convert} method applies {@code secondConverter} to the result
    * of this converter. Its {@code reverse} method applies the converters in reverse order.
    *
    * <p>The returned converter is serializable if {@code this} converter and {@code secondConverter}
    * are.
    */
   public final <C> Converter<A, C> andThen(Converter<B, C> secondConverter) {
     return doAndThen(secondConverter);
   }
 
   /**
    * Package-private non-final implementation of andThen() so only we can override it.
    */
   <C> Converter<A, C> doAndThen(Converter<B, C> secondConverter) {
-    return new ConverterComposition<A, B, C>(this, checkNotNull(secondConverter));
+    return new ConverterComposition<>(this, checkNotNull(secondConverter));
   }
 
   private static final class ConverterComposition<A, B, C> extends Converter<A, C>
       implements Serializable {
     final Converter<A, B> first;
     final Converter<B, C> second;
 
     ConverterComposition(Converter<A, B> first, Converter<B, C> second) {
       this.first = first;
       this.second = second;
     }
 
     /*
      * These gymnastics are a little confusing. Basically this class has neither legacy nor
      * non-legacy behavior; it just needs to let the behaviors of the backing converters shine
      * through (which might even differ from each other!). So, we override the correctedDo* methods,
      * after which the do* methods should never be reached.
      */
 
     @Override
     protected C doForward(A a) {
       throw new AssertionError();
     }
 
     @Override
     protected A doBackward(C c) {
       throw new AssertionError();
     }
 
     @Override
     @Nullable
     C correctedDoForward(@Nullable A a) {
       return second.correctedDoForward(first.correctedDoForward(a));
     }
 
     @Override
     @Nullable
     A correctedDoBackward(@Nullable C c) {
       return first.correctedDoBackward(second.correctedDoBackward(c));
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       if (object instanceof ConverterComposition) {
         ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;
         return this.first.equals(that.first) && this.second.equals(that.second);
       }
       return false;
     }
 
@@ -384,101 +384,101 @@ public abstract class Converter<A, B> implements Function<A, B> {
 
     private static final long serialVersionUID = 0L;
   }
 
   /**
    * @deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.
    */
   @Deprecated
   @Override
   @Nullable
   @CanIgnoreReturnValue
   public final B apply(@Nullable A a) {
     return convert(a);
   }
 
   /**
    * Indicates whether another object is equal to this converter.
    *
    * <p>Most implementations will have no reason to override the behavior of {@link Object#equals}.
    * However, an implementation may also choose to return {@code true} whenever {@code object} is a
    * {@link Converter} that it considers <i>interchangeable</i> with this one. "Interchangeable"
    * <i>typically</i> means that {@code Objects.equal(this.convert(a), that.convert(a))} is true for
    * all {@code a} of type {@code A} (and similarly for {@code reverse}). Note that a {@code false}
    * result from this method does not imply that the converters are known <i>not</i> to be
    * interchangeable.
    */
   @Override
   public boolean equals(@Nullable Object object) {
     return super.equals(object);
   }
 
   // Static converters
 
   /**
    * Returns a converter based on separate forward and backward functions. This is useful if the
    * function instances already exist, or so that you can supply lambda expressions. If those
    * circumstances don't apply, you probably don't need to use this; subclass {@code Converter} and
    * implement its {@link #doForward} and {@link #doBackward} methods directly.
    *
    * <p>These functions will never be passed {@code null} and must not under any circumstances
    * return {@code null}. If a value cannot be converted, the function should throw an unchecked
    * exception (typically, but not necessarily, {@link IllegalArgumentException}).
    *
    * <p>The returned converter is serializable if both provided functions are.
    *
    * @since 17.0
    */
   public static <A, B> Converter<A, B> from(
       Function<? super A, ? extends B> forwardFunction,
       Function<? super B, ? extends A> backwardFunction) {
-    return new FunctionBasedConverter<A, B>(forwardFunction, backwardFunction);
+    return new FunctionBasedConverter<>(forwardFunction, backwardFunction);
   }
 
   private static final class FunctionBasedConverter<A, B> extends Converter<A, B>
       implements Serializable {
     private final Function<? super A, ? extends B> forwardFunction;
     private final Function<? super B, ? extends A> backwardFunction;
 
     private FunctionBasedConverter(
         Function<? super A, ? extends B> forwardFunction,
         Function<? super B, ? extends A> backwardFunction) {
       this.forwardFunction = checkNotNull(forwardFunction);
       this.backwardFunction = checkNotNull(backwardFunction);
     }
 
     @Override
     protected B doForward(A a) {
       return forwardFunction.apply(a);
     }
 
     @Override
     protected A doBackward(B b) {
       return backwardFunction.apply(b);
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       if (object instanceof FunctionBasedConverter) {
         FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;
         return this.forwardFunction.equals(that.forwardFunction)
             && this.backwardFunction.equals(that.backwardFunction);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return forwardFunction.hashCode() * 31 + backwardFunction.hashCode();
     }
 
     @Override
     public String toString() {
       return "Converter.from(" + forwardFunction + ", " + backwardFunction + ")";
     }
   }
 
   /**
    * Returns a serializable converter that always converts or reverses an object to itself.
    */
   @SuppressWarnings("unchecked") // implementation is "fully variant"
   public static <T> Converter<T, T> identity() {
