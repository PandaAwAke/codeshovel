diff --git a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
index 2cf1aa2fe..87f7411d0 100644
--- a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -171,118 +171,118 @@ public final class LinkedHashMultimap<K, V>
 
     boolean matchesValue(@NullableDecl Object v, int smearedVHash) {
       return smearedValueHash == smearedVHash && Objects.equal(getValue(), v);
     }
 
     @Override
     public ValueSetLink<K, V> getPredecessorInValueSet() {
       return predecessorInValueSet;
     }
 
     @Override
     public ValueSetLink<K, V> getSuccessorInValueSet() {
       return successorInValueSet;
     }
 
     @Override
     public void setPredecessorInValueSet(ValueSetLink<K, V> entry) {
       predecessorInValueSet = entry;
     }
 
     @Override
     public void setSuccessorInValueSet(ValueSetLink<K, V> entry) {
       successorInValueSet = entry;
     }
 
     public ValueEntry<K, V> getPredecessorInMultimap() {
       return predecessorInMultimap;
     }
 
     public ValueEntry<K, V> getSuccessorInMultimap() {
       return successorInMultimap;
     }
 
     public void setSuccessorInMultimap(ValueEntry<K, V> multimapSuccessor) {
       this.successorInMultimap = multimapSuccessor;
     }
 
     public void setPredecessorInMultimap(ValueEntry<K, V> multimapPredecessor) {
       this.predecessorInMultimap = multimapPredecessor;
     }
   }
 
   private static final int DEFAULT_KEY_CAPACITY = 16;
   private static final int DEFAULT_VALUE_SET_CAPACITY = 2;
   @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = 1.0;
 
   @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
   private transient ValueEntry<K, V> multimapHeaderEntry;
 
   private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
-    super(new LinkedHashMap<K, Collection<V>>(keyCapacity));
+    super(Platform.<K, Collection<V>>newLinkedHashMapWithExpectedSize(keyCapacity));
     checkNonnegative(valueSetCapacity, "expectedValuesPerKey");
 
     this.valueSetCapacity = valueSetCapacity;
     this.multimapHeaderEntry = new ValueEntry<>(null, null, 0, null);
     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>Creates an empty {@code LinkedHashSet} for a collection of values for one key.
    *
    * @return a new {@code LinkedHashSet} containing a collection of values for one key
    */
   @Override
   Set<V> createCollection() {
-    return new LinkedHashSet<V>(valueSetCapacity);
+    return Platform.newLinkedHashSetWithExpectedSize(valueSetCapacity);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>Creates a decorated insertion-ordered set that also keeps track of the order in which
    * key-value pairs are added to the multimap.
    *
    * @param key key to associate with values in the collection
    * @return a new decorated set containing a collection of values for one key
    */
   @Override
   Collection<V> createCollection(K key) {
     return new ValueSet(key, valueSetCapacity);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>If {@code values} is not empty and the multimap already contains a mapping for {@code key},
    * the {@code keySet()} ordering is unchanged. However, the provided values always come last in
    * the {@link #entries()} and {@link #values()} iteration orderings.
    */
   @CanIgnoreReturnValue
   @Override
   public Set<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
     return super.replaceValues(key, values);
   }
 
   /**
    * Returns a set of all key-value pairs. Changes to the returned set will update the underlying
    * multimap, and vice versa. The entries set does not support the {@code add} or {@code addAll}
    * operations.
    *
    * <p>The iterator generated by the returned set traverses the entries in the order they were
    * added to the multimap.
    *
    * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
    * time the entry is returned by a method call to the collection or its iterator.
    */
   @Override
   public Set<Entry<K, V>> entries() {
     return super.entries();
   }
 
   /**
    * Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the
    * key set contains a key if and only if this multimap maps that key to at least one value.
    *
    * <p>The iterator generated by the returned set traverses the keys in the order they were first
@@ -523,70 +523,70 @@ public final class LinkedHashMultimap<K, V>
         toRemove = result;
         nextEntry = nextEntry.successorInMultimap;
         return result;
       }
 
       @Override
       public void remove() {
         checkRemove(toRemove != null);
         LinkedHashMultimap.this.remove(toRemove.getKey(), toRemove.getValue());
         toRemove = null;
       }
     };
   }
 
   @Override
   Iterator<V> valueIterator() {
     return Maps.valueIterator(entryIterator());
   }
 
   @Override
   public void clear() {
     super.clear();
     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
   }
 
   /**
    * @serialData the expected values per key, the number of distinct keys, the number of entries,
    *     and the entries in order
    */
   @GwtIncompatible // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(keySet().size());
     for (K key : keySet()) {
       stream.writeObject(key);
     }
     stream.writeInt(size());
     for (Entry<K, V> entry : entries()) {
       stream.writeObject(entry.getKey());
       stream.writeObject(entry.getValue());
     }
   }
 
   @GwtIncompatible // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     multimapHeaderEntry = new ValueEntry<>(null, null, 0, null);
     succeedsInMultimap(multimapHeaderEntry, multimapHeaderEntry);
     valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY;
     int distinctKeys = stream.readInt();
-    Map<K, Collection<V>> map = new LinkedHashMap<>();
+    Map<K, Collection<V>> map = Platform.newLinkedHashMapWithExpectedSize(12);
     for (int i = 0; i < distinctKeys; i++) {
       @SuppressWarnings("unchecked")
       K key = (K) stream.readObject();
       map.put(key, createCollection(key));
     }
     int entries = stream.readInt();
     for (int i = 0; i < entries; i++) {
       @SuppressWarnings("unchecked")
       K key = (K) stream.readObject();
       @SuppressWarnings("unchecked")
       V value = (V) stream.readObject();
       map.get(key).add(value);
     }
     setMap(map);
   }
 
   @GwtIncompatible // java serialization not supported
   private static final long serialVersionUID = 1;
 }
