diff --git a/android/guava/src/com/google/common/collect/ImmutableMultimap.java b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
index 7df47f853..f3652e20d 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
@@ -74,101 +74,101 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
 
   /**
    * Returns an immutable multimap containing a single entry.
    */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) {
     return ImmutableListMultimap.of(k1, v1);
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in order.
    */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {
     return ImmutableListMultimap.of(k1, v1, k2, v2);
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in the
    * "key-grouped" insertion order described in the
    * <a href="#iteration">class documentation</a>.
    */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
     return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3);
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in the
    * "key-grouped" insertion order described in the
    * <a href="#iteration">class documentation</a>.
    */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
     return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4);
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in the
    * "key-grouped" insertion order described in the
    * <a href="#iteration">class documentation</a>.
    */
   public static <K, V> ImmutableMultimap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
     return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);
   }
 
   // looking for of() with > 5 entries? Use the builder instead.
 
   /**
    * Returns a new builder. The generated builder is equivalent to the builder
    * created by the {@link Builder} constructor.
    */
   public static <K, V> Builder<K, V> builder() {
-    return new Builder<K, V>();
+    return new Builder<>();
   }
 
   /**
    * A builder for creating immutable multimap instances, especially
    * {@code public static final} multimaps ("constant multimaps"). Example:
    * <pre>   {@code
    *
    *   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
    *       new ImmutableMultimap.Builder<String, Integer>()
    *           .put("one", 1)
    *           .putAll("several", 1, 2, 3)
    *           .putAll("many", 1, 2, 3, 4, 5)
    *           .build();}</pre>
    *
    * <p>Builder instances can be reused; it is safe to call {@link #build} multiple
    * times to build multiple multimaps in series. Each multimap contains the
    * key-value mappings in the previously created multimaps.
    *
    * @since 2.0
    */
   public static class Builder<K, V> {
     Multimap<K, V> builderMultimap;
     Comparator<? super K> keyComparator;
     Comparator<? super V> valueComparator;
 
     /**
      * Creates a new builder. The returned builder is equivalent to the builder
      * generated by {@link ImmutableMultimap#builder}.
      */
     public Builder() {
       this(MultimapBuilder.linkedHashKeys().arrayListValues().<K, V>build());
     }
 
     Builder(Multimap<K, V> builderMultimap) {
       this.builderMultimap = builderMultimap;
     }
 
     /**
      * Adds a key-value mapping to the built multimap.
      */
     @CanIgnoreReturnValue
     public Builder<K, V> put(K key, V value) {
       checkEntryNotNull(key, value);
       builderMultimap.put(key, value);
       return this;
     }
 
     /**
      * Adds an entry to the built multimap.
      *
@@ -476,101 +476,101 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
     return map.containsKey(key);
   }
 
   @Override
   public boolean containsValue(@Nullable Object value) {
     return value != null && super.containsValue(value);
   }
 
   @Override
   public int size() {
     return size;
   }
 
   // views
 
   /**
    * Returns an immutable set of the distinct keys in this multimap, in the same
    * order as they appear in this multimap.
    */
   @Override
   public ImmutableSet<K> keySet() {
     return map.keySet();
   }
 
   /**
    * Returns an immutable map that associates each key with its corresponding
    * values in the multimap. Keys and values appear in the same order as in this
    * multimap.
    */
   @Override
   @SuppressWarnings("unchecked") // a widening cast
   public ImmutableMap<K, Collection<V>> asMap() {
     return (ImmutableMap) map;
   }
 
   @Override
   Map<K, Collection<V>> createAsMap() {
     throw new AssertionError("should never be called");
   }
 
   /**
    * Returns an immutable collection of all key-value pairs in the multimap.
    */
   @Override
   public ImmutableCollection<Entry<K, V>> entries() {
     return (ImmutableCollection<Entry<K, V>>) super.entries();
   }
 
   @Override
   ImmutableCollection<Entry<K, V>> createEntries() {
-    return new EntryCollection<K, V>(this);
+    return new EntryCollection<>(this);
   }
 
   private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {
     @Weak final ImmutableMultimap<K, V> multimap;
 
     EntryCollection(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
     }
 
     @Override
     public UnmodifiableIterator<Entry<K, V>> iterator() {
       return multimap.entryIterator();
     }
 
     @Override
     boolean isPartialView() {
       return multimap.isPartialView();
     }
 
     @Override
     public int size() {
       return multimap.size();
     }
 
     @Override
     public boolean contains(Object object) {
       if (object instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) object;
         return multimap.containsEntry(entry.getKey(), entry.getValue());
       }
       return false;
     }
 
     private static final long serialVersionUID = 0;
   }
 
   private abstract class Itr<T> extends UnmodifiableIterator<T> {
     final Iterator<Entry<K, Collection<V>>> mapIterator = asMap().entrySet().iterator();
     K key = null;
     Iterator<V> valueIterator = Iterators.emptyIterator();
 
     abstract T output(K key, V value);
 
     @Override
     public boolean hasNext() {
       return mapIterator.hasNext() || valueIterator.hasNext();
     }
 
     @Override
     public T next() {
@@ -609,101 +609,101 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
   }
 
   @SuppressWarnings("serial") // Uses writeReplace, not default serialization
   @WeakOuter
   class Keys extends ImmutableMultiset<K> {
     @Override
     public boolean contains(@Nullable Object object) {
       return containsKey(object);
     }
 
     @Override
     public int count(@Nullable Object element) {
       Collection<V> values = map.get(element);
       return (values == null) ? 0 : values.size();
     }
 
     @Override
     public ImmutableSet<K> elementSet() {
       return keySet();
     }
 
     @Override
     public int size() {
       return ImmutableMultimap.this.size();
     }
 
     @Override
     Multiset.Entry<K> getEntry(int index) {
       Map.Entry<K, ? extends Collection<V>> entry = map.entrySet().asList().get(index);
       return Multisets.immutableEntry(entry.getKey(), entry.getValue().size());
     }
 
     @Override
     boolean isPartialView() {
       return true;
     }
   }
 
   /**
    * Returns an immutable collection of the values in this multimap. Its
    * iterator traverses the values for the first key, the values for the second
    * key, and so on.
    */
   @Override
   public ImmutableCollection<V> values() {
     return (ImmutableCollection<V>) super.values();
   }
 
   @Override
   ImmutableCollection<V> createValues() {
-    return new Values<K, V>(this);
+    return new Values<>(this);
   }
 
   @Override
   UnmodifiableIterator<V> valueIterator() {
     return new Itr<V>() {
       @Override
       V output(K key, V value) {
         return value;
       }
     };
   }
 
   private static final class Values<K, V> extends ImmutableCollection<V> {
     @Weak private final transient ImmutableMultimap<K, V> multimap;
 
     Values(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
     }
 
     @Override
     public boolean contains(@Nullable Object object) {
       return multimap.containsValue(object);
     }
 
     @Override
     public UnmodifiableIterator<V> iterator() {
       return multimap.valueIterator();
     }
 
     @GwtIncompatible // not present in emulated superclass
     @Override
     int copyIntoArray(Object[] dst, int offset) {
       for (ImmutableCollection<V> valueCollection : multimap.map.values()) {
         offset = valueCollection.copyIntoArray(dst, offset);
       }
       return offset;
     }
 
     @Override
     public int size() {
       return multimap.size();
     }
 
     @Override
     boolean isPartialView() {
       return true;
     }
 
     private static final long serialVersionUID = 0;
   }
