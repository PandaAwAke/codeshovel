diff --git a/android/guava/src/com/google/common/collect/HashBiMap.java b/android/guava/src/com/google/common/collect/HashBiMap.java
index b727db9c0..423fa8180 100644
--- a/android/guava/src/com/google/common/collect/HashBiMap.java
+++ b/android/guava/src/com/google/common/collect/HashBiMap.java
@@ -606,236 +606,254 @@ public final class HashBiMap<K, V> extends AbstractMap<K, V> implements BiMap<K,
           /* should never reach end */ ;
           entryInBucket = nextInBucketKToV[entryInBucket]) {
         if (entryInBucket == src) {
           nextInBucketKToV[prevInBucket] = dest;
           break;
         }
         prevInBucket = entryInBucket;
       }
     }
     nextInBucketKToV[dest] = nextInBucketKToV[src];
     nextInBucketKToV[src] = ABSENT;
 
     // update pointers in hashTableVToK
     int valueHash = Hashing.smearedHash(value);
     int valueBucket = bucket(valueHash);
     if (hashTableVToK[valueBucket] == src) {
       hashTableVToK[valueBucket] = dest;
     } else {
       int prevInBucket = hashTableVToK[valueBucket];
       for (int entryInBucket = nextInBucketVToK[prevInBucket];
           /* should never reach end*/ ;
           entryInBucket = nextInBucketVToK[entryInBucket]) {
         if (entryInBucket == src) {
           nextInBucketVToK[prevInBucket] = dest;
           break;
         }
         prevInBucket = entryInBucket;
       }
     }
     nextInBucketVToK[dest] = nextInBucketVToK[src];
     nextInBucketVToK[src] = ABSENT;
   }
 
   @Override
   public void clear() {
     Arrays.fill(keys, 0, size, null);
     Arrays.fill(values, 0, size, null);
     Arrays.fill(hashTableKToV, ABSENT);
     Arrays.fill(hashTableVToK, ABSENT);
     Arrays.fill(nextInBucketKToV, 0, size, ABSENT);
     Arrays.fill(nextInBucketVToK, 0, size, ABSENT);
     Arrays.fill(prevInInsertionOrder, 0, size, ABSENT);
     Arrays.fill(nextInInsertionOrder, 0, size, ABSENT);
     size = 0;
     firstInInsertionOrder = ENDPOINT;
     lastInInsertionOrder = ENDPOINT;
     modCount++;
   }
 
   /** Shared supertype of keySet, values, entrySet, and inverse.entrySet. */
-  abstract class View<T> extends AbstractSet<T> {
+  abstract static class View<K, V, T> extends AbstractSet<T> {
+    final HashBiMap<K, V> biMap;
+
+    View(HashBiMap<K, V> biMap) {
+      this.biMap = biMap;
+    }
+
     abstract T forEntry(int entry);
 
     @Override
     public Iterator<T> iterator() {
       return new Iterator<T>() {
-        private int index = firstInInsertionOrder;
+        private int index = biMap.firstInInsertionOrder;
         private int indexToRemove = ABSENT;
-        private int expectedModCount = modCount;
+        private int expectedModCount = biMap.modCount;
 
         // Calls to setValue on inverse entries can move already-visited entries to the end.
         // Make sure we don't visit those.
-        private int remaining = size;
+        private int remaining = biMap.size;
 
         private void checkForComodification() {
-          if (modCount != expectedModCount) {
+          if (biMap.modCount != expectedModCount) {
             throw new ConcurrentModificationException();
           }
         }
 
         @Override
         public boolean hasNext() {
           checkForComodification();
           return index != ENDPOINT && remaining > 0;
         }
 
         @Override
         public T next() {
           if (!hasNext()) {
             throw new NoSuchElementException();
           }
           T result = forEntry(index);
           indexToRemove = index;
-          index = nextInInsertionOrder[index];
+          index = biMap.nextInInsertionOrder[index];
           remaining--;
           return result;
         }
 
         @Override
         public void remove() {
           checkForComodification();
           CollectPreconditions.checkRemove(indexToRemove != ABSENT);
-          removeEntry(indexToRemove);
-          if (index == size) {
+          biMap.removeEntry(indexToRemove);
+          if (index == biMap.size) {
             index = indexToRemove;
           }
           indexToRemove = ABSENT;
-          expectedModCount = modCount;
+          expectedModCount = biMap.modCount;
         }
       };
     }
 
     @Override
     public int size() {
-      return size;
+      return biMap.size;
     }
 
     @Override
     public void clear() {
-      HashBiMap.this.clear();
+      biMap.clear();
     }
   }
 
   private transient Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
     Set<K> result = keySet;
     return (result == null) ? keySet = new KeySet() : result;
   }
 
-  final class KeySet extends View<K> {
+  final class KeySet extends View<K, V, K> {
+    KeySet() {
+      super(HashBiMap.this);
+    }
+
     @Override
     K forEntry(int entry) {
       return keys[entry];
     }
 
     @Override
     public boolean contains(@NullableDecl Object o) {
       return HashBiMap.this.containsKey(o);
     }
 
     @Override
     public boolean remove(@NullableDecl Object o) {
       int oHash = Hashing.smearedHash(o);
       int entry = findEntryByKey(o, oHash);
       if (entry != ABSENT) {
         removeEntryKeyHashKnown(entry, oHash);
         return true;
       } else {
         return false;
       }
     }
   }
 
   private transient Set<V> valueSet;
 
   @Override
   public Set<V> values() {
     Set<V> result = valueSet;
     return (result == null) ? valueSet = new ValueSet() : result;
   }
 
-  final class ValueSet extends View<V> {
+  final class ValueSet extends View<K, V, V> {
+    ValueSet() {
+      super(HashBiMap.this);
+    }
+
     @Override
     V forEntry(int entry) {
       return values[entry];
     }
 
     @Override
     public boolean contains(@NullableDecl Object o) {
       return HashBiMap.this.containsValue(o);
     }
 
     @Override
     public boolean remove(@NullableDecl Object o) {
       int oHash = Hashing.smearedHash(o);
       int entry = findEntryByValue(o, oHash);
       if (entry != ABSENT) {
         removeEntryValueHashKnown(entry, oHash);
         return true;
       } else {
         return false;
       }
     }
   }
 
   private transient Set<Entry<K, V>> entrySet;
 
   @Override
   public Set<Entry<K, V>> entrySet() {
     Set<Entry<K, V>> result = entrySet;
     return (result == null) ? entrySet = new EntrySet() : result;
   }
 
-  final class EntrySet extends View<Entry<K, V>> {
+  final class EntrySet extends View<K, V, Entry<K, V>> {
+    EntrySet() {
+      super(HashBiMap.this);
+    }
+
     @Override
     public boolean contains(@NullableDecl Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         @NullableDecl Object k = e.getKey();
         @NullableDecl Object v = e.getValue();
         int eIndex = findEntryByKey(k);
         return eIndex != ABSENT && Objects.equal(v, values[eIndex]);
       }
       return false;
     }
 
     @Override
     @CanIgnoreReturnValue
     public boolean remove(@NullableDecl Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         @NullableDecl Object k = e.getKey();
         @NullableDecl Object v = e.getValue();
         int kHash = Hashing.smearedHash(k);
         int eIndex = findEntryByKey(k, kHash);
         if (eIndex != ABSENT && Objects.equal(v, values[eIndex])) {
           removeEntryKeyHashKnown(eIndex, kHash);
           return true;
         }
       }
       return false;
     }
 
     @Override
     Entry<K, V> forEntry(int entry) {
       return new EntryForKey(entry);
     }
   }
 
   /**
    * An {@code Entry} implementation that attempts to follow its key around the map -- that is, if
    * the key is moved, deleted, or reinserted, it will account for that -- while not doing any extra
    * work if the key has not moved.
    */
   final class EntryForKey extends AbstractMapEntry<K, V> {
     @NullableDecl final K key;
     int index;
 
     EntryForKey(int index) {
       this.key = keys[index];
       this.index = index;
     }
 
     void updateIndex() {
@@ -906,158 +924,164 @@ public final class HashBiMap<K, V> extends AbstractMap<K, V> implements BiMap<K,
     public boolean containsValue(@NullableDecl Object value) {
       return forward.containsKey(value);
     }
 
     @Override
     @NullableDecl
     @CanIgnoreReturnValue
     public K put(@NullableDecl V value, @NullableDecl K key) {
       return forward.putInverse(value, key, false);
     }
 
     @Override
     @NullableDecl
     @CanIgnoreReturnValue
     public K forcePut(@NullableDecl V value, @NullableDecl K key) {
       return forward.putInverse(value, key, true);
     }
 
     @Override
     public BiMap<K, V> inverse() {
       return forward;
     }
 
     @Override
     @NullableDecl
     @CanIgnoreReturnValue
     public K remove(@NullableDecl Object value) {
       return forward.removeInverse(value);
     }
 
     @Override
     public void clear() {
       forward.clear();
     }
 
     @Override
     public Set<V> keySet() {
       return forward.values();
     }
 
     @Override
     public Set<K> values() {
       return forward.keySet();
     }
 
     private transient Set<Entry<V, K>> inverseEntrySet;
 
     @Override
     public Set<Entry<V, K>> entrySet() {
       Set<Entry<V, K>> result = inverseEntrySet;
-      return (result == null) ? inverseEntrySet = forward.new InverseEntrySet() : result;
+      return (result == null) ? inverseEntrySet = new InverseEntrySet<K, V>(forward) : result;
     }
 
     @GwtIncompatible("serialization")
     private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
       in.defaultReadObject();
       this.forward.inverse = this;
     }
   }
 
-  class InverseEntrySet extends View<Entry<V, K>> {
+  static class InverseEntrySet<K, V> extends View<K, V, Entry<V, K>> {
+    InverseEntrySet(HashBiMap<K, V> biMap) {
+      super(biMap);
+    }
+
     @Override
     public boolean contains(@NullableDecl Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         Object v = e.getKey();
         Object k = e.getValue();
-        int eIndex = findEntryByValue(v);
-        return eIndex != ABSENT && Objects.equal(keys[eIndex], k);
+        int eIndex = biMap.findEntryByValue(v);
+        return eIndex != ABSENT && Objects.equal(biMap.keys[eIndex], k);
       }
       return false;
     }
 
     @Override
     public boolean remove(Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         Object v = e.getKey();
         Object k = e.getValue();
         int vHash = Hashing.smearedHash(v);
-        int eIndex = findEntryByValue(v, vHash);
-        if (eIndex != ABSENT && Objects.equal(keys[eIndex], k)) {
-          removeEntryValueHashKnown(eIndex, vHash);
+        int eIndex = biMap.findEntryByValue(v, vHash);
+        if (eIndex != ABSENT && Objects.equal(biMap.keys[eIndex], k)) {
+          biMap.removeEntryValueHashKnown(eIndex, vHash);
           return true;
         }
       }
       return false;
     }
 
     @Override
     Entry<V, K> forEntry(int entry) {
-      return new EntryForValue(entry);
+      return new EntryForValue<K, V>(biMap, entry);
     }
   }
 
   /**
    * An {@code Entry} implementation that attempts to follow its value around the map -- that is, if
    * the value is moved, deleted, or reinserted, it will account for that -- while not doing any
    * extra work if the value has not moved.
    */
-  final class EntryForValue extends AbstractMapEntry<V, K> {
+  static final class EntryForValue<K, V> extends AbstractMapEntry<V, K> {
+    final HashBiMap<K, V> biMap;
     final V value;
     int index;
 
-    EntryForValue(int index) {
-      this.value = values[index];
+    EntryForValue(HashBiMap<K, V> biMap, int index) {
+      this.biMap = biMap;
+      this.value = biMap.values[index];
       this.index = index;
     }
 
     private void updateIndex() {
-      if (index == ABSENT || index > size || !Objects.equal(value, values[index])) {
-        index = findEntryByValue(value);
+      if (index == ABSENT || index > biMap.size || !Objects.equal(value, biMap.values[index])) {
+        index = biMap.findEntryByValue(value);
       }
     }
 
     @Override
     public V getKey() {
       return value;
     }
 
     @Override
     public K getValue() {
       updateIndex();
-      return (index == ABSENT) ? null : keys[index];
+      return (index == ABSENT) ? null : biMap.keys[index];
     }
 
     @Override
     public K setValue(K key) {
       updateIndex();
       if (index == ABSENT) {
-        return HashBiMap.this.putInverse(value, key, false);
+        return biMap.putInverse(value, key, false);
       }
-      K oldKey = keys[index];
+      K oldKey = biMap.keys[index];
       if (Objects.equal(oldKey, key)) {
         return key;
       }
-      replaceKeyInEntry(index, key, false);
+      biMap.replaceKeyInEntry(index, key, false);
       return oldKey;
     }
   }
 
   /**
    * @serialData the number of entries, first key, first value, second key, second value, and so on.
    */
   @GwtIncompatible // java.io.ObjectOutputStream
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     Serialization.writeMap(this, stream);
   }
 
   @GwtIncompatible // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     int size = Serialization.readCount(stream);
     init(16); // resist hostile attempts to allocate gratuitous heap
     Serialization.populateMap(this, stream, size);
   }
 }
