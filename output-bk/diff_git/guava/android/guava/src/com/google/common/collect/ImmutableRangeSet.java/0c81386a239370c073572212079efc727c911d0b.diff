diff --git a/android/guava/src/com/google/common/collect/ImmutableRangeSet.java b/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
index fb7b82288..b39a59ed3 100644
--- a/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
+++ b/android/guava/src/com/google/common/collect/ImmutableRangeSet.java
@@ -1,104 +1,104 @@
 /*
  * Copyright (C) 2012 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_HIGHER;
 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_LOWER;
 import static com.google.common.collect.SortedLists.KeyPresentBehavior.ANY_PRESENT;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.SortedLists.KeyAbsentBehavior;
 import com.google.common.collect.SortedLists.KeyPresentBehavior;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import javax.annotation.Nullable;
 
 /**
  * A {@link RangeSet} whose contents will never change, with many other important properties
  * detailed at {@link ImmutableCollection}.
  *
  * @author Louis Wasserman
  * @since 14.0
  */
 @Beta
 @GwtIncompatible
 public final class ImmutableRangeSet<C extends Comparable> extends AbstractRangeSet<C>
     implements Serializable {
 
   private static final ImmutableRangeSet<Comparable<?>> EMPTY =
-      new ImmutableRangeSet<Comparable<?>>(ImmutableList.<Range<Comparable<?>>>of());
+      new ImmutableRangeSet<>(ImmutableList.<Range<Comparable<?>>>of());
 
   private static final ImmutableRangeSet<Comparable<?>> ALL =
-      new ImmutableRangeSet<Comparable<?>>(ImmutableList.of(Range.<Comparable<?>>all()));
+      new ImmutableRangeSet<>(ImmutableList.of(Range.<Comparable<?>>all()));
 
   /**
    * Returns an empty immutable range set.
    */
   @SuppressWarnings("unchecked")
   public static <C extends Comparable> ImmutableRangeSet<C> of() {
     return (ImmutableRangeSet<C>) EMPTY;
   }
 
   /**
    * Returns an immutable range set containing the single range {@link Range#all()}.
    */
   @SuppressWarnings("unchecked")
   static <C extends Comparable> ImmutableRangeSet<C> all() {
     return (ImmutableRangeSet<C>) ALL;
   }
 
   /**
    * Returns an immutable range set containing the specified single range. If {@link Range#isEmpty()
    * range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.
    */
   public static <C extends Comparable> ImmutableRangeSet<C> of(Range<C> range) {
     checkNotNull(range);
     if (range.isEmpty()) {
       return of();
     } else if (range.equals(Range.all())) {
       return all();
     } else {
       return new ImmutableRangeSet<C>(ImmutableList.of(range));
     }
   }
 
   /**
    * Returns an immutable copy of the specified {@code RangeSet}.
    */
   public static <C extends Comparable> ImmutableRangeSet<C> copyOf(RangeSet<C> rangeSet) {
     checkNotNull(rangeSet);
     if (rangeSet.isEmpty()) {
       return of();
     } else if (rangeSet.encloses(Range.<C>all())) {
       return all();
     }
 
     if (rangeSet instanceof ImmutableRangeSet) {
       ImmutableRangeSet<C> immutableRangeSet = (ImmutableRangeSet<C>) rangeSet;
       if (!immutableRangeSet.isPartialView()) {
         return immutableRangeSet;
       }
     }
     return new ImmutableRangeSet<C>(ImmutableList.copyOf(rangeSet.asRanges()));
@@ -232,110 +232,109 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void addAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void remove(Range<C> range) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void removeAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @Deprecated
   @Override
   public void removeAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
 
   @Override
   public ImmutableSet<Range<C>> asRanges() {
     if (ranges.isEmpty()) {
       return ImmutableSet.of();
     }
-    return new RegularImmutableSortedSet<Range<C>>(ranges, Range.<C>rangeLexOrdering());
+    return new RegularImmutableSortedSet<>(ranges, Range.<C>rangeLexOrdering());
   }
 
   @Override
   public ImmutableSet<Range<C>> asDescendingSetOfRanges() {
     if (ranges.isEmpty()) {
       return ImmutableSet.of();
     }
-    return new RegularImmutableSortedSet<Range<C>>(
-        ranges.reverse(), Range.<C>rangeLexOrdering().reverse());
+    return new RegularImmutableSortedSet<>(ranges.reverse(), Range.<C>rangeLexOrdering().reverse());
   }
 
   @LazyInit
   private transient ImmutableRangeSet<C> complement;
 
   private final class ComplementRanges extends ImmutableList<Range<C>> {
     // True if the "positive" range set is empty or bounded below.
     private final boolean positiveBoundedBelow;
 
     // True if the "positive" range set is empty or bounded above.
     private final boolean positiveBoundedAbove;
 
     private final int size;
 
     ComplementRanges() {
       this.positiveBoundedBelow = ranges.get(0).hasLowerBound();
       this.positiveBoundedAbove = Iterables.getLast(ranges).hasUpperBound();
 
       int size = ranges.size() - 1;
       if (positiveBoundedBelow) {
         size++;
       }
       if (positiveBoundedAbove) {
         size++;
       }
       this.size = size;
     }
 
     @Override
     public int size() {
       return size;
     }
 
     @Override
     public Range<C> get(int index) {
       checkElementIndex(index, size);
 
       Cut<C> lowerBound;
       if (positiveBoundedBelow) {
         lowerBound = (index == 0) ? Cut.<C>belowAll() : ranges.get(index - 1).upperBound;
       } else {
         lowerBound = ranges.get(index).upperBound;
       }
 
       Cut<C> upperBound;
       if (positiveBoundedAbove && index == size - 1) {
         upperBound = Cut.<C>aboveAll();
       } else {
         upperBound = ranges.get(index + (positiveBoundedBelow ? 0 : 1)).lowerBound;
       }
@@ -716,101 +715,101 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
       this.ranges = Lists.newArrayList();
     }
 
     // TODO(lowasser): consider adding union, in addition to add, that does allow overlap
 
     /**
      * Add the specified range to this builder. Adjacent ranges are permitted and will be merged,
      * but overlapping ranges will cause an exception when {@link #build()} is called.
      *
      * @throws IllegalArgumentException if {@code range} is empty
      */
     @CanIgnoreReturnValue
     public Builder<C> add(Range<C> range) {
       checkArgument(!range.isEmpty(), "range must not be empty, but was %s", range);
       ranges.add(range);
       return this;
     }
 
     /**
      * Add all ranges from the specified range set to this builder. Adjacent ranges are permitted
      * and will be merged, but overlapping ranges will cause an exception when {@link #build()} is
      * called.
      */
     @CanIgnoreReturnValue
     public Builder<C> addAll(RangeSet<C> ranges) {
       return addAll(ranges.asRanges());
     }
 
     /**
      * Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be
      * merged, but overlapping ranges will cause an exception when {@link #build()} is called.
      *
      * @throws IllegalArgumentException if any inserted ranges are empty
      * @since 21.0
      */
     @CanIgnoreReturnValue
     public Builder<C> addAll(Iterable<Range<C>> ranges) {
       for (Range<C> range : ranges) {
         add(range);
       }
       return this;
     }
 
     /**
      * Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.
      *
      * @throws IllegalArgumentException if any input ranges have nonempty overlap
      */
     public ImmutableRangeSet<C> build() {
       ImmutableList.Builder<Range<C>> mergedRangesBuilder =
-          new ImmutableList.Builder<Range<C>>(ranges.size());
+          new ImmutableList.Builder<>(ranges.size());
       Collections.sort(ranges, Range.<C>rangeLexOrdering());
       PeekingIterator<Range<C>> peekingItr = Iterators.peekingIterator(ranges.iterator());
       while (peekingItr.hasNext()) {
         Range<C> range = peekingItr.next();
         while (peekingItr.hasNext()) {
           Range<C> nextRange = peekingItr.peek();
           if (range.isConnected(nextRange)) {
             checkArgument(
                 range.intersection(nextRange).isEmpty(),
                 "Overlapping ranges not permitted but found %s overlapping %s",
                 range,
                 nextRange);
             range = range.span(peekingItr.next());
           } else {
             break;
           }
         }
         mergedRangesBuilder.add(range);
       }
       ImmutableList<Range<C>> mergedRanges = mergedRangesBuilder.build();
       if (mergedRanges.isEmpty()) {
         return of();
       } else if (mergedRanges.size() == 1
           && Iterables.getOnlyElement(mergedRanges).equals(Range.all())) {
         return all();
       } else {
         return new ImmutableRangeSet<C>(mergedRanges);
       }
     }
   }
 
   private static final class SerializedForm<C extends Comparable> implements Serializable {
     private final ImmutableList<Range<C>> ranges;
 
     SerializedForm(ImmutableList<Range<C>> ranges) {
       this.ranges = ranges;
     }
 
     Object readResolve() {
       if (ranges.isEmpty()) {
         return of();
       } else if (ranges.equals(ImmutableList.of(Range.all()))) {
         return all();
       } else {
         return new ImmutableRangeSet<C>(ranges);
       }
     }
   }
 
   Object writeReplace() {
