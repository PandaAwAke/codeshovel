diff --git a/android/guava/src/com/google/common/collect/ContiguousSet.java b/android/guava/src/com/google/common/collect/ContiguousSet.java
index c83ef517b..3d19be65e 100644
--- a/android/guava/src/com/google/common/collect/ContiguousSet.java
+++ b/android/guava/src/com/google/common/collect/ContiguousSet.java
@@ -1,127 +1,195 @@
 /*
  * Copyright (C) 2010 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software distributed under the License
  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Collections;
 import java.util.NoSuchElementException;
 import java.util.Set;
 
 /**
- * A sorted set of contiguous values in a given {@link DiscreteDomain}.
+ * A sorted set of contiguous values in a given {@link DiscreteDomain}. Example:
+ *
+ * <pre>{@code
+ * ContiguousSet.create(Range.closed(5, 42), DiscreteDomain.integers())
+ * }</pre>
+ *
+ * <p>Note that because bounded ranges over {@code int} and {@code long} values are so common, this
+ * particular example can be written as just:
+ *
+ * <pre>{@code
+ * ContiguousSet.closed(5, 42)
+ * }</pre>
  *
  * <p><b>Warning:</b> Be extremely careful what you do with conceptually large instances (such as
  * {@code ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers()}). Certain
  * operations on such a set can be performed efficiently, but others (such as {@link Set#hashCode}
  * or {@link Collections#frequency}) can cause major performance problems.
  *
  * @author Gregory Kick
  * @since 10.0
  */
 @GwtCompatible(emulated = true)
 @SuppressWarnings("rawtypes") // allow ungenerified Comparable types
 public abstract class ContiguousSet<C extends Comparable> extends ImmutableSortedSet<C> {
   /**
    * Returns a {@code ContiguousSet} containing the same values in the given domain
    * {@linkplain Range#contains contained} by the range.
    *
    * @throws IllegalArgumentException if neither range nor the domain has a lower bound, or if
    *     neither has an upper bound
    *
    * @since 13.0
    */
   public static <C extends Comparable> ContiguousSet<C> create(
       Range<C> range, DiscreteDomain<C> domain) {
     checkNotNull(range);
     checkNotNull(domain);
     Range<C> effectiveRange = range;
     try {
       if (!range.hasLowerBound()) {
         effectiveRange = effectiveRange.intersection(Range.atLeast(domain.minValue()));
       }
       if (!range.hasUpperBound()) {
         effectiveRange = effectiveRange.intersection(Range.atMost(domain.maxValue()));
       }
     } catch (NoSuchElementException e) {
       throw new IllegalArgumentException(e);
     }
 
     // Per class spec, we are allowed to throw CCE if necessary
     boolean empty =
         effectiveRange.isEmpty()
             || Range.compareOrThrow(
                     range.lowerBound.leastValueAbove(domain),
                     range.upperBound.greatestValueBelow(domain))
                 > 0;
 
     return empty
         ? new EmptyContiguousSet<C>(domain)
         : new RegularContiguousSet<C>(effectiveRange, domain);
   }
 
+  /**
+   * Returns a nonempty contiguous set containing all {@code int} values from {@code lower}
+   * (inclusive) to {@code upper} (inclusive). (These are the same values contained in {@code
+   * Range.closed(lower, upper)}.)
+   *
+   * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   *
+   * @since 23.0
+   */
+  @Beta
+  public static ContiguousSet<Integer> closed(int lower, int upper) {
+    return create(Range.closed(lower, upper), DiscreteDomain.integers());
+  }
+
+  /**
+   * Returns a nonempty contiguous set containing all {@code long} values from {@code lower}
+   * (inclusive) to {@code upper} (inclusive). (These are the same values contained in {@code
+   * Range.closed(lower, upper)}.)
+   *
+   * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   *
+   * @since 23.0
+   */
+  @Beta
+  public static ContiguousSet<Long> closed(long lower, long upper) {
+    return create(Range.closed(lower, upper), DiscreteDomain.longs());
+  }
+
+  /**
+   * Returns a contiguous set containing all {@code int} values from {@code lower} (inclusive) to
+   * {@code upper} (exclusive). If the endpoints are equal, an empty set is returned. (These are the
+   * same values contained in {@code Range.closedOpen(lower, upper)}.)
+   *
+   * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   *
+   * @since 23.0
+   */
+  @Beta
+  public static ContiguousSet<Integer> closedOpen(int lower, int upper) {
+    return create(Range.closedOpen(lower, upper), DiscreteDomain.integers());
+  }
+
+  /**
+   * Returns a contiguous set containing all {@code long} values from {@code lower} (inclusive) to
+   * {@code upper} (exclusive). If the endpoints are equal, an empty set is returned. (These are the
+   * same values contained in {@code Range.closedOpen(lower, upper)}.)
+   *
+   * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   *
+   * @since 23.0
+   */
+  @Beta
+  public static ContiguousSet<Long> closedOpen(long lower, long upper) {
+    return create(Range.closedOpen(lower, upper), DiscreteDomain.longs());
+  }
+
   final DiscreteDomain<C> domain;
 
   ContiguousSet(DiscreteDomain<C> domain) {
     super(Ordering.natural());
     this.domain = domain;
   }
 
   @Override
   public ContiguousSet<C> headSet(C toElement) {
     return headSetImpl(checkNotNull(toElement), false);
   }
 
   /**
    * @since 12.0
    */
   @GwtIncompatible // NavigableSet
   @Override
   public ContiguousSet<C> headSet(C toElement, boolean inclusive) {
     return headSetImpl(checkNotNull(toElement), inclusive);
   }
 
   @Override
   public ContiguousSet<C> subSet(C fromElement, C toElement) {
     checkNotNull(fromElement);
     checkNotNull(toElement);
     checkArgument(comparator().compare(fromElement, toElement) <= 0);
     return subSetImpl(fromElement, true, toElement, false);
   }
 
   /**
    * @since 12.0
    */
   @GwtIncompatible // NavigableSet
   @Override
   public ContiguousSet<C> subSet(
       C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {
     checkNotNull(fromElement);
     checkNotNull(toElement);
     checkArgument(comparator().compare(fromElement, toElement) <= 0);
     return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
   }
 
   @Override
   public ContiguousSet<C> tailSet(C fromElement) {
     return tailSetImpl(checkNotNull(fromElement), true);
   }
 
   /**
    * @since 12.0
    */
