diff --git a/android/guava/src/com/google/common/collect/MapMakerInternalMap.java b/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
index 6fbd27b93..73aecd904 100644
--- a/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
+++ b/android/guava/src/com/google/common/collect/MapMakerInternalMap.java
@@ -2721,165 +2721,165 @@ class MapMakerInternalMap<
     }
 
     @Override
     public boolean remove(Object o) {
       return MapMakerInternalMap.this.remove(o) != null;
     }
 
     @Override
     public void clear() {
       MapMakerInternalMap.this.clear();
     }
   }
 
   @WeakOuter
   final class Values extends AbstractCollection<V> {
 
     @Override
     public Iterator<V> iterator() {
       return new ValueIterator();
     }
 
     @Override
     public int size() {
       return MapMakerInternalMap.this.size();
     }
 
     @Override
     public boolean isEmpty() {
       return MapMakerInternalMap.this.isEmpty();
     }
 
     @Override
     public boolean contains(Object o) {
       return MapMakerInternalMap.this.containsValue(o);
     }
 
     @Override
     public void clear() {
       MapMakerInternalMap.this.clear();
     }
 
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
     // https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
 
     @Override
     public Object[] toArray() {
       return toArrayList(this).toArray();
     }
 
     @Override
-    public <E> E[] toArray(E[] a) {
+    public <T> T[] toArray(T[] a) {
       return toArrayList(this).toArray(a);
     }
   }
 
   @WeakOuter
   final class EntrySet extends SafeToArraySet<Entry<K, V>> {
 
     @Override
     public Iterator<Entry<K, V>> iterator() {
       return new EntryIterator();
     }
 
     @Override
     public boolean contains(Object o) {
       if (!(o instanceof Entry)) {
         return false;
       }
       Entry<?, ?> e = (Entry<?, ?>) o;
       Object key = e.getKey();
       if (key == null) {
         return false;
       }
       V v = MapMakerInternalMap.this.get(key);
 
       return v != null && valueEquivalence().equivalent(e.getValue(), v);
     }
 
     @Override
     public boolean remove(Object o) {
       if (!(o instanceof Entry)) {
         return false;
       }
       Entry<?, ?> e = (Entry<?, ?>) o;
       Object key = e.getKey();
       return key != null && MapMakerInternalMap.this.remove(key, e.getValue());
     }
 
     @Override
     public int size() {
       return MapMakerInternalMap.this.size();
     }
 
     @Override
     public boolean isEmpty() {
       return MapMakerInternalMap.this.isEmpty();
     }
 
     @Override
     public void clear() {
       MapMakerInternalMap.this.clear();
     }
   }
 
   private abstract static class SafeToArraySet<E> extends AbstractSet<E> {
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
     // https://code.google.com/p/android/issues/detail?id=36519 / http://r.android.com/47508
 
     @Override
     public Object[] toArray() {
       return toArrayList(this).toArray();
     }
 
     @Override
-    public <E> E[] toArray(E[] a) {
+    public <T> T[] toArray(T[] a) {
       return toArrayList(this).toArray(a);
     }
   }
 
   private static <E> ArrayList<E> toArrayList(Collection<E> c) {
     // Avoid calling ArrayList(Collection), which may call back into toArray.
     ArrayList<E> result = new ArrayList<>(c.size());
     Iterators.addAll(result, c.iterator());
     return result;
   }
 
   // Serialization Support
 
   private static final long serialVersionUID = 5;
 
   Object writeReplace() {
     return new SerializationProxy<>(
         entryHelper.keyStrength(),
         entryHelper.valueStrength(),
         keyEquivalence,
         entryHelper.valueStrength().defaultEquivalence(),
         concurrencyLevel,
         this);
   }
 
   /**
    * The actual object that gets serialized. Unfortunately, readResolve() doesn't get called when a
    * circular dependency is present, so the proxy must be able to behave as the map itself.
    */
   abstract static class AbstractSerializationProxy<K, V> extends ForwardingConcurrentMap<K, V>
       implements Serializable {
     private static final long serialVersionUID = 3;
 
     final Strength keyStrength;
     final Strength valueStrength;
     final Equivalence<Object> keyEquivalence;
     final Equivalence<Object> valueEquivalence;
     final int concurrencyLevel;
 
     transient ConcurrentMap<K, V> delegate;
 
     AbstractSerializationProxy(
         Strength keyStrength,
         Strength valueStrength,
         Equivalence<Object> keyEquivalence,
         Equivalence<Object> valueEquivalence,
         int concurrencyLevel,
         ConcurrentMap<K, V> delegate) {
       this.keyStrength = keyStrength;
       this.valueStrength = valueStrength;
