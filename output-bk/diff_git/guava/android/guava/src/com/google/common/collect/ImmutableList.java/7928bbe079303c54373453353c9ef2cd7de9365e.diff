diff --git a/android/guava/src/com/google/common/collect/ImmutableList.java b/android/guava/src/com/google/common/collect/ImmutableList.java
index a3e7c5828..f6e791396 100644
--- a/android/guava/src/com/google/common/collect/ImmutableList.java
+++ b/android/guava/src/com/google/common/collect/ImmutableList.java
@@ -1,74 +1,76 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
 import static com.google.common.collect.RegularImmutableList.EMPTY;
 
+import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.RandomAccess;
 import javax.annotation.Nullable;
 
 /**
  * A {@link List} whose contents will never change, with many other important properties detailed at
  * {@link ImmutableCollection}.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">
  * immutable collections</a>.
  *
  * @see ImmutableMap
  * @see ImmutableSet
  * @author Kevin Bourrillion
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 public abstract class ImmutableList<E> extends ImmutableCollection<E>
     implements List<E>, RandomAccess {
   /**
    * Returns the empty immutable list. This list behaves and performs comparably
    * to {@link Collections#emptyList}, and is preferable mainly for consistency
    * and maintainability of your code.
    */
   // Casting to any type is safe because the list will never hold any elements.
   @SuppressWarnings("unchecked")
   public static <E> ImmutableList<E> of() {
     return (ImmutableList<E>) EMPTY;
   }
 
   /**
    * Returns an immutable list containing a single element. This list behaves
    * and performs comparably to {@link Collections#singleton}, but will not
    * accept a null element. It is preferable mainly for consistency and
    * maintainability of your code.
    *
    * @throws NullPointerException if {@code element} is null
    */
@@ -592,129 +594,146 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
   }
 
   @Override
   public int hashCode() {
     int hashCode = 1;
     int n = size();
     for (int i = 0; i < n; i++) {
       hashCode = 31 * hashCode + get(i).hashCode();
 
       hashCode = ~~hashCode;
       // needed to deal with GWT integer overflow
     }
     return hashCode;
   }
 
   /*
    * Serializes ImmutableLists as their logical contents. This ensures that
    * implementation types do not leak into the serialized representation.
    */
   static class SerializedForm implements Serializable {
     final Object[] elements;
 
     SerializedForm(Object[] elements) {
       this.elements = elements;
     }
 
     Object readResolve() {
       return copyOf(elements);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   private void readObject(ObjectInputStream stream) throws InvalidObjectException {
     throw new InvalidObjectException("Use SerializedForm");
   }
 
   @Override
   Object writeReplace() {
     return new SerializedForm(toArray());
   }
 
   /**
    * Returns a new builder. The generated builder is equivalent to the builder
    * created by the {@link Builder} constructor.
    */
   public static <E> Builder<E> builder() {
     return new Builder<E>();
   }
 
+  /**
+   * Returns a new builder, expecting the specified number of elements to be added.
+   *
+   * <p>If {@code expectedSize} is exactly the number of elements added to the builder before {@link
+   * Builder#build} is called, the builder is likely to perform better than an unsized {@link
+   * #builder()} would have.
+   *
+   * <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
+   * but not exactly, the number of elements added to the builder.
+   *
+   * @since 24.0
+   */
+  @Beta
+  public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {
+    checkNonnegative(expectedSize, "expectedSize");
+    return new ImmutableList.Builder<E>(expectedSize);
+  }
+
   /**
    * A builder for creating immutable list instances, especially {@code public
    * static final} lists ("constant lists"). Example: <pre>   {@code
    *
    *   public static final ImmutableList<Color> GOOGLE_COLORS
    *       = new ImmutableList.Builder<Color>()
    *           .addAll(WEBSAFE_COLORS)
    *           .add(new Color(0, 191, 255))
    *           .build();}</pre>
    *
    * <p>Elements appear in the resulting list in the same order they were added
    * to the builder.
    *
    * <p>Builder instances can be reused; it is safe to call {@link #build} multiple
    * times to build multiple lists in series. Each new list contains all the
    * elements of the ones created before it.
    *
    * @since 2.0
    */
   public static final class Builder<E> extends ImmutableCollection.ArrayBasedBuilder<E> {
     /**
      * Creates a new builder. The returned builder is equivalent to the builder
      * generated by {@link ImmutableList#builder}.
      */
     public Builder() {
       this(DEFAULT_INITIAL_CAPACITY);
     }
 
-    // TODO(lowasser): consider exposing this
     Builder(int capacity) {
       super(capacity);
     }
 
     /**
      * Adds {@code element} to the {@code ImmutableList}.
      *
      * @param element the element to add
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       super.add(element);
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableList}.
      *
      * @param elements the {@code Iterable} to add to the {@code ImmutableList}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a
      *     null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableList}.
      *
      * @param elements the {@code Iterable} to add to the {@code ImmutableList}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a
      *     null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableList}.
