diff --git a/android/guava/src/com/google/common/collect/ImmutableMultiset.java b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
index f831871a9..2dca981f0 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultiset.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
@@ -358,101 +358,101 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
       return new EntrySetSerializedForm<E>(ImmutableMultiset.this);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   static class EntrySetSerializedForm<E> implements Serializable {
     final ImmutableMultiset<E> multiset;
 
     EntrySetSerializedForm(ImmutableMultiset<E> multiset) {
       this.multiset = multiset;
     }
 
     Object readResolve() {
       return multiset.entrySet();
     }
   }
 
   // We can't label this with @Override, because it doesn't override anything
   // in the GWT emulated version.
   abstract Object writeReplace();
 
   /**
    * Returns a new builder. The generated builder is equivalent to the builder created by the {@link
    * Builder} constructor.
    */
   public static <E> Builder<E> builder() {
     return new Builder<E>();
   }
 
   /**
    * A builder for creating immutable multiset instances, especially {@code public static final}
    * multisets ("constant multisets"). Example:
    *
    * <pre>{@code
    * public static final ImmutableMultiset<Bean> BEANS =
    *     new ImmutableMultiset.Builder<Bean>()
    *         .addCopies(Bean.COCOA, 4)
    *         .addCopies(Bean.GARDEN, 6)
    *         .addCopies(Bean.RED, 8)
    *         .addCopies(Bean.BLACK_EYED, 10)
    *         .build();
    * }</pre>
    *
    * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
    * multiple multisets in series.
    *
    * @since 2.0
    */
   public static class Builder<E> extends ImmutableCollection.Builder<E> {
-    AbstractObjectCountMap<E> contents;
+    ObjectCountHashMap<E> contents;
 
     /**
      * If build() has been called on the current contents multiset, we need to copy it on any future
      * modifications, or we'll modify the already-built ImmutableMultiset.
      */
     boolean buildInvoked = false;
     /**
      * In the event of a setCount(elem, 0) call, we may need to remove elements, which destroys the
      * insertion order property of ObjectCountHashMap. In that event, we need to convert to a
      * ObjectCountLinkedHashMap, but we need to know we did that so we can convert back.
      */
     boolean isLinkedHash = false;
 
     /**
      * Creates a new builder. The returned builder is equivalent to the builder generated by {@link
      * ImmutableMultiset#builder}.
      */
     public Builder() {
       this(4);
     }
 
     Builder(int estimatedDistinct) {
       this.contents = ObjectCountHashMap.createWithExpectedSize(estimatedDistinct);
     }
 
     Builder(boolean forSubtype) {
       // for ImmutableSortedMultiset not to allocate data structures not used there
       this.contents = null;
     }
 
     /**
      * Adds {@code element} to the {@code ImmutableMultiset}.
      *
      * @param element the element to add
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code element} is null
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
       return addCopies(element, 1);
     }
 
     /**
      * Adds a number of occurrences of an element to this {@code ImmutableMultiset}.
      *
      * @param element the element to add
      * @param occurrences the number of occurrences of the element to add. May be zero, in which
      *     case no change will be made.
      * @return this {@code Builder} object
@@ -514,65 +514,65 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableMultiset}.
      *
      * @param elements the {@code Iterable} to add to the {@code ImmutableMultiset}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       if (elements instanceof Multiset) {
         Multiset<? extends E> multiset = Multisets.cast(elements);
         for (Entry<? extends E> entry : multiset.entrySet()) {
           addCopies(entry.getElement(), entry.getCount());
         }
       } else {
         super.addAll(elements);
       }
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableMultiset}.
      *
      * @param elements the elements to add to the {@code ImmutableMultiset}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
     /**
      * Returns a newly-created {@code ImmutableMultiset} based on the contents of the {@code
      * Builder}.
      */
     @Override
     public ImmutableMultiset<E> build() {
-      if (contents.isEmpty()) {
+      if (contents.size() == 0) {
         return of();
       }
       if (isLinkedHash) {
         // we need ObjectCountHashMap-backed contents, with its keys and values array in direct
         // insertion order
         contents = new ObjectCountHashMap<E>(contents);
         isLinkedHash = false;
       }
       buildInvoked = true;
       // contents is now ObjectCountHashMap, but still guaranteed to be in insertion order!
-      return new RegularImmutableMultiset<E>((ObjectCountHashMap<E>) contents);
+      return new RegularImmutableMultiset<E>(contents);
     }
   }
 }
