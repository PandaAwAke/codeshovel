diff --git a/android/guava/src/com/google/common/collect/ImmutableMultimap.java b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
index a0b5f1273..961e05379 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultimap.java
@@ -1,86 +1,87 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.Weak;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * A {@link Multimap} whose contents will never change, with many other important properties
  * detailed at {@link ImmutableCollection}.
  *
  * <p><b>Warning:</b> avoid <i>direct</i> usage of {@link ImmutableMultimap} as a type (as with
  * {@link Multimap} itself). Prefer subtypes such as {@link ImmutableSetMultimap} or {@link
  * ImmutableListMultimap}, which have well-defined {@link #equals} semantics, thus avoiding a common
  * source of bugs and confusion.
  *
  * <p><b>Note:</b> every {@link ImmutableMultimap} offers an {@link #inverse} view, so there is no
  * need for a distinct {@code ImmutableBiMultimap} type.
  *
  * <p><a name="iteration"></a>
  *
  * <p><b>Key-grouped iteration.</b> All view collections follow the same iteration order. In all
  * current implementations, the iteration order always keeps multiple entries with the same key
  * together. Any creation method that would customarily respect insertion order (such as {@link
  * #copyOf(Multimap)}) instead preserves key-grouped order by inserting entries for an existing key
  * immediately after the last entry having that key.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained"> immutable collections</a>.
  *
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(emulated = true)
 public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
     implements Serializable {
 
   /** Returns an empty multimap. */
   public static <K, V> ImmutableMultimap<K, V> of() {
     return ImmutableListMultimap.of();
   }
 
   /** Returns an immutable multimap containing a single entry. */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) {
     return ImmutableListMultimap.of(k1, v1);
   }
 
   /** Returns an immutable multimap containing the given entries, in order. */
   public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {
     return ImmutableListMultimap.of(k1, v1, k2, v2);
   }
 
   /**
    * Returns an immutable multimap containing the given entries, in the "key-grouped" insertion
    * order described in the <a href="#iteration">class documentation</a>.
@@ -442,100 +443,105 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
    * Guaranteed to throw an exception and leave the multimap unmodified.
    *
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
   @Deprecated
   @Override
   public boolean remove(Object key, Object value) {
     throw new UnsupportedOperationException();
   }
 
   /**
    * Returns {@code true} if this immutable multimap's implementation contains references to
    * user-created objects that aren't accessible via this multimap's methods. This is generally used
    * to determine whether {@code copyOf} implementations should make an explicit copy to avoid
    * memory leaks.
    */
   boolean isPartialView() {
     return map.isPartialView();
   }
 
   // accessors
 
   @Override
   public boolean containsKey(@NullableDecl Object key) {
     return map.containsKey(key);
   }
 
   @Override
   public boolean containsValue(@NullableDecl Object value) {
     return value != null && super.containsValue(value);
   }
 
   @Override
   public int size() {
     return size;
   }
 
   // views
 
   /**
    * Returns an immutable set of the distinct keys in this multimap, in the same order as they
    * appear in this multimap.
    */
   @Override
   public ImmutableSet<K> keySet() {
     return map.keySet();
   }
 
+  @Override
+  Set<K> createKeySet() {
+    throw new AssertionError("unreachable");
+  }
+
   /**
    * Returns an immutable map that associates each key with its corresponding values in the
    * multimap. Keys and values appear in the same order as in this multimap.
    */
   @Override
   @SuppressWarnings("unchecked") // a widening cast
   public ImmutableMap<K, Collection<V>> asMap() {
     return (ImmutableMap) map;
   }
 
   @Override
   Map<K, Collection<V>> createAsMap() {
     throw new AssertionError("should never be called");
   }
 
   /** Returns an immutable collection of all key-value pairs in the multimap. */
   @Override
   public ImmutableCollection<Entry<K, V>> entries() {
     return (ImmutableCollection<Entry<K, V>>) super.entries();
   }
 
   @Override
   ImmutableCollection<Entry<K, V>> createEntries() {
     return new EntryCollection<>(this);
   }
 
   private static class EntryCollection<K, V> extends ImmutableCollection<Entry<K, V>> {
     @Weak final ImmutableMultimap<K, V> multimap;
 
     EntryCollection(ImmutableMultimap<K, V> multimap) {
       this.multimap = multimap;
     }
 
     @Override
     public UnmodifiableIterator<Entry<K, V>> iterator() {
       return multimap.entryIterator();
     }
 
     @Override
     boolean isPartialView() {
       return multimap.isPartialView();
     }
 
     @Override
     public int size() {
       return multimap.size();
     }
 
     @Override
     public boolean contains(Object object) {
