diff --git a/android/guava/src/com/google/common/collect/Maps.java b/android/guava/src/com/google/common/collect/Maps.java
index d1ec1dc82..c7e8ec029 100644
--- a/android/guava/src/com/google/common/collect/Maps.java
+++ b/android/guava/src/com/google/common/collect/Maps.java
@@ -99,414 +99,414 @@ public final class Maps {
     };
   }
 
   @SuppressWarnings("unchecked")
   static <K> Function<Entry<K, ?>, K> keyFunction() {
     return (Function) EntryFunction.KEY;
   }
 
   @SuppressWarnings("unchecked")
   static <V> Function<Entry<?, V>, V> valueFunction() {
     return (Function) EntryFunction.VALUE;
   }
 
   static <K, V> Iterator<K> keyIterator(Iterator<Entry<K, V>> entryIterator) {
     return Iterators.transform(entryIterator, Maps.<K>keyFunction());
   }
 
   static <K, V> Iterator<V> valueIterator(Iterator<Entry<K, V>> entryIterator) {
     return Iterators.transform(entryIterator, Maps.<V>valueFunction());
   }
 
   /**
    * Returns an immutable map instance containing the given entries.
    * Internally, the returned map will be backed by an {@link EnumMap}.
    *
    * <p>The iteration order of the returned map follows the enum's iteration
    * order, not the order in which the elements appear in the given map.
    *
    * @param map the map to make an immutable copy of
    * @return an immutable map containing those entries
    * @since 14.0
    */
   @GwtCompatible(serializable = true)
   @Beta
   public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(
       Map<K, ? extends V> map) {
     if (map instanceof ImmutableEnumMap) {
       @SuppressWarnings("unchecked") // safe covariant cast
       ImmutableEnumMap<K, V> result = (ImmutableEnumMap<K, V>) map;
       return result;
     }
     Iterator<? extends Map.Entry<K, ? extends V>> entryItr = map.entrySet().iterator();
     if (!entryItr.hasNext()) {
       return ImmutableMap.of();
     }
     Map.Entry<K, ? extends V> entry1 = entryItr.next();
     K key1 = entry1.getKey();
     V value1 = entry1.getValue();
     checkEntryNotNull(key1, value1);
     Class<K> clazz = key1.getDeclaringClass();
-    EnumMap<K, V> enumMap = new EnumMap<K, V>(clazz);
+    EnumMap<K, V> enumMap = new EnumMap<>(clazz);
     enumMap.put(key1, value1);
     while (entryItr.hasNext()) {
       Entry<K, ? extends V> entry = entryItr.next();
       K key = entry.getKey();
       V value = entry.getValue();
       checkEntryNotNull(key, value);
       enumMap.put(key, value);
     }
     return ImmutableEnumMap.asImmutable(enumMap);
   }
 
   /**
    * Creates a <i>mutable</i>, empty {@code HashMap} instance.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableMap#of()} instead.
    *
    * <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link
    * #newEnumMap} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code HashMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @return a new, empty {@code HashMap}
    */
   public static <K, V> HashMap<K, V> newHashMap() {
-    return new HashMap<K, V>();
+    return new HashMap<>();
   }
 
   /**
    * Creates a {@code HashMap} instance, with a high enough "initial capacity"
    * that it <i>should</i> hold {@code expectedSize} elements without growth.
    * This behavior cannot be broadly guaranteed, but it is observed to be true
    * for OpenJDK 1.7. It also can't be guaranteed that the method isn't
    * inadvertently <i>oversizing</i> the returned map.
    *
    * @param expectedSize the number of entries you expect to add to the
    *        returned map
    * @return a new, empty {@code HashMap} with enough capacity to hold {@code
    *         expectedSize} entries without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
   public static <K, V> HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) {
-    return new HashMap<K, V>(capacity(expectedSize));
+    return new HashMap<>(capacity(expectedSize));
   }
 
   /**
    * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no
    * larger than expectedSize and the load factor is â‰¥ its default (0.75).
    */
   static int capacity(int expectedSize) {
     if (expectedSize < 3) {
       checkNonnegative(expectedSize, "expectedSize");
       return expectedSize + 1;
     }
     if (expectedSize < Ints.MAX_POWER_OF_TWO) {
       // This is the calculation used in JDK8 to resize when a putAll
       // happens; it seems to be the most conservative calculation we
       // can make.  0.75 is the default load factor.
       return (int) ((float) expectedSize / 0.75F + 1.0F);
     }
     return Integer.MAX_VALUE; // any large value
   }
 
   /**
    * Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as
    * the specified map.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableMap#copyOf(Map)} instead.
    *
    * <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link
    * #newEnumMap} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code HashMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @param map the mappings to be placed in the new map
    * @return a new {@code HashMap} initialized with the mappings from {@code
    *         map}
    */
   public static <K, V> HashMap<K, V> newHashMap(Map<? extends K, ? extends V> map) {
-    return new HashMap<K, V>(map);
+    return new HashMap<>(map);
   }
 
   /**
    * Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}
    * instance.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableMap#of()} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code LinkedHashMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @return a new, empty {@code LinkedHashMap}
    */
   public static <K, V> LinkedHashMap<K, V> newLinkedHashMap() {
-    return new LinkedHashMap<K, V>();
+    return new LinkedHashMap<>();
   }
 
   /**
    * Creates a {@code LinkedHashMap} instance, with a high enough
    * "initial capacity" that it <i>should</i> hold {@code expectedSize}
    * elements without growth. This behavior cannot be broadly guaranteed, but
    * it is observed to be true for OpenJDK 1.7. It also can't be guaranteed
    * that the method isn't inadvertently <i>oversizing</i> the returned map.
    *
    * @param expectedSize the number of entries you expect to add to the
    *        returned map
    * @return a new, empty {@code LinkedHashMap} with enough capacity to hold
    *         {@code expectedSize} entries without resizing
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    * @since 19.0
    */
   public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
-    return new LinkedHashMap<K, V>(capacity(expectedSize));
+    return new LinkedHashMap<>(capacity(expectedSize));
   }
 
   /**
    * Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance
    * with the same mappings as the specified map.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableMap#copyOf(Map)} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code LinkedHashMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @param map the mappings to be placed in the new map
    * @return a new, {@code LinkedHashMap} initialized with the mappings from
    *         {@code map}
    */
   public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(Map<? extends K, ? extends V> map) {
-    return new LinkedHashMap<K, V>(map);
+    return new LinkedHashMap<>(map);
   }
 
   /**
    * Creates a new empty {@link ConcurrentHashMap} instance.
    *
    * @since 3.0
    */
   public static <K, V> ConcurrentMap<K, V> newConcurrentMap() {
     return new ConcurrentHashMap<>();
   }
 
   /**
    * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural
    * ordering of its elements.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableSortedMap#of()} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code TreeMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @return a new, empty {@code TreeMap}
    */
   public static <K extends Comparable, V> TreeMap<K, V> newTreeMap() {
-    return new TreeMap<K, V>();
+    return new TreeMap<>();
   }
 
   /**
    * Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as
    * the specified map and using the same ordering as the specified map.
    *
    * <p><b>Note:</b> if mutability is not required, use {@link
    * ImmutableSortedMap#copyOfSorted(SortedMap)} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code TreeMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @param map the sorted map whose mappings are to be placed in the new map
    *        and whose comparator is to be used to sort the new map
    * @return a new {@code TreeMap} initialized with the mappings from {@code
    *         map} and using the comparator of {@code map}
    */
   public static <K, V> TreeMap<K, V> newTreeMap(SortedMap<K, ? extends V> map) {
-    return new TreeMap<K, V>(map);
+    return new TreeMap<>(map);
   }
 
   /**
    * Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given
    * comparator.
    *
    * <p><b>Note:</b> if mutability is not required, use {@code
    * ImmutableSortedMap.orderedBy(comparator).build()} instead.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code TreeMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @param comparator the comparator to sort the keys with
    * @return a new, empty {@code TreeMap}
    */
   public static <C, K extends C, V> TreeMap<K, V> newTreeMap(@Nullable Comparator<C> comparator) {
     // Ideally, the extra type parameter "C" shouldn't be necessary. It is a
     // work-around of a compiler type inference quirk that prevents the
     // following code from being compiled:
     // Comparator<Class<?>> comparator = null;
     // Map<Class<? extends Throwable>, String> map = newTreeMap(comparator);
-    return new TreeMap<K, V>(comparator);
+    return new TreeMap<>(comparator);
   }
 
   /**
    * Creates an {@code EnumMap} instance.
    *
    * @param type the key type for this map
    * @return a new, empty {@code EnumMap}
    */
   public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Class<K> type) {
-    return new EnumMap<K, V>(checkNotNull(type));
+    return new EnumMap<>(checkNotNull(type));
   }
 
   /**
    * Creates an {@code EnumMap} with the same mappings as the specified map.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code EnumMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @param map the map from which to initialize this {@code EnumMap}
    * @return a new {@code EnumMap} initialized with the mappings from {@code
    *         map}
    * @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}
    *         instance and contains no mappings
    */
   public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Map<K, ? extends V> map) {
-    return new EnumMap<K, V>(map);
+    return new EnumMap<>(map);
   }
 
   /**
    * Creates an {@code IdentityHashMap} instance.
    *
    * <p><b>Note for Java 7 and later:</b> this method is now unnecessary and
    * should be treated as deprecated. Instead, use the {@code IdentityHashMap}
    * constructor directly, taking advantage of the new
    * <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
    *
    * @return a new, empty {@code IdentityHashMap}
    */
   public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {
-    return new IdentityHashMap<K, V>();
+    return new IdentityHashMap<>();
   }
 
   /**
    * Computes the difference between two maps. This difference is an immutable
    * snapshot of the state of the maps at the time this method is called. It
    * will never change, even if the maps change at a later time.
    *
    * <p>Since this method uses {@code HashMap} instances internally, the keys of
    * the supplied maps must be well-behaved with respect to
    * {@link Object#equals} and {@link Object#hashCode}.
    *
    * <p><b>Note:</b>If you only need to know whether two maps have the same
    * mappings, call {@code left.equals(right)} instead of this method.
    *
    * @param left the map to treat as the "left" map for purposes of comparison
    * @param right the map to treat as the "right" map for purposes of comparison
    * @return the difference between the two maps
    */
   @SuppressWarnings("unchecked")
   public static <K, V> MapDifference<K, V> difference(
       Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {
     if (left instanceof SortedMap) {
       SortedMap<K, ? extends V> sortedLeft = (SortedMap<K, ? extends V>) left;
       return difference(sortedLeft, right);
     }
     return difference(left, right, Equivalence.equals());
   }
 
   /**
    * Computes the difference between two maps. This difference is an immutable
    * snapshot of the state of the maps at the time this method is called. It
    * will never change, even if the maps change at a later time.
    *
    * <p>Since this method uses {@code HashMap} instances internally, the keys of
    * the supplied maps must be well-behaved with respect to
    * {@link Object#equals} and {@link Object#hashCode}.
    *
    * @param left the map to treat as the "left" map for purposes of comparison
    * @param right the map to treat as the "right" map for purposes of comparison
    * @param valueEquivalence the equivalence relationship to use to compare
    *    values
    * @return the difference between the two maps
    * @since 10.0
    */
   public static <K, V> MapDifference<K, V> difference(
       Map<? extends K, ? extends V> left,
       Map<? extends K, ? extends V> right,
       Equivalence<? super V> valueEquivalence) {
     Preconditions.checkNotNull(valueEquivalence);
 
     Map<K, V> onlyOnLeft = newLinkedHashMap();
-    Map<K, V> onlyOnRight = new LinkedHashMap<K, V>(right); // will whittle it down
+    Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down
     Map<K, V> onBoth = newLinkedHashMap();
     Map<K, MapDifference.ValueDifference<V>> differences = newLinkedHashMap();
     doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);
-    return new MapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);
+    return new MapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);
   }
 
   private static <K, V> void doDifference(
       Map<? extends K, ? extends V> left,
       Map<? extends K, ? extends V> right,
       Equivalence<? super V> valueEquivalence,
       Map<K, V> onlyOnLeft,
       Map<K, V> onlyOnRight,
       Map<K, V> onBoth,
       Map<K, MapDifference.ValueDifference<V>> differences) {
     for (Entry<? extends K, ? extends V> entry : left.entrySet()) {
       K leftKey = entry.getKey();
       V leftValue = entry.getValue();
       if (right.containsKey(leftKey)) {
         V rightValue = onlyOnRight.remove(leftKey);
         if (valueEquivalence.equivalent(leftValue, rightValue)) {
           onBoth.put(leftKey, leftValue);
         } else {
           differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));
         }
       } else {
         onlyOnLeft.put(leftKey, leftValue);
       }
     }
   }
 
   private static <K, V> Map<K, V> unmodifiableMap(Map<K, ? extends V> map) {
     if (map instanceof SortedMap) {
       return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);
     } else {
       return Collections.unmodifiableMap(map);
     }
   }
 
   static class MapDifferenceImpl<K, V> implements MapDifference<K, V> {
     final Map<K, V> onlyOnLeft;
     final Map<K, V> onlyOnRight;
     final Map<K, V> onBoth;
     final Map<K, ValueDifference<V>> differences;
 
     MapDifferenceImpl(
         Map<K, V> onlyOnLeft,
         Map<K, V> onlyOnRight,
         Map<K, V> onBoth,
         Map<K, ValueDifference<V>> differences) {
       this.onlyOnLeft = unmodifiableMap(onlyOnLeft);
       this.onlyOnRight = unmodifiableMap(onlyOnRight);
       this.onBoth = unmodifiableMap(onBoth);
       this.differences = unmodifiableMap(differences);
     }
@@ -604,238 +604,238 @@ public final class Maps {
     public boolean equals(@Nullable Object object) {
       if (object instanceof MapDifference.ValueDifference) {
         MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;
         return Objects.equal(this.left, that.leftValue())
             && Objects.equal(this.right, that.rightValue());
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return Objects.hashCode(left, right);
     }
 
     @Override
     public String toString() {
       return "(" + left + ", " + right + ")";
     }
   }
 
   /**
    * Computes the difference between two sorted maps, using the comparator of
    * the left map, or {@code Ordering.natural()} if the left map uses the
    * natural ordering of its elements. This difference is an immutable snapshot
    * of the state of the maps at the time this method is called. It will never
    * change, even if the maps change at a later time.
    *
    * <p>Since this method uses {@code TreeMap} instances internally, the keys of
    * the right map must all compare as distinct according to the comparator
    * of the left map.
    *
    * <p><b>Note:</b>If you only need to know whether two sorted maps have the
    * same mappings, call {@code left.equals(right)} instead of this method.
    *
    * @param left the map to treat as the "left" map for purposes of comparison
    * @param right the map to treat as the "right" map for purposes of comparison
    * @return the difference between the two maps
    * @since 11.0
    */
   public static <K, V> SortedMapDifference<K, V> difference(
       SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {
     checkNotNull(left);
     checkNotNull(right);
     Comparator<? super K> comparator = orNaturalOrder(left.comparator());
     SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);
     SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);
     onlyOnRight.putAll(right); // will whittle it down
     SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);
     SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);
     doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);
-    return new SortedMapDifferenceImpl<K, V>(onlyOnLeft, onlyOnRight, onBoth, differences);
+    return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);
   }
 
   static class SortedMapDifferenceImpl<K, V> extends MapDifferenceImpl<K, V>
       implements SortedMapDifference<K, V> {
     SortedMapDifferenceImpl(
         SortedMap<K, V> onlyOnLeft,
         SortedMap<K, V> onlyOnRight,
         SortedMap<K, V> onBoth,
         SortedMap<K, ValueDifference<V>> differences) {
       super(onlyOnLeft, onlyOnRight, onBoth, differences);
     }
 
     @Override
     public SortedMap<K, ValueDifference<V>> entriesDiffering() {
       return (SortedMap<K, ValueDifference<V>>) super.entriesDiffering();
     }
 
     @Override
     public SortedMap<K, V> entriesInCommon() {
       return (SortedMap<K, V>) super.entriesInCommon();
     }
 
     @Override
     public SortedMap<K, V> entriesOnlyOnLeft() {
       return (SortedMap<K, V>) super.entriesOnlyOnLeft();
     }
 
     @Override
     public SortedMap<K, V> entriesOnlyOnRight() {
       return (SortedMap<K, V>) super.entriesOnlyOnRight();
     }
   }
 
   /**
    * Returns the specified comparator if not null; otherwise returns {@code
    * Ordering.natural()}. This method is an abomination of generics; the only
    * purpose of this method is to contain the ugly type-casting in one place.
    */
   @SuppressWarnings("unchecked")
   static <E> Comparator<? super E> orNaturalOrder(@Nullable Comparator<? super E> comparator) {
     if (comparator != null) { // can't use ? : because of javac bug 5080917
       return comparator;
     }
     return (Comparator<E>) Ordering.natural();
   }
 
   /**
    * Returns a live {@link Map} view whose keys are the contents of {@code set}
    * and whose values are computed on demand using {@code function}. To get an
    * immutable <i>copy</i> instead, use {@link #toMap(Iterable, Function)}.
    *
    * <p>Specifically, for each {@code k} in the backing set, the returned map
    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code
    * keySet}, {@code values}, and {@code entrySet} views of the returned map
    * iterate in the same order as the backing set.
    *
    * <p>Modifications to the backing set are read through to the returned map.
    * The returned map supports removal operations if the backing set does.
    * Removal operations write through to the backing set.  The returned map
    * does not support put operations.
    *
    * <p><b>Warning:</b> If the function rejects {@code null}, caution is
    * required to make sure the set does not contain {@code null}, because the
    * view cannot stop {@code null} from being added to the set.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also
    * of type {@code K}. Using a key type for which this may not hold, such as
    * {@code ArrayList}, may risk a {@code ClassCastException} when calling
    * methods on the resulting map view.
    *
    * @since 14.0
    */
   public static <K, V> Map<K, V> asMap(Set<K> set, Function<? super K, V> function) {
-    return new AsMapView<K, V>(set, function);
+    return new AsMapView<>(set, function);
   }
 
   /**
    * Returns a view of the sorted set as a map, mapping keys from the set
    * according to the specified function.
    *
    * <p>Specifically, for each {@code k} in the backing set, the returned map
    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code
    * keySet}, {@code values}, and {@code entrySet} views of the returned map
    * iterate in the same order as the backing set.
    *
    * <p>Modifications to the backing set are read through to the returned map.
    * The returned map supports removal operations if the backing set does.
    * Removal operations write through to the backing set.  The returned map does
    * not support put operations.
    *
    * <p><b>Warning:</b> If the function rejects {@code null}, caution is
    * required to make sure the set does not contain {@code null}, because the
    * view cannot stop {@code null} from being added to the set.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
    * type {@code K}. Using a key type for which this may not hold, such as
    * {@code ArrayList}, may risk a {@code ClassCastException} when calling
    * methods on the resulting map view.
    *
    * @since 14.0
    */
   public static <K, V> SortedMap<K, V> asMap(SortedSet<K> set, Function<? super K, V> function) {
-    return new SortedAsMapView<K, V>(set, function);
+    return new SortedAsMapView<>(set, function);
   }
 
   /**
    * Returns a view of the navigable set as a map, mapping keys from the set
    * according to the specified function.
    *
    * <p>Specifically, for each {@code k} in the backing set, the returned map
    * has an entry mapping {@code k} to {@code function.apply(k)}. The {@code
    * keySet}, {@code values}, and {@code entrySet} views of the returned map
    * iterate in the same order as the backing set.
    *
    * <p>Modifications to the backing set are read through to the returned map.
    * The returned map supports removal operations if the backing set does.
    * Removal operations write through to the backing set.  The returned map
    * does not support put operations.
    *
    * <p><b>Warning:</b> If the function rejects {@code null}, caution is
    * required to make sure the set does not contain {@code null}, because the
    * view cannot stop {@code null} from being added to the set.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also
    * of type {@code K}. Using a key type for which this may not hold, such as
    * {@code ArrayList}, may risk a {@code ClassCastException} when calling
    * methods on the resulting map view.
    *
    * @since 14.0
    */
   @GwtIncompatible // NavigableMap
   public static <K, V> NavigableMap<K, V> asMap(
       NavigableSet<K> set, Function<? super K, V> function) {
-    return new NavigableAsMapView<K, V>(set, function);
+    return new NavigableAsMapView<>(set, function);
   }
 
   private static class AsMapView<K, V> extends ViewCachingAbstractMap<K, V> {
 
     private final Set<K> set;
     final Function<? super K, V> function;
 
     Set<K> backingSet() {
       return set;
     }
 
     AsMapView(Set<K> set, Function<? super K, V> function) {
       this.set = checkNotNull(set);
       this.function = checkNotNull(function);
     }
 
     @Override
     public Set<K> createKeySet() {
       return removeOnlySet(backingSet());
     }
 
     @Override
     Collection<V> createValues() {
       return Collections2.transform(set, function);
     }
 
     @Override
     public int size() {
       return backingSet().size();
     }
 
     @Override
     public boolean containsKey(@Nullable Object key) {
       return backingSet().contains(key);
     }
 
     @Override
     public V get(@Nullable Object key) {
       if (Collections2.safeContains(backingSet(), key)) {
         @SuppressWarnings("unchecked") // unsafe, but Javadoc warns about it
         K k = (K) key;
         return function.apply(k);
       } else {
         return null;
       }
     }
 
     @Override
     public V remove(@Nullable Object key) {
       if (backingSet().remove(key)) {
@@ -1237,113 +1237,113 @@ public final class Maps {
     ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
     while (values.hasNext()) {
       V value = values.next();
       builder.put(keyFunction.apply(value), value);
     }
     try {
       return builder.build();
     } catch (IllegalArgumentException duplicateKeys) {
       throw new IllegalArgumentException(
           duplicateKeys.getMessage()
               + ". To index multiple values under a key, use Multimaps.index.");
     }
   }
 
   /**
    * Creates an {@code ImmutableMap<String, String>} from a {@code Properties}
    * instance. Properties normally derive from {@code Map<Object, Object>}, but
    * they typically contain strings, which is awkward. This method lets you get
    * a plain-old-{@code Map} out of a {@code Properties}.
    *
    * @param properties a {@code Properties} object to be converted
    * @return an immutable map containing all the entries in {@code properties}
    * @throws ClassCastException if any key in {@code Properties} is not a {@code
    *         String}
    * @throws NullPointerException if any key or value in {@code Properties} is
    *         null
    */
   @GwtIncompatible // java.util.Properties
   public static ImmutableMap<String, String> fromProperties(Properties properties) {
     ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
 
     for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {
       String key = (String) e.nextElement();
       builder.put(key, properties.getProperty(key));
     }
 
     return builder.build();
   }
 
   /**
    * Returns an immutable map entry with the specified key and value. The {@link
    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.
    *
    * <p>The returned entry is serializable.
    *
    * @param key the key to be associated with the returned entry
    * @param value the value to be associated with the returned entry
    */
   @GwtCompatible(serializable = true)
   public static <K, V> Entry<K, V> immutableEntry(@Nullable K key, @Nullable V value) {
-    return new ImmutableEntry<K, V>(key, value);
+    return new ImmutableEntry<>(key, value);
   }
 
   /**
    * Returns an unmodifiable view of the specified set of entries. The {@link
    * Entry#setValue} operation throws an {@link UnsupportedOperationException},
    * as do any operations that would modify the returned set.
    *
    * @param entrySet the entries for which to return an unmodifiable view
    * @return an unmodifiable view of the entries
    */
   static <K, V> Set<Entry<K, V>> unmodifiableEntrySet(Set<Entry<K, V>> entrySet) {
-    return new UnmodifiableEntrySet<K, V>(Collections.unmodifiableSet(entrySet));
+    return new UnmodifiableEntrySet<>(Collections.unmodifiableSet(entrySet));
   }
 
   /**
    * Returns an unmodifiable view of the specified map entry. The {@link
    * Entry#setValue} operation throws an {@link UnsupportedOperationException}.
    * This also has the side-effect of redefining {@code equals} to comply with
    * the Entry contract, to avoid a possible nefarious implementation of equals.
    *
    * @param entry the entry for which to return an unmodifiable view
    * @return an unmodifiable view of the entry
    */
   static <K, V> Entry<K, V> unmodifiableEntry(final Entry<? extends K, ? extends V> entry) {
     checkNotNull(entry);
     return new AbstractMapEntry<K, V>() {
       @Override
       public K getKey() {
         return entry.getKey();
       }
 
       @Override
       public V getValue() {
         return entry.getValue();
       }
     };
   }
 
   static <K, V> UnmodifiableIterator<Entry<K, V>> unmodifiableEntryIterator(
       final Iterator<Entry<K, V>> entryIterator) {
     return new UnmodifiableIterator<Entry<K, V>>() {
       @Override
       public boolean hasNext() {
         return entryIterator.hasNext();
       }
 
       @Override
       public Entry<K, V> next() {
         return unmodifiableEntry(entryIterator.next());
       }
     };
   }
 
   /** @see Multimaps#unmodifiableEntries */
   static class UnmodifiableEntries<K, V> extends ForwardingCollection<Entry<K, V>> {
     private final Collection<Entry<K, V>> entries;
 
     UnmodifiableEntries(Collection<Entry<K, V>> entries) {
       this.entries = entries;
     }
 
     @Override
@@ -1355,228 +1355,228 @@ public final class Maps {
     public Iterator<Entry<K, V>> iterator() {
       return unmodifiableEntryIterator(entries.iterator());
     }
 
     // See java.util.Collections.UnmodifiableEntrySet for details on attacks.
 
     @Override
     public Object[] toArray() {
       return standardToArray();
     }
 
     @Override
     public <T> T[] toArray(T[] array) {
       return standardToArray(array);
     }
   }
 
   /** @see Maps#unmodifiableEntrySet(Set) */
   static class UnmodifiableEntrySet<K, V> extends UnmodifiableEntries<K, V>
       implements Set<Entry<K, V>> {
     UnmodifiableEntrySet(Set<Entry<K, V>> entries) {
       super(entries);
     }
 
     // See java.util.Collections.UnmodifiableEntrySet for details on attacks.
 
     @Override
     public boolean equals(@Nullable Object object) {
       return Sets.equalsImpl(this, object);
     }
 
     @Override
     public int hashCode() {
       return Sets.hashCodeImpl(this);
     }
   }
 
   /**
    * Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()},
    * and whose inverse view converts values using
    * {@link BiMap#inverse bimap.inverse()}{@code .get()}.
    *
    * <p>To use a plain {@link Map} as a {@link Function}, see
    * {@link com.google.common.base.Functions#forMap(Map)} or
    * {@link com.google.common.base.Functions#forMap(Map, Object)}.
    *
    * @since 16.0
    */
   @Beta
   public static <A, B> Converter<A, B> asConverter(final BiMap<A, B> bimap) {
-    return new BiMapConverter<A, B>(bimap);
+    return new BiMapConverter<>(bimap);
   }
 
   private static final class BiMapConverter<A, B> extends Converter<A, B> implements Serializable {
     private final BiMap<A, B> bimap;
 
     BiMapConverter(BiMap<A, B> bimap) {
       this.bimap = checkNotNull(bimap);
     }
 
     @Override
     protected B doForward(A a) {
       return convert(bimap, a);
     }
 
     @Override
     protected A doBackward(B b) {
       return convert(bimap.inverse(), b);
     }
 
     private static <X, Y> Y convert(BiMap<X, Y> bimap, X input) {
       Y output = bimap.get(input);
       checkArgument(output != null, "No non-null mapping present for input: %s", input);
       return output;
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       if (object instanceof BiMapConverter) {
         BiMapConverter<?, ?> that = (BiMapConverter<?, ?>) object;
         return this.bimap.equals(that.bimap);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return bimap.hashCode();
     }
 
     // There's really no good way to implement toString() without printing the entire BiMap, right?
     @Override
     public String toString() {
       return "Maps.asConverter(" + bimap + ")";
     }
 
     private static final long serialVersionUID = 0L;
   }
 
   /**
    * Returns a synchronized (thread-safe) bimap backed by the specified bimap.
    * In order to guarantee serial access, it is critical that <b>all</b> access
    * to the backing bimap is accomplished through the returned bimap.
    *
    * <p>It is imperative that the user manually synchronize on the returned map
    * when accessing any of its collection views: <pre>   {@code
    *
    *   BiMap<Long, String> map = Maps.synchronizedBiMap(
    *       HashBiMap.<Long, String>create());
    *   ...
    *   Set<Long> set = map.keySet();  // Needn't be in synchronized block
    *   ...
    *   synchronized (map) {  // Synchronizing on map, not set!
    *     Iterator<Long> it = set.iterator(); // Must be in synchronized block
    *     while (it.hasNext()) {
    *       foo(it.next());
    *     }
    *   }}</pre>
    *
    * <p>Failure to follow this advice may result in non-deterministic behavior.
    *
    * <p>The returned bimap will be serializable if the specified bimap is
    * serializable.
    *
    * @param bimap the bimap to be wrapped in a synchronized view
    * @return a synchronized view of the specified bimap
    */
   public static <K, V> BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) {
     return Synchronized.biMap(bimap, null);
   }
 
   /**
    * Returns an unmodifiable view of the specified bimap. This method allows
    * modules to provide users with "read-only" access to internal bimaps. Query
    * operations on the returned bimap "read through" to the specified bimap, and
    * attempts to modify the returned map, whether direct or via its collection
    * views, result in an {@code UnsupportedOperationException}.
    *
    * <p>The returned bimap will be serializable if the specified bimap is
    * serializable.
    *
    * @param bimap the bimap for which an unmodifiable view is to be returned
    * @return an unmodifiable view of the specified bimap
    */
   public static <K, V> BiMap<K, V> unmodifiableBiMap(BiMap<? extends K, ? extends V> bimap) {
-    return new UnmodifiableBiMap<K, V>(bimap, null);
+    return new UnmodifiableBiMap<>(bimap, null);
   }
 
   /** @see Maps#unmodifiableBiMap(BiMap) */
   private static class UnmodifiableBiMap<K, V> extends ForwardingMap<K, V>
       implements BiMap<K, V>, Serializable {
     final Map<K, V> unmodifiableMap;
     final BiMap<? extends K, ? extends V> delegate;
     @RetainedWith
     BiMap<V, K> inverse;
     transient Set<V> values;
 
     UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse) {
       unmodifiableMap = Collections.unmodifiableMap(delegate);
       this.delegate = delegate;
       this.inverse = inverse;
     }
 
     @Override
     protected Map<K, V> delegate() {
       return unmodifiableMap;
     }
 
     @Override
     public V forcePut(K key, V value) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     public BiMap<V, K> inverse() {
       BiMap<V, K> result = inverse;
       return (result == null)
-          ? inverse = new UnmodifiableBiMap<V, K>(delegate.inverse(), this)
+          ? inverse = new UnmodifiableBiMap<>(delegate.inverse(), this)
           : result;
     }
 
     @Override
     public Set<V> values() {
       Set<V> result = values;
       return (result == null) ? values = Collections.unmodifiableSet(delegate.values()) : result;
     }
 
     private static final long serialVersionUID = 0;
   }
 
   /**
    * Returns a view of a map where each value is transformed by a function. All
    * other properties of the map, such as iteration order, are left intact. For
    * example, the code: <pre>   {@code
    *
    *   Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);
    *   Function<Integer, Double> sqrt =
    *       new Function<Integer, Double>() {
    *         public Double apply(Integer in) {
    *           return Math.sqrt((int) in);
    *         }
    *       };
    *   Map<String, Double> transformed = Maps.transformValues(map, sqrt);
    *   System.out.println(transformed);}</pre>
    *
    * ... prints {@code {a=2.0, b=3.0}}.
    *
    * <p>Changes in the underlying map are reflected in this view. Conversely,
    * this view supports removal operations, and these are reflected in the
    * underlying map.
    *
    * <p>It's acceptable for the underlying map to contain null keys, and even
    * null values provided that the function is capable of accepting null input.
    * The transformed map might contain null values, if the function sometimes
    * gives a null result.
    *
    * <p>The returned map is not thread-safe or serializable, even if the
    * underlying map is.
    *
    * <p>The function is applied lazily, invoked when needed. This is necessary
    * for the returned map to be a view, but it means that the function will be
    * applied many times for bulk operations like {@link Map#containsValue} and
    * {@code Map.toString()}. For this to perform well, {@code function} should
    * be fast. To avoid lazy evaluation when the returned map doesn't need to be
    * a view, copy the returned map into a new map of your choosing.
    */
   public static <K, V1, V2> Map<K, V2> transformValues(
       Map<K, V1> fromMap, Function<? super V1, V2> function) {
@@ -1680,217 +1680,217 @@ public final class Maps {
    * entry-transformation logic may depend on the key as well as the value.
    *
    * <p>All other properties of the transformed map, such as iteration order,
    * are left intact. For example, the code: <pre>   {@code
    *
    *   Map<String, Boolean> options =
    *       ImmutableMap.of("verbose", true, "sort", false);
    *   EntryTransformer<String, Boolean, String> flagPrefixer =
    *       new EntryTransformer<String, Boolean, String>() {
    *         public String transformEntry(String key, Boolean value) {
    *           return value ? key : "no" + key;
    *         }
    *       };
    *   Map<String, String> transformed =
    *       Maps.transformEntries(options, flagPrefixer);
    *   System.out.println(transformed);}</pre>
    *
    * ... prints {@code {verbose=verbose, sort=nosort}}.
    *
    * <p>Changes in the underlying map are reflected in this view. Conversely,
    * this view supports removal operations, and these are reflected in the
    * underlying map.
    *
    * <p>It's acceptable for the underlying map to contain null keys and null
    * values provided that the transformer is capable of accepting null inputs.
    * The transformed map might contain null values if the transformer sometimes
    * gives a null result.
    *
    * <p>The returned map is not thread-safe or serializable, even if the
    * underlying map is.
    *
    * <p>The transformer is applied lazily, invoked when needed. This is
    * necessary for the returned map to be a view, but it means that the
    * transformer will be applied many times for bulk operations like {@link
    * Map#containsValue} and {@link Object#toString}. For this to perform well,
    * {@code transformer} should be fast. To avoid lazy evaluation when the
    * returned map doesn't need to be a view, copy the returned map into a new
    * map of your choosing.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
    * that {@code k2} is also of type {@code K}. Using an {@code
    * EntryTransformer} key type for which this may not hold, such as {@code
    * ArrayList}, may risk a {@code ClassCastException} when calling methods on
    * the transformed map.
    *
    * @since 7.0
    */
   public static <K, V1, V2> Map<K, V2> transformEntries(
       Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
-    return new TransformedEntriesMap<K, V1, V2>(fromMap, transformer);
+    return new TransformedEntriesMap<>(fromMap, transformer);
   }
 
   /**
    * Returns a view of a sorted map whose values are derived from the original
    * sorted map's entries. In contrast to {@link #transformValues}, this
    * method's entry-transformation logic may depend on the key as well as the
    * value.
    *
    * <p>All other properties of the transformed map, such as iteration order,
    * are left intact. For example, the code: <pre>   {@code
    *
    *   Map<String, Boolean> options =
    *       ImmutableSortedMap.of("verbose", true, "sort", false);
    *   EntryTransformer<String, Boolean, String> flagPrefixer =
    *       new EntryTransformer<String, Boolean, String>() {
    *         public String transformEntry(String key, Boolean value) {
    *           return value ? key : "yes" + key;
    *         }
    *       };
    *   SortedMap<String, String> transformed =
    *       Maps.transformEntries(options, flagPrefixer);
    *   System.out.println(transformed);}</pre>
    *
    * ... prints {@code {sort=yessort, verbose=verbose}}.
    *
    * <p>Changes in the underlying map are reflected in this view. Conversely,
    * this view supports removal operations, and these are reflected in the
    * underlying map.
    *
    * <p>It's acceptable for the underlying map to contain null keys and null
    * values provided that the transformer is capable of accepting null inputs.
    * The transformed map might contain null values if the transformer sometimes
    * gives a null result.
    *
    * <p>The returned map is not thread-safe or serializable, even if the
    * underlying map is.
    *
    * <p>The transformer is applied lazily, invoked when needed. This is
    * necessary for the returned map to be a view, but it means that the
    * transformer will be applied many times for bulk operations like {@link
    * Map#containsValue} and {@link Object#toString}. For this to perform well,
    * {@code transformer} should be fast. To avoid lazy evaluation when the
    * returned map doesn't need to be a view, copy the returned map into a new
    * map of your choosing.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
    * that {@code k2} is also of type {@code K}. Using an {@code
    * EntryTransformer} key type for which this may not hold, such as {@code
    * ArrayList}, may risk a {@code ClassCastException} when calling methods on
    * the transformed map.
    *
    * @since 11.0
    */
   public static <K, V1, V2> SortedMap<K, V2> transformEntries(
       SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
-    return new TransformedEntriesSortedMap<K, V1, V2>(fromMap, transformer);
+    return new TransformedEntriesSortedMap<>(fromMap, transformer);
   }
 
   /**
    * Returns a view of a navigable map whose values are derived from the
    * original navigable map's entries. In contrast to {@link
    * #transformValues}, this method's entry-transformation logic may
    * depend on the key as well as the value.
    *
    * <p>All other properties of the transformed map, such as iteration order,
    * are left intact. For example, the code: <pre>   {@code
    *
    *   NavigableMap<String, Boolean> options = Maps.newTreeMap();
    *   options.put("verbose", false);
    *   options.put("sort", true);
    *   EntryTransformer<String, Boolean, String> flagPrefixer =
    *       new EntryTransformer<String, Boolean, String>() {
    *         public String transformEntry(String key, Boolean value) {
    *           return value ? key : ("yes" + key);
    *         }
    *       };
    *   NavigableMap<String, String> transformed =
    *       LabsMaps.transformNavigableEntries(options, flagPrefixer);
    *   System.out.println(transformed);}</pre>
    *
    * ... prints {@code {sort=yessort, verbose=verbose}}.
    *
    * <p>Changes in the underlying map are reflected in this view.
    * Conversely, this view supports removal operations, and these are reflected
    * in the underlying map.
    *
    * <p>It's acceptable for the underlying map to contain null keys and null
    * values provided that the transformer is capable of accepting null inputs.
    * The transformed map might contain null values if the transformer sometimes
    * gives a null result.
    *
    * <p>The returned map is not thread-safe or serializable, even if the
    * underlying map is.
    *
    * <p>The transformer is applied lazily, invoked when needed. This is
    * necessary for the returned map to be a view, but it means that the
    * transformer will be applied many times for bulk operations like {@link
    * Map#containsValue} and {@link Object#toString}. For this to perform well,
    * {@code transformer} should be fast. To avoid lazy evaluation when the
    * returned map doesn't need to be a view, copy the returned map into a new
    * map of your choosing.
    *
    * <p><b>Warning:</b> This method assumes that for any instance {@code k} of
    * {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
    * that {@code k2} is also of type {@code K}. Using an {@code
    * EntryTransformer} key type for which this may not hold, such as {@code
    * ArrayList}, may risk a {@code ClassCastException} when calling methods on
    * the transformed map.
    *
    * @since 13.0
    */
   @GwtIncompatible // NavigableMap
   public static <K, V1, V2> NavigableMap<K, V2> transformEntries(
       NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
-    return new TransformedEntriesNavigableMap<K, V1, V2>(fromMap, transformer);
+    return new TransformedEntriesNavigableMap<>(fromMap, transformer);
   }
 
   /**
    * A transformation of the value of a key-value pair, using both key and value
    * as inputs. To apply the transformation to a map, use
    * {@link Maps#transformEntries(Map, EntryTransformer)}.
    *
    * @param <K> the key type of the input and output entries
    * @param <V1> the value type of the input entry
    * @param <V2> the value type of the output entry
    * @since 7.0
    */
   public interface EntryTransformer<K, V1, V2> {
     /**
      * Determines an output value based on a key-value pair. This method is
      * <i>generally expected</i>, but not absolutely required, to have the
      * following properties:
      *
      * <ul>
      * <li>Its execution does not cause any observable side effects.
      * <li>The computation is <i>consistent with equals</i>; that is,
      *     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}
      *     {@link Objects#equal}{@code (v1, v2)} implies that {@code
      *     Objects.equal(transformer.transform(k1, v1),
      *     transformer.transform(k2, v2))}.
      * </ul>
      *
      * @throws NullPointerException if the key or value is null and this
      *     transformer does not accept null arguments
      */
     V2 transformEntry(@Nullable K key, @Nullable V1 value);
   }
 
   /**
    * Views a function as an entry transformer that ignores the entry key.
    */
   static <K, V1, V2> EntryTransformer<K, V1, V2> asEntryTransformer(
       final Function<? super V1, V2> function) {
     checkNotNull(function);
     return new EntryTransformer<K, V1, V2>() {
       @Override
       public V2 transformEntry(K key, V1 value) {
         return function.apply(value);
       }
     };
   }
 
   static <K, V1, V2> Function<V1, V2> asValueToValueFunction(
       final EntryTransformer<? super K, V1, V2> transformer, final K key) {
     checkNotNull(transformer);
@@ -1960,101 +1960,101 @@ public final class Maps {
       this.transformer = checkNotNull(transformer);
     }
 
     @Override
     public int size() {
       return fromMap.size();
     }
 
     @Override
     public boolean containsKey(Object key) {
       return fromMap.containsKey(key);
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
     @SuppressWarnings("unchecked")
     @Override
     public V2 get(Object key) {
       V1 value = fromMap.get(key);
       return (value != null || fromMap.containsKey(key))
           ? transformer.transformEntry((K) key, value)
           : null;
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
     @SuppressWarnings("unchecked")
     @Override
     public V2 remove(Object key) {
       return fromMap.containsKey(key)
           ? transformer.transformEntry((K) key, fromMap.remove(key))
           : null;
     }
 
     @Override
     public void clear() {
       fromMap.clear();
     }
 
     @Override
     public Set<K> keySet() {
       return fromMap.keySet();
     }
 
     @Override
     Iterator<Entry<K, V2>> entryIterator() {
       return Iterators.transform(
           fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));
     }
 
     @Override
     public Collection<V2> values() {
-      return new Values<K, V2>(this);
+      return new Values<>(this);
     }
   }
 
   static class TransformedEntriesSortedMap<K, V1, V2> extends TransformedEntriesMap<K, V1, V2>
       implements SortedMap<K, V2> {
 
     protected SortedMap<K, V1> fromMap() {
       return (SortedMap<K, V1>) fromMap;
     }
 
     TransformedEntriesSortedMap(
         SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
       super(fromMap, transformer);
     }
 
     @Override
     public Comparator<? super K> comparator() {
       return fromMap().comparator();
     }
 
     @Override
     public K firstKey() {
       return fromMap().firstKey();
     }
 
     @Override
     public SortedMap<K, V2> headMap(K toKey) {
       return transformEntries(fromMap().headMap(toKey), transformer);
     }
 
     @Override
     public K lastKey() {
       return fromMap().lastKey();
     }
 
     @Override
     public SortedMap<K, V2> subMap(K fromKey, K toKey) {
       return transformEntries(fromMap().subMap(fromKey, toKey), transformer);
     }
 
     @Override
     public SortedMap<K, V2> tailMap(K fromKey) {
       return transformEntries(fromMap().tailMap(fromKey), transformer);
     }
   }
 
   @GwtIncompatible // NavigableMap
   private static class TransformedEntriesNavigableMap<K, V1, V2>
       extends TransformedEntriesSortedMap<K, V1, V2> implements NavigableMap<K, V2> {
 
@@ -2583,159 +2583,159 @@ public final class Maps {
   public static <K, V> NavigableMap<K, V> filterEntries(
       NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(entryPredicate);
     return (unfiltered instanceof FilteredEntryNavigableMap)
         ? filterFiltered((FilteredEntryNavigableMap<K, V>) unfiltered, entryPredicate)
         : new FilteredEntryNavigableMap<K, V>(checkNotNull(unfiltered), entryPredicate);
   }
 
   /**
    * Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The
    * returned bimap is a live view of {@code unfiltered}; changes to one affect the other.
    *
    * <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
    * iterators that don't support {@code remove()}, but all other methods are supported by the bimap
    * and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's
    * {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an
    * {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue}
    * method that throws an {@link IllegalArgumentException} when the existing key and the provided
    * value don't satisfy the predicate.
    *
    * <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
    * bimap or its views, only mappings that satisfy the filter will be removed from the underlying
    * bimap.
    *
    * <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.
    *
    * <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every
    * key/value mapping in the underlying bimap and determine which satisfy the filter. When a live
    * view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.
    *
    * <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as
    * documented at {@link Predicate#apply}.
    *
    * @since 14.0
    */
   public static <K, V> BiMap<K, V> filterEntries(
       BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
     checkNotNull(unfiltered);
     checkNotNull(entryPredicate);
     return (unfiltered instanceof FilteredEntryBiMap)
         ? filterFiltered((FilteredEntryBiMap<K, V>) unfiltered, entryPredicate)
         : new FilteredEntryBiMap<K, V>(unfiltered, entryPredicate);
   }
 
   /**
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when
    * filtering a filtered map.
    */
   private static <K, V> Map<K, V> filterFiltered(
       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
-    return new FilteredEntryMap<K, V>(
+    return new FilteredEntryMap<>(
         map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));
   }
 
   private abstract static class AbstractFilteredMap<K, V> extends ViewCachingAbstractMap<K, V> {
     final Map<K, V> unfiltered;
     final Predicate<? super Entry<K, V>> predicate;
 
     AbstractFilteredMap(Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {
       this.unfiltered = unfiltered;
       this.predicate = predicate;
     }
 
     boolean apply(@Nullable Object key, @Nullable V value) {
       // This method is called only when the key is in the map, implying that
       // key is a K.
       @SuppressWarnings("unchecked")
       K k = (K) key;
       return predicate.apply(Maps.immutableEntry(k, value));
     }
 
     @Override
     public V put(K key, V value) {
       checkArgument(apply(key, value));
       return unfiltered.put(key, value);
     }
 
     @Override
     public void putAll(Map<? extends K, ? extends V> map) {
       for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
         checkArgument(apply(entry.getKey(), entry.getValue()));
       }
       unfiltered.putAll(map);
     }
 
     @Override
     public boolean containsKey(Object key) {
       return unfiltered.containsKey(key) && apply(key, unfiltered.get(key));
     }
 
     @Override
     public V get(Object key) {
       V value = unfiltered.get(key);
       return ((value != null) && apply(key, value)) ? value : null;
     }
 
     @Override
     public boolean isEmpty() {
       return entrySet().isEmpty();
     }
 
     @Override
     public V remove(Object key) {
       return containsKey(key) ? unfiltered.remove(key) : null;
     }
 
     @Override
     Collection<V> createValues() {
-      return new FilteredMapValues<K, V>(this, unfiltered, predicate);
+      return new FilteredMapValues<>(this, unfiltered, predicate);
     }
   }
 
   private static final class FilteredMapValues<K, V> extends Maps.Values<K, V> {
     final Map<K, V> unfiltered;
     final Predicate<? super Entry<K, V>> predicate;
 
     FilteredMapValues(
         Map<K, V> filteredMap, Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {
       super(filteredMap);
       this.unfiltered = unfiltered;
       this.predicate = predicate;
     }
 
     @Override
     public boolean remove(Object o) {
       Iterator<Entry<K, V>> entryItr = unfiltered.entrySet().iterator();
       while (entryItr.hasNext()) {
         Entry<K, V> entry = entryItr.next();
         if (predicate.apply(entry) && Objects.equal(entry.getValue(), o)) {
           entryItr.remove();
           return true;
         }
       }
       return false;
     }
 
     @Override
     public boolean removeAll(Collection<?> collection) {
       Iterator<Entry<K, V>> entryItr = unfiltered.entrySet().iterator();
       boolean result = false;
       while (entryItr.hasNext()) {
         Entry<K, V> entry = entryItr.next();
         if (predicate.apply(entry) && collection.contains(entry.getValue())) {
           entryItr.remove();
           result = true;
         }
       }
       return result;
     }
 
     @Override
     public boolean retainAll(Collection<?> collection) {
       Iterator<Entry<K, V>> entryItr = unfiltered.entrySet().iterator();
       boolean result = false;
       while (entryItr.hasNext()) {
         Entry<K, V> entry = entryItr.next();
         if (predicate.apply(entry) && !collection.contains(entry.getValue())) {
           entryItr.remove();
           result = true;
@@ -2863,524 +2863,524 @@ public final class Maps {
         }
       }
       return result;
     }
 
     @WeakOuter
     class KeySet extends Maps.KeySet<K, V> {
       KeySet() {
         super(FilteredEntryMap.this);
       }
 
       @Override
       public boolean remove(Object o) {
         if (containsKey(o)) {
           unfiltered.remove(o);
           return true;
         }
         return false;
       }
 
       @Override
       public boolean removeAll(Collection<?> collection) {
         return removeAllKeys(unfiltered, predicate, collection);
       }
 
       @Override
       public boolean retainAll(Collection<?> collection) {
         return retainAllKeys(unfiltered, predicate, collection);
       }
 
       @Override
       public Object[] toArray() {
         // creating an ArrayList so filtering happens once
         return Lists.newArrayList(iterator()).toArray();
       }
 
       @Override
       public <T> T[] toArray(T[] array) {
         return Lists.newArrayList(iterator()).toArray(array);
       }
     }
   }
 
   /**
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when
    * filtering a filtered sorted map.
    */
   private static <K, V> SortedMap<K, V> filterFiltered(
       FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);
-    return new FilteredEntrySortedMap<K, V>(map.sortedMap(), predicate);
+    return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);
   }
 
   private static class FilteredEntrySortedMap<K, V> extends FilteredEntryMap<K, V>
       implements SortedMap<K, V> {
 
     FilteredEntrySortedMap(
         SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
       super(unfiltered, entryPredicate);
     }
 
     SortedMap<K, V> sortedMap() {
       return (SortedMap<K, V>) unfiltered;
     }
 
     @Override
     public SortedSet<K> keySet() {
       return (SortedSet<K>) super.keySet();
     }
 
     @Override
     SortedSet<K> createKeySet() {
       return new SortedKeySet();
     }
 
     @WeakOuter
     class SortedKeySet extends KeySet implements SortedSet<K> {
       @Override
       public Comparator<? super K> comparator() {
         return sortedMap().comparator();
       }
 
       @Override
       public SortedSet<K> subSet(K fromElement, K toElement) {
         return (SortedSet<K>) subMap(fromElement, toElement).keySet();
       }
 
       @Override
       public SortedSet<K> headSet(K toElement) {
         return (SortedSet<K>) headMap(toElement).keySet();
       }
 
       @Override
       public SortedSet<K> tailSet(K fromElement) {
         return (SortedSet<K>) tailMap(fromElement).keySet();
       }
 
       @Override
       public K first() {
         return firstKey();
       }
 
       @Override
       public K last() {
         return lastKey();
       }
     }
 
     @Override
     public Comparator<? super K> comparator() {
       return sortedMap().comparator();
     }
 
     @Override
     public K firstKey() {
       // correctly throws NoSuchElementException when filtered map is empty.
       return keySet().iterator().next();
     }
 
     @Override
     public K lastKey() {
       SortedMap<K, V> headMap = sortedMap();
       while (true) {
         // correctly throws NoSuchElementException when filtered map is empty.
         K key = headMap.lastKey();
         if (apply(key, unfiltered.get(key))) {
           return key;
         }
         headMap = sortedMap().headMap(key);
       }
     }
 
     @Override
     public SortedMap<K, V> headMap(K toKey) {
-      return new FilteredEntrySortedMap<K, V>(sortedMap().headMap(toKey), predicate);
+      return new FilteredEntrySortedMap<>(sortedMap().headMap(toKey), predicate);
     }
 
     @Override
     public SortedMap<K, V> subMap(K fromKey, K toKey) {
-      return new FilteredEntrySortedMap<K, V>(sortedMap().subMap(fromKey, toKey), predicate);
+      return new FilteredEntrySortedMap<>(sortedMap().subMap(fromKey, toKey), predicate);
     }
 
     @Override
     public SortedMap<K, V> tailMap(K fromKey) {
-      return new FilteredEntrySortedMap<K, V>(sortedMap().tailMap(fromKey), predicate);
+      return new FilteredEntrySortedMap<>(sortedMap().tailMap(fromKey), predicate);
     }
   }
 
   /**
    * Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when
    * filtering a filtered navigable map.
    */
   @GwtIncompatible // NavigableMap
   private static <K, V> NavigableMap<K, V> filterFiltered(
       FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {
     Predicate<Entry<K, V>> predicate =
         Predicates.<Entry<K, V>>and(map.entryPredicate, entryPredicate);
-    return new FilteredEntryNavigableMap<K, V>(map.unfiltered, predicate);
+    return new FilteredEntryNavigableMap<>(map.unfiltered, predicate);
   }
 
   @GwtIncompatible // NavigableMap
   private static class FilteredEntryNavigableMap<K, V> extends AbstractNavigableMap<K, V> {
     /*
      * It's less code to extend AbstractNavigableMap and forward the filtering logic to
      * FilteredEntryMap than to extend FilteredEntrySortedMap and reimplement all the NavigableMap
      * methods.
      */
 
     private final NavigableMap<K, V> unfiltered;
     private final Predicate<? super Entry<K, V>> entryPredicate;
     private final Map<K, V> filteredDelegate;
 
     FilteredEntryNavigableMap(
         NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
       this.unfiltered = checkNotNull(unfiltered);
       this.entryPredicate = entryPredicate;
-      this.filteredDelegate = new FilteredEntryMap<K, V>(unfiltered, entryPredicate);
+      this.filteredDelegate = new FilteredEntryMap<>(unfiltered, entryPredicate);
     }
 
     @Override
     public Comparator<? super K> comparator() {
    