diff --git a/android/guava/src/com/google/common/base/Functions.java b/android/guava/src/com/google/common/base/Functions.java
index ec1f0306a..d9e58edb6 100644
--- a/android/guava/src/com/google/common/base/Functions.java
+++ b/android/guava/src/com/google/common/base/Functions.java
@@ -69,208 +69,208 @@ public final class Functions {
     public String apply(Object o) {
       checkNotNull(o); // eager for GWT.
       return o.toString();
     }
 
     @Override
     public String toString() {
       return "Functions.toStringFunction()";
     }
   }
 
   /**
    * Returns the identity function.
    */
   // implementation is "fully variant"; E has become a "pass-through" type
   @SuppressWarnings("unchecked")
   public static <E> Function<E, E> identity() {
     return (Function<E, E>) IdentityFunction.INSTANCE;
   }
 
   // enum singleton pattern
   private enum IdentityFunction implements Function<Object, Object> {
     INSTANCE;
 
     @Override
     @Nullable
     public Object apply(@Nullable Object o) {
       return o;
     }
 
     @Override
     public String toString() {
       return "Functions.identity()";
     }
   }
 
   /**
    * Returns a function which performs a map lookup. The returned function throws an
    * {@link IllegalArgumentException} if given a key that does not exist in the map. See also
    * {@link #forMap(Map, Object)}, which returns a default value in this case.
    *
    * <p>Note: if {@code map} is a {@link com.google.common.collect.BiMap BiMap} (or can be one), you
    * can use {@link com.google.common.collect.Maps#asConverter Maps.asConverter} instead to get a
    * function that also supports reverse conversion.
    *
    * <p><b>Java 8 users:</b> if you are okay with {@code null} being returned for an unrecognized
    * key (instead of an exception being thrown), you can use the method reference {@code map::get}
    * instead.
    */
   public static <K, V> Function<K, V> forMap(Map<K, V> map) {
-    return new FunctionForMapNoDefault<K, V>(map);
+    return new FunctionForMapNoDefault<>(map);
   }
 
   private static class FunctionForMapNoDefault<K, V> implements Function<K, V>, Serializable {
     final Map<K, V> map;
 
     FunctionForMapNoDefault(Map<K, V> map) {
       this.map = checkNotNull(map);
     }
 
     @Override
     public V apply(@Nullable K key) {
       V result = map.get(key);
       checkArgument(result != null || map.containsKey(key), "Key '%s' not present in map", key);
       return result;
     }
 
     @Override
     public boolean equals(@Nullable Object o) {
       if (o instanceof FunctionForMapNoDefault) {
         FunctionForMapNoDefault<?, ?> that = (FunctionForMapNoDefault<?, ?>) o;
         return map.equals(that.map);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return map.hashCode();
     }
 
     @Override
     public String toString() {
       return "Functions.forMap(" + map + ")";
     }
 
     private static final long serialVersionUID = 0;
   }
 
   /**
    * Returns a function which performs a map lookup with a default value. The function created by
    * this method returns {@code defaultValue} for all inputs that do not belong to the map's key
    * set. See also {@link #forMap(Map)}, which throws an exception in this case.
    *
    * <p><b>Java 8 users:</b> you can just write the lambda expression {@code k ->
    * map.getWithDefault(k, defaultValue)} instead.
    *
    * @param map source map that determines the function behavior
    * @param defaultValue the value to return for inputs that aren't map keys
    * @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
    *         defaultValue} otherwise
    */
   public static <K, V> Function<K, V> forMap(Map<K, ? extends V> map, @Nullable V defaultValue) {
-    return new ForMapWithDefault<K, V>(map, defaultValue);
+    return new ForMapWithDefault<>(map, defaultValue);
   }
 
   private static class ForMapWithDefault<K, V> implements Function<K, V>, Serializable {
     final Map<K, ? extends V> map;
     final V defaultValue;
 
     ForMapWithDefault(Map<K, ? extends V> map, @Nullable V defaultValue) {
       this.map = checkNotNull(map);
       this.defaultValue = defaultValue;
     }
 
     @Override
     public V apply(@Nullable K key) {
       V result = map.get(key);
       return (result != null || map.containsKey(key)) ? result : defaultValue;
     }
 
     @Override
     public boolean equals(@Nullable Object o) {
       if (o instanceof ForMapWithDefault) {
         ForMapWithDefault<?, ?> that = (ForMapWithDefault<?, ?>) o;
         return map.equals(that.map) && Objects.equal(defaultValue, that.defaultValue);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return Objects.hashCode(map, defaultValue);
     }
 
     @Override
     public String toString() {
       // TODO(cpovirk): maybe remove "defaultValue=" to make this look like the method call does
       return "Functions.forMap(" + map + ", defaultValue=" + defaultValue + ")";
     }
 
     private static final long serialVersionUID = 0;
   }
 
   /**
    * Returns the composition of two functions. For {@code f: A->B} and {@code g: B->C}, composition
    * is defined as the function h such that {@code h(a) == g(f(a))} for each {@code a}.
    *
    * <p><b>Java 8 users:</b> use {@code g.compose(f)} or (probably clearer) {@code f.andThen(g)}
    * instead.
    *
    * @param g the second function to apply
    * @param f the first function to apply
    * @return the composition of {@code f} and {@code g}
    * @see <a href="//en.wikipedia.org/wiki/Function_composition">function composition</a>
    */
   public static <A, B, C> Function<A, C> compose(Function<B, C> g, Function<A, ? extends B> f) {
-    return new FunctionComposition<A, B, C>(g, f);
+    return new FunctionComposition<>(g, f);
   }
 
   private static class FunctionComposition<A, B, C> implements Function<A, C>, Serializable {
     private final Function<B, C> g;
     private final Function<A, ? extends B> f;
 
     public FunctionComposition(Function<B, C> g, Function<A, ? extends B> f) {
       this.g = checkNotNull(g);
       this.f = checkNotNull(f);
     }
 
     @Override
     public C apply(@Nullable A a) {
       return g.apply(f.apply(a));
     }
 
     @Override
     public boolean equals(@Nullable Object obj) {
       if (obj instanceof FunctionComposition) {
         FunctionComposition<?, ?, ?> that = (FunctionComposition<?, ?, ?>) obj;
         return f.equals(that.f) && g.equals(that.g);
       }
       return false;
     }
 
     @Override
     public int hashCode() {
       return f.hashCode() ^ g.hashCode();
     }
 
     @Override
     public String toString() {
       // TODO(cpovirk): maybe make this look like the method call does ("Functions.compose(...)")
       return g + "(" + f + ")";
     }
 
     private static final long serialVersionUID = 0;
   }
 
   /**
    * Creates a function that returns the same boolean output as the given predicate for all inputs.
    *
    * <p>The returned function is <i>consistent with equals</i> (as documented at
    * {@link Function#apply}) if and only if {@code predicate} is itself consistent with equals.
    *
    * <p><b>Java 8 users:</b> use the method reference {@code predicate::test} instead.
    */
   public static <T> Function<T, Boolean> forPredicate(Predicate<T> predicate) {
     return new PredicateFunction<T>(predicate);
   }
