diff --git a/android/guava/src/com/google/common/collect/AbstractMultimap.java b/android/guava/src/com/google/common/collect/AbstractMultimap.java
index d7c67524e..f6d69128a 100644
--- a/android/guava/src/com/google/common/collect/AbstractMultimap.java
+++ b/android/guava/src/com/google/common/collect/AbstractMultimap.java
@@ -43,101 +43,101 @@ abstract class AbstractMultimap<K, V> implements Multimap<K, V> {
 
   @Override
   public boolean containsValue(@Nullable Object value) {
     for (Collection<V> collection : asMap().values()) {
       if (collection.contains(value)) {
         return true;
       }
     }
 
     return false;
   }
 
   @Override
   public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
     Collection<V> collection = asMap().get(key);
     return collection != null && collection.contains(value);
   }
 
   @CanIgnoreReturnValue
   @Override
   public boolean remove(@Nullable Object key, @Nullable Object value) {
     Collection<V> collection = asMap().get(key);
     return collection != null && collection.remove(value);
   }
 
   @CanIgnoreReturnValue
   @Override
   public boolean put(@Nullable K key, @Nullable V value) {
     return get(key).add(value);
   }
 
   @CanIgnoreReturnValue
   @Override
   public boolean putAll(@Nullable K key, Iterable<? extends V> values) {
     checkNotNull(values);
     // make sure we only call values.iterator() once
     // and we only call get(key) if values is nonempty
     if (values instanceof Collection) {
       Collection<? extends V> valueCollection = (Collection<? extends V>) values;
       return !valueCollection.isEmpty() && get(key).addAll(valueCollection);
     } else {
       Iterator<? extends V> valueItr = values.iterator();
       return valueItr.hasNext() && Iterators.addAll(get(key), valueItr);
     }
   }
 
   @CanIgnoreReturnValue
   @Override
   public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     boolean changed = false;
-    for (Map.Entry<? extends K, ? extends V> entry : multimap.entries()) {
+    for (Entry<? extends K, ? extends V> entry : multimap.entries()) {
       changed |= put(entry.getKey(), entry.getValue());
     }
     return changed;
   }
 
   @CanIgnoreReturnValue
   @Override
   public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     checkNotNull(values);
     Collection<V> result = removeAll(key);
     putAll(key, values);
     return result;
   }
 
   private transient Collection<Entry<K, V>> entries;
 
   @Override
   public Collection<Entry<K, V>> entries() {
     Collection<Entry<K, V>> result = entries;
     return (result == null) ? entries = createEntries() : result;
   }
 
   Collection<Entry<K, V>> createEntries() {
     if (this instanceof SetMultimap) {
       return new EntrySet();
     } else {
       return new Entries();
     }
   }
 
   @WeakOuter
   private class Entries extends Multimaps.Entries<K, V> {
     @Override
     Multimap<K, V> multimap() {
       return AbstractMultimap.this;
     }
 
     @Override
     public Iterator<Entry<K, V>> iterator() {
       return entryIterator();
     }
   }
 
   @WeakOuter
   private class EntrySet extends Entries implements Set<Entry<K, V>> {
     @Override
     public int hashCode() {
       return Sets.hashCodeImpl(this);
     }
 
