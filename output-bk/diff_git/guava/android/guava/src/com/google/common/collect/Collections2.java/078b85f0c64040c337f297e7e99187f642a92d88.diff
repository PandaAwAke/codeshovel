diff --git a/android/guava/src/com/google/common/collect/Collections2.java b/android/guava/src/com/google/common/collect/Collections2.java
index b091b05c8..87417fa52 100644
--- a/android/guava/src/com/google/common/collect/Collections2.java
+++ b/android/guava/src/com/google/common/collect/Collections2.java
@@ -1,88 +1,87 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.math.IntMath;
 import com.google.common.primitives.Ints;
 import java.util.AbstractCollection;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Provides static methods for working with {@code Collection} instances.
  *
  * <p><b>Java 8 users:</b> several common uses for this class are now more comprehensively addressed
  * by the new {@link java.util.stream.Stream} library. Read the method documentation below for
  * comparisons. These methods are not being deprecated, but we gently encourage you to migrate to
  * streams.
  *
  * @author Chris Povirk
  * @author Mike Bostock
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible
 public final class Collections2 {
   private Collections2() {}
 
   /**
    * Returns the elements of {@code unfiltered} that satisfy a predicate. The returned collection is
    * a live view of {@code unfiltered}; changes to one affect the other.
    *
    * <p>The resulting collection's iterator does not support {@code remove()}, but all other
    * collection methods are supported. When given an element that doesn't satisfy the predicate, the
    * collection's {@code add()} and {@code addAll()} methods throw an {@link
    * IllegalArgumentException}. When methods such as {@code removeAll()} and {@code clear()} are
    * called on the filtered collection, only elements that satisfy the filter will be removed from
    * the underlying collection.
    *
    * <p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.
    *
    * <p>Many of the filtered collection's methods, such as {@code size()}, iterate across every
    * element in the underlying collection and determine which elements satisfy the filter. When a
    * live view is <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered,
    * predicate)} and use the copy.
    *
    * <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
    * {@link Predicate#apply}. Do not provide a predicate such as {@code
    * Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
    * Iterables#filter(Iterable, Class)} for related functionality.)
    *
    * <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#filter Stream.filter}.
    */
   // TODO(kevinb): how can we omit that Iterables link when building gwt
   // javadoc?
   public static <E> Collection<E> filter(Collection<E> unfiltered, Predicate<? super E> predicate) {
     if (unfiltered instanceof FilteredCollection) {
       // Support clear(), removeAll(), and retainAll() when filtering a filtered
       // collection.
@@ -616,61 +615,74 @@ public final class Collections2 {
 
     @Override
     protected List<E> computeNext() {
       if (j <= 0) {
         return endOfData();
       }
       ImmutableList<E> next = ImmutableList.copyOf(list);
       calculateNextPermutation();
       return next;
     }
 
     void calculateNextPermutation() {
       j = list.size() - 1;
       int s = 0;
 
       // Handle the special case of an empty list. Skip the calculation of the
       // next permutation.
       if (j == -1) {
         return;
       }
 
       while (true) {
         int q = c[j] + o[j];
         if (q < 0) {
           switchDirection();
           continue;
         }
         if (q == j + 1) {
           if (j == 0) {
             break;
           }
           s++;
           switchDirection();
           continue;
         }
 
         Collections.swap(list, j - c[j] + s, j - q + s);
         c[j] = q;
         break;
       }
     }
 
     void switchDirection() {
       o[j] = -o[j];
       j--;
     }
   }
 
   /** Returns {@code true} if the second list is a permutation of the first. */
   private static boolean isPermutation(List<?> first, List<?> second) {
-    return first.size() == second.size() && counts(first).equals(counts(second));
+    if (first.size() != second.size()) {
+      return false;
+    }
+    ObjectCountHashMap<?> firstCounts = counts(first);
+    ObjectCountHashMap<?> secondCounts = counts(second);
+    if (first.size() != second.size()) {
+      return false;
+    }
+    for (int i = 0; i < first.size(); i++) {
+      if (firstCounts.getValue(i) != secondCounts.get(firstCounts.getKey(i))) {
+        return false;
+      }
+    }
+    return true;
   }
 
-  private static <E> Set<Multiset.Entry<E>> counts(Collection<E> collection) {
-    AbstractObjectCountMap<E> map = new ObjectCountHashMap<>();
+  private static <E> ObjectCountHashMap<E> counts(Collection<E> collection) {
+    ObjectCountHashMap<E> map = new ObjectCountHashMap<>();
     for (E e : collection) {
       map.put(e, map.get(e) + 1);
     }
-    return map.entrySet();
+    return map;
   }
 }
