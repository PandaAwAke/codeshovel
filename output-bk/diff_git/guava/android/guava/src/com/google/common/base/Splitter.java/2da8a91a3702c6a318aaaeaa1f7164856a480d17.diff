diff --git a/android/guava/src/com/google/common/base/Splitter.java b/android/guava/src/com/google/common/base/Splitter.java
index ee497c635..24ab8085a 100644
--- a/android/guava/src/com/google/common/base/Splitter.java
+++ b/android/guava/src/com/google/common/base/Splitter.java
@@ -361,174 +361,174 @@ public final class Splitter {
   // TODO(kevinb): throw if a trimmer was already specified!
   public Splitter trimResults(CharMatcher trimmer) {
     checkNotNull(trimmer);
     return new Splitter(strategy, omitEmptyStrings, trimmer, limit);
   }
 
   /**
    * Splits {@code sequence} into string components and makes them available through an
    * {@link Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List},
    * use {@link #splitToList(CharSequence)}.
    *
    * @param sequence the sequence of characters to split
    * @return an iteration over the segments split from the parameter
    */
   public Iterable<String> split(final CharSequence sequence) {
     checkNotNull(sequence);
 
     return new Iterable<String>() {
       @Override
       public Iterator<String> iterator() {
         return splittingIterator(sequence);
       }
 
       @Override
       public String toString() {
         return Joiner.on(", ")
             .appendTo(new StringBuilder().append('['), this)
             .append(']')
             .toString();
       }
     };
   }
 
   private Iterator<String> splittingIterator(CharSequence sequence) {
     return strategy.iterator(this, sequence);
   }
 
   /**
    * Splits {@code sequence} into string components and returns them as an immutable list. If you
    * want an {@link Iterable} which may be lazily evaluated, use {@link #split(CharSequence)}.
    *
    * @param sequence the sequence of characters to split
    * @return an immutable list of the segments split from the parameter
    * @since 15.0
    */
   @Beta
   public List<String> splitToList(CharSequence sequence) {
     checkNotNull(sequence);
 
     Iterator<String> iterator = splittingIterator(sequence);
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
 
     while (iterator.hasNext()) {
       result.add(iterator.next());
     }
 
     return Collections.unmodifiableList(result);
   }
 
   /**
    * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
    * into keys and values using the specified separator.
    *
    * @since 10.0
    */
   @Beta
   public MapSplitter withKeyValueSeparator(String separator) {
     return withKeyValueSeparator(on(separator));
   }
 
   /**
    * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
    * into keys and values using the specified separator.
    *
    * @since 14.0
    */
   @Beta
   public MapSplitter withKeyValueSeparator(char separator) {
     return withKeyValueSeparator(on(separator));
   }
 
   /**
    * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
    * into keys and values using the specified key-value splitter.
    *
    * @since 10.0
    */
   @Beta
   public MapSplitter withKeyValueSeparator(Splitter keyValueSplitter) {
     return new MapSplitter(this, keyValueSplitter);
   }
 
   /**
    * An object that splits strings into maps as {@code Splitter} splits iterables and lists. Like
    * {@code Splitter}, it is thread-safe and immutable. The common way to build instances is by
    * providing an additional {@linkplain Splitter#withKeyValueSeparator key-value separator} to
    * {@link Splitter}.
    *
    * @since 10.0
    */
   @Beta
   public static final class MapSplitter {
     private static final String INVALID_ENTRY_MESSAGE = "Chunk [%s] is not a valid entry";
     private final Splitter outerSplitter;
     private final Splitter entrySplitter;
 
     private MapSplitter(Splitter outerSplitter, Splitter entrySplitter) {
       this.outerSplitter = outerSplitter; // only "this" is passed
       this.entrySplitter = checkNotNull(entrySplitter);
     }
 
     /**
      * Splits {@code sequence} into substrings, splits each substring into an entry, and returns an
      * unmodifiable map with each of the entries. For example,
      * {@code Splitter.on(';').trimResults().withKeyValueSeparator("=>").split("a=>b ; c=>b")} will
      * return a mapping from {@code "a"} to {@code "b"} and {@code "c"} to {@code "b"}.
      *
      * <p>The returned map preserves the order of the entries from {@code sequence}.
      *
      * @throws IllegalArgumentException if the specified sequence does not split into valid map
      *     entries, or if there are duplicate keys
      */
     public Map<String, String> split(CharSequence sequence) {
-      Map<String, String> map = new LinkedHashMap<String, String>();
+      Map<String, String> map = new LinkedHashMap<>();
       for (String entry : outerSplitter.split(sequence)) {
         Iterator<String> entryFields = entrySplitter.splittingIterator(entry);
 
         checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);
         String key = entryFields.next();
         checkArgument(!map.containsKey(key), "Duplicate key [%s] found.", key);
 
         checkArgument(entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);
         String value = entryFields.next();
         map.put(key, value);
 
         checkArgument(!entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);
       }
       return Collections.unmodifiableMap(map);
     }
   }
 
   private interface Strategy {
     Iterator<String> iterator(Splitter splitter, CharSequence toSplit);
   }
 
   private abstract static class SplittingIterator extends AbstractIterator<String> {
     final CharSequence toSplit;
     final CharMatcher trimmer;
     final boolean omitEmptyStrings;
 
     /**
      * Returns the first index in {@code toSplit} at or after {@code start} that contains the
      * separator.
      */
     abstract int separatorStart(int start);
 
     /**
      * Returns the first index in {@code toSplit} after {@code
      * separatorPosition} that does not contain a separator. This method is only invoked after a
      * call to {@code separatorStart}.
      */
     abstract int separatorEnd(int separatorPosition);
 
     int offset = 0;
     int limit;
 
     protected SplittingIterator(Splitter splitter, CharSequence toSplit) {
       this.trimmer = splitter.trimmer;
       this.omitEmptyStrings = splitter.omitEmptyStrings;
       this.limit = splitter.limit;
       this.toSplit = toSplit;
     }
 
     @Override
