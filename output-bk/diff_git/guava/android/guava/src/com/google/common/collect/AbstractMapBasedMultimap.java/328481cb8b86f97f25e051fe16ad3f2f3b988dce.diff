diff --git a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
index 89aad1607..e263e3056 100644
--- a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
+++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
@@ -891,103 +891,103 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
         return getDelegateListIterator().previousIndex();
       }
 
       @Override
       public void set(V value) {
         getDelegateListIterator().set(value);
       }
 
       @Override
       public void add(V value) {
         boolean wasEmpty = isEmpty();
         getDelegateListIterator().add(value);
         totalSize++;
         if (wasEmpty) {
           addToMap();
         }
       }
     }
   }
 
   /**
    * List decorator that stays in sync with the multimap values for a key and
    * supports rapid random access.
    */
   private class RandomAccessWrappedList extends WrappedList implements RandomAccess {
     RandomAccessWrappedList(
         @Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {
       super(key, delegate, ancestor);
     }
   }
 
   @Override
   Set<K> createKeySet() {
     if (map instanceof NavigableMap) {
       return new NavigableKeySet((NavigableMap<K, Collection<V>>) map);
     } else if (map instanceof SortedMap) {
       return new SortedKeySet((SortedMap<K, Collection<V>>) map);
     } else {
       return new KeySet(map);
     }
   }
 
   @WeakOuter
   private class KeySet extends Maps.KeySet<K, Collection<V>> {
     KeySet(final Map<K, Collection<V>> subMap) {
       super(subMap);
     }
 
     @Override
     public Iterator<K> iterator() {
-      final Iterator<Map.Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();
+      final Iterator<Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();
       return new Iterator<K>() {
-        Map.Entry<K, Collection<V>> entry;
+        Entry<K, Collection<V>> entry;
 
         @Override
         public boolean hasNext() {
           return entryIterator.hasNext();
         }
 
         @Override
         public K next() {
           entry = entryIterator.next();
           return entry.getKey();
         }
 
         @Override
         public void remove() {
           checkRemove(entry != null);
           Collection<V> collection = entry.getValue();
           entryIterator.remove();
           totalSize -= collection.size();
           collection.clear();
         }
       };
     }
 
     // The following methods are included for better performance.
 
     @Override
     public boolean remove(Object key) {
       int count = 0;
       Collection<V> collection = map().remove(key);
       if (collection != null) {
         count = collection.size();
         collection.clear();
         totalSize -= count;
       }
       return count > 0;
     }
 
     @Override
     public void clear() {
       Iterators.clear(iterator());
     }
 
     @Override
     public boolean containsAll(Collection<?> c) {
       return map().keySet().containsAll(c);
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       return this == object || this.map().keySet().equals(object);
@@ -1092,193 +1092,193 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
       return descendingSet().iterator();
     }
 
     @Override
     public NavigableSet<K> headSet(K toElement) {
       return headSet(toElement, false);
     }
 
     @Override
     public NavigableSet<K> headSet(K toElement, boolean inclusive) {
       return new NavigableKeySet(sortedMap().headMap(toElement, inclusive));
     }
 
     @Override
     public NavigableSet<K> subSet(K fromElement, K toElement) {
       return subSet(fromElement, true, toElement, false);
     }
 
     @Override
     public NavigableSet<K> subSet(
         K fromElement, boolean fromInclusive, K toElement, boolean toInclusive) {
       return new NavigableKeySet(
           sortedMap().subMap(fromElement, fromInclusive, toElement, toInclusive));
     }
 
     @Override
     public NavigableSet<K> tailSet(K fromElement) {
       return tailSet(fromElement, true);
     }
 
     @Override
     public NavigableSet<K> tailSet(K fromElement, boolean inclusive) {
       return new NavigableKeySet(sortedMap().tailMap(fromElement, inclusive));
     }
   }
 
   /**
    * Removes all values for the provided key.
    */
   private void removeValuesForKey(Object key) {
     Collection<V> collection = Maps.safeRemove(map, key);
 
     if (collection != null) {
       int count = collection.size();
       collection.clear();
       totalSize -= count;
     }
   }
 
   private abstract class Itr<T> implements Iterator<T> {
-    final Iterator<Map.Entry<K, Collection<V>>> keyIterator;
+    final Iterator<Entry<K, Collection<V>>> keyIterator;
     K key;
     Collection<V> collection;
     Iterator<V> valueIterator;
 
     Itr() {
       keyIterator = map.entrySet().iterator();
       key = null;
       collection = null;
       valueIterator = Iterators.emptyModifiableIterator();
     }
 
     abstract T output(K key, V value);
 
     @Override
     public boolean hasNext() {
       return keyIterator.hasNext() || valueIterator.hasNext();
     }
 
     @Override
     public T next() {
       if (!valueIterator.hasNext()) {
-        Map.Entry<K, Collection<V>> mapEntry = keyIterator.next();
+        Entry<K, Collection<V>> mapEntry = keyIterator.next();
         key = mapEntry.getKey();
         collection = mapEntry.getValue();
         valueIterator = collection.iterator();
       }
       return output(key, valueIterator.next());
     }
 
     @Override
     public void remove() {
       valueIterator.remove();
       if (collection.isEmpty()) {
         keyIterator.remove();
       }
       totalSize--;
     }
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values
    * for one key, followed by the values of a second key, and so on.
    */
   @Override
   public Collection<V> values() {
     return super.values();
   }
 
   @Override
   Iterator<V> valueIterator() {
     return new Itr<V>() {
       @Override
       V output(K key, V value) {
         return value;
       }
     };
   }
 
   /*
    * TODO(kevinb): should we copy this javadoc to each concrete class, so that
    * classes like LinkedHashMultimap that need to say something different are
    * still able to {@inheritDoc} all the way from Multimap?
    */
 
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values
    * for one key, followed by the values of a second key, and so on.
    *
    * <p>Each entry is an immutable snapshot of a key-value mapping in the
    * multimap, taken at the time the entry is returned by a method call to the
    * collection or its iterator.
    */
   @Override
-  public Collection<Map.Entry<K, V>> entries() {
+  public Collection<Entry<K, V>> entries() {
     return super.entries();
   }
 
   /**
    * Returns an iterator across all key-value map entries, used by {@code
    * entries().iterator()} and {@code values().iterator()}. The default
    * behavior, which traverses the values for one key, the values for a second
    * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.
    *
    * @return an iterator across map entries
    */
   @Override
-  Iterator<Map.Entry<K, V>> entryIterator() {
-    return new Itr<Map.Entry<K, V>>() {
+  Iterator<Entry<K, V>> entryIterator() {
+    return new Itr<Entry<K, V>>() {
       @Override
       Entry<K, V> output(K key, V value) {
         return Maps.immutableEntry(key, value);
       }
     };
   }
 
   @Override
   Map<K, Collection<V>> createAsMap() {
     if (map instanceof NavigableMap) {
       return new NavigableAsMap((NavigableMap<K, Collection<V>>) map);
     } else if (map instanceof SortedMap) {
       return new SortedAsMap((SortedMap<K, Collection<V>>) map);
     } else {
       return new AsMap(map);
     }
   }
 
   @WeakOuter
   private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     /**
      * Usually the same as map, but smaller for the headMap(), tailMap(), or
      * subMap() of a SortedAsMap.
      */
     final transient Map<K, Collection<V>> submap;
 
     AsMap(Map<K, Collection<V>> submap) {
       this.submap = submap;
     }
 
     @Override
     protected Set<Entry<K, Collection<V>>> createEntrySet() {
       return new AsMapEntries();
     }
 
     // The following methods are included for performance.
 
     @Override
     public boolean containsKey(Object key) {
       return Maps.safeContainsKey(submap, key);
     }
 
     @Override
     public Collection<V> get(Object key) {
       Collection<V> collection = Maps.safeGet(submap, key);
       if (collection == null) {
         return null;
       }
       @SuppressWarnings("unchecked")
       K k = (K) key;
@@ -1299,135 +1299,135 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
     public Collection<V> remove(Object key) {
       Collection<V> collection = submap.remove(key);
       if (collection == null) {
         return null;
       }
 
       Collection<V> output = createCollection();
       output.addAll(collection);
       totalSize -= collection.size();
       collection.clear();
       return output;
     }
 
     @Override
     public boolean equals(@Nullable Object object) {
       return this == object || submap.equals(object);
     }
 
     @Override
     public int hashCode() {
       return submap.hashCode();
     }
 
     @Override
     public String toString() {
       return submap.toString();
     }
 
     @Override
     public void clear() {
       if (submap == map) {
         AbstractMapBasedMultimap.this.clear();
       } else {
         Iterators.clear(new AsMapIterator());
       }
     }
 
     Entry<K, Collection<V>> wrapEntry(Entry<K, Collection<V>> entry) {
       K key = entry.getKey();
       return Maps.immutableEntry(key, wrapCollection(key, entry.getValue()));
     }
 
     @WeakOuter
     class AsMapEntries extends Maps.EntrySet<K, Collection<V>> {
       @Override
       Map<K, Collection<V>> map() {
         return AsMap.this;
       }
 
       @Override
-      public Iterator<Map.Entry<K, Collection<V>>> iterator() {
+      public Iterator<Entry<K, Collection<V>>> iterator() {
         return new AsMapIterator();
       }
 
       // The following methods are included for performance.
 
       @Override
       public boolean contains(Object o) {
         return Collections2.safeContains(submap.entrySet(), o);
       }
 
       @Override
       public boolean remove(Object o) {
         if (!contains(o)) {
           return false;
         }
-        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
+        Entry<?, ?> entry = (Entry<?, ?>) o;
         removeValuesForKey(entry.getKey());
         return true;
       }
     }
 
     /** Iterator across all keys and value collections. */
-    class AsMapIterator implements Iterator<Map.Entry<K, Collection<V>>> {
-      final Iterator<Map.Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();
+    class AsMapIterator implements Iterator<Entry<K, Collection<V>>> {
+      final Iterator<Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();
       Collection<V> collection;
 
       @Override
       public boolean hasNext() {
         return delegateIterator.hasNext();
       }
 
       @Override
-      public Map.Entry<K, Collection<V>> next() {
-        Map.Entry<K, Collection<V>> entry = delegateIterator.next();
+      public Entry<K, Collection<V>> next() {
+        Entry<K, Collection<V>> entry = delegateIterator.next();
         collection = entry.getValue();
         return wrapEntry(entry);
       }
 
       @Override
       public void remove() {
         delegateIterator.remove();
         totalSize -= collection.size();
         collection.clear();
       }
     }
   }
 
   @WeakOuter
   private class SortedAsMap extends AsMap implements SortedMap<K, Collection<V>> {
     SortedAsMap(SortedMap<K, Collection<V>> submap) {
       super(submap);
     }
 
     SortedMap<K, Collection<V>> sortedMap() {
       return (SortedMap<K, Collection<V>>) submap;
     }
 
     @Override
     public Comparator<? super K> comparator() {
       return sortedMap().comparator();
     }
 
     @Override
     public K firstKey() {
       return sortedMap().firstKey();
     }
 
     @Override
     public K lastKey() {
       return sortedMap().lastKey();
     }
 
     @Override
     public SortedMap<K, Collection<V>> headMap(K toKey) {
       return new SortedAsMap(sortedMap().headMap(toKey));
     }
 
     @Override
     public SortedMap<K, Collection<V>> subMap(K fromKey, K toKey) {
       return new SortedAsMap(sortedMap().subMap(fromKey, toKey));
     }
 
     @Override
     public SortedMap<K, Collection<V>> tailMap(K fromKey) {
@@ -1480,101 +1480,101 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
 
     @Override
     public K floorKey(K key) {
       return sortedMap().floorKey(key);
     }
 
     @Override
     public Entry<K, Collection<V>> ceilingEntry(K key) {
       Entry<K, Collection<V>> entry = sortedMap().ceilingEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
     @Override
     public K ceilingKey(K key) {
       return sortedMap().ceilingKey(key);
     }
 
     @Override
     public Entry<K, Collection<V>> higherEntry(K key) {
       Entry<K, Collection<V>> entry = sortedMap().higherEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
     @Override
     public K higherKey(K key) {
       return sortedMap().higherKey(key);
     }
 
     @Override
     public Entry<K, Collection<V>> firstEntry() {
       Entry<K, Collection<V>> entry = sortedMap().firstEntry();
       return (entry == null) ? null : wrapEntry(entry);
     }
 
     @Override
     public Entry<K, Collection<V>> lastEntry() {
       Entry<K, Collection<V>> entry = sortedMap().lastEntry();
       return (entry == null) ? null : wrapEntry(entry);
     }
 
     @Override
     public Entry<K, Collection<V>> pollFirstEntry() {
       return pollAsMapEntry(entrySet().iterator());
     }
 
     @Override
     public Entry<K, Collection<V>> pollLastEntry() {
       return pollAsMapEntry(descendingMap().entrySet().iterator());
     }
 
-    Map.Entry<K, Collection<V>> pollAsMapEntry(Iterator<Entry<K, Collection<V>>> entryIterator) {
+    Entry<K, Collection<V>> pollAsMapEntry(Iterator<Entry<K, Collection<V>>> entryIterator) {
       if (!entryIterator.hasNext()) {
         return null;
       }
       Entry<K, Collection<V>> entry = entryIterator.next();
       Collection<V> output = createCollection();
       output.addAll(entry.getValue());
       entryIterator.remove();
       return Maps.immutableEntry(entry.getKey(), unmodifiableCollectionSubclass(output));
     }
 
     @Override
     public NavigableMap<K, Collection<V>> descendingMap() {
       return new NavigableAsMap(sortedMap().descendingMap());
     }
 
     @Override
     public NavigableSet<K> keySet() {
       return (NavigableSet<K>) super.keySet();
     }
 
     @Override
     NavigableSet<K> createKeySet() {
       return new NavigableKeySet(sortedMap());
     }
 
     @Override
     public NavigableSet<K> navigableKeySet() {
       return keySet();
     }
 
     @Override
     public NavigableSet<K> descendingKeySet() {
       return descendingMap().navigableKeySet();
     }
 
     @Override
     public NavigableMap<K, Collection<V>> subMap(K fromKey, K toKey) {
       return subMap(fromKey, true, toKey, false);
     }
 
     @Override
     public NavigableMap<K, Collection<V>> subMap(
         K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
       return new NavigableAsMap(sortedMap().subMap(fromKey, fromInclusive, toKey, toInclusive));
     }
 
     @Override
     public NavigableMap<K, Collection<V>> headMap(K toKey) {
       return headMap(toKey, false);
     }
