diff --git a/android/guava/src/com/google/common/collect/Iterators.java b/android/guava/src/com/google/common/collect/Iterators.java
index 4da4e26e5..ec18ad177 100644
--- a/android/guava/src/com/google/common/collect/Iterators.java
+++ b/android/guava/src/com/google/common/collect/Iterators.java
@@ -1,88 +1,90 @@
 /*
  * Copyright (C) 2007 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.instanceOf;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Deque;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import javax.annotation.Nullable;
 
 /**
  * This class contains static utility methods that operate on or return objects
  * of type {@link Iterator}. Except as noted, each method has a corresponding
  * {@link Iterable}-based method in the {@link Iterables} class.
  *
  * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators
  * produced in this class are <i>lazy</i>, which means that they only advance
  * the backing iteration when absolutely necessary.
  *
  * <p>See the Guava User Guide section on <a href=
  * "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables">
  * {@code Iterators}</a>.
  *
  * @author Kevin Bourrillion
  * @author Jared Levy
  * @since 2.0
  */
 @GwtCompatible(emulated = true)
 public final class Iterators {
   private Iterators() {}
 
   /**
    * Returns the empty iterator.
    *
    * <p>The {@link Iterable} equivalent of this method is {@link
    * ImmutableSet#of()}.
    */
   static <T> UnmodifiableIterator<T> emptyIterator() {
     return emptyListIterator();
   }
 
   /**
    * Returns the empty iterator.
    *
    * <p>The {@link Iterable} equivalent of this method is {@link
    * ImmutableSet#of()}.
    */
   // Casting to any type is safe since there are no actual elements.
   @SuppressWarnings("unchecked")
   static <T> UnmodifiableListIterator<T> emptyListIterator() {
     return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;
@@ -412,167 +414,202 @@ public final class Iterators {
       @Override
       public boolean hasNext() {
         /*
          * Don't store a new Iterator until we know the user can't remove() the last returned
          * element anymore. Otherwise, when we remove from the old iterator, we may be invalidating
          * the new one. The result is a ConcurrentModificationException or other bad behavior.
          *
          * (If we decide that we really, really hate allocating two Iterators per cycle instead of
          * one, we can optimistically store the new Iterator and then be willing to throw it out if
          * the user calls remove().)
          */
         return iterator.hasNext() || iterable.iterator().hasNext();
       }
 
       @Override
       public T next() {
         if (!iterator.hasNext()) {
           iterator = iterable.iterator();
           if (!iterator.hasNext()) {
             throw new NoSuchElementException();
           }
         }
         return iterator.next();
       }
 
       @Override
       public void remove() {
         iterator.remove();
       }
     };
   }
 
   /**
    * Returns an iterator that cycles indefinitely over the provided elements.
    *
    * <p>The returned iterator supports {@code remove()}. After {@code remove()}
    * is called, subsequent cycles omit the removed
    * element, but {@code elements} does not change. The iterator's
    * {@code hasNext()} method returns {@code true} until all of the original
    * elements have been removed.
    *
    * <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
    * infinite loop. You should use an explicit {@code break} or be certain that
    * you will eventually remove all the elements.
    */
   @SafeVarargs
   public static <T> Iterator<T> cycle(T... elements) {
     return cycle(Lists.newArrayList(elements));
   }
 
+  /**
+   * Returns an Iterator that walks the specified array, nulling out elements behind it.
+   * This can avoid memory leaks when an element is no longer necessary.
+   *
+   * This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.
+   */
+  private static <T> Iterator<T> consumingForArray(final T... elements) {
+    return new UnmodifiableIterator<T>() {
+      int index = 0;
+
+      @Override
+      public boolean hasNext() {
+        return index < elements.length;
+      }
+
+      @Override
+      public T next() {
+        if (!hasNext()) {
+          throw new NoSuchElementException();
+        }
+        T result = elements[index];
+        elements[index] = null;
+        index++;
+        return result;
+      }
+    };
+  }
+
   /**
    * Combines two iterators into a single iterator. The returned iterator
    * iterates across the elements in {@code a}, followed by the elements in
    * {@code b}. The source iterators are not polled until necessary.
    *
    * <p>The returned iterator supports {@code remove()} when the corresponding
    * input iterator supports it.
    */
   public static <T> Iterator<T> concat(Iterator<? extends T> a, Iterator<? extends T> b) {
     checkNotNull(a);
     checkNotNull(b);
-    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b));
+    return concat(consumingForArray(a, b));
   }
 
   /**
    * Combines three iterators into a single iterator. The returned iterator
    * iterates across the elements in {@code a}, followed by the elements in
    * {@code b}, followed by the elements in {@code c}. The source iterators
    * are not polled until necessary.
    *
    * <p>The returned iterator supports {@code remove()} when the corresponding
    * input iterator supports it.
    */
   public static <T> Iterator<T> concat(
       Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c) {
     checkNotNull(a);
     checkNotNull(b);
     checkNotNull(c);
-    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c));
+    return concat(consumingForArray(a, b, c));
   }
 
   /**
    * Combines four iterators into a single iterator. The returned iterator
    * iterates across the elements in {@code a}, followed by the elements in
    * {@code b}, followed by the elements in {@code c}, followed by the elements
    * in {@code d}. The source iterators are not polled until necessary.
    *
    * <p>The returned iterator supports {@code remove()} when the corresponding
    * input iterator supports it.
    */
   public static <T> Iterator<T> concat(
       Iterator<? extends T> a,
       Iterator<? extends T> b,
       Iterator<? extends T> c,
       Iterator<? extends T> d) {
     checkNotNull(a);
     checkNotNull(b);
     checkNotNull(c);
     checkNotNull(d);
-    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(a, b, c, d));
+    return concat(consumingForArray(a, b, c, d));
   }
 
   /**
    * Combines multiple iterators into a single iterator. The returned iterator
    * iterates across the elements of each iterator in {@code inputs}. The input
    * iterators are not polled until necessary.
    *
    * <p>The returned iterator supports {@code remove()} when the corresponding
    * input iterator supports it.
    *
    * @throws NullPointerException if any of the provided iterators is null
    */
   public static <T> Iterator<T> concat(Iterator<? extends T>... inputs) {
+    return concatNoDefensiveCopy(Arrays.copyOf(inputs, inputs.length));
+  }
+
+  /**
+   * Concats a varargs array of iterators without making a defensive copy of the array.
+   */
+  static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs) {
     for (Iterator<? extends T> input : checkNotNull(inputs)) {
       checkNotNull(input);
     }
-    return concat(new ConsumingQueueIterator<Iterator<? extends T>>(inputs));
+    return concat(consumingForArray(inputs));
   }
 
   /**
    * Combines multiple iterators into a single iterator. The returned iterator
    * iterates across the elements of each iterator in {@code inputs}. The input
    * iterators are not polled until necessary.
    *
    * <p>The returned iterator supports {@code remove()} when the corresponding
    * input iterator supports it. The methods of the returned iterator may throw
    * {@code NullPointerException} if any of the input iterators is null.
    */
   public static <T> Iterator<T> concat(Iterator<? extends Iterator<? extends T>> inputs) {
     return new ConcatenatedIterator<T>(inputs);
   }
 
   /**
    * Divides an iterator into unmodifiable sublists of the given size (the final
    * list may be smaller). For example, partitioning an iterator containing
    * {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
    * [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of
    * three and two elements, all in the original order.
    *
    * <p>The returned lists implement {@link java.util.RandomAccess}.
    *
    * @param iterator the iterator to return a partitioned view of
    * @param size the desired size of each partition (the last may be smaller)
    * @return an iterator of immutable lists containing the elements of {@code
    *     iterator} divided into partitions
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
   public static <T> UnmodifiableIterator<List<T>> partition(Iterator<T> iterator, int size) {
     return partitionImpl(iterator, size, false);
   }
 
   /**
    * Divides an iterator into unmodifiable sublists of the given size, padding
    * the final iterator with null values if necessary. For example, partitioning
    * an iterator containing {@code [a, b, c, d, e]} with a partition size of 3
    * yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing
    * two inner lists of three elements each, all in the original order.
    *
    * <p>The returned lists implement {@link java.util.RandomAccess}.
    *
    * @param iterator the iterator to return a partitioned view of
    * @param size the desired size of each partition
    * @return an iterator of immutable lists containing the elements of {@code
    *     iterator} divided into partitions (the final iterable may have
    *     trailing null elements)
    * @throws IllegalArgumentException if {@code size} is nonpositive
    */
@@ -1258,91 +1295,129 @@ public final class Iterators {
   /**
    * An iterator that performs a lazy N-way merge, calculating the next value
    * each time the iterator is polled. This amortizes the sorting cost over the
    * iteration and requires less memory than sorting all elements at once.
    *
    * <p>Retrieving a single element takes approximately O(log(M)) time, where M
    * is the number of iterators. (Retrieving all elements takes approximately
    * O(N*log(M)) time, where N is the total number of elements.)
    */
   private static class MergingIterator<T> extends UnmodifiableIterator<T> {
     final Queue<PeekingIterator<T>> queue;
 
     public MergingIterator(
         Iterable<? extends Iterator<? extends T>> iterators,
         final Comparator<? super T> itemComparator) {
       // A comparator that's used by the heap, allowing the heap
       // to be sorted based on the top of each iterator.
       Comparator<PeekingIterator<T>> heapComparator =
           new Comparator<PeekingIterator<T>>() {
             @Override
             public int compare(PeekingIterator<T> o1, PeekingIterator<T> o2) {
               return itemComparator.compare(o1.peek(), o2.peek());
             }
           };
 
       queue = new PriorityQueue<PeekingIterator<T>>(2, heapComparator);
 
       for (Iterator<? extends T> iterator : iterators) {
         if (iterator.hasNext()) {
           queue.add(Iterators.peekingIterator(iterator));
         }
       }
     }
 
     @Override
     public boolean hasNext() {
       return !queue.isEmpty();
     }
 
     @Override
     public T next() {
       PeekingIterator<T> nextIter = queue.remove();
       T next = nextIter.next();
       if (nextIter.hasNext()) {
         queue.add(nextIter);
       }
       return next;
     }
   }
 
-  private static class ConcatenatedIterator<T>
-      extends MultitransformedIterator<Iterator<? extends T>, T> {
+  private static class ConcatenatedIterator<T> implements Iterator<T> {
+    private Iterator<? extends T> toRemove;
 
-    public ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> iterators) {
-      super(getComponentIterators(iterators));
+    private Iterator<? extends T> iterator = emptyIterator();
+    private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
+
+    ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {
+      this.metaIterators = new ArrayDeque<>();
+      metaIterators.addFirst(checkNotNull(metaIterator));
     }
 
     @Override
-    Iterator<? extends T> transform(Iterator<? extends T> iterator) {
-      return iterator;
+    public boolean hasNext() {
+      while (!checkNotNull(iterator).hasNext()) {
+        // this weird checkNotNull positioning appears required by our tests, which expect
+        // both hasNext and next to throw NPE if an input iterator is null.
+
+        if (metaIterators.isEmpty()) {
+          return false;
+        }
+        Iterator<? extends Iterator<? extends T>> topMeta = checkNotNull(metaIterators.getFirst());
+
+        if (!topMeta.hasNext()) {
+          metaIterators.removeFirst();
+          continue;
+        }
+        iterator = topMeta.next();
+
+        if (iterator instanceof ConcatenatedIterator) {
+          // Instead of taking linear time in the number of nested concatenations, unpack
+          // them into the queue
+          @SuppressWarnings("unchecked")
+          ConcatenatedIterator<T> topConcat = (ConcatenatedIterator<T>) iterator;
+          iterator = topConcat.iterator;
+          metaIterators = smushTogether(topConcat.metaIterators, metaIterators);
+        }
+      }
+      return true;
     }
 
-    /**
-     * Using the component iterators, rather than the input iterators directly,
-     * allows for higher performance in the case of nested concatenation.
-     */
-    private static <T> Iterator<Iterator<? extends T>> getComponentIterators(
-        Iterator<? extends Iterator<? extends T>> iterators) {
-      return new MultitransformedIterator<Iterator<? extends T>, Iterator<? extends T>>(iterators) {
-        @Override
-        Iterator<? extends Iterator<? extends T>> transform(Iterator<? extends T> iterator) {
-          if (iterator instanceof ConcatenatedIterator) {
-            ConcatenatedIterator<? extends T> concatIterator =
-                (ConcatenatedIterator<? extends T>) iterator;
-            if (!concatIterator.current.hasNext()) {
-              return getComponentIterators(concatIterator.backingIterator);
-            }
-          }
-          return Iterators.singletonIterator(iterator);
+    private static <E> Deque<E> smushTogether(Deque<E> first, Deque<E> second) {
+      if (first.size() >= second.size()) {
+        while (!second.isEmpty()) {
+          first.addLast(second.removeFirst());
+        }
+        return first;
+      } else {
+        while (!first.isEmpty()) {
+          second.addFirst(first.removeLast());
         }
-      };
+        return second;
+      }
+    }
+
+    @Override
+    public T next() {
+      if (hasNext()) {
+        toRemove = iterator;
+        return iterator.next();
+      } else {
+        throw new NoSuchElementException();
+      }
+    }
+
+    @Override
+    public void remove() {
+      CollectPreconditions.checkRemove(toRemove != null);
+      toRemove.remove();
+      toRemove = null;
     }
   }
 
   /**
    * Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557
    */
   static <T> ListIterator<T> cast(Iterator<T> iterator) {
     return (ListIterator<T>) iterator;
   }
 }
