diff --git a/android/guava/src/com/google/common/base/Throwables.java b/android/guava/src/com/google/common/base/Throwables.java
index 81bd5787f..852cc5f33 100644
--- a/android/guava/src/com/google/common/base/Throwables.java
+++ b/android/guava/src/com/google/common/base/Throwables.java
@@ -201,131 +201,163 @@ public final class Throwables {
       @Nullable Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)
       throws X1, X2 {
     checkNotNull(declaredType2);
     propagateIfInstanceOf(throwable, declaredType1);
     propagateIfPossible(throwable, declaredType2);
   }
 
   /**
    * Propagates {@code throwable} as-is if it is an instance of {@link RuntimeException} or {@link
    * Error}, or else as a last resort, wraps it in a {@code RuntimeException} and then propagates.
    *
    * <p>This method always throws an exception. The {@code RuntimeException} return type allows
    * client code to signal to the compiler that statements after the call are unreachable. Example
    * usage:
    *
    * <pre>
    * T doSomething() {
    *   try {
    *     return someMethodThatCouldThrowAnything();
    *   } catch (IKnowWhatToDoWithThisException e) {
    *     return handle(e);
    *   } catch (Throwable t) {
    *     throw Throwables.propagate(t);
    *   }
    * }
    * </pre>
    *
    * @param throwable the Throwable to propagate
    * @return nothing will ever be returned; this return type is only for your convenience, as
    *     illustrated in the example above
    * @deprecated Use {@code throw e} or {@code throw new RuntimeException(e)} directly, or use a
    *     combination of {@link #throwIfUnchecked} and {@code throw new RuntimeException(e)}. For
    *     background on the deprecation, read <a href="https://goo.gl/Ivn2kc">Why we deprecated
    *     {@code Throwables.propagate}</a>. This method is scheduled to be removed in July 2018.
    */
   @CanIgnoreReturnValue
   @GwtIncompatible
   @Deprecated
   public static RuntimeException propagate(Throwable throwable) {
     throwIfUnchecked(throwable);
     throw new RuntimeException(throwable);
   }
 
   /**
    * Returns the innermost cause of {@code throwable}. The first throwable in a chain provides
    * context from when the error or exception was initially detected. Example usage:
    *
    * <pre>
    * assertEquals("Unable to assign a customer id", Throwables.getRootCause(e).getMessage());
    * </pre>
+   *
+   * @throws IllegalArgumentException if there is a loop in the causal chain
    */
   public static Throwable getRootCause(Throwable throwable) {
+    // Keep a second pointer that slowly walks the causal chain. If the fast pointer ever catches
+    // the slower pointer, then there's a loop.
+    Throwable slowPointer = throwable;
+    boolean advanceSlowPointer = false;
+
     Throwable cause;
     while ((cause = throwable.getCause()) != null) {
       throwable = cause;
+
+      if (throwable == slowPointer) {
+        throw new IllegalArgumentException("Loop in causal chain detected @ " + throwable);
+      }
+      if (advanceSlowPointer) {
+        slowPointer = slowPointer.getCause();
+      }
+      advanceSlowPointer = !advanceSlowPointer; // only advance every other iteration
     }
     return throwable;
   }
 
   /**
    * Gets a {@code Throwable} cause chain as a list. The first entry in the list will be {@code
    * throwable} followed by its cause hierarchy. Note that this is a snapshot of the cause chain and
    * will not reflect any subsequent changes to the cause chain.
    *
    * <p>Here's an example of how it can be used to find specific types of exceptions in the cause
    * chain:
    *
    * <pre>
    * Iterables.filter(Throwables.getCausalChain(e), IOException.class));
    * </pre>
    *
    * @param throwable the non-null {@code Throwable} to extract causes from
    * @return an unmodifiable list containing the cause chain starting with {@code throwable}
+   * @throws IllegalArgumentException if there is a loop in the causal chain
    */
   @Beta // TODO(kevinb): decide best return type
   public static List<Throwable> getCausalChain(Throwable throwable) {
     checkNotNull(throwable);
     List<Throwable> causes = new ArrayList<Throwable>(4);
-    while (throwable != null) {
+    causes.add(throwable);
+
+    // Keep a second pointer that slowly walks the causal chain. If the fast pointer ever catches
+    // the slower pointer, then there's a loop.
+    Throwable slowPointer = throwable;
+    boolean advanceSlowPointer = false;
+
+    Throwable cause;
+    while ((cause = throwable.getCause()) != null) {
+      throwable = cause;
       causes.add(throwable);
-      throwable = throwable.getCause();
+
+      if (throwable == slowPointer) {
+        throw new IllegalArgumentException("Loop in causal chain detected @ " + throwable);
+      }
+      if (advanceSlowPointer) {
+        slowPointer = slowPointer.getCause();
+      }
+      advanceSlowPointer = !advanceSlowPointer; // only advance every other iteration
     }
     return Collections.unmodifiableList(causes);
   }
 
   /**
    * Returns {@code throwable}'s cause, cast to {@code expectedCauseType}.
    *
    * <p>Prefer this method instead of manually casting an exception's cause. For example, {@code
    * (IOException) e.getCause()} throws a {@link ClassCastException} that discards the original
    * exception {@code e} if the cause is not an {@link IOException}, but {@code
    * Throwables.getCauseAs(e, IOException.class)} keeps {@code e} as the {@link
    * ClassCastException}'s cause.
    *
    * @throws ClassCastException if the cause cannot be cast to the expected type. The {@code
    *     ClassCastException}'s cause is {@code throwable}.
    * @since 22.0
    */
   @Beta
   @GwtIncompatible // Class.cast(Object)
   public static <X extends Throwable> X getCauseAs(
       Throwable throwable, Class<X> expectedCauseType) {
     try {
       return expectedCauseType.cast(throwable.getCause());
     } catch (ClassCastException e) {
       e.initCause(throwable);
       throw e;
     }
   }
 
   /**
    * Returns a string containing the result of {@link Throwable#toString() toString()}, followed by
    * the full, recursive stack trace of {@code throwable}. Note that you probably should not be
    * parsing the resulting string; if you need programmatic access to the stack frames, you can call
    * {@link Throwable#getStackTrace()}.
    */
   @GwtIncompatible // java.io.PrintWriter, java.io.StringWriter
   public static String getStackTraceAsString(Throwable throwable) {
     StringWriter stringWriter = new StringWriter();
     throwable.printStackTrace(new PrintWriter(stringWriter));
     return stringWriter.toString();
   }
 
   /**
    * Returns the stack trace of {@code throwable}, possibly providing slower iteration over the full
    * trace but faster iteration over parts of the trace. Here, "slower" and "faster" are defined in
    * comparison to the normal way to access the stack trace, {@link Throwable#getStackTrace()
    * throwable.getStackTrace()}. Note, however, that this method's special implementation is not
    * available for all platforms and configurations. If that implementation is unavailable, this
    * method falls back to {@code getStackTrace}. Callers that require the special implementation can
    * check its availability with {@link #lazyStackTraceIsLazy()}.
