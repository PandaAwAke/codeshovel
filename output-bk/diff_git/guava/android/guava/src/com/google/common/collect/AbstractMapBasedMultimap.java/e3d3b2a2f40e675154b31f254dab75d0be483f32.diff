diff --git a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
index efb2b95b2..9ea6bcaef 100644
--- a/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
+++ b/android/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
@@ -1199,100 +1199,104 @@ abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V>
    */
 
   @Override
   Multiset<K> createKeys() {
     return new Multimaps.Keys<K, V>(this);
   }
 
   /**
    * {@inheritDoc}
    *
    * <p>The iterator generated by the returned collection traverses the values for one key, followed
    * by the values of a second key, and so on.
    *
    * <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
    * time the entry is returned by a method call to the collection or its iterator.
    */
   @Override
   public Collection<Entry<K, V>> entries() {
     return super.entries();
   }
   
   @Override
   Collection<Entry<K, V>> createEntries() {
     if (this instanceof SetMultimap) {
       return new EntrySet();
     } else {
       return new Entries();
     }
   }
 
   /**
    * Returns an iterator across all key-value map entries, used by {@code entries().iterator()} and
    * {@code values().iterator()}. The default behavior, which traverses the values for one key, the
    * values for a second key, and so on, suffices for most {@code AbstractMapBasedMultimap}
    * implementations.
    *
    * @return an iterator across map entries
    */
   @Override
   Iterator<Entry<K, V>> entryIterator() {
     return new Itr<Entry<K, V>>() {
       @Override
       Entry<K, V> output(K key, V value) {
         return Maps.immutableEntry(key, value);
       }
     };
   }
 
   @Override
   Map<K, Collection<V>> createAsMap() {
+    return new AsMap(map);
+  }
+  
+  final Map<K, Collection<V>> createMaybeNavigableAsMap() {
     if (map instanceof NavigableMap) {
       return new NavigableAsMap((NavigableMap<K, Collection<V>>) map);
     } else if (map instanceof SortedMap) {
       return new SortedAsMap((SortedMap<K, Collection<V>>) map);
     } else {
       return new AsMap(map);
     }
   }
 
   @WeakOuter
   private class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     /**
      * Usually the same as map, but smaller for the headMap(), tailMap(), or subMap() of a
      * SortedAsMap.
      */
     final transient Map<K, Collection<V>> submap;
 
     AsMap(Map<K, Collection<V>> submap) {
       this.submap = submap;
     }
 
     @Override
     protected Set<Entry<K, Collection<V>>> createEntrySet() {
       return new AsMapEntries();
     }
 
     // The following methods are included for performance.
 
     @Override
     public boolean containsKey(Object key) {
       return Maps.safeContainsKey(submap, key);
     }
 
     @Override
     public Collection<V> get(Object key) {
       Collection<V> collection = Maps.safeGet(submap, key);
       if (collection == null) {
         return null;
       }
       @SuppressWarnings("unchecked")
       K k = (K) key;
       return wrapCollection(k, collection);
     }
 
     @Override
     public Set<K> keySet() {
       return AbstractMapBasedMultimap.this.keySet();
     }
 
     @Override
