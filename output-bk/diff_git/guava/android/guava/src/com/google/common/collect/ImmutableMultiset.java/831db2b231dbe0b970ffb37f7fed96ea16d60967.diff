diff --git a/android/guava/src/com/google/common/collect/ImmutableMultiset.java b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
index 09b042ecc..2a4e9065f 100644
--- a/android/guava/src/com/google/common/collect/ImmutableMultiset.java
+++ b/android/guava/src/com/google/common/collect/ImmutableMultiset.java
@@ -1,80 +1,80 @@
 /*
  * Copyright (C) 2008 The Guava Authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.collect.Multiset.Entry;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * A {@link Multiset} whose contents will never change, with many other important properties
  * detailed at {@link ImmutableCollection}.
  *
  * <p><b>Grouped iteration.</b> In all current implementations, duplicate elements always appear
  * consecutively when iterating. Elements iterate in order by the <i>first</i> appearance of that
  * element when the multiset was created.
  *
  * <p>See the Guava User Guide article on <a href=
  * "https://github.com/google/guava/wiki/ImmutableCollectionsExplained"> immutable collections</a>.
  *
  * @author Jared Levy
  * @author Louis Wasserman
  * @since 2.0
  */
 @GwtCompatible(serializable = true, emulated = true)
 @SuppressWarnings("serial") // we're overriding default serialization
 public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializationDependencies<E>
     implements Multiset<E> {
   /** Returns the empty immutable multiset. */
   @SuppressWarnings("unchecked") // all supported methods are covariant
   public static <E> ImmutableMultiset<E> of() {
     return (ImmutableMultiset<E>) RegularImmutableMultiset.EMPTY;
   }
 
   /**
    * Returns an immutable multiset containing a single element.
    *
    * @throws NullPointerException if {@code element} is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") // generic array created but never written
   public static <E> ImmutableMultiset<E> of(E element) {
     return copyFromElements(element);
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in order.
    *
    * @throws NullPointerException if any element is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") //
   public static <E> ImmutableMultiset<E> of(E e1, E e2) {
     return copyFromElements(e1, e2);
   }
 
@@ -104,101 +104,100 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any element is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") //
   public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5) {
     return copyFromElements(e1, e2, e3, e4, e5);
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any element is null
    * @since 6.0 (source-compatible since 2.0)
    */
   @SuppressWarnings("unchecked") //
   public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others) {
     return new Builder<E>().add(e1).add(e2).add(e3).add(e4).add(e5).add(e6).add(others).build();
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any of {@code elements} is null
    * @since 6.0
    */
   public static <E> ImmutableMultiset<E> copyOf(E[] elements) {
     return copyFromElements(elements);
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any of {@code elements} is null
    */
   public static <E> ImmutableMultiset<E> copyOf(Iterable<? extends E> elements) {
     if (elements instanceof ImmutableMultiset) {
       @SuppressWarnings("unchecked") // all supported methods are covariant
       ImmutableMultiset<E> result = (ImmutableMultiset<E>) elements;
       if (!result.isPartialView()) {
         return result;
       }
     }
-
     ImmutableMultiset.Builder<E> builder =
         new ImmutableMultiset.Builder<E>(Multisets.inferDistinctElements(elements));
     builder.addAll(elements);
     return builder.build();
   }
 
   private static <E> ImmutableMultiset<E> copyFromElements(E... elements) {
     return new ImmutableMultiset.Builder<E>().add(elements).build();
   }
 
   static <E> ImmutableMultiset<E> copyFromEntries(
       Collection<? extends Entry<? extends E>> entries) {
     ImmutableMultiset.Builder<E> builder = new ImmutableMultiset.Builder<E>(entries.size());
     for (Entry<? extends E> entry : entries) {
       builder.addCopies(entry.getElement(), entry.getCount());
     }
     return builder.build();
   }
 
   /**
    * Returns an immutable multiset containing the given elements, in the "grouped iteration order"
    * described in the class documentation.
    *
    * @throws NullPointerException if any of {@code elements} is null
    */
   public static <E> ImmutableMultiset<E> copyOf(Iterator<? extends E> elements) {
     return new ImmutableMultiset.Builder<E>().addAll(elements).build();
   }
 
   ImmutableMultiset() {}
 
   @Override
   public UnmodifiableIterator<E> iterator() {
     final Iterator<Entry<E>> entryIterator = entrySet().iterator();
     return new UnmodifiableIterator<E>() {
       int remaining;
       @MonotonicNonNullDecl E element;
 
       @Override
       public boolean hasNext() {
         return (remaining > 0) || entryIterator.hasNext();
       }
 
       @Override
       public E next() {
         if (remaining <= 0) {
           Entry<E> entry = entryIterator.next();
           element = entry.getElement();
           remaining = entry.getCount();
         }
@@ -485,94 +484,120 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      * @throws NullPointerException if {@code element} is null
      * @throws IllegalArgumentException if {@code count} is negative
      */
     @CanIgnoreReturnValue
     public Builder<E> setCount(E element, int count) {
       if (count == 0 && !isLinkedHash) {
         contents = new ObjectCountLinkedHashMap<E>(contents);
         isLinkedHash = true;
         // to preserve insertion order through deletions, we have to switch to an actual linked
         // implementation at least for now, but this should be a super rare case
       } else if (buildInvoked) {
         contents = new ObjectCountHashMap<E>(contents);
         isLinkedHash = false;
       }
       buildInvoked = false;
       checkNotNull(element);
       if (count == 0) {
         contents.remove(element);
       } else {
         contents.put(checkNotNull(element), count);
       }
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableMultiset}.
      *
      * @param elements the elements to add
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
       return this;
     }
 
     /**
      * Adds each element of {@code elements} to the {@code ImmutableMultiset}.
      *
      * @param elements the {@code Iterable} to add to the {@code ImmutableMultiset}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       if (elements instanceof Multiset) {
         Multiset<? extends E> multiset = Multisets.cast(elements);
-        for (Entry<? extends E> entry : multiset.entrySet()) {
-          addCopies(entry.getElement(), entry.getCount());
+        ObjectCountHashMap<? extends E> backingMap = tryGetMap(multiset);
+        if (backingMap != null) {
+          contents.ensureCapacity(Math.max(contents.size(), backingMap.size()));
+          for (int i = backingMap.firstIndex(); i >= 0; i = backingMap.nextIndex(i)) {
+            addCopies(backingMap.getKey(i), backingMap.getValue(i));
+          }
+        } else {
+          Set<? extends Entry<? extends E>> entries = multiset.entrySet();
+          contents.ensureCapacity(Math.max(contents.size(), entries.size())); // might overlap
+          for (Entry<? extends E> entry : multiset.entrySet()) {
+            addCopies(entry.getElement(), entry.getCount());
+          }
         }
       } else {
         super.addAll(elements);
       }
       return this;
     }
 
+    /**
+     * If the specified collection is backed by an ObjectCountHashMap, it will be much more
+     * efficient to iterate over it by index rather than an entry iterator, which will need to
+     * allocate an object for each entry, so we check for that.
+     */
+    @NullableDecl
+    static <T> ObjectCountHashMap<T> tryGetMap(Iterable<T> multiset) {
+      if (multiset instanceof RegularImmutableMultiset) {
+        return ((RegularImmutableMultiset<T>) multiset).contents;
+      } else if (multiset instanceof AbstractMapBasedMultiset) {
+        return ((AbstractMapBasedMultiset<T>) multiset).backingMap;
+      } else {
+        return null;
+      }
+    }
+
     /**
      * Adds each element of {@code elements} to the {@code ImmutableMultiset}.
      *
      * @param elements the elements to add to the {@code ImmutableMultiset}
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
     /**
      * Returns a newly-created {@code ImmutableMultiset} based on the contents of the {@code
      * Builder}.
      */
     @Override
     public ImmutableMultiset<E> build() {
       if (contents.size() == 0) {
         return of();
       }
       if (isLinkedHash) {
         // we need ObjectCountHashMap-backed contents, with its keys and values array in direct
         // insertion order
         contents = new ObjectCountHashMap<E>(contents);
         isLinkedHash = false;
       }
       buildInvoked = true;
       // contents is now ObjectCountHashMap, but still guaranteed to be in insertion order!
       return new RegularImmutableMultiset<E>(contents);
     }
   }
 }
