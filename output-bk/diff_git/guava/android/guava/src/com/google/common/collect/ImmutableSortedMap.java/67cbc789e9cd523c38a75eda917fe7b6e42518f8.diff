diff --git a/android/guava/src/com/google/common/collect/ImmutableSortedMap.java b/android/guava/src/com/google/common/collect/ImmutableSortedMap.java
index 49762b8f5..742c01598 100644
--- a/android/guava/src/com/google/common/collect/ImmutableSortedMap.java
+++ b/android/guava/src/com/google/common/collect/ImmutableSortedMap.java
@@ -506,102 +506,102 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
 
     /**
      * Throws an {@code UnsupportedOperationException}.
      *
      * @since 19.0
      * @deprecated Unsupported by ImmutableSortedMap.Builder.
      */
     @CanIgnoreReturnValue
     @Beta
     @Override
     @Deprecated
     public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       throw new UnsupportedOperationException("Not available on ImmutableSortedMap.Builder");
     }
 
     /**
      * Returns a newly-created immutable sorted map.
      *
      * @throws IllegalArgumentException if any two keys are equal according to
      *     the comparator (which might be the keys' natural order)
      */
     @Override
     public ImmutableSortedMap<K, V> build() {
       switch (size) {
         case 0:
           return emptyMap(comparator);
         case 1:
           return of(comparator, (K) keys[0], (V) values[0]);
         default:
           Object[] sortedKeys = Arrays.copyOf(keys, size);
           Arrays.sort((K[]) sortedKeys, comparator);
           Object[] sortedValues = new Object[size];
 
           // We might, somehow, be able to reorder values in-place.  But it doesn't seem like
           // there's a way around creating the separate sortedKeys array, and if we're allocating
           // one array of size n, we might as well allocate two -- to say nothing of the allocation
           // done in Arrays.sort.
           for (int i = 0; i < size; i++) {
             if (i > 0 && comparator.compare((K) sortedKeys[i - 1], (K) sortedKeys[i]) == 0) {
               throw new IllegalArgumentException(
                   "keys required to be distinct but compared as equal: "
                       + sortedKeys[i - 1]
                       + " and "
                       + sortedKeys[i]);
             }
             int index = Arrays.binarySearch((K[]) sortedKeys, (K) keys[i], comparator);
             sortedValues[index] = values[i];
           }
           return new ImmutableSortedMap<K, V>(
               new RegularImmutableSortedSet<K>(
-                  ImmutableList.asImmutableList(sortedKeys), comparator),
-              ImmutableList.asImmutableList(sortedValues));
+                  ImmutableList.<K>asImmutableList(sortedKeys), comparator),
+              ImmutableList.<V>asImmutableList(sortedValues));
       }
     }
   }
 
   private final transient RegularImmutableSortedSet<K> keySet;
   private final transient ImmutableList<V> valueList;
   private transient ImmutableSortedMap<K, V> descendingMap;
 
   ImmutableSortedMap(RegularImmutableSortedSet<K> keySet, ImmutableList<V> valueList) {
     this(keySet, valueList, null);
   }
 
   ImmutableSortedMap(
       RegularImmutableSortedSet<K> keySet,
       ImmutableList<V> valueList,
       ImmutableSortedMap<K, V> descendingMap) {
     this.keySet = keySet;
     this.valueList = valueList;
     this.descendingMap = descendingMap;
   }
 
   @Override
   public int size() {
     return valueList.size();
   }
 
   @Override
   public V get(@Nullable Object key) {
     int index = keySet.indexOf(key);
     return (index == -1) ? null : valueList.get(index);
   }
 
   @Override
   boolean isPartialView() {
     return keySet.isPartialView() || valueList.isPartialView();
   }
 
   /**
    * Returns an immutable set of the mappings in this map, sorted by the key
    * ordering.
    */
   @Override
   public ImmutableSet<Entry<K, V>> entrySet() {
     return super.entrySet();
   }
 
   @Override
   ImmutableSet<Entry<K, V>> createEntrySet() {
     @WeakOuter
     class EntrySet extends ImmutableMapEntrySet<K, V> {
