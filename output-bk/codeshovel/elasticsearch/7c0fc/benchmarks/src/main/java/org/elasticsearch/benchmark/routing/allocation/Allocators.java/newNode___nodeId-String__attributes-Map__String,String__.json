{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/elasticsearch/.git",
  "startCommitName": "7c0fc209bf78e4824ca1f232b84a1dab22bc2dfa",
  "sourceFileName": "Allocators.java",
  "functionName": "newNode",
  "functionId": "newNode___nodeId-String__attributes-Map__String,String__",
  "sourceFilePath": "benchmarks/src/main/java/org/elasticsearch/benchmark/routing/allocation/Allocators.java",
  "functionStartLine": 97,
  "functionEndLine": 101,
  "changeHistory": [
    "194a6b1df031a95977b6ca395a74a8b74d9af31d",
    "6861d3571e6ded1b9718aea55d20072bcbf632d2",
    "2c467fd9c21cc2f79a58b6c1d412a87b83be94f3"
  ],
  "changeHistoryShort": {
    "194a6b1df031a95977b6ca395a74a8b74d9af31d": "Ybodychange",
    "6861d3571e6ded1b9718aea55d20072bcbf632d2": "Ybodychange",
    "2c467fd9c21cc2f79a58b6c1d412a87b83be94f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "194a6b1df031a95977b6ca395a74a8b74d9af31d": {
      "type": "Ybodychange",
      "commitMessage": "Remove LocalTransport in favor of MockTcpTransport (#20695)\n\nThis change proposes the removal of all non-tcp transport implementations. The\r\nmock transport can be used by default to run tests instead of local transport that has\r\nroughly the same performance compared to TCP or at least not noticeably slower.\r\n\r\nThis is a master only change, deprecation notice in 5.x will be committed as a\r\nseparate change.",
      "commitDate": 1475832467000,
      "commitName": "194a6b1df031a95977b6ca395a74a8b74d9af31d",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1474637506000,
      "commitNameOld": "ac1b13dde7e158d85ce6d7f314f3e823e012bec9",
      "commitAuthorOld": "Ali Beyad",
      "daysBetweenCommits": 13.83,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,5 @@\n     public static DiscoveryNode newNode(String nodeId, Map\u003cString, String\u003e attributes) {\n-        return new DiscoveryNode(\"\", nodeId, LocalTransportAddress.buildUnique(), attributes, Sets.newHashSet(DiscoveryNode.Role.MASTER,\n+        return new DiscoveryNode(\"\", nodeId, new TransportAddress(TransportAddress.META_ADDRESS,\n+            portGenerator.incrementAndGet()), attributes, Sets.newHashSet(DiscoveryNode.Role.MASTER,\n             DiscoveryNode.Role.DATA), Version.CURRENT);\n     }\n\\ No newline at end of file\n"
    },
    "6861d3571e6ded1b9718aea55d20072bcbf632d2": {
      "type": "Ybodychange",
      "commitMessage": "Persistent Node Ids (#19140)\n\nNode IDs are currently randomly generated during node startup. That means they change every time the node is restarted. While this doesn\u0027t matter for ES proper, it makes it hard for external services to track nodes. Another, more minor, side effect is that indexing the output of, say, the node stats API results in creating new fields due to node ID being used as keys.\r\n\r\nThe first approach I considered was to use the node\u0027s published address as the base for the id. We already [treat nodes with the same address as the same](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/discovery/zen/NodeJoinController.java#L387) so this is a simple change (see [here](https://github.com/elastic/elasticsearch/compare/master...bleskes:node_persistent_id_based_on_address)). While this is simple and it works for probably most cases, it is not perfect. For example, if after a node restart, the node is not able to bind to the same port (because it\u0027s not yet freed by the OS), it will cause the node to still change identity. Also in environments where the host IP can change due to a host restart, identity will not be the same. \r\n\r\nDue to those limitation, I opted to go with a different approach where the node id will be persisted in the node\u0027s data folder. This has the upside of connecting the id to the nodes data. It also means that the host can be adapted in any way (replace network cards, attach storage to a new VM). I\r\n\r\nIt does however also have downsides - we now run the risk of two nodes having the same id, if someone copies clones a data folder from one node to another. To mitigate this I changed the semantics of the protection against multiple nodes with the same address to be stricter - it will now reject the incoming join if a node exists with the same id but a different address. Note that if the existing node doesn\u0027t respond to pings (i.e., it\u0027s not alive) it will be removed and the new node will be accepted when it tries another join.\r\n\r\nLast, and most importantly, this change requires that *all* nodes persist data to disk. This is a change from current behavior where only data \u0026 master nodes store local files. This is the main reason for marking this PR as breaking.\r\n\r\nOther less important notes:\r\n- DummyTransportAddress is removed as we need a unique network address per node. Use `LocalTransportAddress.buildUnique()` instead.\r\n- I renamed `node.add_lid_to_custom_path` to `node.add_lock_id_to_custom_path` to avoid confusion with the node ID which is now part of the `NodeEnvironment` logic.\r\n- I removed the `version` paramater from `MetaDataStateFormat#write` , it wasn\u0027t really used and was just in the way :)\r\n- TribeNodes are special in the sense that they do start multiple sub-nodes (previously known as client nodes). Those sub-nodes do not store local files but derive their ID from the parent node id, so they are generated consistently.\r\n\r\n",
      "commitDate": 1467659365000,
      "commitName": "6861d3571e6ded1b9718aea55d20072bcbf632d2",
      "commitAuthor": "Boaz Leskes",
      "commitDateOld": 1466002082000,
      "commitNameOld": "2c467fd9c21cc2f79a58b6c1d412a87b83be94f3",
      "commitAuthorOld": "Daniel Mitterdorfer",
      "daysBetweenCommits": 19.18,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,4 @@\n     public static DiscoveryNode newNode(String nodeId, Map\u003cString, String\u003e attributes) {\n-        return new DiscoveryNode(\"\", nodeId, DummyTransportAddress.INSTANCE, attributes, Sets.newHashSet(DiscoveryNode.Role.MASTER,\n+        return new DiscoveryNode(\"\", nodeId, LocalTransportAddress.buildUnique(), attributes, Sets.newHashSet(DiscoveryNode.Role.MASTER,\n             DiscoveryNode.Role.DATA), Version.CURRENT);\n     }\n\\ No newline at end of file\n"
    },
    "2c467fd9c21cc2f79a58b6c1d412a87b83be94f3": {
      "type": "Yintroduced",
      "commitMessage": "Add microbenchmarking infrastructure (#18891)\n\nWith this commit we add a benchmarks project that contains the necessary build\r\ninfrastructure and an example benchmark. It is added as a separate project to avoid\r\ninterfering with the regular build too much (especially sanity checks) and to keep\r\nthe microbenchmarks isolated.\r\n\r\nMicrobenchmarks are generated with `gradle :benchmarks:jmhJar` and can be run with\r\n` gradle :benchmarks:jmh`.\r\n\r\nWe intentionally do not use the\r\n[jmh-gradle-plugin](https://github.com/melix/jmh-gradle-plugin) as it causes all\r\nsorts of problems (dependencies are not properly excluded, not all JMH parameters\r\ncan be set) and it adds another abstraction layer that is not needed.\r\n\r\nCloses #18242",
      "commitDate": 1466002082000,
      "commitName": "2c467fd9c21cc2f79a58b6c1d412a87b83be94f3",
      "commitAuthor": "Daniel Mitterdorfer"
    }
  }
}