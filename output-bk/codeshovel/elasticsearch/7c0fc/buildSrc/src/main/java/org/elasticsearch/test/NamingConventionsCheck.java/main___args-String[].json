{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/elasticsearch/.git",
  "startCommitName": "7c0fc209bf78e4824ca1f232b84a1dab22bc2dfa",
  "sourceFileName": "NamingConventionsCheck.java",
  "functionName": "main",
  "functionId": "main___args-String[]",
  "sourceFilePath": "buildSrc/src/main/java/org/elasticsearch/test/NamingConventionsCheck.java",
  "functionStartLine": 44,
  "functionEndLine": 121,
  "changeHistory": [
    "23198ea5512891c86e422c69e45970e357c9fade",
    "0afec8f31c14ba1a6dfdd6fbeef118fa174721fa",
    "fc97e25b564011bdb1d272a15e5b6b1f22c0c633",
    "8c6037428490f266b3a73133e37acd44949c192a",
    "d0e4485d421360ff3967bc5fe20ca08086b742c8",
    "95cc3e38fc3c4e7a415473140497fed40394dccc"
  ],
  "changeHistoryShort": {
    "23198ea5512891c86e422c69e45970e357c9fade": "Ybodychange",
    "0afec8f31c14ba1a6dfdd6fbeef118fa174721fa": "Ybodychange",
    "fc97e25b564011bdb1d272a15e5b6b1f22c0c633": "Ybodychange",
    "8c6037428490f266b3a73133e37acd44949c192a": "Ybodychange",
    "d0e4485d421360ff3967bc5fe20ca08086b742c8": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange)",
    "95cc3e38fc3c4e7a415473140497fed40394dccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "23198ea5512891c86e422c69e45970e357c9fade": {
      "type": "Ybodychange",
      "commitMessage": "Convert Version to Java - clusterformation part1 (#32009)\n\nImplement buildSrc Version in java\r\n\r\n- This allows to move all  all .java files from .groovy.\r\n- Will prevent eclipse from tangling up in this setup\r\n- make it possible to use Version from Java\r\n\r\n",
      "commitDate": 1531470912000,
      "commitName": "23198ea5512891c86e422c69e45970e357c9fade",
      "commitAuthor": "Alpar Torok",
      "commitDateOld": 1530188074000,
      "commitNameOld": "0afec8f31c14ba1a6dfdd6fbeef118fa174721fa",
      "commitAuthorOld": "Alpar Torok",
      "daysBetweenCommits": 14.85,
      "commitsBetweenForRepo": 181,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,78 @@\n     public static void main(String[] args) throws IOException {\n         Class\u003c?\u003e testClass \u003d null;\n         Class\u003c?\u003e integTestClass \u003d null;\n         String rootPathList \u003d null;\n         boolean skipIntegTestsInDisguise \u003d false;\n         boolean checkMainClasses \u003d false;\n         for (int i \u003d 0; i \u003c args.length; i++) {\n             String arg \u003d args[i];\n             switch (arg) {\n                 case \"--test-class\":\n                     testClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--integ-test-class\":\n                     integTestClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--skip-integ-tests-in-disguise\":\n                     skipIntegTestsInDisguise \u003d true;\n                     break;\n                 case \"--main\":\n                     checkMainClasses \u003d true;\n                     break;\n                 case \"--\":\n                     rootPathList \u003d args[++i];\n                     break;\n                 default:\n                     fail(\"unsupported argument \u0027\" + arg + \"\u0027\");\n             }\n         }\n+        if (rootPathList \u003d\u003d null) {\n+            fail(\"No paths provided\");\n+            return;\n+        }\n \n         NamingConventionsCheck check \u003d new NamingConventionsCheck(testClass, integTestClass);\n         for (String rootDir : rootPathList.split(Pattern.quote(File.pathSeparator))) {\n             Path rootPath \u003d Paths.get(rootDir);\n             if (checkMainClasses) {\n                 check.checkMain(rootPath);\n             } else {\n                 check.checkTests(rootPath, skipIntegTestsInDisguise);\n             }\n         }\n \n         // Now we should have no violations\n         int exitCode  \u003d 0 ;\n         exitCode +\u003d countAndPrintViolations(\n                 \"Not all subclasses of \" + check.testClass.getSimpleName()\n                     + \" match the naming convention. Concrete classes must end with [Tests]\",\n                 check.missingSuffix) ;\n         exitCode +\u003d countAndPrintViolations(\n             \"Classes ending with [Tests] are abstract or interfaces\",\n             check.notRunnable\n         );\n         exitCode +\u003d countAndPrintViolations(\n             \"Found inner classes that are tests, which are excluded from the test runner\",\n             check.innerClasses\n         );\n         exitCode +\u003d countAndPrintViolations(\n             \"Pure Unit-Test found must subclass [\" + check.testClass.getSimpleName() + \"]\",\n             check.pureUnitTest\n         );\n         exitCode +\u003d countAndPrintViolations(\n             \"Classes ending with [Tests] must subclass [\" + check.testClass.getSimpleName() + \"]\",\n             check.notImplementing\n         );\n         exitCode +\u003d countAndPrintViolations(\n                 \"Classes ending with [Tests] or [IT] or extending [\" +\n                     check.testClass.getSimpleName() + \"] must be in src/test/java\",\n                 check.testsInMain\n         );\n         if (skipIntegTestsInDisguise \u003d\u003d false) {\n             exitCode +\u003d countAndPrintViolations(\"Subclasses of \" + check.integTestClass.getSimpleName() +\n                         \" should end with IT as they are integration tests\",\n                     check.integTestsInDisguise\n                 );\n         }\n         System.exit(exitCode);\n     }\n\\ No newline at end of file\n"
    },
    "0afec8f31c14ba1a6dfdd6fbeef118fa174721fa": {
      "type": "Ybodychange",
      "commitMessage": "Remove deprecation warnings to prepare for Gradle 5 (sourceSets.main.output.classesDirs) (#30389)\n\n* Remove deprecation warnings to prepare for Gradle 5\r\n\r\nGradle replaced `project.sourceSets.main.output.classesDir` of type\r\n`File` with `project.sourceSets.main.output.classesDirs` of type\r\n`FileCollection`\r\n(see [SourceSetOutput](https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/java/org/gradle/api/tasks/SourceSetOutput.java))\r\nBuild output is now stored on a per language folder.\r\n\r\nThere are a few places where we use that, here\u0027s these and how it\u0027s\r\nfixed:\r\n\r\n- Randomized Test execution\r\n    - look in all test folders ( pass the multi dir configuration to the\r\n    ant runner )\r\n    - DRY the task configuration by introducing `basedOn` for\r\n      `RandomizedTestingTask` DSL\r\n- Extend the naming convention test to support passing in multiple\r\n  directories\r\n- Fix the standalon test plugin, the dires were not passed trough,\r\n  checked with a debuger and the statement had no affect due to a\r\n  missing `\u003d`.\r\n\r\nCloses #30354\r\n\r\n* Only check Java tests, PR feedback\r\n\r\n- Name checker was ran for Groovy tests that don\u0027t adhere to the same\r\n  convections causing the check to fail\r\n- implement PR feedback\r\n\r\n* Replace `add` with `addAll`\r\n\r\nThis worked because the list is passed to `project.files` that does the\r\nright thing.\r\n\r\n* Revert \"Only check Java tests, PR feedback\"\r\n\r\nThis reverts commit 9bd9389875d8b88aadb50df57a45cd0d2b073241.\r\n\r\n* Remove `basedOn` helper\r\n\r\n* Bring some changes back\r\n\r\nPrevius revert accidentally reverted too much\r\n\r\n* Fix negation\r\n\r\n* add back public\r\n\r\n* revert name check changes\r\n\r\n* Revert \"revert name check changes\"\r\n\r\nThis reverts commit a2800c0b363168339ea65e2a79ec8256e5883e6d.\r\n\r\n* Pass all dirs to name check\r\n\r\nOnly run on Java for build-tools, this is safe because it\u0027s a self test.\r\nIt needs more work before we could pass in the Groovy classes as well as\r\nthese inherit from `GroovyTestCase`\r\n\r\n* remove self tests from name check\r\n\r\nThe self complicates the task setup and disable real checks on\r\nbuild-tools.\r\nWith this change there are no more self tests, and the build-tools tests\r\nadhere to the conventions.\r\nThe self test will be replaced by gradle test kit, thus the addition of\r\nthe Gradle plugin builder plugin.\r\n\r\n* First test to run a Gradle build\r\n\r\n* Add tests that replace the name check self test\r\n\r\n* Clean up integ test base class\r\n\r\n* Always run tests\r\n\r\n* Align with test naming conventions\r\n\r\n* Make integ. test case inherit from unit test case\r\n\r\nThe check requires this\r\n\r\n* Remove `import static org.junit.Assert.*`\r\n",
      "commitDate": 1530188074000,
      "commitName": "0afec8f31c14ba1a6dfdd6fbeef118fa174721fa",
      "commitAuthor": "Alpar Torok",
      "commitDateOld": 1493169107000,
      "commitNameOld": "fc97e25b564011bdb1d272a15e5b6b1f22c0c633",
      "commitAuthorOld": "Nik Everett",
      "daysBetweenCommits": 428.46,
      "commitsBetweenForRepo": 6655,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n     public static void main(String[] args) throws IOException {\n         Class\u003c?\u003e testClass \u003d null;\n         Class\u003c?\u003e integTestClass \u003d null;\n-        Path rootPath \u003d null;\n+        String rootPathList \u003d null;\n         boolean skipIntegTestsInDisguise \u003d false;\n-        boolean selfTest \u003d false;\n         boolean checkMainClasses \u003d false;\n         for (int i \u003d 0; i \u003c args.length; i++) {\n             String arg \u003d args[i];\n             switch (arg) {\n                 case \"--test-class\":\n                     testClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--integ-test-class\":\n                     integTestClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--skip-integ-tests-in-disguise\":\n                     skipIntegTestsInDisguise \u003d true;\n                     break;\n-                case \"--self-test\":\n-                    selfTest \u003d true;\n-                    break;\n                 case \"--main\":\n                     checkMainClasses \u003d true;\n                     break;\n                 case \"--\":\n-                    rootPath \u003d Paths.get(args[++i]);\n+                    rootPathList \u003d args[++i];\n                     break;\n                 default:\n                     fail(\"unsupported argument \u0027\" + arg + \"\u0027\");\n             }\n         }\n \n         NamingConventionsCheck check \u003d new NamingConventionsCheck(testClass, integTestClass);\n-        if (checkMainClasses) {\n-            check.checkMain(rootPath);\n-        } else {\n-            check.checkTests(rootPath, skipIntegTestsInDisguise);\n-        }\n-\n-        if (selfTest) {\n+        for (String rootDir : rootPathList.split(Pattern.quote(File.pathSeparator))) {\n+            Path rootPath \u003d Paths.get(rootDir);\n             if (checkMainClasses) {\n-                assertViolation(NamingConventionsCheckInMainTests.class.getName(), check.testsInMain);\n-                assertViolation(NamingConventionsCheckInMainIT.class.getName(), check.testsInMain);\n+                check.checkMain(rootPath);\n             } else {\n-                assertViolation(\"WrongName\", check.missingSuffix);\n-                assertViolation(\"WrongNameTheSecond\", check.missingSuffix);\n-                assertViolation(\"DummyAbstractTests\", check.notRunnable);\n-                assertViolation(\"DummyInterfaceTests\", check.notRunnable);\n-                assertViolation(\"InnerTests\", check.innerClasses);\n-                assertViolation(\"NotImplementingTests\", check.notImplementing);\n-                assertViolation(\"PlainUnit\", check.pureUnitTest);\n+                check.checkTests(rootPath, skipIntegTestsInDisguise);\n             }\n         }\n \n         // Now we should have no violations\n-        assertNoViolations(\n+        int exitCode  \u003d 0 ;\n+        exitCode +\u003d countAndPrintViolations(\n                 \"Not all subclasses of \" + check.testClass.getSimpleName()\n                     + \" match the naming convention. Concrete classes must end with [Tests]\",\n-                check.missingSuffix);\n-        assertNoViolations(\"Classes ending with [Tests] are abstract or interfaces\", check.notRunnable);\n-        assertNoViolations(\"Found inner classes that are tests, which are excluded from the test runner\", check.innerClasses);\n-        assertNoViolations(\"Pure Unit-Test found must subclass [\" + check.testClass.getSimpleName() + \"]\", check.pureUnitTest);\n-        assertNoViolations(\"Classes ending with [Tests] must subclass [\" + check.testClass.getSimpleName() + \"]\", check.notImplementing);\n-        assertNoViolations(\n-                \"Classes ending with [Tests] or [IT] or extending [\" + check.testClass.getSimpleName() + \"] must be in src/test/java\",\n-                check.testsInMain);\n+                check.missingSuffix) ;\n+        exitCode +\u003d countAndPrintViolations(\n+            \"Classes ending with [Tests] are abstract or interfaces\",\n+            check.notRunnable\n+        );\n+        exitCode +\u003d countAndPrintViolations(\n+            \"Found inner classes that are tests, which are excluded from the test runner\",\n+            check.innerClasses\n+        );\n+        exitCode +\u003d countAndPrintViolations(\n+            \"Pure Unit-Test found must subclass [\" + check.testClass.getSimpleName() + \"]\",\n+            check.pureUnitTest\n+        );\n+        exitCode +\u003d countAndPrintViolations(\n+            \"Classes ending with [Tests] must subclass [\" + check.testClass.getSimpleName() + \"]\",\n+            check.notImplementing\n+        );\n+        exitCode +\u003d countAndPrintViolations(\n+                \"Classes ending with [Tests] or [IT] or extending [\" +\n+                    check.testClass.getSimpleName() + \"] must be in src/test/java\",\n+                check.testsInMain\n+        );\n         if (skipIntegTestsInDisguise \u003d\u003d false) {\n-            assertNoViolations(\n-                    \"Subclasses of \" + check.integTestClass.getSimpleName() + \" should end with IT as they are integration tests\",\n-                    check.integTestsInDisguise);\n+            exitCode +\u003d countAndPrintViolations(\"Subclasses of \" + check.integTestClass.getSimpleName() +\n+                        \" should end with IT as they are integration tests\",\n+                    check.integTestsInDisguise\n+                );\n         }\n+        System.exit(exitCode);\n     }\n\\ No newline at end of file\n"
    },
    "fc97e25b564011bdb1d272a15e5b6b1f22c0c633": {
      "type": "Ybodychange",
      "commitMessage": "Add task to look for tests in src/main (#24298)\n\nCreates a new task `namingConventionsMain`, that runs on the\r\n`buildSrc` and `test:framework` projects and fails the build if\r\nany of the classes in the main artifacts are named like tests or\r\nare non-abstract subclasses of ESTestCase.\r\n\r\nIt also fixes the three tests that would cause it to fail.",
      "commitDate": 1493169107000,
      "commitName": "fc97e25b564011bdb1d272a15e5b6b1f22c0c633",
      "commitAuthor": "Nik Everett",
      "commitDateOld": 1466163987000,
      "commitNameOld": "8c6037428490f266b3a73133e37acd44949c192a",
      "commitAuthorOld": "javanna",
      "daysBetweenCommits": 312.56,
      "commitsBetweenForRepo": 3947,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,73 @@\n     public static void main(String[] args) throws IOException {\n         Class\u003c?\u003e testClass \u003d null;\n         Class\u003c?\u003e integTestClass \u003d null;\n         Path rootPath \u003d null;\n         boolean skipIntegTestsInDisguise \u003d false;\n         boolean selfTest \u003d false;\n+        boolean checkMainClasses \u003d false;\n         for (int i \u003d 0; i \u003c args.length; i++) {\n             String arg \u003d args[i];\n             switch (arg) {\n                 case \"--test-class\":\n                     testClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--integ-test-class\":\n                     integTestClass \u003d loadClassWithoutInitializing(args[++i]);\n                     break;\n                 case \"--skip-integ-tests-in-disguise\":\n                     skipIntegTestsInDisguise \u003d true;\n                     break;\n                 case \"--self-test\":\n                     selfTest \u003d true;\n                     break;\n+                case \"--main\":\n+                    checkMainClasses \u003d true;\n+                    break;\n                 case \"--\":\n                     rootPath \u003d Paths.get(args[++i]);\n                     break;\n                 default:\n                     fail(\"unsupported argument \u0027\" + arg + \"\u0027\");\n             }\n         }\n \n         NamingConventionsCheck check \u003d new NamingConventionsCheck(testClass, integTestClass);\n-        check.check(rootPath, skipIntegTestsInDisguise);\n+        if (checkMainClasses) {\n+            check.checkMain(rootPath);\n+        } else {\n+            check.checkTests(rootPath, skipIntegTestsInDisguise);\n+        }\n \n         if (selfTest) {\n-            assertViolation(\"WrongName\", check.missingSuffix);\n-            assertViolation(\"WrongNameTheSecond\", check.missingSuffix);\n-            assertViolation(\"DummyAbstractTests\", check.notRunnable);\n-            assertViolation(\"DummyInterfaceTests\", check.notRunnable);\n-            assertViolation(\"InnerTests\", check.innerClasses);\n-            assertViolation(\"NotImplementingTests\", check.notImplementing);\n-            assertViolation(\"PlainUnit\", check.pureUnitTest);\n+            if (checkMainClasses) {\n+                assertViolation(NamingConventionsCheckInMainTests.class.getName(), check.testsInMain);\n+                assertViolation(NamingConventionsCheckInMainIT.class.getName(), check.testsInMain);\n+            } else {\n+                assertViolation(\"WrongName\", check.missingSuffix);\n+                assertViolation(\"WrongNameTheSecond\", check.missingSuffix);\n+                assertViolation(\"DummyAbstractTests\", check.notRunnable);\n+                assertViolation(\"DummyInterfaceTests\", check.notRunnable);\n+                assertViolation(\"InnerTests\", check.innerClasses);\n+                assertViolation(\"NotImplementingTests\", check.notImplementing);\n+                assertViolation(\"PlainUnit\", check.pureUnitTest);\n+            }\n         }\n \n         // Now we should have no violations\n-        assertNoViolations(\"Not all subclasses of \" + check.testClass.getSimpleName()\n-                + \" match the naming convention. Concrete classes must end with [Tests]\", check.missingSuffix);\n+        assertNoViolations(\n+                \"Not all subclasses of \" + check.testClass.getSimpleName()\n+                    + \" match the naming convention. Concrete classes must end with [Tests]\",\n+                check.missingSuffix);\n         assertNoViolations(\"Classes ending with [Tests] are abstract or interfaces\", check.notRunnable);\n         assertNoViolations(\"Found inner classes that are tests, which are excluded from the test runner\", check.innerClasses);\n         assertNoViolations(\"Pure Unit-Test found must subclass [\" + check.testClass.getSimpleName() + \"]\", check.pureUnitTest);\n         assertNoViolations(\"Classes ending with [Tests] must subclass [\" + check.testClass.getSimpleName() + \"]\", check.notImplementing);\n+        assertNoViolations(\n+                \"Classes ending with [Tests] or [IT] or extending [\" + check.testClass.getSimpleName() + \"] must be in src/test/java\",\n+                check.testsInMain);\n         if (skipIntegTestsInDisguise \u003d\u003d false) {\n-            assertNoViolations(\"Subclasses of \" + check.integTestClass.getSimpleName() +\n-                    \" should end with IT as they are integration tests\", check.integTestsInDisguise);\n+            assertNoViolations(\n+                    \"Subclasses of \" + check.integTestClass.getSimpleName() + \" should end with IT as they are integration tests\",\n+                    check.integTestsInDisguise);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8c6037428490f266b3a73133e37acd44949c192a": {
      "type": "Ybodychange",
      "commitMessage": "Build: do not load integ test class if --skip-integ-tests-in-disguise is specified in NamingConventionsCheck\n\nProjects that don\u0027t depend on elasticsearch-test fail otherwise because org.elasticsearch.test.EsIntegTestCase (default integ test class) is not in the classpath. They should provide their onw integ test base class, but having integration tests should not be mandatory. One can simply set skipIntegTestsInDisguise to true to prevent loading of integ test class.\n",
      "commitDate": 1466163987000,
      "commitName": "8c6037428490f266b3a73133e37acd44949c192a",
      "commitAuthor": "javanna",
      "commitDateOld": 1465943434000,
      "commitNameOld": "d0e4485d421360ff3967bc5fe20ca08086b742c8",
      "commitAuthorOld": "Nik Everett",
      "daysBetweenCommits": 2.55,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,54 @@\n     public static void main(String[] args) throws IOException {\n-        int i \u003d 0;\n-        NamingConventionsCheck check \u003d new NamingConventionsCheck(\n-                loadClassWithoutInitializing(args[i++]),\n-                loadClassWithoutInitializing(args[i++]));\n+        Class\u003c?\u003e testClass \u003d null;\n+        Class\u003c?\u003e integTestClass \u003d null;\n+        Path rootPath \u003d null;\n         boolean skipIntegTestsInDisguise \u003d false;\n         boolean selfTest \u003d false;\n-        while (true) {\n-            switch (args[i]) {\n-            case \"--skip-integ-tests-in-disguise\":\n-                skipIntegTestsInDisguise \u003d true;\n-                i++;\n-                continue;\n-            case \"--self-test\":\n-                selfTest \u003d true;\n-                i++;\n-                continue;\n-            case \"--\":\n-                i++;\n-                break;\n-            default:\n-                fail(\"Expected -- before a path.\");\n+        for (int i \u003d 0; i \u003c args.length; i++) {\n+            String arg \u003d args[i];\n+            switch (arg) {\n+                case \"--test-class\":\n+                    testClass \u003d loadClassWithoutInitializing(args[++i]);\n+                    break;\n+                case \"--integ-test-class\":\n+                    integTestClass \u003d loadClassWithoutInitializing(args[++i]);\n+                    break;\n+                case \"--skip-integ-tests-in-disguise\":\n+                    skipIntegTestsInDisguise \u003d true;\n+                    break;\n+                case \"--self-test\":\n+                    selfTest \u003d true;\n+                    break;\n+                case \"--\":\n+                    rootPath \u003d Paths.get(args[++i]);\n+                    break;\n+                default:\n+                    fail(\"unsupported argument \u0027\" + arg + \"\u0027\");\n             }\n-            break;\n         }\n-        check.check(Paths.get(args[i]));\n+\n+        NamingConventionsCheck check \u003d new NamingConventionsCheck(testClass, integTestClass);\n+        check.check(rootPath, skipIntegTestsInDisguise);\n \n         if (selfTest) {\n             assertViolation(\"WrongName\", check.missingSuffix);\n             assertViolation(\"WrongNameTheSecond\", check.missingSuffix);\n             assertViolation(\"DummyAbstractTests\", check.notRunnable);\n             assertViolation(\"DummyInterfaceTests\", check.notRunnable);\n             assertViolation(\"InnerTests\", check.innerClasses);\n             assertViolation(\"NotImplementingTests\", check.notImplementing);\n             assertViolation(\"PlainUnit\", check.pureUnitTest);\n         }\n \n         // Now we should have no violations\n         assertNoViolations(\"Not all subclasses of \" + check.testClass.getSimpleName()\n                 + \" match the naming convention. Concrete classes must end with [Tests]\", check.missingSuffix);\n         assertNoViolations(\"Classes ending with [Tests] are abstract or interfaces\", check.notRunnable);\n         assertNoViolations(\"Found inner classes that are tests, which are excluded from the test runner\", check.innerClasses);\n         assertNoViolations(\"Pure Unit-Test found must subclass [\" + check.testClass.getSimpleName() + \"]\", check.pureUnitTest);\n         assertNoViolations(\"Classes ending with [Tests] must subclass [\" + check.testClass.getSimpleName() + \"]\", check.notImplementing);\n-        if (!skipIntegTestsInDisguise) {\n-            assertNoViolations(\"Subclasses of ESIntegTestCase should end with IT as they are integration tests\",\n-                    check.integTestsInDisguise);\n+        if (skipIntegTestsInDisguise \u003d\u003d false) {\n+            assertNoViolations(\"Subclasses of \" + check.integTestClass.getSimpleName() +\n+                    \" should end with IT as they are integration tests\", check.integTestsInDisguise);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d0e4485d421360ff3967bc5fe20ca08086b742c8": {
      "type": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange)",
      "commitMessage": "Move NamingConventionsCheck into buildSrc\n\nThis will let things that don\u0027t depend on :test:framework like the\nclient use it.\n\nAlso skip initializing the classes we check because we don\u0027t care\nabout their initialization behavior because we\u0027re not executing them.\nThis makes the naming conventions check pretty close to instant\nfrom a \"human eye\" perspective.\n",
      "commitDate": 1465943434000,
      "commitName": "d0e4485d421360ff3967bc5fe20ca08086b742c8",
      "commitAuthor": "Nik Everett",
      "subchanges": [
        "Yfilerename",
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "95cc3e38fc3c4e7a415473140497fed40394dccc": {
      "type": "Yintroduced",
      "commitMessage": "Check test naming conventions on all modules\n\nThe big win here is catching tests that are incorrectly named and will\nbe skipped by gradle, providing a false sense of security.\n\nThe whole thing takes about 10 seconds on my Macbook Air, not counting\ncompiling the test classes, which seems worth it. Because this runs as\na gradle task with propery UP-TO-DATE handling it can be skipped if the\ntests haven\u0027t been changed which should save some time.\n\nI chose to keep this in test:framework rather than a new subproject of\nbuildSrc because ESIntegTestCase and doesn\u0027t inroduce any additional\ndependencies.\n",
      "commitDate": 1456781509000,
      "commitName": "95cc3e38fc3c4e7a415473140497fed40394dccc",
      "commitAuthor": "Nik Everett"
    }
  }
}