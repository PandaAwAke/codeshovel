{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/elasticsearch/.git",
  "startCommitName": "7c0fc209bf78e4824ca1f232b84a1dab22bc2dfa",
  "sourceFileName": "BlendedTermQuery.java",
  "functionName": "commonTermsBlendedQuery",
  "functionId": "commonTermsBlendedQuery___terms-Term[]__boosts-float[]__maxTermFrequency-float",
  "sourceFilePath": "server/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java",
  "functionStartLine": 299,
  "functionEndLine": 336,
  "changeHistory": [
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "4632661bc71bb22fc577df476e70e9dfabaaae66",
    "5ded9ac9eb1360dda6ac75cff9ea268e75fff9b4",
    "10ddd691a36fa3a8199fac8da43da540af19a697",
    "4f5591be8d704868876856a53615ee71c588b07c",
    "8d5fff37ae87d58b849490843accfb2ae2425da0",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
    "0fa5b87fddc10ce487299c10fd3a833962058959",
    "162ca993762ffb5f720ae7f82adcc209d16a5bd2"
  ],
  "changeHistoryShort": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "4632661bc71bb22fc577df476e70e9dfabaaae66": "Ymultichange(Yparameterchange,Ybodychange)",
    "5ded9ac9eb1360dda6ac75cff9ea268e75fff9b4": "Ybodychange",
    "10ddd691a36fa3a8199fac8da43da540af19a697": "Ybodychange",
    "4f5591be8d704868876856a53615ee71c588b07c": "Ybodychange",
    "8d5fff37ae87d58b849490843accfb2ae2425da0": "Ybodychange",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": "Yfilerename",
    "0fa5b87fddc10ce487299c10fd3a833962058959": "Ybodychange",
    "162ca993762ffb5f720ae7f82adcc209d16a5bd2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": 1515695443000,
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": 1515688270000,
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "4632661bc71bb22fc577df476e70e9dfabaaae66": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Upgrade to a Lucene 7 snapshot (#24089)\n\nWe want to upgrade to Lucene 7 ahead of time in order to be able to check whether it causes any trouble to Elasticsearch before Lucene 7.0 gets released. From a user perspective, the main benefit of this upgrade is the enhanced support for sparse fields, whose resource consumption is now function of the number of docs that have a value rather than the total number of docs in the index.\r\n\r\nSome notes about the change:\r\n - it includes the deprecation of the `disable_coord` parameter of the `bool` and `common_terms` queries: Lucene has removed support for coord factors\r\n - it includes the deprecation of the `index.similarity.base` expert setting, since it was only useful to configure coords and query norms, which have both been removed\r\n - two tests have been marked with `@AwaitsFix` because of #23966, which we intend to address after the merge",
      "commitDate": 1492521441000,
      "commitName": "4632661bc71bb22fc577df476e70e9dfabaaae66",
      "commitAuthor": "Adrien Grand",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "5ded9ac9eb1360dda6ac75cff9ea268e75fff9b4": {
      "type": "Ybodychange",
      "commitMessage": "Stop using deprecated constructors for queries\n\nDisjunctionMaxQuery and BooleanQuery\n",
      "commitDate": 1452566176000,
      "commitName": "5ded9ac9eb1360dda6ac75cff9ea268e75fff9b4",
      "commitAuthor": "Nik Everett",
      "commitDateOld": 1450711373000,
      "commitNameOld": "81fd2169cf9f394c7be2a853caae5a54c0c75b18",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 21.47,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {\n         return new BlendedTermQuery(terms, boosts) {\n             @Override\n             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {\n                 BooleanQuery.Builder highBuilder \u003d new BooleanQuery.Builder();\n                 highBuilder.setDisableCoord(disableCoord);\n                 BooleanQuery.Builder lowBuilder \u003d new BooleanQuery.Builder();\n                 lowBuilder.setDisableCoord(disableCoord);\n                 for (int i \u003d 0; i \u003c terms.length; i++) {\n                     Query query \u003d new TermQuery(terms[i], ctx[i]);\n                     if (boosts !\u003d null \u0026\u0026 boosts[i] !\u003d 1f) {\n                         query \u003d new BoostQuery(query, boosts[i]);\n                     }\n                     if ((maxTermFrequency \u003e\u003d 1f \u0026\u0026 docFreqs[i] \u003e maxTermFrequency)\n                             || (docFreqs[i] \u003e (int) Math.ceil(maxTermFrequency\n-                            * (float) maxDoc))) {\n+                            * maxDoc))) {\n                         highBuilder.add(query, BooleanClause.Occur.SHOULD);\n                     } else {\n                         lowBuilder.add(query, BooleanClause.Occur.SHOULD);\n                     }\n                 }\n                 BooleanQuery high \u003d highBuilder.build();\n                 BooleanQuery low \u003d lowBuilder.build();\n                 if (low.clauses().isEmpty()) {\n                     BooleanQuery.Builder queryBuilder \u003d new BooleanQuery.Builder();\n                     queryBuilder.setDisableCoord(disableCoord);\n                     for (BooleanClause booleanClause : high) {\n                         queryBuilder.add(booleanClause.getQuery(), Occur.MUST);\n                     }\n                     return queryBuilder.build();\n                 } else if (high.clauses().isEmpty()) {\n                     return low;\n                 } else {\n                     return new BooleanQuery.Builder()\n                         .setDisableCoord(true)\n                         .add(high, BooleanClause.Occur.SHOULD)\n                         .add(low, BooleanClause.Occur.MUST)\n                         .build();\n                 }\n             }\n         };\n     }\n\\ No newline at end of file\n"
    },
    "10ddd691a36fa3a8199fac8da43da540af19a697": {
      "type": "Ybodychange",
      "commitMessage": "Internal: move to lucene BoostQuery\n\nLatest version of lucene deprecated Query#setBoost and Query#getBoost which made queries effectively immutable. Those methods need to be replaced with `BoostQuery` that wraps any query that needs boosting.\n\nThis commit replaces usages of setBoost with BoostQuery and adds it to forbidden-apis for prod code.\n\nUsages of `getBoost` are only partially removed, as some will have to stay for backwards compatibility.\n\nCloses #14264\n",
      "commitDate": 1447077695000,
      "commitName": "10ddd691a36fa3a8199fac8da43da540af19a697",
      "commitAuthor": "javanna",
      "commitDateOld": 1442321081000,
      "commitNameOld": "ff4a11aa32b43a1109a364b5d4fed4f8310d0f6c",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 55.05,
      "commitsBetweenForRepo": 929,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {\n         return new BlendedTermQuery(terms, boosts) {\n             @Override\n             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {\n                 BooleanQuery.Builder highBuilder \u003d new BooleanQuery.Builder();\n                 highBuilder.setDisableCoord(disableCoord);\n                 BooleanQuery.Builder lowBuilder \u003d new BooleanQuery.Builder();\n                 lowBuilder.setDisableCoord(disableCoord);\n                 for (int i \u003d 0; i \u003c terms.length; i++) {\n-                    TermQuery termQuery \u003d new TermQuery(terms[i], ctx[i]);\n-                    if (boosts !\u003d null) {\n-                        termQuery.setBoost(boosts[i]);\n+                    Query query \u003d new TermQuery(terms[i], ctx[i]);\n+                    if (boosts !\u003d null \u0026\u0026 boosts[i] !\u003d 1f) {\n+                        query \u003d new BoostQuery(query, boosts[i]);\n                     }\n                     if ((maxTermFrequency \u003e\u003d 1f \u0026\u0026 docFreqs[i] \u003e maxTermFrequency)\n                             || (docFreqs[i] \u003e (int) Math.ceil(maxTermFrequency\n                             * (float) maxDoc))) {\n-                        highBuilder.add(termQuery, BooleanClause.Occur.SHOULD);\n+                        highBuilder.add(query, BooleanClause.Occur.SHOULD);\n                     } else {\n-                        lowBuilder.add(termQuery, BooleanClause.Occur.SHOULD);\n+                        lowBuilder.add(query, BooleanClause.Occur.SHOULD);\n                     }\n                 }\n                 BooleanQuery high \u003d highBuilder.build();\n                 BooleanQuery low \u003d lowBuilder.build();\n                 if (low.clauses().isEmpty()) {\n                     BooleanQuery.Builder queryBuilder \u003d new BooleanQuery.Builder();\n                     queryBuilder.setDisableCoord(disableCoord);\n                     for (BooleanClause booleanClause : high) {\n                         queryBuilder.add(booleanClause.getQuery(), Occur.MUST);\n                     }\n                     return queryBuilder.build();\n                 } else if (high.clauses().isEmpty()) {\n                     return low;\n                 } else {\n                     return new BooleanQuery.Builder()\n                         .setDisableCoord(true)\n                         .add(high, BooleanClause.Occur.SHOULD)\n                         .add(low, BooleanClause.Occur.MUST)\n                         .build();\n                 }\n             }\n         };\n     }\n\\ No newline at end of file\n"
    },
    "4f5591be8d704868876856a53615ee71c588b07c": {
      "type": "Ybodychange",
      "commitMessage": "Fix deprecations introduced by the upgrade to Lucene 5.3\n\nThis changes construction of Phrase and Boolean queries to use the builder,\nand replaces BitDocIdSetFilter with BitSetProducer for nested and parent/child\nqueries. I had to remove the ParentIdsFilter for the case when there was a\nsingle parent as it was using the source of BitSets for parents as a regular\nFilter, which is not possible anymore now. I don\u0027t think this is an issue since\nthis case rarely occurs, and the alternative logic for when there are several\nmatching parent ids should not be much worse.\n",
      "commitDate": 1441354561000,
      "commitName": "4f5591be8d704868876856a53615ee71c588b07c",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": 1438880832000,
      "commitNameOld": "8d5fff37ae87d58b849490843accfb2ae2425da0",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 28.63,
      "commitsBetweenForRepo": 521,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,42 @@\n     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {\n         return new BlendedTermQuery(terms, boosts) {\n             @Override\n             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {\n-                BooleanQuery query \u003d new BooleanQuery(true);\n-                BooleanQuery high \u003d new BooleanQuery(disableCoord);\n-                BooleanQuery low \u003d new BooleanQuery(disableCoord);\n+                BooleanQuery.Builder highBuilder \u003d new BooleanQuery.Builder();\n+                highBuilder.setDisableCoord(disableCoord);\n+                BooleanQuery.Builder lowBuilder \u003d new BooleanQuery.Builder();\n+                lowBuilder.setDisableCoord(disableCoord);\n                 for (int i \u003d 0; i \u003c terms.length; i++) {\n                     TermQuery termQuery \u003d new TermQuery(terms[i], ctx[i]);\n                     if (boosts !\u003d null) {\n                         termQuery.setBoost(boosts[i]);\n                     }\n                     if ((maxTermFrequency \u003e\u003d 1f \u0026\u0026 docFreqs[i] \u003e maxTermFrequency)\n                             || (docFreqs[i] \u003e (int) Math.ceil(maxTermFrequency\n                             * (float) maxDoc))) {\n-                        high.add(termQuery, BooleanClause.Occur.SHOULD);\n+                        highBuilder.add(termQuery, BooleanClause.Occur.SHOULD);\n                     } else {\n-                        low.add(termQuery, BooleanClause.Occur.SHOULD);\n+                        lowBuilder.add(termQuery, BooleanClause.Occur.SHOULD);\n                     }\n                 }\n+                BooleanQuery high \u003d highBuilder.build();\n+                BooleanQuery low \u003d lowBuilder.build();\n                 if (low.clauses().isEmpty()) {\n+                    BooleanQuery.Builder queryBuilder \u003d new BooleanQuery.Builder();\n+                    queryBuilder.setDisableCoord(disableCoord);\n                     for (BooleanClause booleanClause : high) {\n-                        booleanClause.setOccur(BooleanClause.Occur.MUST);\n+                        queryBuilder.add(booleanClause.getQuery(), Occur.MUST);\n                     }\n-                    return high;\n+                    return queryBuilder.build();\n                 } else if (high.clauses().isEmpty()) {\n                     return low;\n                 } else {\n-                    query.add(high, BooleanClause.Occur.SHOULD);\n-                    query.add(low, BooleanClause.Occur.MUST);\n-                    return query;\n+                    return new BooleanQuery.Builder()\n+                        .setDisableCoord(true)\n+                        .add(high, BooleanClause.Occur.SHOULD)\n+                        .add(low, BooleanClause.Occur.MUST)\n+                        .build();\n                 }\n             }\n         };\n     }\n\\ No newline at end of file\n"
    },
    "8d5fff37ae87d58b849490843accfb2ae2425da0": {
      "type": "Ybodychange",
      "commitMessage": "`multi_match` query applies boosts too many times.\n\nThe `multi_match` query groups terms that have the same analyzer together and\nthen applies the boost of the first query in each group. This is not necessary\ngiven that boosts for each term are already applied another way.\n",
      "commitDate": 1438880832000,
      "commitName": "8d5fff37ae87d58b849490843accfb2ae2425da0",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": 1433502723000,
      "commitNameOld": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 62.25,
      "commitsBetweenForRepo": 830,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {\n-        return new BlendedTermQuery(terms) {\n+        return new BlendedTermQuery(terms, boosts) {\n             @Override\n             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {\n                 BooleanQuery query \u003d new BooleanQuery(true);\n                 BooleanQuery high \u003d new BooleanQuery(disableCoord);\n                 BooleanQuery low \u003d new BooleanQuery(disableCoord);\n                 for (int i \u003d 0; i \u003c terms.length; i++) {\n                     TermQuery termQuery \u003d new TermQuery(terms[i], ctx[i]);\n                     if (boosts !\u003d null) {\n                         termQuery.setBoost(boosts[i]);\n                     }\n                     if ((maxTermFrequency \u003e\u003d 1f \u0026\u0026 docFreqs[i] \u003e maxTermFrequency)\n                             || (docFreqs[i] \u003e (int) Math.ceil(maxTermFrequency\n                             * (float) maxDoc))) {\n                         high.add(termQuery, BooleanClause.Occur.SHOULD);\n                     } else {\n                         low.add(termQuery, BooleanClause.Occur.SHOULD);\n                     }\n                 }\n                 if (low.clauses().isEmpty()) {\n                     for (BooleanClause booleanClause : high) {\n                         booleanClause.setOccur(BooleanClause.Occur.MUST);\n                     }\n                     return high;\n                 } else if (high.clauses().isEmpty()) {\n                     return low;\n                 } else {\n                     query.add(high, BooleanClause.Occur.SHOULD);\n                     query.add(low, BooleanClause.Occur.MUST);\n                     return query;\n                 }\n             }\n         };\n     }\n\\ No newline at end of file\n"
    },
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": {
      "type": "Yfilerename",
      "commitMessage": "create core module\n",
      "commitDate": 1433502723000,
      "commitName": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1433502668000,
      "commitNameOld": "7ccc193a666e2ae888e7ac93d677a2143e5e07c3",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "0fa5b87fddc10ce487299c10fd3a833962058959": {
      "type": "Ybodychange",
      "commitMessage": "Add missing @Override annotations.\n\nThese help a lot when refactoring, upgrading lucene, etc, and\ncan prevent code duplication (as you get a compile error for outdated stuff).\n\nCloses #9832.\n",
      "commitDate": 1424729308000,
      "commitName": "0fa5b87fddc10ce487299c10fd3a833962058959",
      "commitAuthor": "Robert Muir",
      "commitDateOld": 1415220531000,
      "commitNameOld": "610ce078fb3c84c47d6d32aff7d77ba850e28f9d",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 110.06,
      "commitsBetweenForRepo": 816,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n     public static BlendedTermQuery commonTermsBlendedQuery(Term[] terms, final float[] boosts, final boolean disableCoord, final float maxTermFrequency) {\n         return new BlendedTermQuery(terms) {\n+            @Override\n             protected Query topLevelQuery(Term[] terms, TermContext[] ctx, int[] docFreqs, int maxDoc) {\n                 BooleanQuery query \u003d new BooleanQuery(true);\n                 BooleanQuery high \u003d new BooleanQuery(disableCoord);\n                 BooleanQuery low \u003d new BooleanQuery(disableCoord);\n                 for (int i \u003d 0; i \u003c terms.length; i++) {\n                     TermQuery termQuery \u003d new TermQuery(terms[i], ctx[i]);\n                     if (boosts !\u003d null) {\n                         termQuery.setBoost(boosts[i]);\n                     }\n                     if ((maxTermFrequency \u003e\u003d 1f \u0026\u0026 docFreqs[i] \u003e maxTermFrequency)\n                             || (docFreqs[i] \u003e (int) Math.ceil(maxTermFrequency\n                             * (float) maxDoc))) {\n                         high.add(termQuery, BooleanClause.Occur.SHOULD);\n                     } else {\n                         low.add(termQuery, BooleanClause.Occur.SHOULD);\n                     }\n                 }\n                 if (low.clauses().isEmpty()) {\n                     for (BooleanClause booleanClause : high) {\n                         booleanClause.setOccur(BooleanClause.Occur.MUST);\n                     }\n                     return high;\n                 } else if (high.clauses().isEmpty()) {\n                     return low;\n                 } else {\n                     query.add(high, BooleanClause.Occur.SHOULD);\n                     query.add(low, BooleanClause.Occur.MUST);\n                     return query;\n                 }\n             }\n         };\n     }\n\\ No newline at end of file\n"
    },
    "162ca993762ffb5f720ae7f82adcc209d16a5bd2": {
      "type": "Yintroduced",
      "commitMessage": "Added `cross_fields` mode to multi_match query\n\n`cross_fields` attemps to treat fields with the same analysis\nconfiguration as a single field and uses maximum score promotion or\ncombination of the scores based depending on the `use_dis_max` setting.\nBy default scores are combined. `cross_fields` can also search across\nfields of hetrogenous types for instance if numbers can be part of\nthe query it makes sense to search also on numeric fields if an analyzer\nis provided in the reqeust.\n\nRelates to #2959\n",
      "commitDate": 1391703355000,
      "commitName": "162ca993762ffb5f720ae7f82adcc209d16a5bd2",
      "commitAuthor": "Simon Willnauer"
    }
  }
}