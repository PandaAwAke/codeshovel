{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/elasticsearch/.git",
  "startCommitName": "7c0fc209bf78e4824ca1f232b84a1dab22bc2dfa",
  "sourceFileName": "CustomFieldQuery.java",
  "functionName": "flatten",
  "functionId": "flatten___sourceQuery-Query__reader-IndexReader__flatQueries-Collection__Query____boost-float",
  "sourceFilePath": "server/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java",
  "functionStartLine": 57,
  "functionEndLine": 98,
  "changeHistory": [
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "85dd1880fc5e73c6cba4deb8b14e4cf0fafb9471",
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
    "562c3744cab91aa083cb645c67ef57ebb20c8661",
    "8d6a41f67145b3bbc369eb5eec7caceaa39f5345",
    "e874dee3bc919cf51e3b84a7ef63815c622d2ae2",
    "2adc2a19719eeb5781a49e00fbc23f86128103bf",
    "2bdc55c9fffb61a1c2fc9a4881d608082424f2a8",
    "5596e310684c2e540d932c91690cf73a3b083465",
    "57310fc45100ee8ecd35e038c2ab3f1d4d2874f3",
    "c1f2fc76c27acd6f1637993115269eae1023686b",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
    "30a4294a6a76fbef7840cac4c23b05d9de7786a5",
    "610ce078fb3c84c47d6d32aff7d77ba850e28f9d",
    "4a48b93cf5e35017b635256720e5f767c9583715",
    "91acca7836962aa6ae753fb6d270f0a9caff2981",
    "8bd9e34e39eb586f1180c868f8b07b8c2b2cbdf2",
    "11bf7a8b1a7ec88e4d38ee69c8b5c577001fb68d",
    "72a2416a8c6abbef318bc243a230774ff2578e71",
    "48488f707f7fd42de0ce2f55ec5920a0846f2cbb",
    "c22b5218008fd81b62b74d0f510891b9bfbe9268",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
    "f18ad903a913a937836787166db2cd842a27b498",
    "b652c655d23c1e175c5927fa23f3bffafdec44d2",
    "759d7d693d07cb9661a7484a9b837d8aa23b11b5",
    "7550fc570ea5ad59f24fe6dd8d40cab7007a1829",
    "8de7beadc8267cd9a8e068ec13421499441d8bed",
    "a9fc276a3ec849bb94fbe22e4039c4c3128ccef4",
    "5205a183e8324b53c2a2ac1c6b78b3403f56f765",
    "cb8faaa13f34f8340eb9050fbbfcc21cc44d7af7",
    "bf6cead984ffe9fbb13d6374e2dc7ffe1411f341"
  ],
  "changeHistoryShort": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "85dd1880fc5e73c6cba4deb8b14e4cf0fafb9471": "Ybodychange",
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0": "Ybodychange",
    "562c3744cab91aa083cb645c67ef57ebb20c8661": "Ybodychange",
    "8d6a41f67145b3bbc369eb5eec7caceaa39f5345": "Ybodychange",
    "e874dee3bc919cf51e3b84a7ef63815c622d2ae2": "Ybodychange",
    "2adc2a19719eeb5781a49e00fbc23f86128103bf": "Ybodychange",
    "2bdc55c9fffb61a1c2fc9a4881d608082424f2a8": "Ybodychange",
    "5596e310684c2e540d932c91690cf73a3b083465": "Ybodychange",
    "57310fc45100ee8ecd35e038c2ab3f1d4d2874f3": "Ybodychange",
    "c1f2fc76c27acd6f1637993115269eae1023686b": "Ymultichange(Yparameterchange,Ybodychange)",
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": "Yfilerename",
    "30a4294a6a76fbef7840cac4c23b05d9de7786a5": "Ybodychange",
    "610ce078fb3c84c47d6d32aff7d77ba850e28f9d": "Ybodychange",
    "4a48b93cf5e35017b635256720e5f767c9583715": "Ybodychange",
    "91acca7836962aa6ae753fb6d270f0a9caff2981": "Ybodychange",
    "8bd9e34e39eb586f1180c868f8b07b8c2b2cbdf2": "Ybodychange",
    "11bf7a8b1a7ec88e4d38ee69c8b5c577001fb68d": "Ybodychange",
    "72a2416a8c6abbef318bc243a230774ff2578e71": "Ybodychange",
    "48488f707f7fd42de0ce2f55ec5920a0846f2cbb": "Ybodychange",
    "c22b5218008fd81b62b74d0f510891b9bfbe9268": "Ybodychange",
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": "Yfilerename",
    "f18ad903a913a937836787166db2cd842a27b498": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "b652c655d23c1e175c5927fa23f3bffafdec44d2": "Ybodychange",
    "759d7d693d07cb9661a7484a9b837d8aa23b11b5": "Ybodychange",
    "7550fc570ea5ad59f24fe6dd8d40cab7007a1829": "Ybodychange",
    "8de7beadc8267cd9a8e068ec13421499441d8bed": "Ybodychange",
    "a9fc276a3ec849bb94fbe22e4039c4c3128ccef4": "Ybodychange",
    "5205a183e8324b53c2a2ac1c6b78b3403f56f765": "Ybodychange",
    "cb8faaa13f34f8340eb9050fbbfcc21cc44d7af7": "Ybodychange",
    "bf6cead984ffe9fbb13d6374e2dc7ffe1411f341": "Yintroduced"
  },
  "changeHistoryDetails": {
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": 1515695443000,
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": 1515688270000,
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "85dd1880fc5e73c6cba4deb8b14e4cf0fafb9471": {
      "type": "Ybodychange",
      "commitMessage": "Fix some type checks that were always false (#27706)\n\n* CustomFieldQuery: removed a redundant type check that was \r\nalready done higher up in the same if/else chain.\r\n* PrioritizedEsThreadPoolExecutor: removed a check that was \r\nsimply a duplicate of one earlier one and would never have been true.",
      "commitDate": 1512988083000,
      "commitName": "85dd1880fc5e73c6cba4deb8b14e4cf0fafb9471",
      "commitAuthor": "Robin Neatherway",
      "commitDateOld": 1503394605000,
      "commitNameOld": "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 111.04,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,42 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof BoostQuery) {\n             BoostQuery bq \u003d (BoostQuery) sourceQuery;\n             sourceQuery \u003d bq.getQuery();\n             boost *\u003d bq.getBoost();\n             flatten(sourceQuery, reader, flatQueries, boost);\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n-        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n-            ESToParentBlockJoinQuery blockJoinQuery \u003d (ESToParentBlockJoinQuery) sourceQuery;\n-            flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof BoostingQuery) {\n             BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n             //flatten positive query with query boost\n             flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n             //flatten negative query with negative boost\n             flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n         } else if (sourceQuery instanceof SynonymQuery) {\n             // SynonymQuery should be handled by the parent class directly.\n             // This statement should be removed when https://issues.apache.org/jira/browse/LUCENE-7484 is merged.\n             SynonymQuery synQuery \u003d (SynonymQuery) sourceQuery;\n             for (Term term : synQuery.getTerms()) {\n                 flatten(new TermQuery(term), reader, flatQueries, boost);\n             }\n         } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n             Query childQuery \u003d ((ESToParentBlockJoinQuery) sourceQuery).getChildQuery();\n             if (childQuery !\u003d null) {\n                 flatten(childQuery, reader, flatQueries, boost);\n             }\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0": {
      "type": "Ybodychange",
      "commitMessage": "Fix nested query highlighting (#26305)\n\nThis commit extracts the inner query in the ESToParentBlockJoinQuery for highlighting.\r\nThis query has been added in 5.4 and breaks plain highlighting on nested queries.\r\nHighlighters that use postings or term vectors are not affected because they can\u0027t highlight nested documents correctly.\r\n\r\nFixes #26230",
      "commitDate": 1503394605000,
      "commitName": "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1501226540000,
      "commitNameOld": "562c3744cab91aa083cb645c67ef57ebb20c8661",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 25.09,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,45 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof BoostQuery) {\n             BoostQuery bq \u003d (BoostQuery) sourceQuery;\n             sourceQuery \u003d bq.getQuery();\n             boost *\u003d bq.getBoost();\n             flatten(sourceQuery, reader, flatQueries, boost);\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n             ESToParentBlockJoinQuery blockJoinQuery \u003d (ESToParentBlockJoinQuery) sourceQuery;\n             flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof BoostingQuery) {\n             BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n             //flatten positive query with query boost\n             flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n             //flatten negative query with negative boost\n             flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n         } else if (sourceQuery instanceof SynonymQuery) {\n             // SynonymQuery should be handled by the parent class directly.\n             // This statement should be removed when https://issues.apache.org/jira/browse/LUCENE-7484 is merged.\n             SynonymQuery synQuery \u003d (SynonymQuery) sourceQuery;\n             for (Term term : synQuery.getTerms()) {\n                 flatten(new TermQuery(term), reader, flatQueries, boost);\n             }\n+        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n+            Query childQuery \u003d ((ESToParentBlockJoinQuery) sourceQuery).getChildQuery();\n+            if (childQuery !\u003d null) {\n+                flatten(childQuery, reader, flatQueries, boost);\n+            }\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "562c3744cab91aa083cb645c67ef57ebb20c8661": {
      "type": "Ybodychange",
      "commitMessage": "Merge FunctionScoreQuery and FiltersFunctionScoreQuery (#25889)\n\nThis change merges the functionality of the FiltersFunctionScoreQuery in the FunctionScoreQuery.\r\nIt also ensures that an exception is thrown when the computed score is equals to Float.NaN or Float.NEGATIVE_INFINITY.\r\nThese scores are invalid for TopDocsCollectors that relies on score comparison.\r\n\r\nFixes #15709\r\nFixes #23628",
      "commitDate": 1501226540000,
      "commitName": "562c3744cab91aa083cb645c67ef57ebb20c8661",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1487084719000,
      "commitNameOld": "8d6a41f67145b3bbc369eb5eec7caceaa39f5345",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 163.68,
      "commitsBetweenForRepo": 1837,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,40 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof BoostQuery) {\n             BoostQuery bq \u003d (BoostQuery) sourceQuery;\n             sourceQuery \u003d bq.getQuery();\n             boost *\u003d bq.getBoost();\n             flatten(sourceQuery, reader, flatQueries, boost);\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n-        } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n-            flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n             ESToParentBlockJoinQuery blockJoinQuery \u003d (ESToParentBlockJoinQuery) sourceQuery;\n             flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof BoostingQuery) {\n             BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n             //flatten positive query with query boost\n             flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n             //flatten negative query with negative boost\n             flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n         } else if (sourceQuery instanceof SynonymQuery) {\n             // SynonymQuery should be handled by the parent class directly.\n             // This statement should be removed when https://issues.apache.org/jira/browse/LUCENE-7484 is merged.\n             SynonymQuery synQuery \u003d (SynonymQuery) sourceQuery;\n             for (Term term : synQuery.getTerms()) {\n                 flatten(new TermQuery(term), reader, flatQueries, boost);\n             }\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8d6a41f67145b3bbc369eb5eec7caceaa39f5345": {
      "type": "Ybodychange",
      "commitMessage": "Nested queries should avoid adding unnecessary filters when possible. (#23079)\n\nWhen nested objects are present in the mappings, many queries get deoptimized\r\ndue to the need to exclude documents that are not in the right space. For\r\ninstance, a filter is applied to all queries that prevents them from matching\r\nnon-root documents (`+*:* -_type:__*`). Moreover, a filter is applied to all\r\nchild queries of `nested` queries in order to make sure that the child query\r\nonly matches child documents (`_type:__nested_path`), which is required by\r\n`ToParentBlockJoinQuery` (the Lucene query behing Elasticsearch\u0027s `nested`\r\nqueries).\r\n\r\nThese additional filters slow down `nested` queries. In 1.7-, the cost was\r\nsomehow amortized by the fact that we cached filters very aggressively. However,\r\nthis has proven to be a significant source of slow downs since 2.0 for users\r\nof `nested` mappings and queries, see #20797.\r\n\r\nThis change makes the filtering a bit smarter. For instance if the query is a\r\n`match_all` query, then we need to exclude nested docs. However, if the query\r\nis `foo: bar` then it may only match root documents since `foo` is a top-level\r\nfield, so no additional filtering is required.\r\n\r\nAnother improvement is to use a `FILTER` clause on all types rather than a\r\n`MUST_NOT` clause on all nested paths when possible since `FILTER` clauses\r\nare more efficient.\r\n\r\nHere are some examples of queries and how they get rewritten:\r\n\r\n```\r\n\"match_all\": {}\r\n```\r\n\r\nThis query gets rewritten to `ConstantScore(+*:* -_type:__*)` on master and\r\n`ConstantScore(_type:AutomatonQuery {\\norg.apache.lucene.util.automaton.Automaton@4371da44})`\r\nwith this change. The automaton is the complement of `_type:__*` so it matches\r\nthe same documents, but is faster since it is now a positive clause. Simplistic\r\nperformance testing on a 10M index where each root document has 5 nested\r\ndocuments on average gave a latency of 420ms on master and 90ms with this change\r\napplied.\r\n\r\n```\r\n\"term\": {\r\n  \"foo\": {\r\n    \"value\": \"0\"\r\n  }\r\n}\r\n```\r\n\r\nThis query is rewritten to `+foo:0 #(ConstantScore(+*:* -_type:__*))^0.0` on\r\nmaster and `foo:0` with this change: we do not need to filter nested docs out\r\nsince the query cannot match nested docs. While doing performance testing in\r\nthe same conditions as above, response times went from 250ms to 50ms.\r\n\r\n```\r\n\"nested\": {\r\n  \"path\": \"nested\",\r\n  \"query\": {\r\n    \"term\": {\r\n      \"nested.foo\": {\r\n        \"value\": \"0\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis query is rewritten to\r\n`+ToParentBlockJoinQuery (+nested.foo:0 #_type:__nested) #(ConstantScore(+*:* -_type:__*))^0.0`\r\non master and `ToParentBlockJoinQuery (nested.foo:0)` with this change. The\r\ntop-level filter (`-_type:__*`) could be removed since `nested` queries only\r\nmatch documents of the parent space, as well as the child filter\r\n(`#_type:__nested`) since the child query may only match nested docs since the\r\n`nested` object has both `include_in_parent` and `include_in_root` set to\r\n`false`. While doing performance testing in the same conditions as above,\r\nresponse times went from 850ms to 270ms.",
      "commitDate": 1487084719000,
      "commitName": "8d6a41f67145b3bbc369eb5eec7caceaa39f5345",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": 1476260829000,
      "commitNameOld": "44ac5d057a8ceb6940c26275d9963bccb9f5065a",
      "commitAuthorOld": "Tanguy Leroux",
      "daysBetweenCommits": 125.28,
      "commitsBetweenForRepo": 1601,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof BoostQuery) {\n             BoostQuery bq \u003d (BoostQuery) sourceQuery;\n             sourceQuery \u003d bq.getQuery();\n             boost *\u003d bq.getBoost();\n             flatten(sourceQuery, reader, flatQueries, boost);\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n-        } else if (sourceQuery instanceof ToParentBlockJoinQuery) {\n-            ToParentBlockJoinQuery blockJoinQuery \u003d (ToParentBlockJoinQuery) sourceQuery;\n+        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {\n+            ESToParentBlockJoinQuery blockJoinQuery \u003d (ESToParentBlockJoinQuery) sourceQuery;\n             flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof BoostingQuery) {\n             BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n             //flatten positive query with query boost\n             flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n             //flatten negative query with negative boost\n             flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n         } else if (sourceQuery instanceof SynonymQuery) {\n             // SynonymQuery should be handled by the parent class directly.\n             // This statement should be removed when https://issues.apache.org/jira/browse/LUCENE-7484 is merged.\n             SynonymQuery synQuery \u003d (SynonymQuery) sourceQuery;\n             for (Term term : synQuery.getTerms()) {\n                 flatten(new TermQuery(term), reader, flatQueries, boost);\n             }\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "e874dee3bc919cf51e3b84a7ef63815c622d2ae2": {
      "type": "Ybodychange",
      "commitMessage": "Handle SynonymQuery extraction for the FastVectorHighlighter (#20829)\n\nSynonymQuery was ignored by the FastVectorHighlighter.\r\nThis change adds the support for SynonymQuery in the FVH.\r\nAlthough this change should be implemented in Lucene directly which is why https://issues.apache.org/jira/browse/LUCENE-7484 has been opened.\r\nIn the meantime this PR handles the issue on ES side and could be removed when LUCENE-7484 gets merged.\r\n\r\nFixes #20781",
      "commitDate": 1476114379000,
      "commitName": "e874dee3bc919cf51e3b84a7ef63815c622d2ae2",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1471309216000,
      "commitNameOld": "2adc2a19719eeb5781a49e00fbc23f86128103bf",
      "commitAuthorOld": "chengpohi",
      "daysBetweenCommits": 55.62,
      "commitsBetweenForRepo": 659,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,42 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof BoostQuery) {\n             BoostQuery bq \u003d (BoostQuery) sourceQuery;\n             sourceQuery \u003d bq.getQuery();\n             boost *\u003d bq.getBoost();\n             flatten(sourceQuery, reader, flatQueries, boost);\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ToParentBlockJoinQuery) {\n             ToParentBlockJoinQuery blockJoinQuery \u003d (ToParentBlockJoinQuery) sourceQuery;\n             flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof BoostingQuery) {\n             BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n             //flatten positive query with query boost\n             flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n             //flatten negative query with negative boost\n             flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n+        } else if (sourceQuery instanceof SynonymQuery) {\n+            // SynonymQuery should be handled by the parent class directly.\n+            // This statement should be removed when https://issues.apache.org/jira/browse/LUCENE-7484 is merged.\n+            SynonymQuery synQuery \u003d (SynonymQuery) sourceQuery;\n+            for (Term term : synQuery.getTerms()) {\n+                flatten(new TermQuery(term), reader, flatQueries, boost);\n+            }\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2adc2a19719eeb5781a49e00fbc23f86128103bf": {
      "type": "Ybodychange",
      "commitMessage": "Enable BoostingQuery with FVH highlighter (#19984)\n\n* Enable BoostingQuery with FVH highlighter\r\n* apply boost with negativeBoost\r\n* flatten boosting query with its own boost and update boost query to a single layer\r\n",
      "commitDate": 1471309216000,
      "commitName": "2adc2a19719eeb5781a49e00fbc23f86128103bf",
      "commitAuthor": "chengpohi",
      "commitDateOld": 1468390546000,
      "commitNameOld": "2bdc55c9fffb61a1c2fc9a4881d608082424f2a8",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 33.78,
      "commitsBetweenForRepo": 517,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,35 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n-        if (sourceQuery instanceof SpanTermQuery) {\n+        if (sourceQuery instanceof BoostQuery) {\n+            BoostQuery bq \u003d (BoostQuery) sourceQuery;\n+            sourceQuery \u003d bq.getQuery();\n+            boost *\u003d bq.getBoost();\n+            flatten(sourceQuery, reader, flatQueries, boost);\n+        } else if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ToParentBlockJoinQuery) {\n             ToParentBlockJoinQuery blockJoinQuery \u003d (ToParentBlockJoinQuery) sourceQuery;\n             flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n+        } else if (sourceQuery instanceof BoostingQuery) {\n+            BoostingQuery boostingQuery \u003d (BoostingQuery) sourceQuery;\n+            //flatten positive query with query boost\n+            flatten(boostingQuery.getMatch(), reader, flatQueries, boost);\n+            //flatten negative query with negative boost\n+            flatten(boostingQuery.getContext(), reader, flatQueries, boostingQuery.getBoost());\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2bdc55c9fffb61a1c2fc9a4881d608082424f2a8": {
      "type": "Ybodychange",
      "commitMessage": "fvh: Also extract terms from the nested query\u0027 inner query.\n\nCloses #19265\n",
      "commitDate": 1468390546000,
      "commitName": "2bdc55c9fffb61a1c2fc9a4881d608082424f2a8",
      "commitAuthor": "Martijn van Groningen",
      "commitDateOld": 1457938732000,
      "commitNameOld": "5596e310684c2e540d932c91690cf73a3b083465",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 120.97,
      "commitsBetweenForRepo": 2232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,24 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n+        } else if (sourceQuery instanceof ToParentBlockJoinQuery) {\n+            ToParentBlockJoinQuery blockJoinQuery \u003d (ToParentBlockJoinQuery) sourceQuery;\n+            flatten(blockJoinQuery.getChildQuery(), reader, flatQueries, boost);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5596e310684c2e540d932c91690cf73a3b083465": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade to lucene-6.0.0-f0aa4fc. #17075\n",
      "commitDate": 1457938732000,
      "commitName": "5596e310684c2e540d932c91690cf73a3b083465",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": 1457341943000,
      "commitNameOld": "54018a5d3728e796bb93ba86431f4eb512edb524",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 6.91,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,21 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n-            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n+            convertMultiPhraseQuery(0, new int[q.getTermArrays().length], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "57310fc45100ee8ecd35e038c2ab3f1d4d2874f3": {
      "type": "Ybodychange",
      "commitMessage": "Ban oal.search.Filter.\n\nFilter has been deprecated in Lucene 5.4 and will be removed in 6.0. We should\nstop using this API.\n",
      "commitDate": 1445350186000,
      "commitName": "57310fc45100ee8ecd35e038c2ab3f1d4d2874f3",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": 1441921003000,
      "commitNameOld": "c1f2fc76c27acd6f1637993115269eae1023686b",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 39.69,
      "commitsBetweenForRepo": 702,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,21 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries, float boost) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n-        } else if (sourceQuery instanceof FilteredQuery) {\n-            flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries, boost);\n-            flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries, boost);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries, boost);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries, boost);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c1f2fc76c27acd6f1637993115269eae1023686b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Upgrade lucene to r1702090\n\nThe semantics of the `boost` parameter for `function_score` changed. This is\ndue to the fact that Lucene now requires that query boosts and top-level boosts\nare applied the same way.\n",
      "commitDate": 1441921003000,
      "commitName": "c1f2fc76c27acd6f1637993115269eae1023686b",
      "commitAuthor": "Robert Muir",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "15a62448343fd24f8e63f43b1e4b16f50005e4a5": {
      "type": "Yfilerename",
      "commitMessage": "create core module\n",
      "commitDate": 1433502723000,
      "commitName": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1433502668000,
      "commitNameOld": "7ccc193a666e2ae888e7ac93d677a2143e5e07c3",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "30a4294a6a76fbef7840cac4c23b05d9de7786a5": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade to lucene r1660560\n\nSquashed commit of the following:\n\ncommit 07391388715ed1f737e8acc391cea0bce5d79db9\nMerge: a71cc45 b61b021\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Feb 20 06:58:11 2015 -0500\n\n    Git really sucks\n\n    Merge branch \u0027lucene_r1660560\u0027 of github.com:elasticsearch/elasticsearch into lucene_r1660560\n\ncommit b61b02163f62ad8ddd9906cedb3d57fed75eb52d\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Wed Feb 18 19:03:49 2015 +0100\n\n    Try to improve TopDocs.merge usage.\n\ncommit bf8e4ac46d7fdaf9ae128606d96328a59784f126\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Wed Feb 18 07:43:37 2015 -0800\n\n    reenable scripting test for accessing postings pieces.  commented out\n    parts that fail because of bad assumptions\n\ncommit 6d4d635b1a23b33c437a6bae70beea70ad52d91c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Feb 18 09:41:46 2015 -0500\n\n    add some protection against broken asserts, but, also disable crappy test\n\ncommit c735bbb11f38782dfea9c4200fcf732564126bf5\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Feb 18 02:21:30 2015 -0500\n\n    cutover remaining stuff from old postings api\n\ncommit 11c9c2bea3db3ff1cd2807bd43e77b500b167aed\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Feb 18 01:46:04 2015 -0500\n\n    cut over most DocsEnum usage\n\ncommit bc18017662f6abddf3f074078f74e582494c88e2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Feb 18 01:19:35 2015 -0500\n\n    upgrade to lucene_r1660560, modulo one test fail\n",
      "commitDate": 1424433523000,
      "commitName": "30a4294a6a76fbef7840cac4c23b05d9de7786a5",
      "commitAuthor": "Robert Muir",
      "commitDateOld": 1415220531000,
      "commitNameOld": "610ce078fb3c84c47d6d32aff7d77ba850e28f9d",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 106.63,
      "commitsBetweenForRepo": 784,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,24 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n-            ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n-            if (constantScoreQuery.getFilter() !\u003d null) {\n-                flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n-            } else {\n-                flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n-            }\n+            flatten(((ConstantScoreQuery) sourceQuery).getQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "610ce078fb3c84c47d6d32aff7d77ba850e28f9d": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade master to lucene 5.0 snapshot\n\nThis has a lot of improvements in lucene, particularly around memory usage, merging, safety, compressed bitsets, etc.\n\nOn the elasticsearch side, summary of the larger changes:\n\n    API changes: postings API became a \"pull\" rather than \"push\", collector API became per-segment, etc.\n    packaging changes: add lucene-backwards-codecs.jar as a dependency.\n    improvements to boolean filtering: especially ensuring it will not be slow for SparseBitSet.\n    use generic BitSet api in plumbing so that concrete bitset type is an implementation detail.\n    use generic BitDocIdSetFilter api for dedicated bitset cache, so there is type safety.\n    changes to support atomic commits\n    implement Accountable.getChildResources (detailed memory usage API) for fielddata, etc\n    change handling of IndexFormatTooOld/New, since they no longer extends CorruptIndexException\n\nCloses #8347.\n\nSquashed commit of the following:\n\ncommit d90d53f5f21b876efc1e09cbd6d63c538a16cd89\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Nov 5 21:35:28 2014 +0100\n\n    Make default codec/postings/docvalues format constants\n\ncommit cb66c22c71cd304a36e7371b199a8c279908ae37\nMerge: d4e2f6d ad4ff43\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Nov 5 11:41:13 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit d4e2f6dfe767a5128c9b9ae9e75036378de08f47\nMerge: 4e5445c 4111d93\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Nov 5 06:26:32 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit 4e5445c775f580730eb01360244e9330c0dc3958\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 16:19:19 2014 -0500\n\n    FixedBitSet -\u003e BitSet\n\ncommit 9887ea73e8b857eeda7f851ef3722ef580c92acf\nMerge: 1bf8894 fc84666\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 15:26:25 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit 1bf8894430de3e566d0dc5623b0cc28b0d674ebb\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 15:22:51 2014 -0500\n\n    remove nocommit\n\ncommit a9c2a2259ff79c69bae7806b64e92d5f472c18c8\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 13:48:43 2014 -0500\n\n    turn jenkins red again\n\ncommit 067baaaa4d52fce772c81654dcdb5051ea79139f\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 13:18:21 2014 -0500\n\n    unzip from stream\n\ncommit 82b6fba33d362aca2313cc0ca495f28f5ebb9260\nMerge: b2214bb 6523cd9\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 13:10:59 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit b2214bb093ec2f759003c488c3c403c8931db914\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 13:09:53 2014 -0500\n\n    go back to my URL until we can figure out what is up with jenkins\n\ncommit e7d614172240175a51f580aeaefb6460d21cede9\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 10:52:54 2014 -0500\n\n    try this jenkins\n\ncommit 337a3c7704efa7c9809bf373152d711ee55f876c\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Tue Nov 4 16:17:49 2014 +0100\n\n    Rename temp-files under lock to prevent metadata reads while renaming\n\ncommit 77d5ba80d0a76efa549dd753b9f114b2f2d2d29c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 10:07:11 2014 -0500\n\n    continue to treat too-old/too-new as corruption for now\n\ncommit 98d0fd2f4851bc50e505a94ca592a694d502c51c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Nov 4 09:24:21 2014 -0500\n\n    fix last nocommit\n\ncommit 643fceed66c8caf22b97fc489d67b4a2a90a1a1c\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Tue Nov 4 14:46:17 2014 +0100\n\n    remove NoSuchDirectoryException\n\ncommit 2e43c4feba05cfaf451df70f946c0930cbcc4557\nMerge: 93826e4 8163107\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Tue Nov 4 14:38:00 2014 +0100\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit 93826e4d56a6a97c2074669014af77ff519bde63\nMerge: 7f10129 44e24d3\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Tue Nov 4 12:54:27 2014 +0100\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\n    Conflicts:\n    \tsrc/main/java/org/elasticsearch/index/store/DistributorDirectory.java\n    \tsrc/main/java/org/elasticsearch/index/store/Store.java\n    \tsrc/main/java/org/elasticsearch/indices/recovery/RecoveryStatus.java\n    \tsrc/test/java/org/elasticsearch/index/store/DistributorDirectoryTest.java\n    \tsrc/test/java/org/elasticsearch/index/store/StoreTest.java\n    \tsrc/test/java/org/elasticsearch/indices/recovery/RecoveryStatusTests.java\n\ncommit 7f10129364623620575c109df725cf54488b3abb\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Tue Nov 4 11:32:24 2014 +0100\n\n    Fix TopHitsAggregator to not ignore the top-level/leaf collector split.\n\ncommit 042fadc8603b997bdfdc45ca44fec70dc86774a6\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Tue Nov 4 11:31:20 2014 +0100\n\n    Remove MatchDocIdSet in favor of DocValuesDocIdSet.\n\ncommit 7d877581ff5db585a674c95ac391ac78a0282826\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Tue Nov 4 11:10:08 2014 +0100\n\n    Make the and filter use the cost API.\n\n    Lucene 5 ensured that cost() can safely be used, and this will have the benefit\n    that the order in which filters are specified is not important anymore (only\n    for slow random-access filters in practice).\n\ncommit 78f1718aa2cd82184db7c3a8393e6215f43eb4a8\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 23:55:17 2014 -0500\n\n    fix previous eclipse import braindamage\n\ncommit 186c40e9258ce32f22a9a714ab442a310b6376e0\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 22:32:34 2014 -0500\n\n    allow child queries to exhaust iterators again\n\ncommit b0b1271305e1b6d0c4c4da51a3c54df1aa5c0605\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Mon Nov 3 14:50:44 2014 -0800\n\n    Fix nocommit for mapping output.  index_options will not be printed if\n    the field is not indexed.\n\ncommit ba223eb85e399c9620a347a983e29bf703953e7a\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Mon Nov 3 14:07:26 2014 -0800\n\n    Remove no commit for chinese analyzer provider.  We should have a\n    separate issue to address not using this provider on new indexes.\n\ncommit ca554b03c4471797682b2fb724f25205cf040c4a\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Mon Nov 3 13:41:59 2014 -0800\n\n    Fix stop tests\n\ncommit de67c4653ec47dee9c671390536110749d2bb05f\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Mon Nov 3 12:51:17 2014 -0800\n\n    Remove analysis nocommits, switching over to Lucene43*Filters for\n    backcompat\n\ncommit 50cae9bec72c25c33a1ab8a8931bccb3355171e2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 15:32:25 2014 -0500\n\n    add ram accounting and TODO lazy-loading (its no worse than master, can be a followup improvement) for suggesters\n\ncommit 7a7f0122f138684b312d0f0b03dc2a9c16c15f9c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 15:11:26 2014 -0500\n\n    bump lucene version\n\ncommit cd0cae5c35e7a9e049f49ae45431f658fb86676b\nMerge: 446bc09 3c72073\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 14:49:05 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit 446bc09b4e8bf4602d3c252b53ddaa0da65cce2f\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 14:46:30 2014 -0500\n\n    remove hack\n\ncommit a19d85a968d82e6d00292b49630ef6ff2dbf2f32\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 12:53:11 2014 -0500\n\n    dont create exceptions with circular references on corruption (will open a PR for this)\n\ncommit 0beefb9e821d97c37e90ec556d81ac7b00369b8a\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 11:47:14 2014 -0500\n\n    temporarily add craptastic detector for this horrible bug\n\ncommit e9f2d298bff75f3d1591f8622441e459c3ce7ac3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 10:56:01 2014 -0500\n\n    add nocommit\n\ncommit e97f1d50a91a7129650b8effc7a9ecf74ca0569a\nMerge: c57a3c8 f1f50ac\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 10:12:12 2014 -0500\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit c57a3c8341ed61dca62eaf77fad6b8b48aeb6940\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 10:11:46 2014 -0500\n\n    fix nocommit\n\ncommit dd0e77e4ec07c7011ab5f6b60b2ead33dc2333d2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Nov 3 09:54:09 2014 -0500\n\n    nocommit -\u003e TODO, this is in much more places in the codebase, bigger issue\n\ncommit 3cc3bf56d72d642059f8fe220d6f2fed608363e9\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Sat Nov 1 23:59:17 2014 -0700\n\n    Remove nocommit and awaitsfix for edge ngram filter test.\n\ncommit 89f115245155511c0fbc0d5ee62e63141c3700c1\nAuthor: Ryan Ernst \u003cryan@iernst.net\u003e\nDate:   Sat Nov 1 23:57:44 2014 -0700\n\n    Fix EdgeNGramTokenFilter logic for version \u003c\u003d 4.3, and fixed instanceof\n    checks in corresponding tests to correctly check for reverse filter when\n    applicable.\n\ncommit 112df869cd199e36aab0e1a7a288bb1fdb2ebf1c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sun Nov 2 00:08:30 2014 -0400\n\n    execute geo disjoint query/filter as intersects\n\ncommit e5061273cc685f1252e9a3a9ae4877ec9bce7752\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 22:58:59 2014 -0400\n\n    remove chinese analyzer from docs\n\ncommit ea1af11b8978fcc551f198e24fe21d52806993ef\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 22:29:00 2014 -0400\n\n    fix ram accounting bug\n\ncommit 53c0a42c6aa81aa6bf81d3aa77b95efd513e0f81\nMerge: e3bcd3c 6011a18\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 22:16:29 2014 -0400\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit e3bcd3cc07a4957e12c7b3affc462c31290a9186\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 22:15:01 2014 -0400\n\n    fix url-email back compat (thanks ryan)\n\ncommit 91d6b096a96c357755abee167098607223be1aad\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 22:11:26 2014 -0400\n\n    bump lucene version\n\ncommit d2bb9568df72b37ec7050d25940160b8517394bc\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 20:33:07 2014 -0400\n\n    remove nocommit\n\ncommit 1d049c471e19e5c457262c7399c5bad9e023b2e3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 20:28:58 2014 -0400\n\n    fix eclipse to group org/com imports together: without this, its madness\n\ncommit 09d8c1585ee99b6e63be032732c04ef6fed84ed2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Nov 1 14:27:41 2014 -0400\n\n    remove nocommit, if you dont liek it, print assembly and tell me how it can be better\n\ncommit 8a6a294313fdf33b50c7126ec20c07867ecd637c\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 20:01:55 2014 +0100\n\n    Remove deprecated usage of DocIdSets.newDocIDSet.\n\ncommit 601bee60543610558403298124a84b1b3bbd1045\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 14:13:18 2014 -0400\n\n    maybe one of these zillions of annotations will stop thread leaks\n\ncommit 9d3f69abc7267c5e455aefa26db95cb554b02d62\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 14:05:39 2014 -0400\n\n    fix some analysis nocommits\n\ncommit 312e3a29c77214b8142d21c33a6b2c2b151acf9a\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 18:28:45 2014 +0100\n\n    Remove XConstantScoreQuery/XFilteredQuery/ApplyAcceptedDocsFilter.\n\ncommit 5a0cb9f8e167215df7f1b1fad11eec6e6c74940f\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 17:06:45 2014 +0100\n\n    Fix misleading documentation of DocIdSets.toCacheable.\n\ncommit 8b4ef2b5b476fff4c79c0c2a0e4769ead26cf82b\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 17:05:59 2014 +0100\n\n    Fix CustomRandomAccessFilterStrategy to override the right method.\n\ncommit d7a9a407a615987cfffc651f724fbd8795c9c671\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 16:21:35 2014 +0100\n\n    Better handle the special case when there is a single SHOULD clause.\n\ncommit 648ad389f07e92dfc451f345549c9841ba5e4c9a\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 15:53:38 2014 +0100\n\n    Cut over XBooleanFilter to BitDocIdSet.Builder.\n\n    The idea is similar to what happened to Lucene\u0027s BooleanFilter.\n\n    Yet XBooleanFilter is a bit more sophisticated and I had to slightly\n    change the way it is implemented in order to make it work. The main difference\n    with before is that slow filters are now applied lazily, so eg. if you have 3\n    MUST clauses, two with a fast iterator and the third with a slow iterator, the\n    previous implementation used to apply the fast iterators first and then only\n    check the slow filter for bits which were set in the bit set. Now we are\n    computing a bit set based on the fast must clauses and then basically returning\n    a BitsFilteredDocIdSet.wrap(bitset, slowClause).\n\n    Other than that, BooleanFilter still uses the bitset optimizations when or-ing\n    and and-ind filters.\n\n    Another improvement is that BooleanFilter is now aware of the cost API.\n\ncommit b2dad312b4bc9f931dc3a25415dd81c0d9deee08\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 10:18:53 2014 -0400\n\n    clear nocommit\n\ncommit 4851d2091e744294336dfade33906c75fbe695cd\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 15:15:16 2014 +0100\n\n    cut over to RoaringDocIdSet\n\ncommit ca6aec24a901073e65ce4dd6b70964fd3612409e\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:57:30 2014 +0100\n\n    make nocommit more explicit\n\ncommit d0742ee2cb7a6c48b0bbb31580b7fbcebdb6ec40\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 09:55:24 2014 -0400\n\n    fix standardtokenizer nocommit\n\ncommit 7d6faccafff22a86af62af0384838391d46695ca\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:54:08 2014 +0100\n\n    fix compilation\n\ncommit a038a405c1ff6458ad294e6b5bc469e622f699d0\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:53:43 2014 +0100\n\n    fix compilation\n\ncommit 30c9e307b1f5d80e2deca3392c0298682241207f\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:52:35 2014 +0100\n\n    fix compilation\n\ncommit e5139bc5a0a9abd2bdc6ba0dfbcb7e3c2e7b8481\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 09:52:16 2014 -0400\n\n    clear nocommit here\n\ncommit 85dd2cedf7a7994bed871ac421cfda06aaf5c0a5\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:46:17 2014 +0100\n\n    fix CompletionPostingsFormatTest\n\ncommit c0f3781f616c9b0ee3b5c4d0998810f595868649\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 09:38:00 2014 -0400\n\n    add tests for these analyzers\n\ncommit 51f9999b4ad079c283ae762c862fd0e22d00445f\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 14:10:26 2014 +0100\n\n    remove nocommit - this is not an issue\n\ncommit fd1388fa03e622b0738601c8aeb2dbf7949a6dd2\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Fri Oct 31 14:07:01 2014 +0100\n\n    Remove redundant null check\n\ncommit 3d6dd51b0927337ba941a235446b22e8cd500dc3\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Fri Oct 31 14:01:37 2014 +0100\n\n    Removed the work around to prevent p/c error when invoking #iterator() twice, because the custom query filter wrapper now doesn\u0027t transform the result to a cache doc id set any more.\n\n    I think the transforming to a cachable doc id set in CustomQueryWrappingFilter isn\u0027t needed at all, because we use the DocIdSet only once and because of that is just slowed things down.\n\ncommit 821832a537e00cd1216064b379df3e01d2911d3a\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 13:54:33 2014 +0100\n\n    one more nocommit\n\ncommit 77eb9ea4c4ea50afb2680c29682ddcb3851a9d4f\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Fri Oct 31 13:52:29 2014 +0100\n\n    Remove cast\n\ncommit a400573c034ed602221f801b20a58a9186a06eae\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 13:49:24 2014 +0100\n\n    fix stop filter\n\ncommit 51746087cf8ec34c4d20aa05ba8dbff7b3b43eec\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 13:21:36 2014 +0100\n\n    fix changed semantics of FBS.nextSetBit to check for NO_MORE_DOCS\n\ncommit 8d0a4e2511310f1293860823fe3ba80ac771bbe3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 08:13:44 2014 -0400\n\n    do the bogus cast differently\n\ncommit 46a5cc5732dea096c0c80ae5ce42911c9c51e44e\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Fri Oct 31 13:00:16 2014 +0100\n\n    I hate it but P/C now passes\n\ncommit 580c0c2f82bbeacf217e594f22312b11d1bdb839\nMerge: a9d3c00 1645434\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 31 06:54:31 2014 -0400\n\n    fix nocommit/classcast\n\ncommit a9d3c004d62fe04989f49a897e6ff84973c06eb9\nAuthor: Adrien Grand \u003cjpountz@gmail.com\u003e\nDate:   Fri Oct 31 08:49:31 2014 +0100\n\n    Update TODO.\n\ncommit aa75af0b407792aeef32017f03a6f442ed970baa\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 19:18:25 2014 -0400\n\n    clear obselete nocommits from lucene bump\n\ncommit d438534cf41fcbe2d88070e2f27c994625e082c2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 18:53:20 2014 -0400\n\n    throw classcastexception when ES abuses regular filtercache for nested docs\n\ncommit 2c751f3a8feda43ec127c34769b069de21f3d16f\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 18:31:34 2014 -0400\n\n    bump lucene revision, fix tests\n\ncommit d6ef7f6304ae262bf6228a7d661b2a452df332be\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 22:37:58 2014 +0100\n\n    fix merge problems\n\ncommit de9d361f88a9ce6bb3fba85285de41f223c95767\nMerge: 41f6aab f6b37a3\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 22:28:59 2014 +0100\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\n    Conflicts:\n    \tpom.xml\n    \tsrc/main/java/org/elasticsearch/Version.java\n    \tsrc/main/java/org/elasticsearch/gateway/local/state/meta/MetaDataStateFormat.java\n\ncommit 41f6aab388aa80c40b08a2facab2617576203a0d\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 17:48:46 2014 +0100\n\n    fix potiential NPE\n\ncommit c4428b12e1ae838b91e847df8b4a8be7f49e10f4\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 17:38:46 2014 +0100\n\n    don\u0027t advance iterator in a match(doc) method\n\ncommit 28ab948e99e3ea4497c9b1e468384806ba7e1790\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 17:34:58 2014 +0100\n\n    don\u0027t advance iterator in a match(doc) method\n\ncommit eb0f33f6634fadfcf4b2bf7327400e568f0427bb\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 16:55:54 2014 +0100\n\n    fix GeoUtilsTest\n\ncommit 7f711fe3eaf73b6c2268cf42d5a41132a61ad831\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 16:43:16 2014 +0100\n\n    Use a dedicated default index option if field type is not indexed by default\n\ncommit 78e3f37ab779e3e1b25b45a742cc86ab5f975149\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 10:56:14 2014 -0400\n\n    disable this test with AwaitsFix to reduce noise\n\ncommit 9a590f563c8e03a99ecf0505c92d12d7ab20d11d\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 09:38:49 2014 +0100\n\n    fix lucene version\n\ncommit abe3ca1d8bb6b5101b545198f59aec44bacfa741\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Thu Oct 30 09:35:05 2014 +0100\n\n    fix AnalyzingCompletionLookupProvider to wrok with new codec API\n\ncommit 464293b245852d60bde050c6d3feb5907dcfbf5f\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 00:26:00 2014 -0400\n\n    don\u0027t try to write stuff to tests class directory\n\ncommit 031cc6c19f4fe4423a034b515f77e5a0e282a124\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 00:12:36 2014 -0400\n\n    AwaitsFix these known issues to reduce noise\n\ncommit 4600d51891e35847f2d344247d6f915a0605c0d1\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Thu Oct 30 00:06:53 2014 -0400\n\n    openbitset lives on\n\ncommit 8492bae056249e2555d24acd55f1046b66a667c4\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 23:42:54 2014 -0400\n\n    fixes for filter tests\n\ncommit 31f24ce4efeda31f97eafdb122346c7047a53bf2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 23:12:38 2014 -0400\n\n    don\u0027t use fieldcache\n\ncommit 8480789942fdff14a6d2b2cd8134502fe62f20c8\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 23:04:29 2014 -0400\n\n    ancient index no longer supported\n\ncommit 02e78dc7ebdd827533009f542582e8db44309c57\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 23:37:02 2014 +0100\n\n    fix more tests\n\ncommit ff746c6df23c50b3f3ec24922413b962c8983080\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 23:08:19 2014 +0100\n\n    fix all mapper\n\ncommit e4fb84b517107b25cb064c66f83c9aa814a311b2\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 22:55:54 2014 +0100\n\n    fix distributor tests and cut over to FileStore API\n\ncommit 20c850e2cfe3210cd1fb9e232afed8d4ac045857\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 22:42:18 2014 +0100\n\n    use DOCS_ONLY if index\u003dtrue and current options \u003d\u003d null\n\ncommit 44169c108418413cfe51f5ce23ab82047463e4c2\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 22:33:36 2014 +0100\n\n    Fix index\u003dyes|no settings in mappers\n\ncommit a3c5f77987461a18121156ed345d42ded301c566\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 21:51:41 2014 +0100\n\n    fix several field mappers conversion from setIndexed to indexOptions\n\ncommit df84d736908e88a031d710f98e222be68ae96af1\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 21:33:35 2014 +0100\n\n    fix SourceFieldMapper to be not indexed\n\ncommit b2bf01d12a8271a31fb2df601162d0e89924c8f5\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 21:23:08 2014 +0100\n\n    Cut over to .liv files in store and corruption tests\n\ncommit 619004df436f9ef05d24bef1b6a7f084c6b0ad75\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 17:05:52 2014 +0100\n\n    fix more tests\n\ncommit b7ed653a8b464de446e00456bce0a89e47627c38\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 16:19:08 2014 +0100\n\n    [STORE] Add dedicated method to write temporary files\n\n    Recovery writes temporary files which might not end up in the\n    right distributor directories today. This commit adds a dedicated\n    API that allows specifying the target file name in order to create the\n    tempoary file in the correct directory.\n\ncommit 7d574659f6ae04adc2b857146ad0d8d56ca66f12\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 10:28:49 2014 -0400\n\n    add some leniency to temporary bogus method\n\ncommit f97022ea7c2259f7a5cf97d924c59ed75ab65b32\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 10:24:17 2014 -0400\n\n    fix MultiCollector bug\n\ncommit b760533128c2b4eb10ad76e9689ef714293dd819\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:56:08 2014 +0100\n\n    CheckIndex is now closeable we need to close it\n\ncommit 9dae9fb6d63546a6c2427be2a2d5c8358f5b1934\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:45:11 2014 +0100\n\n    s/Lucene51/Lucene50\n\ncommit 7aea9b86856a8c1b06a08e7c312ede1168af1287\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:42:30 2014 +0100\n\n    fix BloomFilterPostingsFormat\n\ncommit 16fea6fe842e88665d59cc091e8224e8dc6ce08c\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:41:16 2014 +0100\n\n    fix some codec format issues\n\ncommit 3d77aa97dd2c4012b63befef3f2ba2525965e8a6\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:30:43 2014 +0100\n\n    fix CodecTests\n\ncommit 6ef823b1fde25657438ace1aabd9d552d6ae215e\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:26:47 2014 +0100\n\n    make it compile\n\ncommit 9991eee1fe99435118d4dd42b297ffc83fce5ec5\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 09:12:43 2014 -0400\n\n    add an ugly hack for TopHitsAggregator for now\n\ncommit 03e768a01fcae6b1f4cb50bcceec7d42977ac3e6\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Wed Oct 29 14:01:02 2014 +0100\n\n    cut over ES090PostingsFormat\n\ncommit 463d281faadb794fdde3b469326bdaada25af048\nMerge: 0f8740a 8eac79c\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 08:30:36 2014 -0400\n\n    Merge branch \u0027master\u0027 into enhancement/lucene_5_0_upgrade\n\ncommit 0f8740a782455a63524a5a82169f6bbbfc613518\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Wed Oct 29 01:00:15 2014 -0400\n\n    fix/hack remaining filter and analysis issues\n\ncommit df534488569da13b31d66e581456dfd4b55156b9\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Oct 28 23:11:47 2014 -0400\n\n    fix ngrams / openbitset usage\n\ncommit 11f5dc3b9887f4da80a0fa1818e1350b30599329\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Oct 28 22:42:44 2014 -0400\n\n    hack over sort comparators\n\ncommit 4ebdc754350f512596f6a02770d223e9f5f7975a\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Oct 28 21:27:07 2014 -0400\n\n    compiler errors \u003c 100\n\ncommit 2d60c9e29de48ccb0347dd87f7201f47b67b83a0\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Tue Oct 28 03:13:08 2014 -0400\n\n    clear some nocommits around ram usage\n\ncommit aaf47fe6c0aabcfb2581dd456fc50edf871da758\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 12:27:34 2014 -0400\n\n    migrate fieldinfo handling\n\ncommit ef6ed6d15d8def71cd880d97249678136cd29fe3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 12:07:13 2014 -0400\n\n    more simple fixes\n\ncommit f475e1048ae697dd9da5bd9da445102b0b7bc5b3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 11:58:21 2014 -0400\n\n    more fielddata ram accounting fixes\n\ncommit 16b4239eaa9b4262df258257df4f31d39f28a3a2\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 16:47:32 2014 +0100\n\n    add missing file\n\ncommit 5b542fa2a6da81e36a0c35b8e891a1d8bc58f663\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 16:43:29 2014 +0100\n\n    cut over completion posting formats - still some nocommits\n\ncommit ecdea49404c4ec4e1b78fb54575825f21b4e096e\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 11:21:09 2014 -0400\n\n    fielddata accountable fixes\n\ncommit d43da265718917e20c8264abd43342069198fe9c\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 16:19:53 2014 +0100\n\n    cut over BloomFilterPostings to new API\n\ncommit 29b192ba621c14820175775d01242162b88bd364\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 10:22:51 2014 -0400\n\n    fix more analyzers\n\ncommit 74b4a0c5283e323a7d02490df469497c722780d2\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 09:54:25 2014 -0400\n\n    fix tests\n\ncommit 554084ccb4779dd6b1c65fa7212ad1f64f3a6968\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 14:51:48 2014 +0100\n\n    maintain supressed exceptions on CorruptIndexException\n\ncommit cf882d9112c5e8ef1e9f2b0f800f7aa59001a4f2\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 14:47:17 2014 +0100\n\n    commitOnClose\u003dfalse\n\ncommit ebb2a9189ab2f459b7c6c9985be610fd90dfe410\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 14:46:06 2014 +0100\n\n    cut over indexwriter closeing in InternalEngine\n\ncommit cd21b3d4706f0b562bd37792d077d60832aff65f\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Mon Oct 27 14:38:10 2014 +0100\n\n    fix constant\n\ncommit f93f900c4a1c90af3a21a4af5735a7536423fe28\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Mon Oct 27 09:50:49 2014 -0400\n\n    fix test\n\ncommit a9a752940b1ab4699a6a08ba8b34afca82b843fe\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Mon Oct 27 09:26:18 2014 +0100\n\n    Be explicit about the index options\n\ncommit d9ee815babd030fa2ceaec9f467c105ee755bf6b\nAuthor: Simon Willnauer \u003csimonw@apache.org\u003e\nDate:   Sun Oct 26 20:03:44 2014 +0100\n\n    cut over store and directory\n\ncommit b3f5c8e39039dd8f5caac0c4dd1fc3b1116e64ca\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sun Oct 26 13:08:39 2014 -0400\n\n    more test fixes\n\ncommit 8842f2684e3606aae0860c27f7a4c53e273d47fb\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sun Oct 26 12:14:52 2014 -0400\n\n    tests manual labor\n\ncommit c43de5aec337919a3fdc3638406dff17fc80bc98\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sun Oct 26 11:04:13 2014 -0400\n\n    BytesRef -\u003e BytesRefBuilder\n\ncommit 020c0d087a2f37566a1db390b0e044ebab030138\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Sun Oct 26 15:53:37 2014 +0100\n\n    Moved over to BitSetFilter\n\ncommit 48dd1b909e6c52cef733961c9ecebfe4f67109fe\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Sun Oct 26 15:53:11 2014 +0100\n\n    Left over Collector api change in ScanContext\n\ncommit 6ec248ef63f262bcda400181b838fd9244752625\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Sun Oct 26 15:47:40 2014 +0100\n\n    Moved indexed() over to indexOptions !\u003d null or indexOptions \u003d\u003d null\n\ncommit 9937aebfd8546ae4bb652cd976b3b43ac5ab7a63\nAuthor: Martijn van Groningen \u003cmartijn.v.groningen@gmail.com\u003e\nDate:   Sun Oct 26 13:26:31 2014 +0100\n\n    Fixed many compile errors. Mainly around the breaking Collector api change in 5.0.\n\ncommit fec32c4abc0e3309cf34260c8816305a6f820c9e\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Oct 25 11:22:17 2014 -0400\n\n    more easy fixes\n\ncommit dab22531d801800d17a65dc7c9464148ce8ebffd\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Oct 25 09:33:41 2014 -0400\n\n    more progress\n\ncommit 414767e9a955010076b0497cc4f6d0c1850b48d3\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Sat Oct 25 06:33:17 2014 -0400\n\n    more progress\n\ncommit ad9d969fddf139a8830254d3eb36a908ba87cc12\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 24 14:28:01 2014 -0400\n\n    current state of fun\n\ncommit 464475eecb0be15d7d084135ed16051f76a7e521\nAuthor: Robert Muir \u003crmuir@apache.org\u003e\nDate:   Fri Oct 24 11:42:41 2014 -0400\n\n    bump to 5.0 snapshot\n",
      "commitDate": 1415220531000,
      "commitName": "610ce078fb3c84c47d6d32aff7d77ba850e28f9d",
      "commitAuthor": "Robert Muir",
      "commitDateOld": 1395932085000,
      "commitNameOld": "1952df982b69873544c00470293ee851697abbf4",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 223.25,
      "commitsBetweenForRepo": 2309,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,29 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n-        } else if (sourceQuery instanceof XFilteredQuery) {\n-            flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n-            flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else if (sourceQuery instanceof BlendedTermQuery) {\n             final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n             flatten(blendedTermQuery.rewrite(reader), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4a48b93cf5e35017b635256720e5f767c9583715": {
      "type": "Ybodychange",
      "commitMessage": "Implement BlendedTermQuery#extractTerms to support highlighing.\n\nsome of the highlighters require term extraction to be implemented in\norder to work. BlendedTermQuery doesn\u0027t implement the trivial extraction.\n\nCloses #5246\n",
      "commitDate": 1393319588000,
      "commitName": "4a48b93cf5e35017b635256720e5f767c9583715",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1390901739000,
      "commitNameOld": "91acca7836962aa6ae753fb6d270f0a9caff2981",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 27.98,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof SpanTermQuery) {\n             super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n-            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n+            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()], q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n+        } else if (sourceQuery instanceof BlendedTermQuery) {\n+            final BlendedTermQuery blendedTermQuery \u003d (BlendedTermQuery) sourceQuery;\n+            flatten(blendedTermQuery.rewrite(reader), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "91acca7836962aa6ae753fb6d270f0a9caff2981": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade to Lucene 4.6.1\n\nThis upgrade includes a fix for RAM estimation on IndexReader\nthat allows to expose the amount of used bytes per segment now\nas a setting in Elasticsearch. (LUCENE-5373)\n\nAdditionally this bugfix release contained a small fix for highlighting\nthat was already ported to Elasticsearch when reported (LUCENE-5361)\n\nCloses #4897\n",
      "commitDate": 1390901739000,
      "commitName": "91acca7836962aa6ae753fb6d270f0a9caff2981",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1389178308000,
      "commitNameOld": "8bd9e34e39eb586f1180c868f8b07b8c2b2cbdf2",
      "commitAuthorOld": "Nik Everett",
      "daysBetweenCommits": 19.95,
      "commitsBetweenForRepo": 312,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,29 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n-        assert Lucene.VERSION \u003d\u003d Version.LUCENE_46 : \"LUCENE-5361\";\n-        if( sourceQuery instanceof BooleanQuery ){\n-            BooleanQuery bq \u003d (BooleanQuery)sourceQuery;\n-            if (bq.getBoost() \u003d\u003d 1) {\n-                for( BooleanClause clause : bq.getClauses() ) {\n-                    if(!clause.isProhibited()) {\n-                        flatten(clause.getQuery(), reader, flatQueries);\n-                    }\n-                }\n-            } else {\n-                for( BooleanClause clause : bq.getClauses() ) {\n-                    if(!clause.isProhibited()) {\n-                        Query cloned \u003d clause.getQuery().clone();\n-                        cloned.setBoost(cloned.getBoost() * bq.getBoost());\n-                        flatten(cloned, reader, flatQueries);\n-                    }\n-                }\n-            }\n-        } else if (sourceQuery instanceof DisjunctionMaxQuery) {\n-            DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n-            if (dmq.getBoost() \u003d\u003d 1) {\n-                for (Query query : dmq) {\n-                    flatten(query, reader, flatQueries);\n-                }\n-            } else {\n-                for (Query query : dmq) {\n-                    Query clone \u003d query.clone();\n-                    clone.setBoost(clone.getBoost() * dmq.getBoost());\n-                    flatten(clone, reader, flatQueries);\n-                }\n-            }\n-        } else if (sourceQuery instanceof SpanTermQuery) {\n-            TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n-            if (!flatQueries.contains(termQuery)) {\n-                flatQueries.add(termQuery);\n-            }\n+        if (sourceQuery instanceof SpanTermQuery) {\n+            super.flatten(new TermQuery(((SpanTermQuery) sourceQuery).getTerm()), reader, flatQueries);\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n-        } \n+        }\n     }\n\\ No newline at end of file\n"
    },
    "8bd9e34e39eb586f1180c868f8b07b8c2b2cbdf2": {
      "type": "Ybodychange",
      "commitMessage": "Stop FVH from throwing away some query boosts\n\nThe FVH was throwing away some boosts on queries stopping a number of\nways to boost phrase matches to the top of the list of fragments from\nworking.\n\nThe plain highlighter also doesn\u0027t work for this but that is because it\ndoesn\u0027t support the concept of the same term having a different score at\ndifferent positions.\n\nAlso update documentation claiming that FHV is nicer for weighing terms\nfound by query combinations.\n\nCloses #4351\n",
      "commitDate": 1389178308000,
      "commitName": "8bd9e34e39eb586f1180c868f8b07b8c2b2cbdf2",
      "commitAuthor": "Nik Everett",
      "commitDateOld": 1389090121000,
      "commitNameOld": "10ec2e948a2f1426a5058ca3b2c2e39952f141d8",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,63 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n-        if (sourceQuery instanceof DisjunctionMaxQuery) {\n+        assert Lucene.VERSION \u003d\u003d Version.LUCENE_46 : \"LUCENE-5361\";\n+        if( sourceQuery instanceof BooleanQuery ){\n+            BooleanQuery bq \u003d (BooleanQuery)sourceQuery;\n+            if (bq.getBoost() \u003d\u003d 1) {\n+                for( BooleanClause clause : bq.getClauses() ) {\n+                    if(!clause.isProhibited()) {\n+                        flatten(clause.getQuery(), reader, flatQueries);\n+                    }\n+                }\n+            } else {\n+                for( BooleanClause clause : bq.getClauses() ) {\n+                    if(!clause.isProhibited()) {\n+                        Query cloned \u003d clause.getQuery().clone();\n+                        cloned.setBoost(cloned.getBoost() * bq.getBoost());\n+                        flatten(cloned, reader, flatQueries);\n+                    }\n+                }\n+            }\n+        } else if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n-            for (Query query : dmq) {\n-                flatten(query, reader, flatQueries);\n+            if (dmq.getBoost() \u003d\u003d 1) {\n+                for (Query query : dmq) {\n+                    flatten(query, reader, flatQueries);\n+                }\n+            } else {\n+                for (Query query : dmq) {\n+                    Query clone \u003d query.clone();\n+                    clone.setBoost(clone.getBoost() * dmq.getBoost());\n+                    flatten(clone, reader, flatQueries);\n+                }\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         } \n     }\n\\ No newline at end of file\n"
    },
    "11bf7a8b1a7ec88e4d38ee69c8b5c577001fb68d": {
      "type": "Ybodychange",
      "commitMessage": "Upgrade to Lucene 4.2\n",
      "commitDate": 1362986581000,
      "commitName": "11bf7a8b1a7ec88e4d38ee69c8b5c577001fb68d",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1359384085000,
      "commitNameOld": "72a2416a8c6abbef318bc243a230774ff2578e71",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 41.7,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,37 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n-        } else if (sourceQuery instanceof ExtendedCommonTermsQuery) {\n-            flatten(((ExtendedCommonTermsQuery)sourceQuery).rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhraseQuery) {\n             MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n             convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         } \n     }\n\\ No newline at end of file\n"
    },
    "72a2416a8c6abbef318bc243a230774ff2578e71": {
      "type": "Ybodychange",
      "commitMessage": "Support MultiPhrasePrefixQuery and MultiPhraseQuery in highlighters\n\nCloses #2596\n",
      "commitDate": 1359384085000,
      "commitName": "72a2416a8c6abbef318bc243a230774ff2578e71",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1359370625000,
      "commitNameOld": "48488f707f7fd42de0ce2f55ec5920a0846f2cbb",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,39 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n-            try {\n-                flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n-            } catch (IOException e) {\n-                // ignore\n-            }\n+            flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof ExtendedCommonTermsQuery) {\n             flatten(((ExtendedCommonTermsQuery)sourceQuery).rewrite(reader), reader, flatQueries);\n+        } else if (sourceQuery instanceof MultiPhraseQuery) {\n+            MultiPhraseQuery q \u003d ((MultiPhraseQuery) sourceQuery);\n+            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         } \n     }\n\\ No newline at end of file\n"
    },
    "48488f707f7fd42de0ce2f55ec5920a0846f2cbb": {
      "type": "Ybodychange",
      "commitMessage": "Expose CommonTermsQuery in Match \u0026 MultiMatch and enable highlighting\n\nCloses #2591\n",
      "commitDate": 1359370625000,
      "commitName": "48488f707f7fd42de0ce2f55ec5920a0846f2cbb",
      "commitAuthor": "Simon Willnauer",
      "commitDateOld": 1356806393000,
      "commitNameOld": "b6f766af3fc2ed0f16d6a4d73b9a3e6508c20a15",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 29.68,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof XFilteredQuery) {\n             flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             try {\n                 flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             }\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n+        } else if (sourceQuery instanceof ExtendedCommonTermsQuery) {\n+            flatten(((ExtendedCommonTermsQuery)sourceQuery).rewrite(reader), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n-        }\n+        } \n     }\n\\ No newline at end of file\n"
    },
    "c22b5218008fd81b62b74d0f510891b9bfbe9268": {
      "type": "Ybodychange",
      "commitMessage": "fix properly handling acceptDocs in filters\nour idea is to apply it on the \"filtered/constant\" level, and not on compound filters, so we won\u0027t apply it multiple times. The solution is conservative a bit now, we can further optimize it in the future, for example, not to wrap it when no caching is done within the filter chain\n",
      "commitDate": 1354755316000,
      "commitName": "c22b5218008fd81b62b74d0f510891b9bfbe9268",
      "commitAuthor": "Shay Banon",
      "commitDateOld": 1354039461000,
      "commitNameOld": "69ef822da6277d56d5fd6be42a2450fca95ee941",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n     void flatten(Query sourceQuery, IndexReader reader, Collection\u003cQuery\u003e flatQueries) throws IOException {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), reader, flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), reader, flatQueries);\n             }\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n+        } else if (sourceQuery instanceof XFilteredQuery) {\n+            flatten(((XFilteredQuery) sourceQuery).getQuery(), reader, flatQueries);\n+            flatten(((XFilteredQuery) sourceQuery).getFilter(), reader, flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             try {\n                 flatten(sourceQuery.rewrite(reader), reader, flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             }\n         } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n             flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), reader, flatQueries);\n         } else {\n             super.flatten(sourceQuery, reader, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": {
      "type": "Yfilerename",
      "commitMessage": "first cleanup phase, move to single src\n",
      "commitDate": 1323125963000,
      "commitName": "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
      "commitAuthor": "Shay Banon",
      "commitDateOld": 1323111612000,
      "commitNameOld": "473b0f4dff504690754acc0f00967c275bf322a8",
      "commitAuthorOld": "Shay Banon",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "f18ad903a913a937836787166db2cd842a27b498": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Upgrade to Lucene 3.5, closes #1502.\n",
      "commitDate": 1322391446000,
      "commitName": "f18ad903a913a937836787166db2cd842a27b498",
      "commitAuthor": "Shay Banon",
      "subchanges": [
        "Yparameterchange",
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "b652c655d23c1e175c5927fa23f3bffafdec44d2": {
      "type": "Ybodychange",
      "commitMessage": "Highlighting broken with custom_filters_score query, closes #1425.\n",
      "commitDate": 1319583532000,
      "commitName": "b652c655d23c1e175c5927fa23f3bffafdec44d2",
      "commitAuthor": "Shay Banon",
      "commitDateOld": 1309210146000,
      "commitNameOld": "73898067b8d30ac13188d6084d0c95662df6d72b",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 120.06,
      "commitsBetweenForRepo": 483,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,54 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), flatQueries);\n             }\n         } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n             flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             // we want to rewrite a multi term query to extract the terms out of it\n             // LUCENE MONITOR: The regular Highlighter actually uses MemoryIndex to extract the terms\n             multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n             try {\n                 flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             } catch (BooleanQuery.TooManyClauses e) {\n                 // ignore\n             } finally {\n                 multiTermQuery.setRewriteMethod(rewriteMethod);\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n             try {\n                 flatten(sourceQuery.rewrite(reader.get()), flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             }\n+        } else if (sourceQuery instanceof FiltersFunctionScoreQuery) {\n+            flatten(((FiltersFunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n+        } else if (sourceQuery instanceof FunctionScoreQuery) {\n+            flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "759d7d693d07cb9661a7484a9b837d8aa23b11b5": {
      "type": "Ybodychange",
      "commitMessage": "Support for highlighting of phrase prefix queries\n",
      "commitDate": 1309209966000,
      "commitName": "759d7d693d07cb9661a7484a9b837d8aa23b11b5",
      "commitAuthor": "Nicolas Lalevée",
      "commitDateOld": 1302779964000,
      "commitNameOld": "7550fc570ea5ad59f24fe6dd8d40cab7007a1829",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 74.42,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,50 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n             if (constantScoreQuery.getFilter() !\u003d null) {\n                 flatten(constantScoreQuery.getFilter(), flatQueries);\n             } else {\n                 flatten(constantScoreQuery.getQuery(), flatQueries);\n             }\n         } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n             flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             // we want to rewrite a multi term query to extract the terms out of it\n             // LUCENE MONITOR: The regular Highlighter actually uses MemoryIndex to extract the terms\n             multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n             try {\n                 flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             } catch (BooleanQuery.TooManyClauses e) {\n                 // ignore\n             } finally {\n                 multiTermQuery.setRewriteMethod(rewriteMethod);\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n+        } else if (sourceQuery instanceof MultiPhrasePrefixQuery) {\n+        \ttry {\n+        \t\tflatten(sourceQuery.rewrite(reader.get()), flatQueries);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "7550fc570ea5ad59f24fe6dd8d40cab7007a1829": {
      "type": "Ybodychange",
      "commitMessage": "Query DSL: Allow to directly wrap a query with a constant_score query, closes #857.\n",
      "commitDate": 1302779964000,
      "commitName": "7550fc570ea5ad59f24fe6dd8d40cab7007a1829",
      "commitAuthor": "kimchy",
      "commitDateOld": 1294449589000,
      "commitNameOld": "8de7beadc8267cd9a8e068ec13421499441d8bed",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 96.42,
      "commitsBetweenForRepo": 435,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,44 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n-            flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n+            ConstantScoreQuery constantScoreQuery \u003d (ConstantScoreQuery) sourceQuery;\n+            if (constantScoreQuery.getFilter() !\u003d null) {\n+                flatten(constantScoreQuery.getFilter(), flatQueries);\n+            } else {\n+                flatten(constantScoreQuery.getQuery(), flatQueries);\n+            }\n         } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n             flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             // we want to rewrite a multi term query to extract the terms out of it\n             // LUCENE MONITOR: The regular Highlighter actually uses MemoryIndex to extract the terms\n             multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n             try {\n                 flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n             } catch (IOException e) {\n                 // ignore\n             } catch (BooleanQuery.TooManyClauses e) {\n                 // ignore\n             } finally {\n                 multiTermQuery.setRewriteMethod(rewriteMethod);\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8de7beadc8267cd9a8e068ec13421499441d8bed": {
      "type": "Ybodychange",
      "commitMessage": "Highlighting: Sometimes highlighting returns empty fragments even thought there should be, closes #613.\n",
      "commitDate": 1294449589000,
      "commitName": "8de7beadc8267cd9a8e068ec13421499441d8bed",
      "commitAuthor": "kimchy",
      "commitDateOld": 1293747751000,
      "commitNameOld": "fd593acafe72dbb76b20ca8387a9ad88972843d1",
      "commitAuthorOld": "Tim Dysinger",
      "daysBetweenCommits": 8.12,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,39 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n             flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof FunctionScoreQuery) {\n             flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n-            if (rewriteMethod !\u003d MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE \u0026\u0026 rewriteMethod !\u003d MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n-                // we need to rewrite\n-                multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n-                try {\n-                    flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n-                } catch (IOException e) {\n-                    // ignore\n-                } catch (BooleanQuery.TooManyClauses e) {\n-                    // ignore\n-                } finally {\n-                    multiTermQuery.setRewriteMethod(rewriteMethod);\n-                }\n+            // we want to rewrite a multi term query to extract the terms out of it\n+            // LUCENE MONITOR: The regular Highlighter actually uses MemoryIndex to extract the terms\n+            multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n+            try {\n+                flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n+            } catch (IOException e) {\n+                // ignore\n+            } catch (BooleanQuery.TooManyClauses e) {\n+                // ignore\n+            } finally {\n+                multiTermQuery.setRewriteMethod(rewriteMethod);\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a9fc276a3ec849bb94fbe22e4039c4c3128ccef4": {
      "type": "Ybodychange",
      "commitMessage": "refactor the custom boost factor query into a more general function boost query\n",
      "commitDate": 1276437079000,
      "commitName": "a9fc276a3ec849bb94fbe22e4039c4c3128ccef4",
      "commitAuthor": "kimchy",
      "commitDateOld": 1276171476000,
      "commitNameOld": "5205a183e8324b53c2a2ac1c6b78b3403f56f765",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n             flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n-        } else if (sourceQuery instanceof CustomBoostFactorQuery) {\n-            flatten(((CustomBoostFactorQuery) sourceQuery).getSubQuery(), flatQueries);\n+        } else if (sourceQuery instanceof FunctionScoreQuery) {\n+            flatten(((FunctionScoreQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             if (rewriteMethod !\u003d MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE \u0026\u0026 rewriteMethod !\u003d MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n                 // we need to rewrite\n                 multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n                 try {\n                     flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n                 } catch (IOException e) {\n                     // ignore\n                 } catch (BooleanQuery.TooManyClauses e) {\n                     // ignore\n                 } finally {\n                     multiTermQuery.setRewriteMethod(rewriteMethod);\n                 }\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5205a183e8324b53c2a2ac1c6b78b3403f56f765": {
      "type": "Ybodychange",
      "commitMessage": "use deletion aware constant score query\n",
      "commitDate": 1276171476000,
      "commitName": "5205a183e8324b53c2a2ac1c6b78b3403f56f765",
      "commitAuthor": "kimchy",
      "commitDateOld": 1272350427000,
      "commitNameOld": "cb8faaa13f34f8340eb9050fbbfcc21cc44d7af7",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 44.23,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n             flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n+        } else if (sourceQuery instanceof DeletionAwareConstantScoreQuery) {\n+            flatten(((DeletionAwareConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n         } else if (sourceQuery instanceof CustomBoostFactorQuery) {\n             flatten(((CustomBoostFactorQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             if (rewriteMethod !\u003d MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE \u0026\u0026 rewriteMethod !\u003d MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n                 // we need to rewrite\n                 multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n                 try {\n                     flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n                 } catch (IOException e) {\n                     // ignore\n                 } catch (BooleanQuery.TooManyClauses e) {\n                     // ignore\n                 } finally {\n                     multiTermQuery.setRewriteMethod(rewriteMethod);\n                 }\n             }\n         } else if (sourceQuery instanceof FilteredQuery) {\n             flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n             flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cb8faaa13f34f8340eb9050fbbfcc21cc44d7af7": {
      "type": "Ybodychange",
      "commitMessage": "improve query handling (rewrite) when searching, try and minize the number of rewrites. Also, better highlighting when wrapping in filtered query\n",
      "commitDate": 1272350427000,
      "commitName": "cb8faaa13f34f8340eb9050fbbfcc21cc44d7af7",
      "commitAuthor": "kimchy",
      "commitDateOld": 1272209566000,
      "commitNameOld": "bf6cead984ffe9fbb13d6374e2dc7ffe1411f341",
      "commitAuthorOld": "kimchy",
      "daysBetweenCommits": 1.63,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,38 @@\n     @Override void flatten(Query sourceQuery, Collection\u003cQuery\u003e flatQueries) {\n         if (sourceQuery instanceof DisjunctionMaxQuery) {\n             DisjunctionMaxQuery dmq \u003d (DisjunctionMaxQuery) sourceQuery;\n             for (Query query : dmq) {\n                 flatten(query, flatQueries);\n             }\n         } else if (sourceQuery instanceof SpanTermQuery) {\n             TermQuery termQuery \u003d new TermQuery(((SpanTermQuery) sourceQuery).getTerm());\n             if (!flatQueries.contains(termQuery)) {\n                 flatQueries.add(termQuery);\n             }\n         } else if (sourceQuery instanceof ConstantScoreQuery) {\n-            Boolean highlight \u003d highlightFilters.get();\n-            if (highlight !\u003d null \u0026\u0026 highlight.equals(Boolean.TRUE)) {\n-                flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n-            }\n+            flatten(((ConstantScoreQuery) sourceQuery).getFilter(), flatQueries);\n+        } else if (sourceQuery instanceof CustomBoostFactorQuery) {\n+            flatten(((CustomBoostFactorQuery) sourceQuery).getSubQuery(), flatQueries);\n         } else if (sourceQuery instanceof MultiTermQuery) {\n             MultiTermQuery multiTermQuery \u003d (MultiTermQuery) sourceQuery;\n             MultiTermQuery.RewriteMethod rewriteMethod \u003d multiTermQuery.getRewriteMethod();\n             if (rewriteMethod !\u003d MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE \u0026\u0026 rewriteMethod !\u003d MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n                 // we need to rewrite\n                 multiTermQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n                 try {\n                     flatten(multiTermQuery.rewrite(reader.get()), flatQueries);\n                 } catch (IOException e) {\n                     // ignore\n+                } catch (BooleanQuery.TooManyClauses e) {\n+                    // ignore\n                 } finally {\n                     multiTermQuery.setRewriteMethod(rewriteMethod);\n                 }\n             }\n+        } else if (sourceQuery instanceof FilteredQuery) {\n+            flatten(((FilteredQuery) sourceQuery).getQuery(), flatQueries);\n+            flatten(((FilteredQuery) sourceQuery).getFilter(), flatQueries);\n         } else {\n             super.flatten(sourceQuery, flatQueries);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "bf6cead984ffe9fbb13d6374e2dc7ffe1411f341": {
      "type": "Yintroduced",
      "commitMessage": "Highlighting broken when query is on `_all` field or with prefixes. Add also a flag to highlight to control if filters should be highlighted or not (called highlight_filters) which defaults to true. Closes #148.\n",
      "commitDate": 1272209566000,
      "commitName": "bf6cead984ffe9fbb13d6374e2dc7ffe1411f341",
      "commitAuthor": "kimchy"
    }
  }
}