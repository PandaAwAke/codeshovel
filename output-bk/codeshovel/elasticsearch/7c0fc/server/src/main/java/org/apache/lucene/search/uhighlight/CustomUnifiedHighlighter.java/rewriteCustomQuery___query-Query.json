{
  "origin": "codeshovel",
  "repositoryName": "elasticsearch",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/elasticsearch/.git",
  "startCommitName": "7c0fc209bf78e4824ca1f232b84a1dab22bc2dfa",
  "sourceFileName": "CustomUnifiedHighlighter.java",
  "functionName": "rewriteCustomQuery",
  "functionId": "rewriteCustomQuery___query-Query",
  "sourceFilePath": "server/src/main/java/org/apache/lucene/search/uhighlight/CustomUnifiedHighlighter.java",
  "functionStartLine": 165,
  "functionEndLine": 215,
  "changeHistory": [
    "bd1c513422d63d8f7df1fac6743ba7fd7133fa9e",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
    "86d97971a44451d8c77c93aec6b1b7f661a95620",
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
    "562c3744cab91aa083cb645c67ef57ebb20c8661",
    "c8bf7ecaeda5f0670e67b8af1619d78da595fa21",
    "f6d38d480af8b2b1f4731bd7373b84b934d809b5"
  ],
  "changeHistoryShort": {
    "bd1c513422d63d8f7df1fac6743ba7fd7133fa9e": "Ybodychange",
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": "Yfilerename",
    "86d97971a44451d8c77c93aec6b1b7f661a95620": "Ybodychange",
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0": "Ybodychange",
    "562c3744cab91aa083cb645c67ef57ebb20c8661": "Ybodychange",
    "c8bf7ecaeda5f0670e67b8af1619d78da595fa21": "Ybodychange",
    "f6d38d480af8b2b1f4731bd7373b84b934d809b5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bd1c513422d63d8f7df1fac6743ba7fd7133fa9e": {
      "type": "Ybodychange",
      "commitMessage": "Reduce more raw types warnings (#31780)\n\nSimilar to #31523.",
      "commitDate": 1530797886000,
      "commitName": "bd1c513422d63d8f7df1fac6743ba7fd7133fa9e",
      "commitAuthor": "Christoph BÃ¼scher",
      "commitDateOld": 1520006945000,
      "commitNameOld": "f53d159aa180c425775f49563bd58870287cd15d",
      "commitAuthorOld": "Mayya Sharipova",
      "daysBetweenCommits": 124.9,
      "commitsBetweenForRepo": 1728,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     private Collection\u003cQuery\u003e rewriteCustomQuery(Query query) {\n         if (query instanceof MultiPhrasePrefixQuery) {\n             MultiPhrasePrefixQuery mpq \u003d (MultiPhrasePrefixQuery) query;\n             Term[][] terms \u003d mpq.getTerms();\n             int[] positions \u003d mpq.getPositions();\n             SpanQuery[] positionSpanQueries \u003d new SpanQuery[positions.length];\n             int sizeMinus1 \u003d terms.length - 1;\n             for (int i \u003d 0; i \u003c positions.length; i++) {\n                 SpanQuery[] innerQueries \u003d new SpanQuery[terms[i].length];\n                 for (int j \u003d 0; j \u003c terms[i].length; j++) {\n                     if (i \u003d\u003d sizeMinus1) {\n-                        innerQueries[j] \u003d new SpanMultiTermQueryWrapper(new PrefixQuery(terms[i][j]));\n+                        innerQueries[j] \u003d new SpanMultiTermQueryWrapper\u003cPrefixQuery\u003e(new PrefixQuery(terms[i][j]));\n                     } else {\n                         innerQueries[j] \u003d new SpanTermQuery(terms[i][j]);\n                     }\n                 }\n                 if (innerQueries.length \u003e 1) {\n                     positionSpanQueries[i] \u003d new SpanOrQuery(innerQueries);\n                 } else {\n                     positionSpanQueries[i] \u003d innerQueries[0];\n                 }\n             }\n \n             if (positionSpanQueries.length \u003d\u003d 1) {\n                 return Collections.singletonList(positionSpanQueries[0]);\n             }\n             // sum position increments beyond 1\n             int positionGaps \u003d 0;\n             if (positions.length \u003e\u003d 2) {\n                 // positions are in increasing order.   max(0,...) is just a safeguard.\n                 positionGaps \u003d Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n             }\n             //if original slop is 0 then require inOrder\n             boolean inorder \u003d (mpq.getSlop() \u003d\u003d 0);\n             return Collections.singletonList(new SpanNearQuery(positionSpanQueries,\n                 mpq.getSlop() + positionGaps, inorder));\n         } else if (query instanceof CommonTermsQuery) {\n             CommonTermsQuery ctq \u003d (CommonTermsQuery) query;\n             List\u003cQuery\u003e tqs \u003d new ArrayList\u003c\u003e ();\n             for (Term term : ctq.getTerms()) {\n                 tqs.add(new TermQuery(term));\n             }\n             return tqs;\n         } else if (query instanceof FunctionScoreQuery) {\n             return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery());\n         } else if (query instanceof ESToParentBlockJoinQuery) {\n             return Collections.singletonList(((ESToParentBlockJoinQuery) query).getChildQuery());\n         } else {\n             return null;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
      "type": "Yfilerename",
      "commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
      "commitDate": 1515695443000,
      "commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
      "commitAuthor": "Tim Brooks",
      "commitDateOld": 1515688270000,
      "commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
      "commitAuthorOld": "Martijn van Groningen",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "86d97971a44451d8c77c93aec6b1b7f661a95620": {
      "type": "Ybodychange",
      "commitMessage": "Remove the _all metadata field (#26356)\n\n* Remove the _all metadata field\r\n\r\nThis change removes the `_all` metadata field. This field is deprecated in 6\r\nand cannot be activated for indices created in 6 so it can be safely removed in\r\nthe next major version (e.g. 7).",
      "commitDate": 1503935039000,
      "commitName": "86d97971a44451d8c77c93aec6b1b7f661a95620",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1503394605000,
      "commitNameOld": "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 6.26,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,51 @@\n     private Collection\u003cQuery\u003e rewriteCustomQuery(Query query) {\n         if (query instanceof MultiPhrasePrefixQuery) {\n             MultiPhrasePrefixQuery mpq \u003d (MultiPhrasePrefixQuery) query;\n             Term[][] terms \u003d mpq.getTerms();\n             int[] positions \u003d mpq.getPositions();\n             SpanQuery[] positionSpanQueries \u003d new SpanQuery[positions.length];\n             int sizeMinus1 \u003d terms.length - 1;\n             for (int i \u003d 0; i \u003c positions.length; i++) {\n                 SpanQuery[] innerQueries \u003d new SpanQuery[terms[i].length];\n                 for (int j \u003d 0; j \u003c terms[i].length; j++) {\n                     if (i \u003d\u003d sizeMinus1) {\n                         innerQueries[j] \u003d new SpanMultiTermQueryWrapper(new PrefixQuery(terms[i][j]));\n                     } else {\n                         innerQueries[j] \u003d new SpanTermQuery(terms[i][j]);\n                     }\n                 }\n                 if (innerQueries.length \u003e 1) {\n                     positionSpanQueries[i] \u003d new SpanOrQuery(innerQueries);\n                 } else {\n                     positionSpanQueries[i] \u003d innerQueries[0];\n                 }\n             }\n \n             if (positionSpanQueries.length \u003d\u003d 1) {\n                 return Collections.singletonList(positionSpanQueries[0]);\n             }\n             // sum position increments beyond 1\n             int positionGaps \u003d 0;\n             if (positions.length \u003e\u003d 2) {\n                 // positions are in increasing order.   max(0,...) is just a safeguard.\n                 positionGaps \u003d Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n             }\n             //if original slop is 0 then require inOrder\n             boolean inorder \u003d (mpq.getSlop() \u003d\u003d 0);\n             return Collections.singletonList(new SpanNearQuery(positionSpanQueries,\n                 mpq.getSlop() + positionGaps, inorder));\n         } else if (query instanceof CommonTermsQuery) {\n             CommonTermsQuery ctq \u003d (CommonTermsQuery) query;\n             List\u003cQuery\u003e tqs \u003d new ArrayList\u003c\u003e ();\n             for (Term term : ctq.getTerms()) {\n                 tqs.add(new TermQuery(term));\n             }\n             return tqs;\n-        } else if (query instanceof AllTermQuery) {\n-            AllTermQuery atq \u003d (AllTermQuery) query;\n-            return Collections.singletonList(new TermQuery(atq.getTerm()));\n         } else if (query instanceof FunctionScoreQuery) {\n             return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery());\n         } else if (query instanceof ESToParentBlockJoinQuery) {\n             return Collections.singletonList(((ESToParentBlockJoinQuery) query).getChildQuery());\n         } else {\n             return null;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4756c9a884f3e5341db0cf7799e7e8656c7338d0": {
      "type": "Ybodychange",
      "commitMessage": "Fix nested query highlighting (#26305)\n\nThis commit extracts the inner query in the ESToParentBlockJoinQuery for highlighting.\r\nThis query has been added in 5.4 and breaks plain highlighting on nested queries.\r\nHighlighters that use postings or term vectors are not affected because they can\u0027t highlight nested documents correctly.\r\n\r\nFixes #26230",
      "commitDate": 1503394605000,
      "commitName": "4756c9a884f3e5341db0cf7799e7e8656c7338d0",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1501226540000,
      "commitNameOld": "562c3744cab91aa083cb645c67ef57ebb20c8661",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 25.09,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n     private Collection\u003cQuery\u003e rewriteCustomQuery(Query query) {\n         if (query instanceof MultiPhrasePrefixQuery) {\n             MultiPhrasePrefixQuery mpq \u003d (MultiPhrasePrefixQuery) query;\n             Term[][] terms \u003d mpq.getTerms();\n             int[] positions \u003d mpq.getPositions();\n             SpanQuery[] positionSpanQueries \u003d new SpanQuery[positions.length];\n             int sizeMinus1 \u003d terms.length - 1;\n             for (int i \u003d 0; i \u003c positions.length; i++) {\n                 SpanQuery[] innerQueries \u003d new SpanQuery[terms[i].length];\n                 for (int j \u003d 0; j \u003c terms[i].length; j++) {\n                     if (i \u003d\u003d sizeMinus1) {\n                         innerQueries[j] \u003d new SpanMultiTermQueryWrapper(new PrefixQuery(terms[i][j]));\n                     } else {\n                         innerQueries[j] \u003d new SpanTermQuery(terms[i][j]);\n                     }\n                 }\n                 if (innerQueries.length \u003e 1) {\n                     positionSpanQueries[i] \u003d new SpanOrQuery(innerQueries);\n                 } else {\n                     positionSpanQueries[i] \u003d innerQueries[0];\n                 }\n             }\n \n             if (positionSpanQueries.length \u003d\u003d 1) {\n                 return Collections.singletonList(positionSpanQueries[0]);\n             }\n             // sum position increments beyond 1\n             int positionGaps \u003d 0;\n             if (positions.length \u003e\u003d 2) {\n                 // positions are in increasing order.   max(0,...) is just a safeguard.\n                 positionGaps \u003d Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n             }\n             //if original slop is 0 then require inOrder\n             boolean inorder \u003d (mpq.getSlop() \u003d\u003d 0);\n             return Collections.singletonList(new SpanNearQuery(positionSpanQueries,\n                 mpq.getSlop() + positionGaps, inorder));\n         } else if (query instanceof CommonTermsQuery) {\n             CommonTermsQuery ctq \u003d (CommonTermsQuery) query;\n             List\u003cQuery\u003e tqs \u003d new ArrayList\u003c\u003e ();\n             for (Term term : ctq.getTerms()) {\n                 tqs.add(new TermQuery(term));\n             }\n             return tqs;\n         } else if (query instanceof AllTermQuery) {\n             AllTermQuery atq \u003d (AllTermQuery) query;\n             return Collections.singletonList(new TermQuery(atq.getTerm()));\n         } else if (query instanceof FunctionScoreQuery) {\n             return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery());\n+        } else if (query instanceof ESToParentBlockJoinQuery) {\n+            return Collections.singletonList(((ESToParentBlockJoinQuery) query).getChildQuery());\n         } else {\n             return null;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "562c3744cab91aa083cb645c67ef57ebb20c8661": {
      "type": "Ybodychange",
      "commitMessage": "Merge FunctionScoreQuery and FiltersFunctionScoreQuery (#25889)\n\nThis change merges the functionality of the FiltersFunctionScoreQuery in the FunctionScoreQuery.\r\nIt also ensures that an exception is thrown when the computed score is equals to Float.NaN or Float.NEGATIVE_INFINITY.\r\nThese scores are invalid for TopDocsCollectors that relies on score comparison.\r\n\r\nFixes #15709\r\nFixes #23628",
      "commitDate": 1501226540000,
      "commitName": "562c3744cab91aa083cb645c67ef57ebb20c8661",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1500311446000,
      "commitNameOld": "41ea8fdcec064b5920a1ae392974fa6c51e9aef6",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 10.59,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,52 @@\n     private Collection\u003cQuery\u003e rewriteCustomQuery(Query query) {\n         if (query instanceof MultiPhrasePrefixQuery) {\n             MultiPhrasePrefixQuery mpq \u003d (MultiPhrasePrefixQuery) query;\n             Term[][] terms \u003d mpq.getTerms();\n             int[] positions \u003d mpq.getPositions();\n             SpanQuery[] positionSpanQueries \u003d new SpanQuery[positions.length];\n             int sizeMinus1 \u003d terms.length - 1;\n             for (int i \u003d 0; i \u003c positions.length; i++) {\n                 SpanQuery[] innerQueries \u003d new SpanQuery[terms[i].length];\n                 for (int j \u003d 0; j \u003c terms[i].length; j++) {\n                     if (i \u003d\u003d sizeMinus1) {\n                         innerQueries[j] \u003d new SpanMultiTermQueryWrapper(new PrefixQuery(terms[i][j]));\n                     } else {\n                         innerQueries[j] \u003d new SpanTermQuery(terms[i][j]);\n                     }\n                 }\n                 if (innerQueries.length \u003e 1) {\n                     positionSpanQueries[i] \u003d new SpanOrQuery(innerQueries);\n                 } else {\n                     positionSpanQueries[i] \u003d innerQueries[0];\n                 }\n             }\n \n             if (positionSpanQueries.length \u003d\u003d 1) {\n                 return Collections.singletonList(positionSpanQueries[0]);\n             }\n             // sum position increments beyond 1\n             int positionGaps \u003d 0;\n             if (positions.length \u003e\u003d 2) {\n                 // positions are in increasing order.   max(0,...) is just a safeguard.\n                 positionGaps \u003d Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n             }\n             //if original slop is 0 then require inOrder\n             boolean inorder \u003d (mpq.getSlop() \u003d\u003d 0);\n             return Collections.singletonList(new SpanNearQuery(positionSpanQueries,\n                 mpq.getSlop() + positionGaps, inorder));\n         } else if (query instanceof CommonTermsQuery) {\n             CommonTermsQuery ctq \u003d (CommonTermsQuery) query;\n             List\u003cQuery\u003e tqs \u003d new ArrayList\u003c\u003e ();\n             for (Term term : ctq.getTerms()) {\n                 tqs.add(new TermQuery(term));\n             }\n             return tqs;\n         } else if (query instanceof AllTermQuery) {\n             AllTermQuery atq \u003d (AllTermQuery) query;\n             return Collections.singletonList(new TermQuery(atq.getTerm()));\n         } else if (query instanceof FunctionScoreQuery) {\n             return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery());\n-        } else if (query instanceof FiltersFunctionScoreQuery) {\n-            return Collections.singletonList(((FiltersFunctionScoreQuery) query).getSubQuery());\n         } else {\n             return null;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c8bf7ecaeda5f0670e67b8af1619d78da595fa21": {
      "type": "Ybodychange",
      "commitMessage": "Higlighters: Fix MultiPhrasePrefixQuery rewriting (#25103)\n\nThe unified highlighter rewrites MultiPhrasePrefixQuery to SpanNearQuer even when there is a single term in the phrase.\r\nThough SpanNearQuery throws an exception when the number of clauses is less than 2.\r\nThis change returns a simple PrefixQuery when there is a single term and builds the SpanNearQuery otherwise.\r\n\r\nRelates #25088",
      "commitDate": 1496844868000,
      "commitName": "c8bf7ecaeda5f0670e67b8af1619d78da595fa21",
      "commitAuthor": "Jim Ferenczi",
      "commitDateOld": 1489770613000,
      "commitNameOld": "b8c352fc3fa0595d074dd03766cc3313deab3d0e",
      "commitAuthorOld": "Jim Ferenczi",
      "daysBetweenCommits": 81.88,
      "commitsBetweenForRepo": 976,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,54 @@\n     private Collection\u003cQuery\u003e rewriteCustomQuery(Query query) {\n         if (query instanceof MultiPhrasePrefixQuery) {\n             MultiPhrasePrefixQuery mpq \u003d (MultiPhrasePrefixQuery) query;\n             Term[][] terms \u003d mpq.getTerms();\n             int[] positions \u003d mpq.getPositions();\n             SpanQuery[] positionSpanQueries \u003d new SpanQuery[positions.length];\n             int sizeMinus1 \u003d terms.length - 1;\n             for (int i \u003d 0; i \u003c positions.length; i++) {\n                 SpanQuery[] innerQueries \u003d new SpanQuery[terms[i].length];\n                 for (int j \u003d 0; j \u003c terms[i].length; j++) {\n                     if (i \u003d\u003d sizeMinus1) {\n                         innerQueries[j] \u003d new SpanMultiTermQueryWrapper(new PrefixQuery(terms[i][j]));\n                     } else {\n                         innerQueries[j] \u003d new SpanTermQuery(terms[i][j]);\n                     }\n                 }\n                 if (innerQueries.length \u003e 1) {\n                     positionSpanQueries[i] \u003d new SpanOrQuery(innerQueries);\n                 } else {\n                     positionSpanQueries[i] \u003d innerQueries[0];\n                 }\n             }\n+\n+            if (positionSpanQueries.length \u003d\u003d 1) {\n+                return Collections.singletonList(positionSpanQueries[0]);\n+            }\n             // sum position increments beyond 1\n             int positionGaps \u003d 0;\n             if (positions.length \u003e\u003d 2) {\n                 // positions are in increasing order.   max(0,...) is just a safeguard.\n                 positionGaps \u003d Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n             }\n-\n             //if original slop is 0 then require inOrder\n             boolean inorder \u003d (mpq.getSlop() \u003d\u003d 0);\n             return Collections.singletonList(new SpanNearQuery(positionSpanQueries,\n                 mpq.getSlop() + positionGaps, inorder));\n         } else if (query instanceof CommonTermsQuery) {\n             CommonTermsQuery ctq \u003d (CommonTermsQuery) query;\n             List\u003cQuery\u003e tqs \u003d new ArrayList\u003c\u003e ();\n             for (Term term : ctq.getTerms()) {\n                 tqs.add(new TermQuery(term));\n             }\n             return tqs;\n         } else if (query instanceof AllTermQuery) {\n             AllTermQuery atq \u003d (AllTermQuery) query;\n             return Collections.singletonList(new TermQuery(atq.getTerm()));\n         } else if (query instanceof FunctionScoreQuery) {\n             return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery());\n         } else if (query instanceof FiltersFunctionScoreQuery) {\n             return Collections.singletonList(((FiltersFunctionScoreQuery) query).getSubQuery());\n         } else {\n             return null;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f6d38d480af8b2b1f4731bd7373b84b934d809b5": {
      "type": "Yintroduced",
      "commitMessage": "Integrate UnifiedHighlighter (#21621)\n\n* Integrate UnifiedHighlighter\r\n\r\nThis change integrates the Lucene highlighter called \"unified\" in the list of supported highlighters for ES.\r\nThis highlighter can extract offsets from either postings, term vectors, or via re-analyzing text.\r\nThe best strategy is picked automatically at query time and depends on the field and the query to highlight.",
      "commitDate": 1485885963000,
      "commitName": "f6d38d480af8b2b1f4731bd7373b84b934d809b5",
      "commitAuthor": "Jim Ferenczi"
    }
  }
}