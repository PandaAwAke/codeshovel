{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "JavadocMethodCheck.java",
  "functionName": "getMethodTags",
  "functionId": "getMethodTags___comment-TextBlock",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java",
  "functionStartLine": 561,
  "functionEndLine": 602,
  "changeHistory": [
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "5b01236f52f59b632659cac386768805f7a9006f",
    "af095344e1501d55b2dfbbd18deaf305e814601c",
    "4c078ba710068498ca513ce115993e30dab4562a",
    "89a51ba032fd9126651fa9efad31baf10c006ddf",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "1aee9d55cc5bd8cca011e17369f6e370efcc85bb",
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94",
    "e27489c7721909245ea5055eac3b9c7c659081f6",
    "8fb2acd39b7db6223486f5e06126c7f0a2642a72",
    "24ba45a971569b9702e6bf78c5c07c48beb25464",
    "04ac5dd87c11a2bf7b908b45bbca7933382df515",
    "65440ae208e3b2f2a88f76ff41977ae9b70bfab4",
    "8e55d5c09147620f59461387d45d09c2bc0bbd6e",
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf"
  ],
  "changeHistoryShort": {
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "5b01236f52f59b632659cac386768805f7a9006f": "Ybodychange",
    "af095344e1501d55b2dfbbd18deaf305e814601c": "Ybodychange",
    "4c078ba710068498ca513ce115993e30dab4562a": "Ymodifierchange",
    "89a51ba032fd9126651fa9efad31baf10c006ddf": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": "Ybodychange",
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d": "Ymultichange(Yreturntypechange,Ybodychange)",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "1aee9d55cc5bd8cca011e17369f6e370efcc85bb": "Ybodychange",
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94": "Ybodychange",
    "e27489c7721909245ea5055eac3b9c7c659081f6": "Ybodychange",
    "8fb2acd39b7db6223486f5e06126c7f0a2642a72": "Ymultichange(Yparameterchange,Ybodychange)",
    "24ba45a971569b9702e6bf78c5c07c48beb25464": "Ymultichange(Yparameterchange,Ybodychange)",
    "04ac5dd87c11a2bf7b908b45bbca7933382df515": "Yfilerename",
    "65440ae208e3b2f2a88f76ff41977ae9b70bfab4": "Ybodychange",
    "8e55d5c09147620f59461387d45d09c2bc0bbd6e": "Ybodychange",
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": 1474426326000,
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1473886714000,
      "commitNameOld": "25a37e5049b7816b34c552899841a978efc37a63",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     private static List\u003cJavadocTag\u003e getMethodTags(TextBlock comment) {\n         final String[] lines \u003d comment.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n+        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n         int currentLine \u003d comment.getStartLineNo() - 1;\n         final int startColumnNumber \u003d comment.getStartColNo();\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             final Matcher javadocArgMatcher \u003d\n                 MATCH_JAVADOC_ARG.matcher(lines[i]);\n             final Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             final Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             final Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             final Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n \n             if (javadocArgMatcher.find()) {\n                 final int col \u003d calculateTagColumn(javadocArgMatcher, i, startColumnNumber);\n                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),\n                         javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 final int col \u003d calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);\n                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 final int col \u003d calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);\n                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final int col \u003d calculateTagColumn(argMultilineStart, i, startColumnNumber);\n                 tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));\n             }\n             else if (noargMultilineStart.find()) {\n                 tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "5b01236f52f59b632659cac386768805f7a9006f": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Refactoring of JavadocMethodCheck to reduce its method length.\n",
      "commitDate": 1440682230000,
      "commitName": "5b01236f52f59b632659cac386768805f7a9006f",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1440682229000,
      "commitNameOld": "6f1840f011cea3a523d9df1278d4a0af98e1d967",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,42 @@\n     private static List\u003cJavadocTag\u003e getMethodTags(TextBlock comment) {\n         final String[] lines \u003d comment.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         int currentLine \u003d comment.getStartLineNo() - 1;\n+        final int startColumnNumber \u003d comment.getStartColNo();\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             final Matcher javadocArgMatcher \u003d\n                 MATCH_JAVADOC_ARG.matcher(lines[i]);\n             final Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             final Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             final Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             final Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n \n             if (javadocArgMatcher.find()) {\n-                int col \u003d javadocArgMatcher.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d comment.getStartColNo();\n-                }\n-                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher\n-                        .group(1), javadocArgMatcher.group(2)));\n+                final int col \u003d calculateTagColumn(javadocArgMatcher, i, startColumnNumber);\n+                tags.add(new JavadocTag(currentLine, col, javadocArgMatcher.group(1),\n+                        javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n-                int col \u003d javadocNoargMatcher.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d comment.getStartColNo();\n-                }\n-                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher\n-                        .group(1)));\n+                final int col \u003d calculateTagColumn(javadocNoargMatcher, i, startColumnNumber);\n+                tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher.group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n-                int col \u003d noargCurlyMatcher.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d comment.getStartColNo();\n-                }\n-                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher\n-                        .group(1)));\n+                final int col \u003d calculateTagColumn(noargCurlyMatcher, i, startColumnNumber);\n+                tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher.group(1)));\n             }\n             else if (argMultilineStart.find()) {\n-                final String p1 \u003d argMultilineStart.group(1);\n-                final String p2 \u003d argMultilineStart.group(2);\n-                int col \u003d argMultilineStart.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d comment.getStartColNo();\n-                }\n-\n-                // Look for the rest of the comment if all we saw was\n-                // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n-                // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n-                // not whitespace or \u0027*\u0027 characters.\n-                int remIndex \u003d i + 1;\n-                while (remIndex \u003c lines.length) {\n-                    final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n-                            .matcher(lines[remIndex]);\n-                    if (multilineCont.find()) {\n-                        remIndex \u003d lines.length;\n-                        final String lFin \u003d multilineCont.group(1);\n-                        if (!lFin.equals(NEXT_TAG)\n-                            \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n-                            tags.add(new JavadocTag(currentLine, col, p1, p2));\n-                        }\n-                    }\n-                    remIndex++;\n-                }\n+                final int col \u003d calculateTagColumn(argMultilineStart, i, startColumnNumber);\n+                tags.addAll(getMultilineArgTags(argMultilineStart, col, lines, i, currentLine));\n             }\n             else if (noargMultilineStart.find()) {\n-                final String p1 \u003d noargMultilineStart.group(1);\n-                final int col \u003d noargMultilineStart.start(1) - 1;\n-\n-                // Look for the rest of the comment if all we saw was\n-                // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n-                // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n-                // not whitespace or \u0027*\u0027 characters.\n-                int remIndex \u003d i + 1;\n-                while (remIndex \u003c lines.length) {\n-                    final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n-                            .matcher(lines[remIndex]);\n-                    multilineCont.find();\n-                    remIndex \u003d lines.length;\n-                    final String lFin \u003d multilineCont.group(1);\n-                    if (!lFin.equals(NEXT_TAG)\n-                        \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n-                        tags.add(new JavadocTag(currentLine, col, p1));\n-                    }\n-                    remIndex++;\n-                }\n+                tags.addAll(getMultilineNoArgTags(noargMultilineStart, lines, i, currentLine));\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "af095344e1501d55b2dfbbd18deaf305e814601c": {
      "type": "Ybodychange",
      "commitMessage": "Add tests and refactor JavadocMethod check. #1308\n",
      "commitDate": 1438285571000,
      "commitName": "af095344e1501d55b2dfbbd18deaf305e814601c",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1437631122000,
      "commitNameOld": "acbd47a66b01acc392a7bd37ad3a2e65eecd308a",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 7.57,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,94 @@\n     private static List\u003cJavadocTag\u003e getMethodTags(TextBlock comment) {\n         final String[] lines \u003d comment.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         int currentLine \u003d comment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             final Matcher javadocArgMatcher \u003d\n                 MATCH_JAVADOC_ARG.matcher(lines[i]);\n             final Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             final Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             final Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             final Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n \n             if (javadocArgMatcher.find()) {\n                 int col \u003d javadocArgMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher\n                         .group(1), javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 int col \u003d javadocNoargMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher\n                         .group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 int col \u003d noargCurlyMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher\n                         .group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n                 int col \u003d argMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG)\n                             \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n                             tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n-                int col \u003d noargMultilineStart.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d comment.getStartColNo();\n-                }\n+                final int col \u003d noargMultilineStart.start(1) - 1;\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n-                    if (multilineCont.find()) {\n-                        remIndex \u003d lines.length;\n-                        final String lFin \u003d multilineCont.group(1);\n-                        if (!lFin.equals(NEXT_TAG)\n-                            \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n-                            tags.add(new JavadocTag(currentLine, col, p1));\n-                        }\n+                    multilineCont.find();\n+                    remIndex \u003d lines.length;\n+                    final String lFin \u003d multilineCont.group(1);\n+                    if (!lFin.equals(NEXT_TAG)\n+                        \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n+                        tags.add(new JavadocTag(currentLine, col, p1));\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "4c078ba710068498ca513ce115993e30dab4562a": {
      "type": "Ymodifierchange",
      "commitMessage": "Make \"private\" methods \"static\" where possible. #46\n\nSonarQube rule: [\"private\" methods that don\u0027t access instance data should be \"static\"](http://nemo.sonarqube.org/coding_rules#rule_key\u003dsquid%3AS2325).\n\nRationale: private methods that don\u0027t access instance data can be static to prevent any misunderstanding about the contract of the method.\n",
      "commitDate": 1437195084000,
      "commitName": "4c078ba710068498ca513ce115993e30dab4562a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1436323201000,
      "commitNameOld": "1b3e900ee47bd289ddbf72e3fd69e8a15e51b20a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 10.09,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n-    private List\u003cJavadocTag\u003e getMethodTags(TextBlock comment) {\n+    private static List\u003cJavadocTag\u003e getMethodTags(TextBlock comment) {\n         final String[] lines \u003d comment.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         int currentLine \u003d comment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             final Matcher javadocArgMatcher \u003d\n                 MATCH_JAVADOC_ARG.matcher(lines[i]);\n             final Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             final Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             final Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             final Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n \n             if (javadocArgMatcher.find()) {\n                 int col \u003d javadocArgMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher\n                         .group(1), javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 int col \u003d javadocNoargMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher\n                         .group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 int col \u003d noargCurlyMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher\n                         .group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n                 int col \u003d argMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG)\n                             \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n                             tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n                 int col \u003d noargMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d comment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG)\n                             \u0026\u0026 !lFin.equals(END_JAVADOC)) {\n                             tags.add(new JavadocTag(currentLine, col, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "89a51ba032fd9126651fa9efad31baf10c006ddf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, javadoc, #512\n",
      "commitDate": 1421677262000,
      "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": {
      "type": "Ybodychange",
      "commitMessage": "Drinking the \"Google Collections\" Kool-Aid.\n\nI like the reduced duplication.\n",
      "commitDate": 1208867287000,
      "commitName": "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1200295112000,
      "commitNameOld": "4d715df131a0c5ae3a9f2eae6ecf636ab52eda0e",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 99.21,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n     private List\u003cJavadocTag\u003e getMethodTags(TextBlock aComment)\n     {\n         final String[] lines \u003d aComment.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003cJavadocTag\u003e();\n+        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         int currentLine \u003d aComment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             final Matcher javadocArgMatcher \u003d\n                 MATCH_JAVADOC_ARG.matcher(lines[i]);\n             final Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             final Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             final Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             final Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n \n             if (javadocArgMatcher.find()) {\n                 int col \u003d javadocArgMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher\n                         .group(1), javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 int col \u003d javadocNoargMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher\n                         .group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 int col \u003d noargCurlyMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher\n                         .group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n                 int col \u003d argMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n                 int col \u003d noargMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": 1197694270000,
      "commitName": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Yreturntypechange",
        "Ybodychange"
      ]
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": 1152243856000,
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1148305756000,
      "commitNameOld": "0a72322796c28266f07df8af6f7e000aa9cf0e48",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 45.58,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,99 @@\n     private List getMethodTags(TextBlock aComment)\n     {\n         final String[] lines \u003d aComment.getText();\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aComment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n-            Matcher javadocArgMatcher \u003d MATCH_JAVADOC_ARG.matcher(lines[i]);\n-            Matcher javadocNoargMatcher \u003d MATCH_JAVADOC_NOARG.matcher(lines[i]);\n-            Matcher noargCurlyMatcher \u003d MATCH_JAVADOC_NOARG_CURLY\n-                    .matcher(lines[i]);\n-            Matcher argMultilineStart \u003d MATCH_JAVADOC_ARG_MULTILINE_START\n-                    .matcher(lines[i]);\n-            Matcher noargMultilineStart \u003d MATCH_JAVADOC_NOARG_MULTILINE_START\n-                    .matcher(lines[i]);\n+            final Matcher javadocArgMatcher \u003d\n+                MATCH_JAVADOC_ARG.matcher(lines[i]);\n+            final Matcher javadocNoargMatcher \u003d\n+                MATCH_JAVADOC_NOARG.matcher(lines[i]);\n+            final Matcher noargCurlyMatcher \u003d\n+                MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n+            final Matcher argMultilineStart \u003d\n+                MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n+            final Matcher noargMultilineStart \u003d\n+                MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n+\n             if (javadocArgMatcher.find()) {\n                 int col \u003d javadocArgMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocArgMatcher\n                         .group(1), javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 int col \u003d javadocNoargMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, javadocNoargMatcher\n                         .group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 int col \u003d noargCurlyMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col, noargCurlyMatcher\n                         .group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n                 int col \u003d argMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n-                    Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n+                    final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n-                        String lFin \u003d multilineCont.group(1);\n+                        final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n                 int col \u003d noargMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n-                    Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n+                    final Matcher multilineCont \u003d MATCH_JAVADOC_MULTILINE_CONT\n                             .matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n-                        String lFin \u003d multilineCont.group(1);\n+                        final String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "1aee9d55cc5bd8cca011e17369f6e370efcc85bb": {
      "type": "Ybodychange",
      "commitMessage": "Fixed 1290379 (now JavadomMethod check does not allow single @see tag in javadoc).  NUMBER of javadocs changed to follow new rule.\n",
      "commitDate": 1130786628000,
      "commitName": "1aee9d55cc5bd8cca011e17369f6e370efcc85bb",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1130531388000,
      "commitNameOld": "d3dd0586454d1757c8a188ecb9d2954b244344d4",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n     private List getMethodTags(TextBlock aComment)\n     {\n         final String[] lines \u003d aComment.getText();\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aComment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             Matcher javadocArgMatcher \u003d MATCH_JAVADOC_ARG.matcher(lines[i]);\n             Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n             if (javadocArgMatcher.find()) {\n                 int col \u003d javadocArgMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col,\n                                         javadocArgMatcher.group(1),\n                                         javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n                 int col \u003d javadocNoargMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col,\n                                         javadocNoargMatcher.group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n                 int col \u003d noargCurlyMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n                 tags.add(new JavadocTag(currentLine, col,\n                                         noargCurlyMatcher.group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n                 int col \u003d argMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n-                // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n+                // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     Matcher multilineCont \u003d\n                         MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n                 int col \u003d noargMultilineStart.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aComment.getStartColNo();\n                 }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n-                // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n+                // Javadoc), \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     Matcher multilineCont \u003d\n                         MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, col, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94": {
      "type": "Ybodychange",
      "commitMessage": "Fixed 1249707: AbstractTypeAwareCheck doesn\u0027t work with types from typeparm\n\nSome pretty big refactoring for typeaware checks performed.\nAlso added handling for type params.  Current handling algorithm\nhas some preconditions and restriction, but it works for most cases\n(not sure I\u0027ve covered all situation when type param will have name\nof real exception, but I do not think it is critical for now :)\n\nAlso, I\u0027ve added column number for JavadocTag (mainly to be able use\nClassInfo for it).  So, JavadocTypeCheck also affected.\n\nAnd I\u0027ve added new logger for TreeWalker (if we have loggers we should\nuse them :)\n",
      "commitDate": 1123248811000,
      "commitName": "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1120383479000,
      "commitNameOld": "b106eab0414affa16fbc0e2dfce511e3aed9d557",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 33.16,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,98 @@\n     private List getMethodTags(TextBlock aComment)\n     {\n         final String[] lines \u003d aComment.getText();\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aComment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n             Matcher javadocArgMatcher \u003d MATCH_JAVADOC_ARG.matcher(lines[i]);\n             Matcher javadocNoargMatcher \u003d\n                 MATCH_JAVADOC_NOARG.matcher(lines[i]);\n             Matcher noargCurlyMatcher \u003d\n                 MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n             Matcher argMultilineStart \u003d\n                 MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n             Matcher noargMultilineStart \u003d\n                 MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n             if (javadocArgMatcher.find()) {\n-                tags.add(new JavadocTag(currentLine,\n+                int col \u003d javadocArgMatcher.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aComment.getStartColNo();\n+                }\n+                tags.add(new JavadocTag(currentLine, col,\n                                         javadocArgMatcher.group(1),\n                                         javadocArgMatcher.group(2)));\n             }\n             else if (javadocNoargMatcher.find()) {\n-                tags.add(new JavadocTag(currentLine,\n+                int col \u003d javadocNoargMatcher.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aComment.getStartColNo();\n+                }\n+                tags.add(new JavadocTag(currentLine, col,\n                                         javadocNoargMatcher.group(1)));\n             }\n             else if (noargCurlyMatcher.find()) {\n-                tags.add(new JavadocTag(currentLine,\n+                int col \u003d noargCurlyMatcher.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aComment.getStartColNo();\n+                }\n+                tags.add(new JavadocTag(currentLine, col,\n                                         noargCurlyMatcher.group(1)));\n             }\n             else if (argMultilineStart.find()) {\n                 final String p1 \u003d argMultilineStart.group(1);\n                 final String p2 \u003d argMultilineStart.group(2);\n+                int col \u003d argMultilineStart.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aComment.getStartColNo();\n+                }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     Matcher multilineCont \u003d\n                         MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n-                            tags.add(new JavadocTag(currentLine, p1, p2));\n+                            tags.add(new JavadocTag(currentLine, col, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n             else if (noargMultilineStart.find()) {\n                 final String p1 \u003d noargMultilineStart.group(1);\n+                int col \u003d noargMultilineStart.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aComment.getStartColNo();\n+                }\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n                     Matcher multilineCont \u003d\n                         MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n                     if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n                         String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n-                            tags.add(new JavadocTag(currentLine, p1));\n+                            tags.add(new JavadocTag(currentLine, col, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "e27489c7721909245ea5055eac3b9c7c659081f6": {
      "type": "Ybodychange",
      "commitMessage": "initial replacing RE by Pattern (need to update docs)\n",
      "commitDate": 1115830091000,
      "commitName": "e27489c7721909245ea5055eac3b9c7c659081f6",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1111314995000,
      "commitNameOld": "cc50f3ba0a3f2adf4fce291372b20263f5f30f16",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 52.26,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,78 @@\n     private List getMethodTags(TextBlock aComment)\n     {\n         final String[] lines \u003d aComment.getText();\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aComment.getStartLineNo() - 1;\n \n         for (int i \u003d 0; i \u003c lines.length; i++) {\n             currentLine++;\n-            if (MATCH_JAVADOC_ARG.match(lines[i])) {\n+            Matcher javadocArgMatcher \u003d MATCH_JAVADOC_ARG.matcher(lines[i]);\n+            Matcher javadocNoargMatcher \u003d\n+                MATCH_JAVADOC_NOARG.matcher(lines[i]);\n+            Matcher noargCurlyMatcher \u003d\n+                MATCH_JAVADOC_NOARG_CURLY.matcher(lines[i]);\n+            Matcher argMultilineStart \u003d\n+                MATCH_JAVADOC_ARG_MULTILINE_START.matcher(lines[i]);\n+            Matcher noargMultilineStart \u003d\n+                MATCH_JAVADOC_NOARG_MULTILINE_START.matcher(lines[i]);\n+            if (javadocArgMatcher.find()) {\n                 tags.add(new JavadocTag(currentLine,\n-                                        MATCH_JAVADOC_ARG.getParen(1),\n-                                        MATCH_JAVADOC_ARG.getParen(2)));\n+                                        javadocArgMatcher.group(1),\n+                                        javadocArgMatcher.group(2)));\n             }\n-            else if (MATCH_JAVADOC_NOARG.match(lines[i])) {\n+            else if (javadocNoargMatcher.find()) {\n                 tags.add(new JavadocTag(currentLine,\n-                                        MATCH_JAVADOC_NOARG.getParen(1)));\n+                                        javadocNoargMatcher.group(1)));\n             }\n-            else if (MATCH_JAVADOC_NOARG_CURLY.match(lines[i])) {\n+            else if (noargCurlyMatcher.find()) {\n                 tags.add(new JavadocTag(currentLine,\n-                                        MATCH_JAVADOC_NOARG_CURLY.getParen(1)));\n+                                        noargCurlyMatcher.group(1)));\n             }\n-            else if (MATCH_JAVADOC_ARG_MULTILINE_START.match(lines[i])) {\n-                final String p1 \u003d MATCH_JAVADOC_ARG_MULTILINE_START.getParen(1);\n-                final String p2 \u003d MATCH_JAVADOC_ARG_MULTILINE_START.getParen(2);\n+            else if (argMultilineStart.find()) {\n+                final String p1 \u003d argMultilineStart.group(1);\n+                final String p2 \u003d argMultilineStart.group(2);\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n-                    if (MATCH_JAVADOC_MULTILINE_CONT.match(lines[remIndex])) {\n+                    Matcher multilineCont \u003d\n+                        MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n+                    if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n-                        String lFin \u003d MATCH_JAVADOC_MULTILINE_CONT.getParen(1);\n+                        String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n-            else if (MATCH_JAVADOC_NOARG_MULTILINE_START.match(lines[i])) {\n-                final String p1 \u003d MATCH_JAVADOC_NOARG_MULTILINE_START\n-                    .getParen(1);\n+            else if (noargMultilineStart.find()) {\n+                final String p1 \u003d noargMultilineStart.group(1);\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c lines.length) {\n-                    if (MATCH_JAVADOC_MULTILINE_CONT.match(lines[remIndex])) {\n+                    Matcher multilineCont \u003d\n+                        MATCH_JAVADOC_MULTILINE_CONT.matcher(lines[remIndex]);\n+                    if (multilineCont.find()) {\n                         remIndex \u003d lines.length;\n-                        String lFin \u003d MATCH_JAVADOC_MULTILINE_CONT.getParen(1);\n+                        String lFin \u003d multilineCont.group(1);\n                         if (!lFin.equals(NEXT_TAG) \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, p1));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "8fb2acd39b7db6223486f5e06126c7f0a2642a72": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "replaced Comment class with TextBlock interface, Comment is now a package private implementation\n",
      "commitDate": 1069656302000,
      "commitName": "8fb2acd39b7db6223486f5e06126c7f0a2642a72",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "24ba45a971569b9702e6bf78c5c07c48beb25464": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix for ArrayIndexOutOfBounds in JavadocStyle (bug 841942 )\n",
      "commitDate": 1069576421000,
      "commitName": "24ba45a971569b9702e6bf78c5c07c48beb25464",
      "commitAuthor": "Oleg Sukhodolsky",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "04ac5dd87c11a2bf7b908b45bbca7933382df515": {
      "type": "Yfilerename",
      "commitMessage": "Moving another Javadoc check to see what is involved.\nA suprisingly small amount. Love the Eclipse refactoring\nsupport having the smarts to do the CVS operations.\n",
      "commitDate": 1054648289000,
      "commitName": "04ac5dd87c11a2bf7b908b45bbca7933382df515",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1054647239000,
      "commitNameOld": "2ef6dc6a43ede89c5b5b9091dee83e1e58bb5edc",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "65440ae208e3b2f2a88f76ff41977ae9b70bfab4": {
      "type": "Ybodychange",
      "commitMessage": "Fixed Bug 579190, \"expected return tag when one is there\".\n",
      "commitDate": 1042112655000,
      "commitName": "65440ae208e3b2f2a88f76ff41977ae9b70bfab4",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1041156037000,
      "commitNameOld": "28d1968038af94b1f169eca09a12f19164daac04",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 11.07,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,65 @@\n     private List getMethodTags(String[] aLines, int aLastLineNo)\n     {\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aLastLineNo - aLines.length;\n         for (int i \u003d 0; i \u003c aLines.length; i++) {\n             currentLine++;\n             if (MATCH_JAVADOC_ARG.match(aLines[i])) {\n                 tags.add(new JavadocTag(currentLine,\n                                         MATCH_JAVADOC_ARG.getParen(1),\n                                         MATCH_JAVADOC_ARG.getParen(2)));\n             }\n             else if (MATCH_JAVADOC_NOARG.match(aLines[i])) {\n                 tags.add(new JavadocTag(currentLine,\n                                         MATCH_JAVADOC_NOARG.getParen(1)));\n             }\n             else if (MATCH_JAVADOC_NOARG_CURLY.match(aLines[i])) {\n                 tags.add(new JavadocTag(currentLine,\n                                         MATCH_JAVADOC_NOARG_CURLY.getParen(1)));\n             }\n-            else if (MATCH_JAVADOC_MULTILINE_START.match(aLines[i])) {\n-                final String p1 \u003d MATCH_JAVADOC_MULTILINE_START.getParen(1);\n-                final String p2 \u003d MATCH_JAVADOC_MULTILINE_START.getParen(2);\n+            else if (MATCH_JAVADOC_ARG_MULTILINE_START.match(aLines[i])) {\n+                final String p1 \u003d MATCH_JAVADOC_ARG_MULTILINE_START.getParen(1);\n+                final String p2 \u003d MATCH_JAVADOC_ARG_MULTILINE_START.getParen(2);\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c aLines.length) {\n                     if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {\n                         remIndex \u003d aLines.length;\n                         String lFin \u003d MATCH_JAVADOC_MULTILINE_CONT.getParen(1);\n                         if (!lFin.equals(NEXT_TAG)\n                             \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n+            else if (MATCH_JAVADOC_NOARG_MULTILINE_START.match(aLines[i])) {\n+                final String p1 \u003d MATCH_JAVADOC_NOARG_MULTILINE_START.getParen(1);\n+\n+                // Look for the rest of the comment if all we saw was\n+                // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n+                // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n+                // not whitespace or \u0027*\u0027 characters.\n+                int remIndex \u003d i + 1;\n+                while (remIndex \u003c aLines.length) {\n+                    if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {\n+                        remIndex \u003d aLines.length;\n+                        String lFin \u003d MATCH_JAVADOC_MULTILINE_CONT.getParen(1);\n+                        if (!lFin.equals(NEXT_TAG)\n+                            \u0026\u0026 !lFin.equals(END_JAVADOC))\n+                        {\n+                            tags.add(new JavadocTag(currentLine, p1));\n+                        }\n+                    }\n+                    remIndex++;\n+                }\n+            }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "8e55d5c09147620f59461387d45d09c2bc0bbd6e": {
      "type": "Ybodychange",
      "commitMessage": "Support the {@inheritDoc} tag.\n",
      "commitDate": 1039435977000,
      "commitName": "8e55d5c09147620f59461387d45d09c2bc0bbd6e",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1039071020000,
      "commitNameOld": "d91d78bc0f5863756c334c8d2afdf74447cfd4ae",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 4.22,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,44 @@\n     private List getMethodTags(String[] aLines, int aLastLineNo)\n     {\n         final List tags \u003d new ArrayList();\n         int currentLine \u003d aLastLineNo - aLines.length;\n         for (int i \u003d 0; i \u003c aLines.length; i++) {\n             currentLine++;\n             if (MATCH_JAVADOC_ARG.match(aLines[i])) {\n                 tags.add(new JavadocTag(currentLine,\n                                         MATCH_JAVADOC_ARG.getParen(1),\n                                         MATCH_JAVADOC_ARG.getParen(2)));\n             }\n             else if (MATCH_JAVADOC_NOARG.match(aLines[i])) {\n                 tags.add(new JavadocTag(currentLine,\n                                         MATCH_JAVADOC_NOARG.getParen(1)));\n             }\n+            else if (MATCH_JAVADOC_NOARG_CURLY.match(aLines[i])) {\n+                tags.add(new JavadocTag(currentLine,\n+                                        MATCH_JAVADOC_NOARG_CURLY.getParen(1)));\n+            }\n             else if (MATCH_JAVADOC_MULTILINE_START.match(aLines[i])) {\n                 final String p1 \u003d MATCH_JAVADOC_MULTILINE_START.getParen(1);\n                 final String p2 \u003d MATCH_JAVADOC_MULTILINE_START.getParen(2);\n \n                 // Look for the rest of the comment if all we saw was\n                 // the tag and the name. Stop when we see \u0027*/\u0027 (end of\n                 // Javadoc, \u0027@\u0027 (start of next tag), or anything that\u0027s\n                 // not whitespace or \u0027*\u0027 characters.\n                 int remIndex \u003d i + 1;\n                 while (remIndex \u003c aLines.length) {\n                     if (MATCH_JAVADOC_MULTILINE_CONT.match(aLines[remIndex])) {\n                         remIndex \u003d aLines.length;\n                         String lFin \u003d MATCH_JAVADOC_MULTILINE_CONT.getParen(1);\n                         if (!lFin.equals(NEXT_TAG)\n                             \u0026\u0026 !lFin.equals(END_JAVADOC))\n                         {\n                             tags.add(new JavadocTag(currentLine, p1, p2));\n                         }\n                     }\n                     remIndex++;\n                 }\n             }\n         }\n         return tags;\n     }\n\\ No newline at end of file\n"
    },
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf": {
      "type": "Yintroduced",
      "commitMessage": "Javadoc method check\n",
      "commitDate": 1036501994000,
      "commitName": "c75f97dbc2123f550a1acc64886a8bebf4b888cf",
      "commitAuthor": "Rick Giles"
    }
  }
}