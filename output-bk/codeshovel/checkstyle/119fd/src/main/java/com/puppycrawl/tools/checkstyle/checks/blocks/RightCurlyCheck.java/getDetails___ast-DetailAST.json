{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "RightCurlyCheck.java",
  "functionName": "getDetails",
  "functionId": "getDetails___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java",
  "functionStartLine": 388,
  "functionEndLine": 413,
  "changeHistory": [
    "59aa0915eae4629a5787edba5eb487389e27cf72",
    "8de64da1a00da618106b03c68400a5b265ec2580",
    "d2ddf5c6fc6b816dce7566dd5beaff5c5841f679",
    "11e1eb3ddd07df6a8859430bb6794b418c6a08b7",
    "2551676ccf743822951d42658085c70e7aa869bd",
    "b0d5b01b3cd174004843fb6fcc91cb971f17f7a2",
    "4cda2565674ea4260547e663e9660df0029709d1",
    "2c81de1bb030dbaf3885a17cdfff8a260a7b337e",
    "490128302232d627388fc5f0023e00ec18b7939c",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
    "423ed9e469db620671459827b58c89025d8f6c66",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
    "f1dced161ab0c818f0e1e125fc5b88b71f5b171e",
    "f1dc9b205d1ccdba85e34f4cb7adf9ffd4af2361",
    "d46134bc27a43ca9244e0c609f8ec044a43f36de",
    "4c078ba710068498ca513ce115993e30dab4562a",
    "cf8a2787c193f6f56d1259154f00de3d5f44fb12",
    "4ea1896f464b0f6c0ddfca3d8d9c9f84703bae5e",
    "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037",
    "c9cf116fcb4d295c3dd6fa80d73648bc7f34301c"
  ],
  "changeHistoryShort": {
    "59aa0915eae4629a5787edba5eb487389e27cf72": "Ybodychange",
    "8de64da1a00da618106b03c68400a5b265ec2580": "Ybodychange",
    "d2ddf5c6fc6b816dce7566dd5beaff5c5841f679": "Ybodychange",
    "11e1eb3ddd07df6a8859430bb6794b418c6a08b7": "Ybodychange",
    "2551676ccf743822951d42658085c70e7aa869bd": "Ybodychange",
    "b0d5b01b3cd174004843fb6fcc91cb971f17f7a2": "Ybodychange",
    "4cda2565674ea4260547e663e9660df0029709d1": "Ybodychange",
    "2c81de1bb030dbaf3885a17cdfff8a260a7b337e": "Ybodychange",
    "490128302232d627388fc5f0023e00ec18b7939c": "Ybodychange",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": "Ybodychange",
    "423ed9e469db620671459827b58c89025d8f6c66": "Ybodychange",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": "Ybodychange",
    "f1dced161ab0c818f0e1e125fc5b88b71f5b171e": "Ybodychange",
    "f1dc9b205d1ccdba85e34f4cb7adf9ffd4af2361": "Ybodychange",
    "d46134bc27a43ca9244e0c609f8ec044a43f36de": "Ybodychange",
    "4c078ba710068498ca513ce115993e30dab4562a": "Ymodifierchange",
    "cf8a2787c193f6f56d1259154f00de3d5f44fb12": "Ybodychange",
    "4ea1896f464b0f6c0ddfca3d8d9c9f84703bae5e": "Ybodychange",
    "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037": "Ybodychange",
    "c9cf116fcb4d295c3dd6fa80d73648bc7f34301c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "59aa0915eae4629a5787edba5eb487389e27cf72": {
      "type": "Ybodychange",
      "commitMessage": "minor: Refactored getDetails method of RightCurlyCheck\n",
      "commitDate": 1493732429000,
      "commitName": "59aa0915eae4629a5787edba5eb487389e27cf72",
      "commitAuthor": "Piyush Sharma",
      "commitDateOld": 1492451466000,
      "commitNameOld": "8de64da1a00da618106b03c68400a5b265ec2580",
      "commitAuthorOld": "Vladislav Lisetskii",
      "daysBetweenCommits": 14.83,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,26 @@\n-    private static Details getDetails(DetailAST ast) {\n-        // Attempt to locate the tokens to do the check\n-        boolean shouldCheckLastRcurly \u003d false;\n-        DetailAST rcurly \u003d null;\n-        final DetailAST lcurly;\n-        DetailAST nextToken;\n-\n-        switch (ast.getType()) {\n-            case TokenTypes.LITERAL_TRY:\n-                if (ast.getFirstChild().getType() \u003d\u003d TokenTypes.RESOURCE_SPECIFICATION) {\n-                    lcurly \u003d ast.getFirstChild().getNextSibling();\n-                }\n-                else {\n-                    lcurly \u003d ast.getFirstChild();\n-                }\n-                nextToken \u003d lcurly.getNextSibling();\n-                rcurly \u003d lcurly.getLastChild();\n-\n-                if (nextToken \u003d\u003d null) {\n-                    shouldCheckLastRcurly \u003d true;\n-                    nextToken \u003d getNextToken(ast);\n-                }\n-                break;\n-            case TokenTypes.LITERAL_CATCH:\n-                nextToken \u003d ast.getNextSibling();\n-                lcurly \u003d ast.getLastChild();\n-                rcurly \u003d lcurly.getLastChild();\n-                if (nextToken \u003d\u003d null) {\n-                    shouldCheckLastRcurly \u003d true;\n-                    nextToken \u003d getNextToken(ast);\n-                }\n-                break;\n-            case TokenTypes.LITERAL_IF:\n-                nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n-                if (nextToken \u003d\u003d null) {\n-                    shouldCheckLastRcurly \u003d true;\n-                    nextToken \u003d getNextToken(ast);\n-                    lcurly \u003d ast.getLastChild();\n-                }\n-                else {\n-                    lcurly \u003d nextToken.getPreviousSibling();\n-                }\n-                if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                break;\n-            case TokenTypes.LITERAL_ELSE:\n-            case TokenTypes.LITERAL_FINALLY:\n-                shouldCheckLastRcurly \u003d true;\n-                nextToken \u003d getNextToken(ast);\n-                lcurly \u003d ast.getFirstChild();\n-                if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                break;\n-            case TokenTypes.CLASS_DEF:\n-                final DetailAST child \u003d ast.getLastChild();\n-                lcurly \u003d child.getFirstChild();\n-                rcurly \u003d child.getLastChild();\n-                nextToken \u003d ast;\n-                break;\n-            case TokenTypes.CTOR_DEF:\n-            case TokenTypes.STATIC_INIT:\n-            case TokenTypes.INSTANCE_INIT:\n-                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                rcurly \u003d lcurly.getLastChild();\n-                nextToken \u003d getNextToken(ast);\n-                break;\n-            case TokenTypes.LITERAL_DO:\n-                nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n-                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                if (lcurly !\u003d null) {\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                break;\n-            case TokenTypes.LAMBDA:\n-                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                nextToken \u003d getNextToken(ast);\n-                if (nextToken.getType() !\u003d TokenTypes.RPAREN\n-                        \u0026\u0026 nextToken.getType() !\u003d TokenTypes.COMMA) {\n-                    shouldCheckLastRcurly \u003d true;\n-                    nextToken \u003d getNextToken(nextToken);\n-                }\n-                if (lcurly !\u003d null) {\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                break;\n-            default:\n-                // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n-                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE only.\n-                // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n-                // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n-\n-                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                if (lcurly !\u003d null) {\n-                    // SLIST could be absent if method is abstract,\n-                    // and code like \"while(true);\"\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                nextToken \u003d getNextToken(ast);\n-                break;\n-        }\n-\n-        final Details details \u003d new Details();\n-        details.rcurly \u003d rcurly;\n-        details.lcurly \u003d lcurly;\n-        details.nextToken \u003d nextToken;\n-        details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n-\n-        return details;\n-    }\n\\ No newline at end of file\n+        private static Details getDetails(DetailAST ast) {\n+            final Details details;\n+            switch (ast.getType()) {\n+                case TokenTypes.LITERAL_TRY:\n+                case TokenTypes.LITERAL_CATCH:\n+                case TokenTypes.LITERAL_FINALLY:\n+                    details \u003d getDetailsForTryCatchFinally(ast);\n+                    break;\n+                case TokenTypes.LITERAL_IF:\n+                case TokenTypes.LITERAL_ELSE:\n+                    details \u003d getDetailsForIfElse(ast);\n+                    break;\n+                case TokenTypes.LITERAL_DO:\n+                case TokenTypes.LITERAL_WHILE:\n+                case TokenTypes.LITERAL_FOR:\n+                    details \u003d getDetailsForLoops(ast);\n+                    break;\n+                case TokenTypes.LAMBDA:\n+                    details \u003d getDetailsForLambda(ast);\n+                    break;\n+                default:\n+                    details \u003d getDetailsForOthers(ast);\n+                    break;\n+            }\n+            return details;\n+        }\n\\ No newline at end of file\n"
    },
    "8de64da1a00da618106b03c68400a5b265ec2580": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3546: Add lambda in RightCurlyCheck\n",
      "commitDate": 1492451466000,
      "commitName": "8de64da1a00da618106b03c68400a5b265ec2580",
      "commitAuthor": "Vladislav Lisetskii",
      "commitDateOld": 1491402064000,
      "commitNameOld": "e0bb421ead241b65c5d8b4acafe5f8247aea8576",
      "commitAuthorOld": "Vladislav Lisetskii",
      "daysBetweenCommits": 12.15,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,111 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 if (ast.getFirstChild().getType() \u003d\u003d TokenTypes.RESOURCE_SPECIFICATION) {\n                     lcurly \u003d ast.getFirstChild().getNextSibling();\n                 }\n                 else {\n                     lcurly \u003d ast.getFirstChild();\n                 }\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n \n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                 }\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n+            case TokenTypes.LAMBDA:\n+                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n+                nextToken \u003d getNextToken(ast);\n+                if (nextToken.getType() !\u003d TokenTypes.RPAREN\n+                        \u0026\u0026 nextToken.getType() !\u003d TokenTypes.COMMA) {\n+                    shouldCheckLastRcurly \u003d true;\n+                    nextToken \u003d getNextToken(nextToken);\n+                }\n+                if (lcurly !\u003d null) {\n+                    rcurly \u003d lcurly.getLastChild();\n+                }\n+                break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "d2ddf5c6fc6b816dce7566dd5beaff5c5841f679": {
      "type": "Ybodychange",
      "commitMessage": "spelling: fix spelling and punctuation in comments (RightCurly)\n",
      "commitDate": 1489894018000,
      "commitName": "d2ddf5c6fc6b816dce7566dd5beaff5c5841f679",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1489375704000,
      "commitNameOld": "70ab9f4af3d163b940e025bc4665f2f23892525a",
      "commitAuthorOld": "Sagar",
      "daysBetweenCommits": 6.0,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 if (ast.getFirstChild().getType() \u003d\u003d TokenTypes.RESOURCE_SPECIFICATION) {\n                     lcurly \u003d ast.getFirstChild().getNextSibling();\n                 }\n                 else {\n                     lcurly \u003d ast.getFirstChild();\n                 }\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n \n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                 }\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n-                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n+                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "11e1eb3ddd07df6a8859430bb6794b418c6a08b7": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3776: fixed try-resource in RightCurlyCheck",
      "commitDate": 1485983813000,
      "commitName": "11e1eb3ddd07df6a8859430bb6794b418c6a08b7",
      "commitAuthor": "rnveach",
      "commitDateOld": 1485641699000,
      "commitNameOld": "2551676ccf743822951d42658085c70e7aa869bd",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 3.96,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,99 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n-                lcurly \u003d ast.getFirstChild();\n+                if (ast.getFirstChild().getType() \u003d\u003d TokenTypes.RESOURCE_SPECIFICATION) {\n+                    lcurly \u003d ast.getFirstChild().getNextSibling();\n+                }\n+                else {\n+                    lcurly \u003d ast.getFirstChild();\n+                }\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n+\n+                if (nextToken \u003d\u003d null) {\n+                    shouldCheckLastRcurly \u003d true;\n+                    nextToken \u003d getNextToken(ast);\n+                }\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                 }\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "2551676ccf743822951d42658085c70e7aa869bd": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Issue #3546: add lambda in a rightcurlycheck\"\n\nThis reverts commit b0d5b01b3cd174004843fb6fcc91cb971f17f7a2.\n",
      "commitDate": 1485641699000,
      "commitName": "2551676ccf743822951d42658085c70e7aa869bd",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1485641674000,
      "commitNameOld": "b0d5b01b3cd174004843fb6fcc91cb971f17f7a2",
      "commitAuthorOld": "MaksimP",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,89 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                 }\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n-            case TokenTypes.LAMBDA:\n-                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                nextToken \u003d getNextToken(ast);\n-                if (lcurly !\u003d null) {\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n-                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE only.\n+                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "b0d5b01b3cd174004843fb6fcc91cb971f17f7a2": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3546: add lambda in a rightcurlycheck\n",
      "commitDate": 1485641674000,
      "commitName": "b0d5b01b3cd174004843fb6fcc91cb971f17f7a2",
      "commitAuthor": "MaksimP",
      "commitDateOld": 1485547897000,
      "commitNameOld": "4cda2565674ea4260547e663e9660df0029709d1",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,96 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                 }\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n+            case TokenTypes.LAMBDA:\n+                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n+                nextToken \u003d getNextToken(ast);\n+                if (lcurly !\u003d null) {\n+                    rcurly \u003d lcurly.getLastChild();\n+                }\n+                break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n-                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n+                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "4cda2565674ea4260547e663e9660df0029709d1": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3764: removed garbage placed in RightCurlyCheck\u0027s rcurly",
      "commitDate": 1485547897000,
      "commitName": "4cda2565674ea4260547e663e9660df0029709d1",
      "commitAuthor": "rnveach",
      "commitDateOld": 1485527514000,
      "commitNameOld": "b4a337a599e853cdc44b19a76da28fcfab2956cd",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,89 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n-                    rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n+                }\n+                if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n-                rcurly \u003d lcurly.getLastChild();\n+                if (lcurly.getType() \u003d\u003d TokenTypes.SLIST) {\n+                    rcurly \u003d lcurly.getLastChild();\n+                }\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "2c81de1bb030dbaf3885a17cdfff8a260a7b337e": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3681: fixed NPE in RightCurly when do has no curlies",
      "commitDate": 1483624054000,
      "commitName": "2c81de1bb030dbaf3885a17cdfff8a260a7b337e",
      "commitAuthor": "rnveach",
      "commitDateOld": 1473886714000,
      "commitNameOld": "25a37e5049b7816b34c552899841a978efc37a63",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 112.7,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,86 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             case TokenTypes.LITERAL_DO:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n-                rcurly \u003d lcurly.getLastChild();\n+                if (lcurly !\u003d null) {\n+                    rcurly \u003d lcurly.getLastChild();\n+                }\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "490128302232d627388fc5f0023e00ec18b7939c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3090: Fix wrong enforcement of same brace policy for LITERAL_DO in RightCurlyCheck (#3267)\n\n",
      "commitDate": 1465738066000,
      "commitName": "490128302232d627388fc5f0023e00ec18b7939c",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1464356569000,
      "commitNameOld": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 15.99,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,84 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n+            case TokenTypes.LITERAL_DO:\n+                nextToken \u003d ast.findFirstToken(TokenTypes.DO_WHILE);\n+                lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n+                rcurly \u003d lcurly.getLastChild();\n+                break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n-                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n+                // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": {
      "type": "Ybodychange",
      "commitMessage": "minor: enforce FinalLocalVariableCheck on checkstyle code\n",
      "commitDate": 1453646135000,
      "commitName": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": 1451953543000,
      "commitNameOld": "617ebf2bf27d284dcc7b866f85439fcf6dab3402",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.59,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n-        DetailAST lcurly;\n+        final DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "423ed9e469db620671459827b58c89025d8f6c66": {
      "type": "Ybodychange",
      "commitMessage": "Issue #974: PMD violation ConfusingTernary (partial fix)\n",
      "commitDate": 1444265756000,
      "commitName": "423ed9e469db620671459827b58c89025d8f6c66",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1441043008000,
      "commitNameOld": "a1128cd7428ba71035c132a072de0da2e5c4c9cd",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 37.3,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly;\n         DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n-                if (nextToken !\u003d null) {\n-                    lcurly \u003d nextToken.getPreviousSibling();\n-                    rcurly \u003d lcurly.getLastChild();\n-                }\n-                else {\n+                if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n+                else {\n+                    lcurly \u003d nextToken.getPreviousSibling();\n+                    rcurly \u003d lcurly.getLastChild();\n+                }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             default:\n                 // ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n                 // TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n                 // It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n                 // if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": {
      "type": "Ybodychange",
      "commitMessage": "Remove unused assignments. #1555\n\nFixes UnusedAssignment inspection violations.\n\nDescription:\n\u003eThis inspection points out the cases where a variable value is never used after its assignment, i.e.:\n- the variable never gets read after assignment OR\n- the value is always overwritten with another assignment before the next variable read OR\n - the variable initializer is redundant (for one of the above two reasons) OR\n - the variable is never used.\n",
      "commitDate": 1439007161000,
      "commitName": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1438592589000,
      "commitNameOld": "d282d5b8db9eba5943d1cb0269315744d5344a47",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 4.8,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n-        DetailAST lcurly \u003d null;\n-        DetailAST nextToken \u003d null;\n+        DetailAST lcurly;\n+        DetailAST nextToken;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d getNextToken(ast);\n                 break;\n             default:\n //              ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n //              TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n //              It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n //              if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "f1dced161ab0c818f0e1e125fc5b88b71f5b171e": {
      "type": "Ybodychange",
      "commitMessage": "Add new option for RightCurlyCheck, issue #1019.\n",
      "commitDate": 1438285211000,
      "commitName": "f1dced161ab0c818f0e1e125fc5b88b71f5b171e",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1438050838000,
      "commitNameOld": "f1dc9b205d1ccdba85e34f4cb7adf9ffd4af2361",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n-                nextToken \u003d ast;\n+                nextToken \u003d getNextToken(ast);\n                 break;\n             default:\n //              ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n //              TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n //              It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n //              if-else-if block because code was ugly and didn\u0027t pass pmd check.\n \n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n-                nextToken \u003d lcurly;\n+                nextToken \u003d getNextToken(ast);\n                 break;\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "f1dc9b205d1ccdba85e34f4cb7adf9ffd4af2361": {
      "type": "Ybodychange",
      "commitMessage": "coverage has been increased to 100% in RughtCurlyCheck. Issue #1291\n",
      "commitDate": 1438050838000,
      "commitName": "f1dc9b205d1ccdba85e34f4cb7adf9ffd4af2361",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1437631122000,
      "commitNameOld": "acbd47a66b01acc392a7bd37ad3a2e65eecd308a",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 4.86,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n-            case TokenTypes.METHOD_DEF:\n-            case TokenTypes.LITERAL_FOR:\n-            case TokenTypes.LITERAL_WHILE:\n-            case TokenTypes.LITERAL_DO:\n+            default:\n+//              ATTENTION! We have default here, but we expect case TokenTypes.METHOD_DEF,\n+//              TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_WHILE, TokenTypes.LITERAL_DO only.\n+//              It has been done to improve coverage to 100%. I couldn\u0027t replace it with\n+//              if-else-if block because code was ugly and didn\u0027t pass pmd check.\n+\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     // SLIST could be absent if method is abstract,\n                     // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d lcurly;\n                 break;\n-            default:\n-                throw new IllegalStateException(\"Unexpected token type (\"\n-                        + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "d46134bc27a43ca9244e0c609f8ec044a43f36de": {
      "type": "Ybodychange",
      "commitMessage": "Correct typos in RightCurlyCheck.\n",
      "commitDate": 1437298836000,
      "commitName": "d46134bc27a43ca9244e0c609f8ec044a43f36de",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1437195084000,
      "commitNameOld": "4c078ba710068498ca513ce115993e30dab4562a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.2,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,80 @@\n     private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.METHOD_DEF:\n             case TokenTypes.LITERAL_FOR:\n             case TokenTypes.LITERAL_WHILE:\n             case TokenTypes.LITERAL_DO:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n-                    //SLIST could be absent if method is abstract, and code like \"while(true);\"\n+                    // SLIST could be absent if method is abstract,\n+                    // and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d lcurly;\n                 break;\n             default:\n                 throw new IllegalStateException(\"Unexpected token type (\"\n                         + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "4c078ba710068498ca513ce115993e30dab4562a": {
      "type": "Ymodifierchange",
      "commitMessage": "Make \"private\" methods \"static\" where possible. #46\n\nSonarQube rule: [\"private\" methods that don\u0027t access instance data should be \"static\"](http://nemo.sonarqube.org/coding_rules#rule_key\u003dsquid%3AS2325).\n\nRationale: private methods that don\u0027t access instance data can be static to prevent any misunderstanding about the contract of the method.\n",
      "commitDate": 1437195084000,
      "commitName": "4c078ba710068498ca513ce115993e30dab4562a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1435721870000,
      "commitNameOld": "cf8a2787c193f6f56d1259154f00de3d5f44fb12",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 17.05,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n-    private Details getDetails(DetailAST ast) {\n+    private static Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.METHOD_DEF:\n             case TokenTypes.LITERAL_FOR:\n             case TokenTypes.LITERAL_WHILE:\n             case TokenTypes.LITERAL_DO:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     //SLIST could be absent if method is abstract, and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d lcurly;\n                 break;\n             default:\n                 throw new IllegalStateException(\"Unexpected token type (\"\n                         + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "cf8a2787c193f6f56d1259154f00de3d5f44fb12": {
      "type": "Ybodychange",
      "commitMessage": "Fix bug at RightCurlyCheck: curly brace \u0027}\u0027 should be on line by itself not reported for method with annotation, issue #1014.\n",
      "commitDate": 1435721870000,
      "commitName": "cf8a2787c193f6f56d1259154f00de3d5f44fb12",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1435511623000,
      "commitNameOld": "4ea1896f464b0f6c0ddfca3d8d9c9f84703bae5e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.METHOD_DEF:\n             case TokenTypes.LITERAL_FOR:\n             case TokenTypes.LITERAL_WHILE:\n             case TokenTypes.LITERAL_DO:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     //SLIST could be absent if method is abstract, and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n-                nextToken \u003d ast;\n+                nextToken \u003d lcurly;\n                 break;\n             default:\n                 throw new IllegalStateException(\"Unexpected token type (\"\n                         + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "4ea1896f464b0f6c0ddfca3d8d9c9f84703bae5e": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations of AvoidCatchingGenericException rule. #959\n",
      "commitDate": 1435511623000,
      "commitName": "4ea1896f464b0f6c0ddfca3d8d9c9f84703bae5e",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1434261690000,
      "commitNameOld": "c99f34002b7340ec8d0888f8f9b3992df798e408",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.47,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     private Details getDetails(DetailAST ast) {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.METHOD_DEF:\n             case TokenTypes.LITERAL_FOR:\n             case TokenTypes.LITERAL_WHILE:\n             case TokenTypes.LITERAL_DO:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     //SLIST could be absent if method is abstract, and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d ast;\n                 break;\n             default:\n-                throw new RuntimeException(\"Unexpected token type (\"\n+                throw new IllegalStateException(\"Unexpected token type (\"\n                         + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037": {
      "type": "Ybodychange",
      "commitMessage": "Findbugs violation: api.TokenTypes do System.exit(...). #923\n",
      "commitDate": 1431729119000,
      "commitName": "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431536292000,
      "commitNameOld": "dba746ba9387bee04ed362254abb5d9ed35169cd",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     private Details getDetails(DetailAST ast)\n     {\n         // Attempt to locate the tokens to do the check\n         boolean shouldCheckLastRcurly \u003d false;\n         DetailAST rcurly \u003d null;\n         DetailAST lcurly \u003d null;\n         DetailAST nextToken \u003d null;\n \n         switch (ast.getType()) {\n             case TokenTypes.LITERAL_TRY:\n                 lcurly \u003d ast.getFirstChild();\n                 nextToken \u003d lcurly.getNextSibling();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.LITERAL_CATCH:\n                 nextToken \u003d ast.getNextSibling();\n                 lcurly \u003d ast.getLastChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 if (nextToken \u003d\u003d null) {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                 }\n                 break;\n             case TokenTypes.LITERAL_IF:\n                 nextToken \u003d ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n                 if (nextToken !\u003d null) {\n                     lcurly \u003d nextToken.getPreviousSibling();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 else {\n                     shouldCheckLastRcurly \u003d true;\n                     nextToken \u003d getNextToken(ast);\n                     lcurly \u003d ast.getLastChild();\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 break;\n             case TokenTypes.LITERAL_ELSE:\n             case TokenTypes.LITERAL_FINALLY:\n                 shouldCheckLastRcurly \u003d true;\n                 nextToken \u003d getNextToken(ast);\n                 lcurly \u003d ast.getFirstChild();\n                 rcurly \u003d lcurly.getLastChild();\n                 break;\n             case TokenTypes.CLASS_DEF:\n                 final DetailAST child \u003d ast.getLastChild();\n                 lcurly \u003d child.getFirstChild();\n                 rcurly \u003d child.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.CTOR_DEF:\n             case TokenTypes.STATIC_INIT:\n             case TokenTypes.INSTANCE_INIT:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 rcurly \u003d lcurly.getLastChild();\n                 nextToken \u003d ast;\n                 break;\n             case TokenTypes.METHOD_DEF:\n             case TokenTypes.LITERAL_FOR:\n             case TokenTypes.LITERAL_WHILE:\n             case TokenTypes.LITERAL_DO:\n                 lcurly \u003d ast.findFirstToken(TokenTypes.SLIST);\n                 if (lcurly !\u003d null) {\n                     //SLIST could be absent if method is abstract, and code like \"while(true);\"\n                     rcurly \u003d lcurly.getLastChild();\n                 }\n                 nextToken \u003d ast;\n                 break;\n             default:\n                 throw new RuntimeException(\"Unexpected token type (\"\n-                        + TokenTypes.getTokenName(ast.getType()) + \")\");\n+                        + Utils.getTokenName(ast.getType()) + \")\");\n         }\n \n         final Details details \u003d new Details();\n         details.rcurly \u003d rcurly;\n         details.lcurly \u003d lcurly;\n         details.nextToken \u003d nextToken;\n         details.shouldCheckLastRcurly \u003d shouldCheckLastRcurly;\n \n         return details;\n     }\n\\ No newline at end of file\n"
    },
    "c9cf116fcb4d295c3dd6fa80d73648bc7f34301c": {
      "type": "Yintroduced",
      "commitMessage": "PMD Rule:ExcessiveMethodLength Priority:3 Avoid really long methods. Issue #744\n",
      "commitDate": 1429638508000,
      "commitName": "c9cf116fcb4d295c3dd6fa80d73648bc7f34301c",
      "commitAuthor": "Roman Ivanov"
    }
  }
}