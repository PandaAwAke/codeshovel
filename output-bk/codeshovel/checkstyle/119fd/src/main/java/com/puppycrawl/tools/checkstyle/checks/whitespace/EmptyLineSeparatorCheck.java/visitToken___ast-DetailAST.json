{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "EmptyLineSeparatorCheck.java",
  "functionName": "visitToken",
  "functionId": "visitToken___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
  "functionStartLine": 288,
  "functionEndLine": 324,
  "changeHistory": [
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9",
    "753e733c95f0a5183dfc3b29835f8b86e5df5316",
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa",
    "fb5cf249885869256567d41798e14f2964a26192",
    "a0acabc125d3398e13655302500423c01e10dcb0",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a",
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "d97a2df674716efb7deda50180ae933bdc46d68a",
    "0518b753a40f1857516b356654e5d01834af2109",
    "a5031acb330edaa2311acbce4945f7b44fc76b29",
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab"
  ],
  "changeHistoryShort": {
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9": "Ybodychange",
    "753e733c95f0a5183dfc3b29835f8b86e5df5316": "Ybodychange",
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa": "Ybodychange",
    "fb5cf249885869256567d41798e14f2964a26192": "Ybodychange",
    "a0acabc125d3398e13655302500423c01e10dcb0": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817": "Ybodychange",
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d": "Ybodychange",
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a": "Ybodychange",
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d": "Ybodychange",
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ybodychange",
    "d97a2df674716efb7deda50180ae933bdc46d68a": "Ymultichange(Yparameterchange,Ybodychange)",
    "0518b753a40f1857516b356654e5d01834af2109": "Ybodychange",
    "a5031acb330edaa2311acbce4945f7b44fc76b29": "Ybodychange",
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab": "Yintroduced"
  },
  "changeHistoryDetails": {
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3426: remove warning on PACKAGE_DEF preceded by javadoc not separated by line\n",
      "commitDate": 1481551452000,
      "commitName": "65fe91df6a9712f3ec7af2ed963867a50303b0e9",
      "commitAuthor": "kazachka",
      "commitDateOld": 1459290303000,
      "commitNameOld": "753e733c95f0a5183dfc3b29835f8b86e5df5316",
      "commitAuthorOld": "Vladislav Lisetskiy",
      "daysBetweenCommits": 257.65,
      "commitsBetweenForRepo": 480,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,37 @@\n     public void visitToken(DetailAST ast) {\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n         if (!allowMultipleEmptyLinesInsideClassMembers) {\n             processMultipleLinesInside(ast);\n         }\n \n-        final DetailAST nextToken \u003d ast.getNextSibling();\n+        DetailAST nextToken \u003d ast.getNextSibling();\n+        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n+            nextToken \u003d nextToken.getNextSibling();\n+        }\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "753e733c95f0a5183dfc3b29835f8b86e5df5316": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2944: add EmptyLineSeparator option to check empty lines inside methods\n",
      "commitDate": 1459290303000,
      "commitName": "753e733c95f0a5183dfc3b29835f8b86e5df5316",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": 1458221995000,
      "commitNameOld": "167dd96d8ca503a472bf003f187191d6b0ce586c",
      "commitAuthorOld": "Rasmus Kaj",
      "daysBetweenCommits": 12.36,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,34 @@\n     public void visitToken(DetailAST ast) {\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n+        if (!allowMultipleEmptyLinesInsideClassMembers) {\n+            processMultipleLinesInside(ast);\n+        }\n \n         final DetailAST nextToken \u003d ast.getNextSibling();\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2067: Fix false-negatives in EmptyLineSeparatorCheck\n",
      "commitDate": 1447274797000,
      "commitName": "3b26b571a8dae611366c481aa1fce606ca1f1cfa",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": 1445172696000,
      "commitNameOld": "caa58734b9891ec51a113f861f6f1225ae6b499d",
      "commitAuthorOld": "Pavel Baranchikov",
      "daysBetweenCommits": 24.33,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,31 @@\n     public void visitToken(DetailAST ast) {\n-        final DetailAST nextToken \u003d ast.getNextSibling();\n+        if (hasMultipleLinesBefore(ast)) {\n+            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+        }\n \n+        final DetailAST nextToken \u003d ast.getNextSibling();\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n-                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n+                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n+                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n+                        }\n                     }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    else if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                            nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "fb5cf249885869256567d41798e14f2964a26192": {
      "type": "Ybodychange",
      "commitMessage": "EmptyLineSeparator updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434344165000,
      "commitName": "fb5cf249885869256567d41798e14f2964a26192",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431863229000,
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 28.71,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,25 @@\n     public void visitToken(DetailAST ast) {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n-                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        if (allowNoEmptyLineBetweenFields\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n-                                 nextToken.getText());\n-                        }\n-                        else if (!allowNoEmptyLineBetweenFields\n-                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n-                                 nextToken.getText());\n-                        }\n-                    }\n-                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n-                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n-                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n-                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n-                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n-                    }\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a0acabc125d3398e13655302500423c01e10dcb0": {
      "type": "Ybodychange",
      "commitMessage": "Fix FallThrough check violation in code, issue #945\n",
      "commitDate": 1430678040000,
      "commitName": "a0acabc125d3398e13655302500423c01e10dcb0",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1426023398000,
      "commitNameOld": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 53.87,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,60 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n+                    if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n+                    break;\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1426017514000,
      "commitNameOld": "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
      "commitAuthorOld": "liscju",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n-                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n-                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n+                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n+                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817": {
      "type": "Ybodychange",
      "commitMessage": "Fix bug with multiple imports, part of issue #706\n",
      "commitDate": 1426017514000,
      "commitName": "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
      "commitAuthor": "liscju",
      "commitDateOld": 1425656481000,
      "commitNameOld": "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
      "commitAuthorOld": "liscju",
      "daysBetweenCommits": 4.18,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n-                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d": {
      "type": "Ybodychange",
      "commitMessage": "Fix bugs with multiple fields, part of issue #706\n",
      "commitDate": 1425656481000,
      "commitName": "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
      "commitAuthor": "liscju",
      "commitDateOld": 1424294072000,
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 15.77,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if ((!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines)\n+                        else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n                              \u0026\u0026 isPrePreviousLineEmpty(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a": {
      "type": "Ybodychange",
      "commitMessage": "Empty Line Separator Check, added option for managing empty lines between class members, issue #530\n",
      "commitDate": 1422784835000,
      "commitName": "2db0dab62fc4986c3bebb38a1b8cac857f37664a",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1422762518000,
      "commitNameOld": "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,57 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n+        if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields) {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                        else if ((!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines)\n+                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n+                        {\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n+                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n+                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Empty Line Separator Check, added option for managing empty lines between class members, issue #530\"\n\nThis reverts commit 3f853ae96a24f2079901c3d47c6e6a7fa0604654.\n",
      "commitDate": 1422762518000,
      "commitName": "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1422512089000,
      "commitNameOld": "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 2.9,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,40 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null) {\n+        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                         {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                        else if (!allowNoEmptyLineBetweenFields) {\n+                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                  nextToken.getText());\n                         }\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n-                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n-                    {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                     }\n                 default:\n-                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654": {
      "type": "Ybodychange",
      "commitMessage": "Empty Line Separator Check, added option for managing empty lines between class members, issue #530\n",
      "commitDate": 1422512089000,
      "commitName": "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1421929874000,
      "commitNameOld": "7487028f2ab4b37432ce6e87416a308adbab9282",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,54 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n+        if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                         {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields) {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                        else if (!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines) {\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n+                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n+                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ybodychange",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": 1421678312000,
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1421677248000,
      "commitNameOld": "d97a2df674716efb7deda50180ae933bdc46d68a",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                     if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                     {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                     else if (!allowNoEmptyLineBetweenFields) {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n                 if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                     || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n                 if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                     log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                 }\n             default:\n                 if (!hasEmptyLineAfter(ast)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d97a2df674716efb7deda50180ae933bdc46d68a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, whitespace, #512\n",
      "commitDate": 1421677248000,
      "commitName": "d97a2df674716efb7deda50180ae933bdc46d68a",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "0518b753a40f1857516b356654e5d01834af2109": {
      "type": "Ybodychange",
      "commitMessage": "Update for EmptyLineSeparatorCheck #227\n",
      "commitDate": 1407530698000,
      "commitName": "0518b753a40f1857516b356654e5d01834af2109",
      "commitAuthor": "Max",
      "commitDateOld": 1407390545000,
      "commitNameOld": "a5031acb330edaa2311acbce4945f7b44fc76b29",
      "commitAuthorOld": "Max",
      "daysBetweenCommits": 1.62,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,38 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST nextToken \u003d aAST.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d aAST.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n                 if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (mAllowNoEmptyLineBetweenFields\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n+                    {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    }\n+                    else if (!mAllowNoEmptyLineBetweenFields) {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n                 if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n                     || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n                             \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n                 if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n                     log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n                 }\n             default:\n                 if (!hasEmptyLineAfter(aAST)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a5031acb330edaa2311acbce4945f7b44fc76b29": {
      "type": "Ybodychange",
      "commitMessage": "EmptyLineSeparatorCheck was updated #218\n",
      "commitDate": 1407390545000,
      "commitName": "a5031acb330edaa2311acbce4945f7b44fc76b29",
      "commitAuthor": "Max",
      "commitDateOld": 1405537567000,
      "commitNameOld": "af8d57317fd308e72ab9041200df10506b96870f",
      "commitAuthorOld": "Max",
      "daysBetweenCommits": 21.45,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST nextToken \u003d aAST.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d aAST.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (isTypeField(aAST) \u0026\u0026 !hasBlankLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n-                if (astType !\u003d nextToken.getType()\n-                    \u0026\u0026 !hasBlankLineAfter(aAST))\n+                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n+                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n+                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                 {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n+            case TokenTypes.PACKAGE_DEF:\n+                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n+                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n+                }\n             default:\n-                if (!hasBlankLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                if (!hasEmptyLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab": {
      "type": "Yintroduced",
      "commitMessage": "EmptyLineSeparatorCheck #186. Exactly one blank line separates each section that is present.\n",
      "commitDate": 1405480097000,
      "commitName": "d9452c8d5e2cffcad33fbf763db8473fcbb42eab",
      "commitAuthor": "Max"
    }
  }
}