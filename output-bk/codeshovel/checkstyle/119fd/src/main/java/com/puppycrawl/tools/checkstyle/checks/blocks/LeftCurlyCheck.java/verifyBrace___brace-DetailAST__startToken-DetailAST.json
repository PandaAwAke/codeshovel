{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "LeftCurlyCheck.java",
  "functionName": "verifyBrace",
  "functionId": "verifyBrace___brace-DetailAST__startToken-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java",
  "functionStartLine": 304,
  "functionEndLine": 323,
  "changeHistory": [
    "9eec8df60589da1069885cd56345fe1f3d609859",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
    "cb5a59fc6baf5de204e3cc99be6ba9865e44350a",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
    "085ce12db0983590844ccc24ea49f91686a30ed8",
    "289ef67e9e9ee424723b8aa22ae7a6d31f126d23",
    "3a5a73d5c110418f712f5a9a838c6b4106506fdd",
    "71d0a829e42bfcbfa3fd692a29abf8796e467fc9",
    "2b32b003ab81c9bfcb8205b512eb4ea313e529af",
    "ae0e7def779cddabf1e93ee744b9b341ef27647f",
    "04ceb4b91f4e66439479406834f42014c5be62ed",
    "44e274bfbaf09a067726164e01a9c277f4a97090",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "cea86a6cad3098ebcdb4a88db2e49477b07e0d93",
    "abe8ae60eefcc58483df0957b27c2b5fa5e92fd5",
    "cba6fc8b0a653a795107566f895d2b8f73e2c6c9",
    "a123763c92761d644fed6010c05ff01cece025ae",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "3bd6412e39a141b980901f291391ff1bcc4a61f3",
    "a14bce7522cc9d73e52efa43954f9a2449df34e3",
    "823ef8630a9eb7c835b54ff4e6727e4f013ee18d",
    "fc358e2da0cfb9a2c34800b781c8894f73d8d345",
    "267bdf541787643fbe6126605cbfb91dbcde1e91",
    "8083866f7257e205cd24b7098c1b80da3a6aebb5",
    "2213adc2bc733b0878c662c314b183b4f7dff1e7"
  ],
  "changeHistoryShort": {
    "9eec8df60589da1069885cd56345fe1f3d609859": "Ybodychange",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": "Ybodychange",
    "cb5a59fc6baf5de204e3cc99be6ba9865e44350a": "Ybodychange",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": "Ybodychange",
    "085ce12db0983590844ccc24ea49f91686a30ed8": "Ybodychange",
    "289ef67e9e9ee424723b8aa22ae7a6d31f126d23": "Ybodychange",
    "3a5a73d5c110418f712f5a9a838c6b4106506fdd": "Ybodychange",
    "71d0a829e42bfcbfa3fd692a29abf8796e467fc9": "Ybodychange",
    "2b32b003ab81c9bfcb8205b512eb4ea313e529af": "Ybodychange",
    "ae0e7def779cddabf1e93ee744b9b341ef27647f": "Ybodychange",
    "04ceb4b91f4e66439479406834f42014c5be62ed": "Ybodychange",
    "44e274bfbaf09a067726164e01a9c277f4a97090": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "cea86a6cad3098ebcdb4a88db2e49477b07e0d93": "Ymultichange(Yparameterchange,Ybodychange)",
    "abe8ae60eefcc58483df0957b27c2b5fa5e92fd5": "Ybodychange",
    "cba6fc8b0a653a795107566f895d2b8f73e2c6c9": "Ybodychange",
    "a123763c92761d644fed6010c05ff01cece025ae": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "3bd6412e39a141b980901f291391ff1bcc4a61f3": "Yfilerename",
    "a14bce7522cc9d73e52efa43954f9a2449df34e3": "Ymultichange(Ymovefromfile,Ymodifierchange)",
    "823ef8630a9eb7c835b54ff4e6727e4f013ee18d": "Yfilerename",
    "fc358e2da0cfb9a2c34800b781c8894f73d8d345": "Ybodychange",
    "267bdf541787643fbe6126605cbfb91dbcde1e91": "Ybodychange",
    "8083866f7257e205cd24b7098c1b80da3a6aebb5": "Ybodychange",
    "2213adc2bc733b0878c662c314b183b4f7dff1e7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9eec8df60589da1069885cd56345fe1f3d609859": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2451: removed excess hierarchy from LeftCurlyCheck",
      "commitDate": 1447384509000,
      "commitName": "9eec8df60589da1069885cd56345fe1f3d609859",
      "commitAuthor": "rnveach",
      "commitDateOld": 1445689627000,
      "commitNameOld": "9316d20698a52bd68060947b8567577e47351b9a",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.62,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n-            if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n+            if (option \u003d\u003d LeftCurlyOption.NL) {\n                 if (!CommonUtils.hasWhitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace, MSG_KEY_LINE_NEW, OPEN_CURLY_BRACE, brace.getColumnNo() + 1);\n                 }\n             }\n-            else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n+            else if (option \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosition(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Rename methods returning boolean to use question word\n\nFixes some `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n\u003eReports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
      "commitDate": 1440827451000,
      "commitName": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1440741100000,
      "commitNameOld": "9ddad74e484384e5ca2d88ab0fe21922189e2b85",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n-                if (!CommonUtils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n+                if (!CommonUtils.hasWhitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace, MSG_KEY_LINE_NEW, OPEN_CURLY_BRACE, brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosition(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cb5a59fc6baf5de204e3cc99be6ba9865e44350a": {
      "type": "Ybodychange",
      "commitMessage": "Fix typos in blocks, headers and filters packages. #1555\n\nFixes some `SpellCheckingInspection` inspection violations.\n\nDescription:\n\u003eSpellchecker inspection helps locate typos and misspelling in your code, comments and literals.\n",
      "commitDate": 1440739668000,
      "commitName": "cb5a59fc6baf5de204e3cc99be6ba9865e44350a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1440677821000,
      "commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!CommonUtils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace, MSG_KEY_LINE_NEW, OPEN_CURLY_BRACE, brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n-                validateNewLinePosion(brace, startToken, braceLine);\n+                validateNewLinePosition(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": {
      "type": "Ybodychange",
      "commitMessage": "Utils class has been splitted to CommonUtils and TokenUtils. Issue #1898\n",
      "commitDate": 1440677821000,
      "commitName": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1440677821000,
      "commitNameOld": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n-                if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n+                if (!CommonUtils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace, MSG_KEY_LINE_NEW, OPEN_CURLY_BRACE, brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosion(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "085ce12db0983590844ccc24ea49f91686a30ed8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MultipleStringLiterals violations fixed\n",
      "commitDate": 1440543609000,
      "commitName": "085ce12db0983590844ccc24ea49f91686a30ed8",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1440243335000,
      "commitNameOld": "27375d081517bbf69110f3c37f73583a5d3c60fb",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 3.48,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                    log(brace, MSG_KEY_LINE_NEW, \"{\", brace.getColumnNo() + 1);\n+                    log(brace, MSG_KEY_LINE_NEW, OPEN_CURLY_BRACE, brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosion(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "289ef67e9e9ee424723b8aa22ae7a6d31f126d23": {
      "type": "Ybodychange",
      "commitMessage": "Marked \u0027maxLineLength\u0027 as \u0027@Deprecated\u0027 at LeftCurlyCheck, issue #965\n",
      "commitDate": 1439356812000,
      "commitName": "289ef67e9e9ee424723b8aa22ae7a6d31f126d23",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1439295539000,
      "commitNameOld": "1935bed5772c0a939b9168b81acd2ab5aa800538",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,23 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n-        // calculate the previous line length without trailing whitespace. Need\n-        // to handle the case where there is no previous line, cause the line\n-        // being check is the first line in the file.\n-        final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n-            ? maxLineLength\n-            : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n-\n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace, MSG_KEY_LINE_NEW, \"{\", brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n-                validateEol(brace, braceLine, prevLineLen);\n+                validateEol(brace, braceLine);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n-                validateNewLinePosion(brace, startToken, braceLine, prevLineLen);\n+                validateNewLinePosion(brace, startToken, braceLine);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "3a5a73d5c110418f712f5a9a838c6b4106506fdd": {
      "type": "Ybodychange",
      "commitMessage": "Added column number into violation messages for RightCurlyCheck and LeftCurlyCheck, issue #1511.\n",
      "commitDate": 1438460185000,
      "commitName": "3a5a73d5c110418f712f5a9a838c6b4106506fdd",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1438038837000,
      "commitNameOld": "71d0a829e42bfcbfa3fd692a29abf8796e467fc9",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 4.88,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,30 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                    log(brace.getLineNo(), brace.getColumnNo(),\n-                        MSG_KEY_LINE_NEW, \"{\");\n+                    log(brace, MSG_KEY_LINE_NEW, \"{\", brace.getColumnNo() + 1);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine, prevLineLen);\n             }\n             else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosion(brace, startToken, braceLine, prevLineLen);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "71d0a829e42bfcbfa3fd692a29abf8796e467fc9": {
      "type": "Ybodychange",
      "commitMessage": " Coverage has been increased t0 100% in LeftCurlyCheck. Issue #1291\n",
      "commitDate": 1438038837000,
      "commitName": "71d0a829e42bfcbfa3fd692a29abf8796e467fc9",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1437675307000,
      "commitNameOld": "cdcddbe49e985fccf170f6bb90e4251ea07952d7",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 4.21,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,31 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n \n                 validateEol(brace, braceLine, prevLineLen);\n             }\n-            else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW\n-                    \u0026\u0026 startToken.getLineNo() !\u003d brace.getLineNo()) {\n+            else if (startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosion(brace, startToken, braceLine, prevLineLen);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2b32b003ab81c9bfcb8205b512eb4ea313e529af": {
      "type": "Ybodychange",
      "commitMessage": "LeftCurlyCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434261690000,
      "commitName": "2b32b003ab81c9bfcb8205b512eb4ea313e529af",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1434261690000,
      "commitNameOld": "ae0e7def779cddabf1e93ee744b9b341ef27647f",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,32 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n-                if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n-                    \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength) {\n-                    log(brace.getLineNo(), brace.getColumnNo(),\n-                        MSG_KEY_LINE_PREVIOUS, \"{\");\n-                }\n-                if (!hasLineBreakAfter(brace)) {\n-                    log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n-                }\n+\n+                validateEol(brace, braceLine, prevLineLen);\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW\n                     \u0026\u0026 startToken.getLineNo() !\u003d brace.getLineNo()) {\n \n                 validateNewLinePosion(brace, startToken, braceLine, prevLineLen);\n \n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "ae0e7def779cddabf1e93ee744b9b341ef27647f": {
      "type": "Ybodychange",
      "commitMessage": "LeftCurlyCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434261690000,
      "commitName": "ae0e7def779cddabf1e93ee744b9b341ef27647f",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431863229000,
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,38 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken) {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n                 || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027) {\n             if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n                 if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n                     \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_PREVIOUS, \"{\");\n                 }\n                 if (!hasLineBreakAfter(brace)) {\n                     log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n                 }\n             }\n             else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW\n                     \u0026\u0026 startToken.getLineNo() !\u003d brace.getLineNo()) {\n-                // not on the same line\n-                if (startToken.getLineNo() + 1 \u003d\u003d brace.getLineNo()) {\n-                    if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                        log(brace.getLineNo(), brace.getColumnNo(),\n-                                MSG_KEY_LINE_NEW, \"{\");\n-                    }\n-                    else if (prevLineLen + 2 \u003c\u003d maxLineLength) {\n-                        log(brace.getLineNo(), brace.getColumnNo(),\n-                                MSG_KEY_LINE_PREVIOUS, \"{\");\n-                    }\n-                }\n-                else if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                    log(brace.getLineNo(), brace.getColumnNo(),\n-                            MSG_KEY_LINE_NEW, \"{\");\n-                }\n+\n+                validateNewLinePosion(brace, startToken, braceLine, prevLineLen);\n+\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "04ceb4b91f4e66439479406834f42014c5be62ed": {
      "type": "Ybodychange",
      "commitMessage": "Remove empty if statements to fix PMD violations, issue #744\n\nViolations of PMD rule [EmptyIfStmt](http://pmd.sourceforge.net/pmd-5.2.3/pmd-java/rules/java/empty.html#EmptyIfStmt) are fixed. All transformations were done by IDE automatically.\n",
      "commitDate": 1426999508000,
      "commitName": "04ceb4b91f4e66439479406834f42014c5be62ed",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1426454536000,
      "commitNameOld": "1c15b6a36baa68dc3f2ebdf9baac131e98bb9e04",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.31,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken)\n     {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n-        if (braceLine.length() \u003e brace.getColumnNo() + 1\n-            \u0026\u0026 braceLine.charAt(brace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027)\n+        if (braceLine.length() \u003c\u003d brace.getColumnNo() + 1\n+                || braceLine.charAt(brace.getColumnNo() + 1) !\u003d \u0027}\u0027)\n         {\n-            // ignore\n-        }\n-        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n-            if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                log(brace.getLineNo(), brace.getColumnNo(),\n-                    MSG_KEY_LINE_NEW, \"{\");\n-            }\n-        }\n-        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n-            if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n-                \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength)\n-            {\n-                log(brace.getLineNo(), brace.getColumnNo(),\n-                    MSG_KEY_LINE_PREVIOUS, \"{\");\n-            }\n-            if (!hasLineBreakAfter(brace)) {\n-                log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n-            }\n-        }\n-        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n-            if (startToken.getLineNo() \u003d\u003d brace.getLineNo()) {\n-                // all ok as on the same line\n-            }\n-            else if (startToken.getLineNo() + 1 \u003d\u003d brace.getLineNo()) {\n+            if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n-                else if (prevLineLen + 2 \u003c\u003d maxLineLength) {\n+            }\n+            else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n+                if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n+                    \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength)\n+                {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_PREVIOUS, \"{\");\n                 }\n+                if (!hasLineBreakAfter(brace)) {\n+                    log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n+                }\n             }\n-            else if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n-                log(brace.getLineNo(), brace.getColumnNo(),\n-                    MSG_KEY_LINE_NEW, \"{\");\n+            else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW\n+                    \u0026\u0026 startToken.getLineNo() !\u003d brace.getLineNo())\n+            {\n+                // not on the same line\n+                if (startToken.getLineNo() + 1 \u003d\u003d brace.getLineNo()) {\n+                    if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n+                        log(brace.getLineNo(), brace.getColumnNo(),\n+                                MSG_KEY_LINE_NEW, \"{\");\n+                    }\n+                    else if (prevLineLen + 2 \u003c\u003d maxLineLength) {\n+                        log(brace.getLineNo(), brace.getColumnNo(),\n+                                MSG_KEY_LINE_PREVIOUS, \"{\");\n+                    }\n+                }\n+                else if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n+                    log(brace.getLineNo(), brace.getColumnNo(),\n+                            MSG_KEY_LINE_NEW, \"{\");\n+                }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "44e274bfbaf09a067726164e01a9c277f4a97090": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary semicolons to fix PMD violations, issue #744\n\nAll violations of rule [EmptyStatementNotInLoop](http://pmd.sourceforge.net/pmd-5.2.3/pmd-java/rules/java/empty.html#EmptyStatementNotInLoop) are fixed. Empty statements sometimes were used to trick Checkstyle to allow empty blocks. While generally empty blocks are bad practice, there are too many of them in Checkstyle code to fix them in scope of this commit. Instead, [EmplyBlock](http://checkstyle.sourceforge.net/config_blocks.html#EmptyBlock) setting was changed to allow empty block when there is comment inside it for Checkstyle codebase.\n",
      "commitDate": 1426113655000,
      "commitName": "44e274bfbaf09a067726164e01a9c277f4a97090",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1426023398000,
      "commitNameOld": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken)\n     {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if (braceLine.length() \u003e brace.getColumnNo() + 1\n             \u0026\u0026 braceLine.charAt(brace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027)\n         {\n-            ; // ignore\n+            // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n                 \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength)\n             {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_PREVIOUS, \"{\");\n             }\n             if (!hasLineBreakAfter(brace)) {\n                 log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (startToken.getLineNo() \u003d\u003d brace.getLineNo()) {\n-                ; // all ok as on the same line\n+                // all ok as on the same line\n             }\n             else if (startToken.getLineNo() + 1 \u003d\u003d brace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n                 else if (prevLineLen + 2 \u003c\u003d maxLineLength) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_PREVIOUS, \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1425968782000,
      "commitNameOld": "49a23751eb6bffdfba94d72454d7676c9f85adc5",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n     private void verifyBrace(final DetailAST brace,\n                              final DetailAST startToken)\n     {\n         final String braceLine \u003d getLine(brace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n-        final int prevLineLen \u003d (brace.getLineNo() \u003d\u003d 1)\n+        final int prevLineLen \u003d brace.getLineNo() \u003d\u003d 1\n             ? maxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(brace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n-        if ((braceLine.length() \u003e (brace.getColumnNo() + 1))\n-            \u0026\u0026 (braceLine.charAt(brace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n+        if (braceLine.length() \u003e brace.getColumnNo() + 1\n+            \u0026\u0026 braceLine.charAt(brace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027)\n         {\n             ; // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(brace.getColumnNo(), braceLine)\n-                \u0026\u0026 ((prevLineLen + 2) \u003c\u003d maxLineLength))\n+                \u0026\u0026 prevLineLen + 2 \u003c\u003d maxLineLength)\n             {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_PREVIOUS, \"{\");\n             }\n             if (!hasLineBreakAfter(brace)) {\n                 log(brace.getLineNo(), brace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (startToken.getLineNo() \u003d\u003d brace.getLineNo()) {\n                 ; // all ok as on the same line\n             }\n-            else if ((startToken.getLineNo() + 1) \u003d\u003d brace.getLineNo()) {\n+            else if (startToken.getLineNo() + 1 \u003d\u003d brace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_NEW, \"{\");\n                 }\n-                else if ((prevLineLen + 2) \u003c\u003d maxLineLength) {\n+                else if (prevLineLen + 2 \u003c\u003d maxLineLength) {\n                     log(brace.getLineNo(), brace.getColumnNo(),\n                         MSG_KEY_LINE_PREVIOUS, \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(brace.getColumnNo(), braceLine)) {\n                 log(brace.getLineNo(), brace.getColumnNo(),\n                     MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cea86a6cad3098ebcdb4a88db2e49477b07e0d93": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, blocks, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java\n",
      "commitDate": 1421677949000,
      "commitName": "cea86a6cad3098ebcdb4a88db2e49477b07e0d93",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "abe8ae60eefcc58483df0957b27c2b5fa5e92fd5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #537 refactored tests from blocks package.\n",
      "commitDate": 1421431669000,
      "commitName": "abe8ae60eefcc58483df0957b27c2b5fa5e92fd5",
      "commitAuthor": "ychulovskyy",
      "commitDateOld": 1421176843000,
      "commitNameOld": "501b7c5240705c6db756608618fdcf58189e807e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n     private void verifyBrace(final DetailAST aBrace,\n                              final DetailAST aStartToken)\n     {\n         final String braceLine \u003d getLine(aBrace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n             : Utils.lengthMinusTrailingWhitespace(getLine(aBrace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n             \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n             ; // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n-                    \"line.new\", \"{\");\n+                        MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n-                    \"line.previous\", \"{\");\n+                        MSG_KEY_LINE_PREVIOUS, \"{\");\n             }\n             if (!hasLineBreakAfter(aBrace)) {\n-                log(aBrace.getLineNo(), aBrace.getColumnNo(), \"line.break.after\");\n+                log(aBrace.getLineNo(), aBrace.getColumnNo(), MSG_KEY_LINE_BREAK_AFTER);\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n                 ; // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n-                        \"line.new\", \"{\");\n+                        MSG_KEY_LINE_NEW, \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n-                        \"line.previous\", \"{\");\n+                        MSG_KEY_LINE_PREVIOUS, \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n-                    \"line.new\", \"{\");\n+                    MSG_KEY_LINE_NEW, \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cba6fc8b0a653a795107566f895d2b8f73e2c6c9": {
      "type": "Ybodychange",
      "commitMessage": "FileContents.getLines performance fix\n",
      "commitDate": 1414957696000,
      "commitName": "cba6fc8b0a653a795107566f895d2b8f73e2c6c9",
      "commitAuthor": "sopov.ivan",
      "commitDateOld": 1407964536000,
      "commitNameOld": "a123763c92761d644fed6010c05ff01cece025ae",
      "commitAuthorOld": "Max",
      "daysBetweenCommits": 80.94,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,55 @@\n     private void verifyBrace(final DetailAST aBrace,\n                              final DetailAST aStartToken)\n     {\n-        final String braceLine \u003d getLines()[aBrace.getLineNo() - 1];\n+        final String braceLine \u003d getLine(aBrace.getLineNo() - 1);\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n-            : Utils.lengthMinusTrailingWhitespace(\n-                getLines()[aBrace.getLineNo() - 2]);\n+            : Utils.lengthMinusTrailingWhitespace(getLine(aBrace.getLineNo() - 2));\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n             \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n             ; // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.previous\", \"{\");\n             }\n             if (!hasLineBreakAfter(aBrace)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(), \"line.break.after\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n                 ; // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.new\", \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.previous\", \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a123763c92761d644fed6010c05ff01cece025ae": {
      "type": "Ybodychange",
      "commitMessage": "Left curly update. Force line break #247\n",
      "commitDate": 1407964536000,
      "commitName": "a123763c92761d644fed6010c05ff01cece025ae",
      "commitAuthor": "Max",
      "commitDateOld": 1393953491000,
      "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthorOld": "Ivan Sopov",
      "daysBetweenCommits": 162.16,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,56 @@\n     private void verifyBrace(final DetailAST aBrace,\n                              final DetailAST aStartToken)\n     {\n         final String braceLine \u003d getLines()[aBrace.getLineNo() - 1];\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n             : Utils.lengthMinusTrailingWhitespace(\n                 getLines()[aBrace.getLineNo() - 2]);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n             \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n             ; // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.previous\", \"{\");\n             }\n+            if (!hasLineBreakAfter(aBrace)) {\n+                log(aBrace.getLineNo(), aBrace.getColumnNo(), \"line.break.after\");\n+            }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n                 ; // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.new\", \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.previous\", \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "3bd6412e39a141b980901f291391ff1bcc4a61f3": {
      "type": "Yfilerename",
      "commitMessage": "Refactored the Block checks\n",
      "commitDate": 1054723367000,
      "commitName": "3bd6412e39a141b980901f291391ff1bcc4a61f3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1054719060000,
      "commitNameOld": "a0844ab125394605a6970a23132daa41ed5cecb1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "a14bce7522cc9d73e52efa43954f9a2449df34e3": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange)",
      "commitMessage": "Refactored all the LeftCurly checks into one\n",
      "commitDate": 1040280935000,
      "commitName": "a14bce7522cc9d73e52efa43954f9a2449df34e3",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Ymovefromfile",
        "Ymodifierchange"
      ]
    },
    "823ef8630a9eb7c835b54ff4e6727e4f013ee18d": {
      "type": "Yfilerename",
      "commitMessage": "Renamed LeftCurlyCheck to AbstractLeftCurlyCheck.\nCompletely happy with the name. :-)\n",
      "commitDate": 1038186288000,
      "commitName": "823ef8630a9eb7c835b54ff4e6727e4f013ee18d",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1038185841000,
      "commitNameOld": "af958820c7532dd4d713bcca5957c67e248528b4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "fc358e2da0cfb9a2c34800b781c8894f73d8d345": {
      "type": "Ybodychange",
      "commitMessage": "Fixed Javadoc errors\n",
      "commitDate": 1036543641000,
      "commitName": "fc358e2da0cfb9a2c34800b781c8894f73d8d345",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036543226000,
      "commitNameOld": "267bdf541787643fbe6126605cbfb91dbcde1e91",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     protected void verifyBrace(final DetailAST aBrace,\n                                final DetailAST aStartToken)\n     {\n         final String braceLine \u003d getLines()[aBrace.getLineNo() - 1];\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n             : Utils.lengthMinusTrailingWhitespace(\n                 getLines()[aBrace.getLineNo() - 2]);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n             \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n-            // ignore\n+            ; // ignore\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.previous\", \"{\");\n             }\n         }\n         else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n-                // all ok as on the same line\n+                ; // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.new\", \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.previous\", \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "267bdf541787643fbe6126605cbfb91dbcde1e91": {
      "type": "Ybodychange",
      "commitMessage": "Refactor to improve the AbstractOptionCheck code.\n",
      "commitDate": 1036543226000,
      "commitName": "267bdf541787643fbe6126605cbfb91dbcde1e91",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036361604000,
      "commitNameOld": "065c1d3bc59e10d0235d8732652d2f2787fbbcd7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     protected void verifyBrace(final DetailAST aBrace,\n                                final DetailAST aStartToken)\n     {\n         final String braceLine \u003d getLines()[aBrace.getLineNo() - 1];\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n             : Utils.lengthMinusTrailingWhitespace(\n                 getLines()[aBrace.getLineNo() - 2]);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n         if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n             \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n             // ignore\n         }\n-        else if (mOption \u003d\u003d LeftCurlyOption.NL) {\n+        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n-        else if (mOption \u003d\u003d LeftCurlyOption.EOL) {\n+        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.previous\", \"{\");\n             }\n         }\n-        else if (mOption \u003d\u003d LeftCurlyOption.NLOW) {\n+        else if (getAbstractOption() \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n                 // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.new\", \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.previous\", \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8083866f7257e205cd24b7098c1b80da3a6aebb5": {
      "type": "Ybodychange",
      "commitMessage": "Removed unused options.\n",
      "commitDate": 1034513193000,
      "commitName": "8083866f7257e205cd24b7098c1b80da3a6aebb5",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1034506323000,
      "commitNameOld": "2213adc2bc733b0878c662c314b183b4f7dff1e7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n     protected void verifyBrace(final DetailAST aBrace, final DetailAST aStartToken)\n     {\n         final String braceLine \u003d getLines()[aBrace.getLineNo() - 1];\n \n         // calculate the previous line length without trailing whitespace. Need\n         // to handle the case where there is no previous line, cause the line\n         // being check is the first line in the file.\n         final int prevLineLen \u003d (aBrace.getLineNo() \u003d\u003d 1)\n             ? mMaxLineLength\n             : Utils.lengthMinusTrailingWhitespace(\n                 getLines()[aBrace.getLineNo() - 2]);\n \n         // Check for being told to ignore, or have \u0027{}\u0027 which is a special case\n-        if ((mOption \u003d\u003d LeftCurlyOption.IGNORE)\n-            || ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n-                \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027)))\n+        if ((braceLine.length() \u003e (aBrace.getColumnNo() + 1))\n+            \u0026\u0026 (braceLine.charAt(aBrace.getColumnNo() + 1) \u003d\u003d \u0027}\u0027))\n         {\n             // ignore\n         }\n         else if (mOption \u003d\u003d LeftCurlyOption.NL) {\n             if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n         else if (mOption \u003d\u003d LeftCurlyOption.EOL) {\n             if (Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)\n                 \u0026\u0026 ((prevLineLen + 2) \u003c\u003d mMaxLineLength))\n             {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.previous\", \"{\");\n             }\n         }\n         else if (mOption \u003d\u003d LeftCurlyOption.NLOW) {\n             if (aStartToken.getLineNo() \u003d\u003d aBrace.getLineNo()) {\n                 // all ok as on the same line\n             }\n             else if ((aStartToken.getLineNo() + 1) \u003d\u003d aBrace.getLineNo()) {\n                 if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.new\", \"{\");\n                 }\n                 else if ((prevLineLen + 2) \u003c\u003d mMaxLineLength) {\n                     log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                         \"line.previous\", \"{\");\n                 }\n             }\n             else if (!Utils.whitespaceBefore(aBrace.getColumnNo(), braceLine)) {\n                 log(aBrace.getLineNo(), aBrace.getColumnNo(),\n                     \"line.new\", \"{\");\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2213adc2bc733b0878c662c314b183b4f7dff1e7": {
      "type": "Yintroduced",
      "commitMessage": "Pulled up common functionality\n",
      "commitDate": 1034506323000,
      "commitName": "2213adc2bc733b0878c662c314b183b4f7dff1e7",
      "commitAuthor": "Oliver Burn"
    }
  }
}