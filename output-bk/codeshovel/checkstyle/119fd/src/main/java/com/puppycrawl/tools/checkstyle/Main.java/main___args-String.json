{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "Main.java",
  "functionName": "main",
  "functionId": "main___args-String",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
  "functionStartLine": 181,
  "functionEndLine": 244,
  "changeHistory": [
    "b1b49751d38af0bf2476aea1f4595283615ab7de",
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5",
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6",
    "a6ab6053e6b3d421d19764418cba3858c683e6e8",
    "1549ea4822139938296a58f59c38ae14f633c5aa",
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
    "25621a3c3391ddf4bc0bb56535d23e73cd293657",
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
    "c225479c7d3a7b82fec7d26131ac27496d336853",
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
    "f020066f8bdfb378df36904af3df8b5bc48858fd",
    "5391df43637f6522979d46c5c4e35f772f08f4ac",
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
    "da6a8d083cb82a94707146de559911578f39affe",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
    "2880edd6554400955fb950bf8127311c436d2a7a",
    "aaf39002ac7fa00b95f4719beca058f6f7445574",
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019",
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
    "ab2f93f9bf61816d84154e636d32c81c05854e24",
    "702a1a957607881e72bb94b3104c2603ef10891f",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "fe9057366308642868c25d427c3ee94411b37170",
    "f38d8abd42c3e824635e542e6031b3da1997c02e",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b",
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "dd477210aefeabb265e105a9fe8120c8310605e8",
    "784842200f5307597d721ba0190c912cfab1b77f",
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84",
    "47802121745d9113b54cdb2d8ccef59e74ce3e72",
    "00fb7f0c1852eb015933c7c121284597de29caad",
    "2820c1d09d418935f7e7c410274f86da173eb96b",
    "88e89a138aa39f50f7642106cde6568f6e07783f",
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
    "822384a711290170148b43b5ae390dd4e8cfaf4f",
    "2debda611fe487021711aa4acce56651799a778f",
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
    "4cbd709c019cf1b69796858506d673f7b66d37c7",
    "1cea3765893e83e0d58ca110113e0d05b15a798a",
    "3288a81e30ddea194f76bd74f3b509500b864163",
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b",
    "add2bdfb27494bff5fa9c305d9782f57c6170b18",
    "ef5716560b2b52a5fcd233ac9ad546a53749339f",
    "e200d9bf3d07b103e633d56215280e5e7d7a980b",
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
    "69138e40225407ef560fd9d06d2903de37c83c2c",
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3"
  ],
  "changeHistoryShort": {
    "b1b49751d38af0bf2476aea1f4595283615ab7de": "Ybodychange",
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc": "Ybodychange",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": "Ybodychange",
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6": "Ybodychange",
    "a6ab6053e6b3d421d19764418cba3858c683e6e8": "Ybodychange",
    "1549ea4822139938296a58f59c38ae14f633c5aa": "Ybodychange",
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a": "Ybodychange",
    "25621a3c3391ddf4bc0bb56535d23e73cd293657": "Ybodychange",
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6": "Ybodychange",
    "c225479c7d3a7b82fec7d26131ac27496d336853": "Ymultichange(Yexceptionschange,Ybodychange)",
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc": "Ybodychange",
    "f020066f8bdfb378df36904af3df8b5bc48858fd": "Ybodychange",
    "5391df43637f6522979d46c5c4e35f772f08f4ac": "Ybodychange",
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af": "Yexceptionschange",
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a": "Ybodychange",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": "Ybodychange",
    "da6a8d083cb82a94707146de559911578f39affe": "Ybodychange",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": "Ybodychange",
    "2880edd6554400955fb950bf8127311c436d2a7a": "Ybodychange",
    "aaf39002ac7fa00b95f4719beca058f6f7445574": "Ybodychange",
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3": "Ymultichange(Yexceptionschange,Ybodychange)",
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019": "Ybodychange",
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f": "Yparameterchange",
    "ab2f93f9bf61816d84154e636d32c81c05854e24": "Ybodychange",
    "702a1a957607881e72bb94b3104c2603ef10891f": "Yexceptionschange",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "fe9057366308642868c25d427c3ee94411b37170": "Ybodychange",
    "f38d8abd42c3e824635e542e6031b3da1997c02e": "Ybodychange",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": "Ybodychange",
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "dd477210aefeabb265e105a9fe8120c8310605e8": "Ybodychange",
    "784842200f5307597d721ba0190c912cfab1b77f": "Ybodychange",
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84": "Ybodychange",
    "47802121745d9113b54cdb2d8ccef59e74ce3e72": "Ybodychange",
    "00fb7f0c1852eb015933c7c121284597de29caad": "Ybodychange",
    "2820c1d09d418935f7e7c410274f86da173eb96b": "Ybodychange",
    "88e89a138aa39f50f7642106cde6568f6e07783f": "Ybodychange",
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa": "Ybodychange",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": "Ybodychange",
    "822384a711290170148b43b5ae390dd4e8cfaf4f": "Ybodychange",
    "2debda611fe487021711aa4acce56651799a778f": "Ybodychange",
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5": "Ybodychange",
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c": "Ybodychange",
    "4cbd709c019cf1b69796858506d673f7b66d37c7": "Ybodychange",
    "1cea3765893e83e0d58ca110113e0d05b15a798a": "Ybodychange",
    "3288a81e30ddea194f76bd74f3b509500b864163": "Ybodychange",
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b": "Ybodychange",
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b": "Ybodychange",
    "add2bdfb27494bff5fa9c305d9782f57c6170b18": "Ybodychange",
    "ef5716560b2b52a5fcd233ac9ad546a53749339f": "Ybodychange",
    "e200d9bf3d07b103e633d56215280e5e7d7a980b": "Ybodychange",
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5": "Ybodychange",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": "Ybodychange",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": "Ybodychange",
    "69138e40225407ef560fd9d06d2903de37c83c2c": "Ybodychange",
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9": "Ybodychange",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b1b49751d38af0bf2476aea1f4595283615ab7de": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4399: increase coverage of pitest-checkstyle main profile to 100%\n",
      "commitDate": 1501160090000,
      "commitName": "b1b49751d38af0bf2476aea1f4595283615ab7de",
      "commitAuthor": "vasilyeva",
      "commitDateOld": 1500859159000,
      "commitNameOld": "4c10bc55b4aea0f7e3b95b06d820eedb7c6a6fb2",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 3.48,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,64 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter \u003d runCli(commandLine, filesToProcess);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n-            if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n-                final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0,\n-                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n-                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n-                System.out.println(errorCounterMessage.getMessage());\n+            // two ifs exist till https://github.com/hcoles/pitest/issues/377\n+            if (errorCounter !\u003d 0) {\n+                if (!cliViolations) {\n+                    final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0,\n+                            Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n+                            new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n+                    System.out.println(errorCounterMessage.getMessage());\n+                }\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "dab682c2f0e2853858a6d24e1fe2c2088315a0cc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3110: Modified Main to remove hardcoded messages and to support i18n for the messages\n",
      "commitDate": 1499482554000,
      "commitName": "dab682c2f0e2853858a6d24e1fe2c2088315a0cc",
      "commitAuthor": "Subbu Dantu",
      "commitDateOld": 1499049797000,
      "commitNameOld": "036582d728d2e2bb37f360bb3a74f899f04d587d",
      "commitAuthorOld": "Andrew Kuchev",
      "daysBetweenCommits": 5.01,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,61 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter \u003d runCli(commandLine, filesToProcess);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n-                System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+                final LocalizedMessage errorCounterMessage \u003d new LocalizedMessage(0,\n+                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n+                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n+                System.out.println(errorCounterMessage.getMessage());\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3233: Resolve IntelijIdea inspection violations for java8 migration (#3434)\n\n",
      "commitDate": 1473337840000,
      "commitName": "de022d2434e58dd633fd50a7f9bb50565a8767b5",
      "commitAuthor": "Mariia Mykhailova",
      "commitDateOld": 1470147795000,
      "commitNameOld": "77081171f2d8deade9fb4f5f677c4b07e05d1540",
      "commitAuthorOld": "Glenn Hollingsworth",
      "daysBetweenCommits": 36.92,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,58 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n-                    for (String message : messages) {\n-                        System.out.println(message);\n-                    }\n+                    messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter \u003d runCli(commandLine, filesToProcess);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3287: added exclude directory option (#3288)\n\n",
      "commitDate": 1469588124000,
      "commitName": "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6",
      "commitAuthor": "rnveach",
      "commitDateOld": 1468298833000,
      "commitNameOld": "44119413b68542bb1db3f50d2585834b9d00d1b3",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.92,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n-                final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n+                final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(getExclusions(commandLine),\n+                        commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     errorCounter \u003d runCli(commandLine, filesToProcess);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a6ab6053e6b3d421d19764418cba3858c683e6e8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3086: added debug option",
      "commitDate": 1464355091000,
      "commitName": "a6ab6053e6b3d421d19764418cba3858c683e6e8",
      "commitAuthor": "rnveach",
      "commitDateOld": 1460322482000,
      "commitNameOld": "1549ea4822139938296a58f59c38ae14f633c5aa",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 46.67,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,59 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n-                    // create config helper object\n-                    final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n-                    if (commandLine.hasOption(OPTION_T_NAME)) {\n-                        // print AST\n-                        final File file \u003d config.files.get(0);\n-                        final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n-                        final File file \u003d config.files.get(0);\n-                        final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_J_NAME)) {\n-                        final File file \u003d config.files.get(0);\n-                        final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n-                        final File file \u003d config.files.get(0);\n-                        final String stringAst \u003d AstTreeStringPrinter.printJavaAndJavadocTree(file);\n-                        System.out.print(stringAst);\n-                    }\n-                    else {\n-                        // run Checker\n-                        errorCounter \u003d runCheckstyle(config);\n-                        exitStatus \u003d errorCounter;\n-                    }\n+                    errorCounter \u003d runCli(commandLine, filesToProcess);\n+                    exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1549ea4822139938296a58f59c38ae14f633c5aa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3040: New CLI option to print full tree (java+comments+javadoc). (#3078)",
      "commitDate": 1460322482000,
      "commitName": "1549ea4822139938296a58f59c38ae14f633c5aa",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1458220789000,
      "commitNameOld": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 24.33,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,85 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_J_NAME)) {\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n                         System.out.print(stringAst);\n                     }\n+                    else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n+                        final File file \u003d config.files.get(0);\n+                        final String stringAst \u003d AstTreeStringPrinter.printJavaAndJavadocTree(file);\n+                        System.out.print(stringAst);\n+                    }\n                     else {\n                         // run Checker\n                         errorCounter \u003d runCheckstyle(config);\n                         exitStatus \u003d errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "68b49fd2843f23f55dc711a89213d59f2acf3a0a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #652: New CLI option to print Javadoc comment parse tree\n",
      "commitDate": 1458220789000,
      "commitName": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1456240030000,
      "commitNameOld": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 22.93,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,80 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n+                    else if (commandLine.hasOption(OPTION_J_NAME)) {\n+                        final File file \u003d config.files.get(0);\n+                        final String stringAst \u003d DetailNodeTreeStringPrinter.printFileAst(file);\n+                        System.out.print(stringAst);\n+                    }\n                     else {\n                         // run Checker\n                         errorCounter \u003d runCheckstyle(config);\n                         exitStatus \u003d errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "25621a3c3391ddf4bc0bb56535d23e73cd293657": {
      "type": "Ybodychange",
      "commitMessage": "Issue #652: New option to print AST with comment nodes.\n",
      "commitDate": 1456240030000,
      "commitName": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1455113230000,
      "commitNameOld": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 13.04,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,75 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n-\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file \u003d config.files.get(0);\n-                        final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n+                        final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, false);\n+                        System.out.print(stringAst);\n+                    }\n+                    else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n+                        final File file \u003d config.files.get(0);\n+                        final String stringAst \u003d AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n                     else {\n                         // run Checker\n                         errorCounter \u003d runCheckstyle(config);\n                         exitStatus \u003d errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2103: removed excess file gathering in main",
      "commitDate": 1455113230000,
      "commitName": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
      "commitAuthor": "rnveach",
      "commitDateOld": 1454581973000,
      "commitNameOld": "c225479c7d3a7b82fec7d26131ac27496d336853",
      "commitAuthorOld": "Vladislav Lisetskiy",
      "daysBetweenCommits": 6.15,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n+                final List\u003cFile\u003e filesToProcess \u003d getFilesToProcess(commandLine.getArgs());\n+\n                 // return error if something is wrong in arguments\n-                final List\u003cString\u003e messages \u003d validateCli(commandLine);\n+                final List\u003cString\u003e messages \u003d validateCli(commandLine, filesToProcess);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n-                    final CliOptions config \u003d convertCliToPojo(commandLine);\n+                    final CliOptions config \u003d convertCliToPojo(commandLine, filesToProcess);\n \n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file \u003d config.files.get(0);\n                         final String stringAst \u003d AstTreeStringPrinter.printFileAst(file);\n                         System.out.print(stringAst);\n                     }\n                     else {\n                         // run Checker\n                         errorCounter \u003d runCheckstyle(config);\n                         exitStatus \u003d errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c225479c7d3a7b82fec7d26131ac27496d336853": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
      "commitDate": 1454581973000,
      "commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
      "commitAuthor": "Vladislav Lisetskiy",
      "subchanges": [
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "f65b17cbc30795247fef3077cce16a8bb53e9ffc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2616: Fix CatchParameterName check violations in Checkstyle code\n",
      "commitDate": 1449184604000,
      "commitName": "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1446559490000,
      "commitNameOld": "1c5d01c3b48ab48fcfb0e7f3764e98d46727870e",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 30.38,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n-        catch (CheckstyleException e) {\n+        catch (CheckstyleException ex) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n-            e.printStackTrace();\n+            ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f020066f8bdfb378df36904af3df8b5bc48858fd": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2109: CLI should print a file name where exception is happen\n",
      "commitDate": 1446385952000,
      "commitName": "f020066f8bdfb378df36904af3df8b5bc48858fd",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1444265756000,
      "commitNameOld": "423ed9e469db620671459827b58c89025d8f6c66",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 24.54,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n-            printMessageAndCause(e);\n+            e.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5391df43637f6522979d46c5c4e35f772f08f4ac": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2213: Print missing cause of exception to console on error\n",
      "commitDate": 1442753319000,
      "commitName": "5391df43637f6522979d46c5c4e35f772f08f4ac",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1442527299000,
      "commitNameOld": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
      "commitAuthorOld": "Michael Osipov",
      "daysBetweenCommits": 2.62,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n-            System.out.println(e.getMessage());\n+            printMessageAndCause(e);\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b6d9344d1c152f225a22ce9ce09341b3cc9488af": {
      "type": "Yexceptionschange",
      "commitMessage": "Pull #2034: Use StandardCharsets and get rid of UnsupportedEncodingException\n",
      "commitDate": 1442527299000,
      "commitName": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
      "commitAuthor": "Michael Osipov",
      "commitDateOld": 1442014362000,
      "commitNameOld": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 5.94,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n-    public static void main(String... args) throws UnsupportedEncodingException,\n-            FileNotFoundException {\n+    public static void main(String... args) throws FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "0fc8b62a35beddc89cb3412388c27e88cd8cab4a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Fix typos in code\n",
      "commitDate": 1442014362000,
      "commitName": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1441879074000,
      "commitNameOld": "a29f01a95b9dee1e64ec7ed91b4d0876eb82c0bf",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 1.57,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n-                // return error is smth is wrong in arguments\n+                // return error if something is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n-            // smth wrong with arguments - print error and manual\n+            // something wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MultipleStringLiterals violations partial fix\n",
      "commitDate": 1440504773000,
      "commitName": "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1440042157000,
      "commitNameOld": "da6a8d083cb82a94707146de559911578f39affe",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n-            if (commandLine.hasOption(\"v\")) {\n+            if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "da6a8d083cb82a94707146de559911578f39affe": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary local variables. #1555\n\nFixes `UnnecessaryLocalVariable` inspection violation.\n\nDescription:\n\u003eReports unnecessary local variables, which add nothing to the comprehensibility of a method. Variables caught include local variables which are immediately returned, local variables that are immediately assigned to another variable and then not used, and local variables which always have the same value as another local variable or parameter.\n",
      "commitDate": 1440042157000,
      "commitName": "da6a8d083cb82a94707146de559911578f39affe",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1439886329000,
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n-            final int exitWithCheckstyleException \u003d -2;\n-            exitStatus \u003d exitWithCheckstyleException;\n+            exitStatus \u003d EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": {
      "type": "Ybodychange",
      "commitMessage": "Invert if statements with negated conditions. #1555\n\nFixes `NegatedIfElse` inspection violations.\n\nDescription:\n\u003eReports if statements which contain else branches and whose conditions are negated. Flipping the order of the if and else branches will usually increase the clarity of such statements.\n",
      "commitDate": 1439189206000,
      "commitName": "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1439011412000,
      "commitNameOld": "186625600d7678f597f56aa6a83d4b0a89e1fe35",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 2.06,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n-                if (!cliViolations) {\n-                    // create config helper object\n-                    final CliOptions config \u003d convertCliToPojo(commandLine);\n-                    // run Checker\n-                    errorCounter \u003d runCheckstyle(config);\n-                    exitStatus \u003d errorCounter;\n-                }\n-                else {\n+                if (cliViolations) {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n+                else {\n+                    // create config helper object\n+                    final CliOptions config \u003d convertCliToPojo(commandLine);\n+                    // run Checker\n+                    errorCounter \u003d runCheckstyle(config);\n+                    exitStatus \u003d errorCounter;\n+                }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             final int exitWithCheckstyleException \u003d -2;\n             exitStatus \u003d exitWithCheckstyleException;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2880edd6554400955fb950bf8127311c436d2a7a": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1538\n",
      "commitDate": 1438566538000,
      "commitName": "2880edd6554400955fb950bf8127311c436d2a7a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1438251815000,
      "commitNameOld": "88f75f5413914bea5b39ba318edf912ee706226d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 3.64,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n-        final int exitWithCheckstyleException \u003d -2;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n                 else {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n+            final int exitWithCheckstyleException \u003d -2;\n             exitStatus \u003d exitWithCheckstyleException;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus !\u003d 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "aaf39002ac7fa00b95f4719beca058f6f7445574": {
      "type": "Ybodychange",
      "commitMessage": "100% coverage for Main.java . #1294\n",
      "commitDate": 1438154965000,
      "commitName": "aaf39002ac7fa00b95f4719beca058f6f7445574",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1437631122000,
      "commitNameOld": "acbd47a66b01acc392a7bd37ad3a2e65eecd308a",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation \u003d -1;\n         final int exitWithCheckstyleException \u003d -2;\n         int exitStatus \u003d 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus \u003d 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n                     exitStatus \u003d errorCounter;\n                 }\n                 else {\n                     exitStatus \u003d exitWithCliViolation;\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             exitStatus \u003d exitWithCliViolation;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus \u003d exitWithCheckstyleException;\n             errorCounter \u003d 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n-            System.exit(exitStatus);\n+            if (exitStatus !\u003d 0) {\n+                System.exit(exitStatus);\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4299a4b408304cd0bcad6c25b4a322dbd94169a3": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
      "commitDate": 1434292672000,
      "commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
      "commitAuthor": "Bhavik Patel",
      "subchanges": [
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "fe6db3ab8a864e11eebfb0496f6a41852bdee019": {
      "type": "Ybodychange",
      "commitMessage": "Solution to \"Incorrect config file cause CLI finish with error but no output with details\" solves #1180\n",
      "commitDate": 1433788956000,
      "commitName": "fe6db3ab8a864e11eebfb0496f6a41852bdee019",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": 1433691729000,
      "commitNameOld": "8a3ccee4918bc1ce5f6bc2dfea51389a59684eb0",
      "commitAuthorOld": "Bhavik Patel",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             CheckstyleException, FileNotFoundException {\n         int errorCounter \u003d 0;\n         boolean cliViolations \u003d false;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine \u003d parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List\u003cString\u003e messages \u003d validateCli(commandLine);\n                 cliViolations \u003d !messages.isEmpty();\n                 if (messages.isEmpty()) {\n \n                     // create config helper object\n                     final CliOptions config \u003d convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter \u003d runCheckstyle(config);\n \n                 }\n                 else {\n                     errorCounter \u003d 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations \u003d true;\n             errorCounter \u003d 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n-        catch (Exception ex) {\n-            // smth wrong during processing\n+        catch (CheckstyleException e) {\n             errorCounter \u003d 1;\n-            throw ex;\n+            System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter !\u003d 0 \u0026\u0026 !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             // provide proper exit code based on results.\n             System.exit(errorCounter);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1a2c318e22a0b2b22ccc76019217c0892fe2d59b": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
      "commitDate": 1430849532000,
      "commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
      "commitAuthor": "Roman Ivanov",
      "subchanges": [
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "c0446a825514ea0279b8c22f633f2c4e3c73dc1f": {
      "type": "Yparameterchange",
      "commitMessage": "Fix PMD violations from UseVarargs rule, issue #999\n\nThe changes are fully backward-compatible. Method with vararg can be invoked both using array and list of parameters.\n",
      "commitDate": 1430353274000,
      "commitName": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1430008241000,
      "commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n-    public static void main(String[] args) throws UnsupportedEncodingException\n+    public static void main(String... args) throws UnsupportedEncodingException\n     {\n         boolean parseResult \u003d false;\n         try {\n             processCommandLine(parseCli(args));\n             parseResult \u003d true;\n         }\n         catch (final ParseException e) {\n             System.err.println(\"Could not parse parameters: \" + e.getMessage());\n             e.printStackTrace();\n         }\n         catch (final Exception e) {\n             System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n             e.printStackTrace();\n         }\n         finally {\n             if (!parseResult) {\n                 usage();\n             }\n             // provide proper exit code based on results.\n             System.exit(parseResult ? 0 : 1);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "ab2f93f9bf61816d84154e636d32c81c05854e24": {
      "type": "Ybodychange",
      "commitMessage": "Delete System.exit() and delegate exit control into separate method.\n\nIssue #596\n",
      "commitDate": 1429852725000,
      "commitName": "ab2f93f9bf61816d84154e636d32c81c05854e24",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": 1428557866000,
      "commitNameOld": "702a1a957607881e72bb94b3104c2603ef10891f",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.99,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,23 @@\n     public static void main(String[] args) throws UnsupportedEncodingException\n     {\n-        // parse the parameters\n-        final CommandLineParser clp \u003d new PosixParser();\n-        CommandLine line \u003d null;\n+        boolean parseResult \u003d false;\n         try {\n-            line \u003d clp.parse(OPTS, args);\n+            processCommandLine(parseCli(args));\n+            parseResult \u003d true;\n         }\n         catch (final ParseException e) {\n-            usage();\n+            System.err.println(\"Could not parse parameters: \" + e.getMessage());\n+            e.printStackTrace();\n         }\n-        assert line !\u003d null;\n-\n-        // show version and exit\n-        if (line.hasOption(\"v\")) {\n-            System.out.println(\"Checkstyle version: \"\n-                    + Main.class.getPackage().getImplementationVersion());\n-            System.exit(0);\n+        catch (final Exception e) {\n+            System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n+            e.printStackTrace();\n         }\n-\n-        // setup the properties\n-        final Properties props \u003d\n-            line.hasOption(\"p\")\n-                ? loadProperties(new File(line.getOptionValue(\"p\")))\n-                : System.getProperties();\n-\n-        // ensure a config file is specified\n-        if (!line.hasOption(\"c\")) {\n-            System.out.println(\"Must specify a config XML file.\");\n-            usage();\n-        }\n-\n-        final Configuration config \u003d loadConfig(line, props);\n-\n-        // setup the output stream\n-        OutputStream out \u003d null;\n-        boolean closeOut \u003d false;\n-        if (line.hasOption(\"o\")) {\n-            final String fname \u003d line.getOptionValue(\"o\");\n-            try {\n-                out \u003d new FileOutputStream(fname);\n-                closeOut \u003d true;\n+        finally {\n+            if (!parseResult) {\n+                usage();\n             }\n-            catch (final FileNotFoundException e) {\n-                System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n-                System.exit(1);\n-            }\n+            // provide proper exit code based on results.\n+            System.exit(parseResult ? 0 : 1);\n         }\n-        else {\n-            out \u003d System.out;\n-            closeOut \u003d false;\n-        }\n-\n-        final AuditListener listener \u003d createListener(line, out, closeOut);\n-        final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n-        final Checker c \u003d createChecker(config, listener);\n-        final int numErrs \u003d c.process(files);\n-        c.destroy();\n-        System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "702a1a957607881e72bb94b3104c2603ef10891f": {
      "type": "Yexceptionschange",
      "commitMessage": "fix for Findbugs violation DM_DEFAULT_ENCODING. Issue #778\n",
      "commitDate": 1428557866000,
      "commitName": "702a1a957607881e72bb94b3104c2603ef10891f",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1426951045000,
      "commitNameOld": "48eee721d989ee5933fe6849a2f693c28a9385c3",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 18.6,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n-    public static void main(String[] args)\n+    public static void main(String[] args) throws UnsupportedEncodingException\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n             usage();\n         }\n         assert line !\u003d null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, listener);\n         final int numErrs \u003d c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
      "type": "Ybodychange",
      "commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
      "commitDate": 1426571164000,
      "commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1426457863000,
      "commitNameOld": "ca1c33e3112d9217e89eec82bbcd589381d48715",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.31,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n     public static void main(String[] args)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n-            e.printStackTrace();\n             usage();\n         }\n         assert line !\u003d null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, listener);\n         final int numErrs \u003d c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": 1421678312000,
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38": {
      "type": "Ybodychange",
      "commitMessage": "#9 -v CLI flag for querying the installed Checkstyle version\n",
      "commitDate": 1416599535000,
      "commitName": "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38",
      "commitAuthor": "ychulovskyy",
      "commitDateOld": 1393953491000,
      "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthorOld": "Ivan Sopov",
      "daysBetweenCommits": 262.11,
      "commitsBetweenForRepo": 268,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,60 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line !\u003d null;\n \n+        // show version and exit\n+        if (line.hasOption(\"v\")) {\n+            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+            System.exit(0);\n+        }\n+\n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, listener);\n         final int numErrs \u003d c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "fe9057366308642868c25d427c3ee94411b37170": {
      "type": "Ybodychange",
      "commitMessage": "Apply patch #1914806 for PackageNamesLoader from Lars Koedderitzsch.\n",
      "commitDate": 1207618517000,
      "commitName": "fe9057366308642868c25d427c3ee94411b37170",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1200192438000,
      "commitNameOld": "5a7e221b757e91d49be1aea105eb4b839e653fbd",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 85.95,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,54 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line !\u003d null;\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n-        //Load the set of package names\n-        ModuleFactory moduleFactory \u003d null;\n-        if (line.hasOption(\"n\")) {\n-            moduleFactory \u003d loadPackages(line);\n-        }\n-\n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n-        final Checker c \u003d createChecker(config, moduleFactory, listener);\n+        final Checker c \u003d createChecker(config, listener);\n         final int numErrs \u003d c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "f38d8abd42c3e824635e542e6031b3da1997c02e": {
      "type": "Ybodychange",
      "commitMessage": "Removed a native array in favour of a List\u003cFile\u003e -- was it worth it??\n\nAdded @Override where possible -- did this as I got bitten by a subtle bug when making the first change. The @Override would have prevented it.\n",
      "commitDate": 1198131671000,
      "commitName": "f38d8abd42c3e824635e542e6031b3da1997c02e",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1197714527000,
      "commitNameOld": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,60 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line !\u003d null;\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, moduleFactory, listener);\n-\n-        final File[] processedFiles \u003d new File[files.size()];\n-        files.toArray(processedFiles);\n-        final int numErrs \u003d c.process(processedFiles);\n+        final int numErrs \u003d c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": {
      "type": "Ybodychange",
      "commitMessage": "Finish of adding generics.\n",
      "commitDate": 1197706480000,
      "commitName": "f1afaf83f39b83cc3bd07a2388448b262652a76b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1169909494000,
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 321.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line !\u003d null;\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n-        final List files \u003d getFilesToProcess(line);\n+        final List\u003cFile\u003e files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0": {
      "type": "Ybodychange",
      "commitMessage": "Fix up warning about line possibly being null.\n",
      "commitDate": 1152244273000,
      "commitName": "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1152243856000,
      "commitNameOld": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n+        assert line !\u003d null;\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": 1152243856000,
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1105267857000,
      "commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 543.7,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n-        catch (ParseException e) {\n+        catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n-            catch (FileNotFoundException e) {\n+            catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "dd477210aefeabb265e105a9fe8120c8310605e8": {
      "type": "Ybodychange",
      "commitMessage": "Custom listeners can be incorported as config modules,\nnot command line arguments and ant task elements.\n",
      "commitDate": 1058527905000,
      "commitName": "dd477210aefeabb265e105a9fe8120c8310605e8",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1056715858000,
      "commitNameOld": "784842200f5307597d721ba0190c912cfab1b77f",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 20.97,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,62 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         final AuditListener listener \u003d createListener(line, out, closeOut);\n         final List files \u003d getFilesToProcess(line);\n         final Checker c \u003d createChecker(config, moduleFactory, listener);\n-        addCustomListeners(c, line);\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "784842200f5307597d721ba0190c912cfab1b77f": {
      "type": "Ybodychange",
      "commitMessage": "Refactored, that was really ugly code I had written.\n",
      "commitDate": 1056715858000,
      "commitName": "784842200f5307597d721ba0190c912cfab1b77f",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1056711878000,
      "commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n-        // Load the config file\n-        Configuration config \u003d null;\n-        try {\n-            config \u003d ConfigurationLoader.loadConfiguration(\n-                    line.getOptionValue(\"c\"), new PropertiesExpander(props));\n-        }\n-        catch (CheckstyleException e) {\n-            System.out.println(\"Error loading configuration file\");\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n+        final Configuration config \u003d loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n-            try {\n-                moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n-                    line.getOptionValue(\"n\"));\n-            }\n-            catch (CheckstyleException e) {\n-                System.out.println(\"Error loading package names file\");\n-                e.printStackTrace(System.out);\n-                System.exit(1);\n-            }\n+            moduleFactory \u003d loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n-        // create the appropriate listener\n-        final String format \u003d\n-            line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n-\n-        AuditListener listener \u003d null;\n-        if (\"xml\".equals(format)) {\n-            listener \u003d new XMLLogger(out, closeOut);\n-        }\n-        else if (\"plain\".equals(format)) {\n-            listener \u003d new DefaultLogger(out, closeOut);\n-        }\n-        else {\n-            System.out.println(\"Invalid format: (\" + format\n-                               + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n-            usage();\n-        }\n-\n-        // Get all the Java files\n-        final List files \u003d new LinkedList();\n-        if (line.hasOption(\"r\")) {\n-            final String[] values \u003d line.getOptionValues(\"r\");\n-            for (int i \u003d 0; i \u003c values.length; i++) {\n-                traverse(new File(values[i]), files);\n-            }\n-        }\n-\n-        final String[] remainingArgs \u003d line.getArgs();\n-        for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n-            files.add(new File(remainingArgs[i]));\n-        }\n-\n-        if (files.isEmpty()) {\n-            System.out.println(\"Must specify files to process\");\n-            usage();\n-        }\n-\n-        // create the checker\n-        Checker c \u003d null;\n-        try {\n-            c \u003d new Checker();\n-            c.setModuleFactory(moduleFactory);\n-            c.configure(config);\n-            c.addListener(listener);\n-        }\n-        catch (Exception e) {\n-            System.out.println(\"Unable to create Checker: \"\n-                               + e.getMessage());\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-\n-        // add custom listeners\n-        if (line.hasOption(\"l\")) {\n-            final String listeners \u003d line.getOptionValue(\"l\");\n-            final StringTokenizer t \u003d new StringTokenizer(listeners, \",\");\n-            while (t.hasMoreTokens()) {\n-                final String className \u003d t.nextToken();\n-                AuditListener customListener \u003d null;\n-                try {\n-                    customListener \u003d\n-                        (AuditListener) Class.forName(className).newInstance();\n-                }\n-                catch (Exception e) {\n-                    System.out.println(\"Unable to create listener \u0027\"\n-                        + className + \"\u0027: \" + e);\n-                    e.printStackTrace(System.out);\n-                    System.exit(1);\n-                }\n-                c.addListener(customListener);\n-            }\n-        }\n+        final AuditListener listener \u003d createListener(line, out, closeOut);\n+        final List files \u003d getFilesToProcess(line);\n+        final Checker c \u003d createChecker(config, moduleFactory, listener);\n+        addCustomListeners(c, line);\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "f2b01a44a216e88957eb6cb22e4b0e39429a6c84": {
      "type": "Ybodychange",
      "commitMessage": "Added custom listener feature\n",
      "commitDate": 1054056804000,
      "commitName": "f2b01a44a216e88957eb6cb22e4b0e39429a6c84",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1053985930000,
      "commitNameOld": "7dd1ab24d1a75687f426cb43a6e70d18d435b0a7",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,148 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), new PropertiesExpander(props));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n+        // add custom listeners\n+        if (line.hasOption(\"l\")) {\n+            final String listeners \u003d line.getOptionValue(\"l\");\n+            final StringTokenizer t \u003d new StringTokenizer(listeners, \",\");\n+            while (t.hasMoreTokens()) {\n+                final String className \u003d t.nextToken();\n+                AuditListener customListener \u003d null;\n+                try {\n+                    customListener \u003d\n+                        (AuditListener) Class.forName(className).newInstance();\n+                }\n+                catch (Exception e) {\n+                    System.out.println(\"Unable to create listener \u0027\"\n+                        + className + \"\u0027: \" + e);\n+                    e.printStackTrace(System.out);\n+                    System.exit(1);\n+                }\n+                c.addListener(customListener);\n+            }\n+        }\n+\n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "47802121745d9113b54cdb2d8ccef59e74ce3e72": {
      "type": "Ybodychange",
      "commitMessage": "use a PropertyResolver interface instead of using Properties directly\n",
      "commitDate": 1046003358000,
      "commitName": "47802121745d9113b54cdb2d8ccef59e74ce3e72",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1045311212000,
      "commitNameOld": "00fb7f0c1852eb015933c7c121284597de29caad",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n-                    line.getOptionValue(\"c\"), props);\n+                    line.getOptionValue(\"c\"), new PropertiesExpander(props));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "00fb7f0c1852eb015933c7c121284597de29caad": {
      "type": "Ybodychange",
      "commitMessage": "FileSetChecks are now responsible for filtering\nout the files they are not interested in, as discussed\non the checkstyle-devel list\n",
      "commitDate": 1045311212000,
      "commitName": "00fb7f0c1852eb015933c7c121284597de29caad",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1044359144000,
      "commitNameOld": "c13f6dd07d38a702143f7f78f74c59548e1f8453",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 11.02,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n-        // Get the file extension\n-        final String javaExtn \u003d\n-            \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n-\n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n-                traverse(new File(values[i]), files, javaExtn);\n+                traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "2820c1d09d418935f7e7c410274f86da173eb96b": {
      "type": "Ybodychange",
      "commitMessage": "rfe-652294: added support for specifying file extension for Java files\n",
      "commitDate": 1044149393000,
      "commitName": "2820c1d09d418935f7e7c410274f86da173eb96b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1040020006000,
      "commitNameOld": "88e89a138aa39f50f7642106cde6568f6e07783f",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 47.79,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,131 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n         \n         //Load the set of package names\n         ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n+        // Get the file extension\n+        final String javaExtn \u003d\n+            \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n+        \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n-                traverse(new File(values[i]), files);\n+                traverse(new File(values[i]), files, javaExtn);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "88e89a138aa39f50f7642106cde6568f6e07783f": {
      "type": "Ybodychange",
      "commitMessage": "Changed implementation of module name resolution from inheritance to delegation approach\n",
      "commitDate": 1040020006000,
      "commitName": "88e89a138aa39f50f7642106cde6568f6e07783f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1039114468000,
      "commitNameOld": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 10.48,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n         \n         //Load the set of package names\n-        String[] packageNames \u003d null;\n+        ModuleFactory moduleFactory \u003d null;\n         if (line.hasOption(\"n\")) {\n             try {\n-                packageNames \u003d PackageNamesLoader.loadPackageNames(\n+                moduleFactory \u003d PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n-            c.setPackageNames(packageNames);\n+            c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "16ba5b35f9f346e7cea294afaad7f9211605ecaa": {
      "type": "Ybodychange",
      "commitMessage": "modified for config XML and mapping names to full class names - see\nposting to checkstyle-devel@lists.sourceforge.net\n",
      "commitDate": 1039114468000,
      "commitName": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1038680984000,
      "commitNameOld": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 5.02,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n+        \n+        //Load the set of package names\n+        String[] packageNames \u003d null;\n+        if (line.hasOption(\"n\")) {\n+            try {\n+                packageNames \u003d PackageNamesLoader.loadPackageNames(\n+                    line.getOptionValue(\"n\"));\n+            }\n+            catch (CheckstyleException e) {\n+                System.out.println(\"Error loading package names file\");\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+        }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker();\n+            c.setPackageNames(packageNames);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
      "type": "Ybodychange",
      "commitMessage": "avalonization\n",
      "commitDate": 1038680984000,
      "commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1038675539000,
      "commitNameOld": "085befb3adfaed30db6623bfc04fa7b1e8755d3a",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,112 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n-//        CheckConfiguration[] checkConfigs \u003d null;\n-//        try {\n-//            checkConfigs \u003d\n-//                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n-//        }\n-//        catch (CheckstyleException e) {\n-//            System.out.println(\"Error loading configuration file\");\n-//            e.printStackTrace(System.out);\n-//            System.exit(1);\n-//        }\n-\n-        // Load the config file\n         Configuration config \u003d null;\n         try {\n-            config \u003d\n-                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n-                                                      props);\n+            config \u003d ConfigurationLoader.loadConfiguration(\n+                    line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n-//        // create the checker\n-//        Checker c \u003d null;\n-//        try {\n-//            c \u003d new Checker(new GlobalProperties(props, System.out),\n-//                            checkConfigs);\n-//            c.addListener(listener);\n-//        }\n-//        catch (Exception e) {\n-//            System.out.println(\"Unable to create Checker: \"\n-//                               + e.getMessage());\n-//            e.printStackTrace(System.out);\n-//            System.exit(1);\n-//        }\n-\n         // create the checker\n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(config);\n+            c \u003d new Checker();\n+            c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles \u003d new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "822384a711290170148b43b5ae390dd4e8cfaf4f": {
      "type": "Ybodychange",
      "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
      "commitDate": 1037515736000,
      "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1037475487000,
      "commitNameOld": "2debda611fe487021711aa4acce56651799a778f",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,138 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n //        CheckConfiguration[] checkConfigs \u003d null;\n //        try {\n //            checkConfigs \u003d\n //                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n //        }\n //        catch (CheckstyleException e) {\n //            System.out.println(\"Error loading configuration file\");\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d\n                 ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n                                                       props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n-        final List files \u003d new ArrayList();\n+        final List files \u003d new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n-            files.add(remainingArgs[i]);\n+            files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n //        // create the checker\n //        Checker c \u003d null;\n //        try {\n //            c \u003d new Checker(new GlobalProperties(props, System.out),\n //                            checkConfigs);\n //            c.addListener(listener);\n //        }\n //        catch (Exception e) {\n //            System.out.println(\"Unable to create Checker: \"\n //                               + e.getMessage());\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        final int numErrs \u003d\n-            c.process((String[]) files.toArray(new String[files.size()]));\n+        final File[] processedFiles \u003d new File[files.size()];\n+        files.toArray(processedFiles);\n+        final int numErrs \u003d c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "2debda611fe487021711aa4acce56651799a778f": {
      "type": "Ybodychange",
      "commitMessage": "Added overriding global properties\nNeeds testing, especially in ant with CheckstyleTask.\n",
      "commitDate": 1037475487000,
      "commitName": "2debda611fe487021711aa4acce56651799a778f",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1037384332000,
      "commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 1.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n //        CheckConfiguration[] checkConfigs \u003d null;\n //        try {\n //            checkConfigs \u003d\n //                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n //        }\n //        catch (CheckstyleException e) {\n //            System.out.println(\"Error loading configuration file\");\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // Load the config file\n         Configuration config \u003d null;\n         try {\n             config \u003d\n-                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n+                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n+                                                      props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n //        // create the checker\n //        Checker c \u003d null;\n //        try {\n //            c \u003d new Checker(new GlobalProperties(props, System.out),\n //                            checkConfigs);\n //            c.addListener(listener);\n //        }\n //        catch (Exception e) {\n //            System.out.println(\"Unable to create Checker: \"\n //                               + e.getMessage());\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "3c0608f33a6c41cf96056c52ae99070cbe5062d5": {
      "type": "Ybodychange",
      "commitMessage": "Wrapped GlobalProperties and CheckConfiguration[] into a Configuration\nclass. TODO: Integrate with CheckStyleTask\n",
      "commitDate": 1037384332000,
      "commitName": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1037268436000,
      "commitNameOld": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 1.34,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,136 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n-        CheckConfiguration[] checkConfigs \u003d null;\n+//        CheckConfiguration[] checkConfigs \u003d null;\n+//        try {\n+//            checkConfigs \u003d\n+//                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+//        }\n+//        catch (CheckstyleException e) {\n+//            System.out.println(\"Error loading configuration file\");\n+//            e.printStackTrace(System.out);\n+//            System.exit(1);\n+//        }\n+\n+        // Load the config file\n+        Configuration config \u003d null;\n         try {\n-            checkConfigs \u003d\n-                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+            config \u003d\n+                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n+//        // create the checker\n+//        Checker c \u003d null;\n+//        try {\n+//            c \u003d new Checker(new GlobalProperties(props, System.out),\n+//                            checkConfigs);\n+//            c.addListener(listener);\n+//        }\n+//        catch (Exception e) {\n+//            System.out.println(\"Unable to create Checker: \"\n+//                               + e.getMessage());\n+//            e.printStackTrace(System.out);\n+//            System.exit(1);\n+//        }\n+\n         // create the checker\n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(new GlobalProperties(props, System.out),\n-                            checkConfigs);\n+            c \u003d new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "6f4247181beca3530b5c2dc762d9c5c6a018a06c": {
      "type": "Ybodychange",
      "commitMessage": "rename Configuration to GlobalProperties\n",
      "commitDate": 1037268436000,
      "commitName": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1037161281000,
      "commitNameOld": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         CheckConfiguration[] checkConfigs \u003d null;\n         try {\n             checkConfigs \u003d\n                 ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n             final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n \n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n+            c \u003d new Checker(new GlobalProperties(props, System.out),\n+                            checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "4cbd709c019cf1b69796858506d673f7b66d37c7": {
      "type": "Ybodychange",
      "commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
      "commitDate": 1037161281000,
      "commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1037051575000,
      "commitNameOld": "1cea3765893e83e0d58ca110113e0d05b15a798a",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp \u003d new PosixParser();\n         CommandLine line \u003d null;\n         try {\n             line \u003d clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n-        \n+\n         // setup the properties\n         final Properties props \u003d\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n-        \n+\n         // Load the config file\n         CheckConfiguration[] checkConfigs \u003d null;\n         try {\n             checkConfigs \u003d\n                 ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n         if (line.hasOption(\"o\")) {\n-            final String fname \u003d line.getOptionValue(\"o\"); \n+            final String fname \u003d line.getOptionValue(\"o\");\n             try {\n                 out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out \u003d System.out;\n             closeOut \u003d false;\n         }\n-        \n+\n         // create the appropriate listener\n         final String format \u003d\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n-        \n+\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files \u003d new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values \u003d line.getOptionValues(\"r\");\n             for (int i \u003d 0; i \u003c values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n- \n+\n         final String[] remainingArgs \u003d line.getArgs();\n         for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n-        } \n+        }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n-        }         \n+        }\n \n         // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n-            c.processNEW((String[]) files.toArray(new String[files.size()]));\n+            c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "1cea3765893e83e0d58ca110113e0d05b15a798a": {
      "type": "Ybodychange",
      "commitMessage": "Refactoring the command line processing to use the new Jakarta Commons package\nhttp://jakarta.apache.org/commons/cli/. It is quite a nice package.\n",
      "commitDate": 1037051575000,
      "commitName": "1cea3765893e83e0d58ca110113e0d05b15a798a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036239734000,
      "commitNameOld": "3288a81e30ddea194f76bd74f3b509500b864163",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 9.4,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,110 @@\n     public static void main(String[] aArgs)\n     {\n-        if (aArgs.length \u003d\u003d 0) {\n+        // parse the parameters\n+        final CommandLineParser clp \u003d new PosixParser();\n+        CommandLine line \u003d null;\n+        try {\n+            line \u003d clp.parse(OPTS, aArgs);\n+        }\n+        catch (ParseException e) {\n+            e.printStackTrace();\n             usage();\n         }\n+        \n+        // setup the properties\n+        final Properties props \u003d\n+            line.hasOption(\"p\")\n+                ? loadProperties(new File(line.getOptionValue(\"p\")))\n+                : System.getProperties();\n \n-        // be brain dead about arguments parsing\n-        String format \u003d \"plain\";\n-        String output \u003d null;\n-        Properties props \u003d System.getProperties();\n-        final List foundFiles \u003d new ArrayList();\n-        final ArrayList files \u003d new ArrayList();\n-        for (int i \u003d 0; i \u003c aArgs.length; i++) {\n-            if (\"-f\".equals(aArgs[i])) {\n-                format \u003d aArgs[++i];\n-            }\n-            else if (\"-o\".equals(aArgs[i])) {\n-                output \u003d aArgs[++i];\n-            }\n-            else if (\"-r\".equals(aArgs[i])) {\n-                traverse(new File(aArgs[++i]), foundFiles);\n-            }\n-            else if (\"-p\".equals(aArgs[i])) {\n-                props \u003d loadProperties(new File(aArgs[++i]));\n-            }\n-            else {\n-                files.add(aArgs[i]);\n-            }\n+        // ensure a config file is specified\n+        if (!line.hasOption(\"c\")) {\n+            System.out.println(\"Must specify a config XML file.\");\n+            usage();\n+        }\n+        \n+        // Load the config file\n+        CheckConfiguration[] checkConfigs \u003d null;\n+        try {\n+            checkConfigs \u003d\n+                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+        }\n+        catch (CheckstyleException e) {\n+            System.out.println(\"Error loading configuration file\");\n+            e.printStackTrace(System.out);\n+            System.exit(1);\n         }\n \n-        // create the appropriate listener\n-        OutputStream out \u003d System.out;\n+        // setup the output stream\n+        OutputStream out \u003d null;\n         boolean closeOut \u003d false;\n-        if (output !\u003d null) {\n+        if (line.hasOption(\"o\")) {\n+            final String fname \u003d line.getOptionValue(\"o\"); \n             try {\n-                out \u003d new FileOutputStream(output);\n+                out \u003d new FileOutputStream(fname);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n-                System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n+                System.out.println(\"Could not find file: \u0027\" + fname + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n+        else {\n+            out \u003d System.out;\n+            closeOut \u003d false;\n+        }\n+        \n+        // create the appropriate listener\n+        final String format \u003d\n+            line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n+        \n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n-        // Check that I have a config file\n+        // Get all the Java files\n+        final List files \u003d new ArrayList();\n+        if (line.hasOption(\"r\")) {\n+            final String[] values \u003d line.getOptionValues(\"r\");\n+            for (int i \u003d 0; i \u003c values.length; i++) {\n+                traverse(new File(values[i]), files);\n+            }\n+        }\n+ \n+        final String[] remainingArgs \u003d line.getArgs();\n+        for (int i \u003d 0; i \u003c remainingArgs.length; i++) {\n+            files.add(remainingArgs[i]);\n+        } \n+\n         if (files.isEmpty()) {\n-            System.out.println(\"Need to specify a config file\");\n+            System.out.println(\"Must specify files to process\");\n             usage();\n-        }\n+        }         \n \n-        // Load the config file\n-        final String configFname \u003d (String) files.remove(0);\n-        CheckConfiguration[] checkConfigs \u003d null;\n-        try {\n-            checkConfigs \u003d ConfigurationLoader.loadConfigs(configFname);\n-        }\n-        catch (CheckstyleException e) {\n-            System.out.println(\"Error loading configuration file\");\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-\n+        // create the checker\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        files.addAll(foundFiles);\n         final int numErrs \u003d\n             c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "3288a81e30ddea194f76bd74f3b509500b864163": {
      "type": "Ybodychange",
      "commitMessage": "Just converted over the Checkstyle ANT task to use the new framework. In\nprocess I had to fix numerous errors now being reported.\n\nThere are some bugs with the method checks, which I will now investigate.\n",
      "commitDate": 1036239734000,
      "commitName": "3288a81e30ddea194f76bd74f3b509500b864163",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036067327000,
      "commitNameOld": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n         Properties props \u003d System.getProperties();\n         final List foundFiles \u003d new ArrayList();\n         final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), foundFiles);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 props \u003d loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         boolean closeOut \u003d false;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         // Check that I have a config file\n         if (files.isEmpty()) {\n             System.out.println(\"Need to specify a config file\");\n             usage();\n         }\n \n         // Load the config file\n         final String configFname \u003d (String) files.remove(0);\n         CheckConfiguration[] checkConfigs \u003d null;\n         try {\n-            checkConfigs \u003d loadConfigs(configFname);\n+            checkConfigs \u003d ConfigurationLoader.loadConfigs(configFname);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         files.addAll(foundFiles);\n         final int numErrs \u003d\n             c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b": {
      "type": "Ybodychange",
      "commitMessage": "Start of conversion to only supporting the new framework. Also refactored\nerror handling.\n",
      "commitDate": 1036067327000,
      "commitName": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1033108888000,
      "commitNameOld": "d077a402da51bb238a7da99d5e2542437b145192",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 34.24,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,92 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n-        Properties properties \u003d System.getProperties();\n+        Properties props \u003d System.getProperties();\n+        final List foundFiles \u003d new ArrayList();\n         final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n-                traverse(new File(aArgs[++i]), files);\n+                traverse(new File(aArgs[++i]), foundFiles);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n-                properties \u003d loadProperties(new File(aArgs[++i]));\n+                props \u003d loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         boolean closeOut \u003d false;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n+        // Check that I have a config file\n+        if (files.isEmpty()) {\n+            System.out.println(\"Need to specify a config file\");\n+            usage();\n+        }\n+\n+        // Load the config file\n+        final String configFname \u003d (String) files.remove(0);\n+        CheckConfiguration[] checkConfigs \u003d null;\n+        try {\n+            checkConfigs \u003d loadConfigs(configFname);\n+        }\n+        catch (CheckstyleException e) {\n+            System.out.println(\"Error loading configuration file\");\n+            e.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n+\n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(new Configuration(properties, System.out));\n+            c \u003d new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n+        files.addAll(foundFiles);\n         final int numErrs \u003d\n-            c.process((String[]) files.toArray(new String[files.size()]));\n+            c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b": {
      "type": "Ybodychange",
      "commitMessage": "Implemented a new version of Checker for that uses the Checks. The intent is\nto be able reuse the existing checker.\n\nOT: Due to ISP problems, I am unable to receive email at the moment.\n",
      "commitDate": 1032849251000,
      "commitName": "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1025640517000,
      "commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 83.43,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n         Properties properties \u003d System.getProperties();\n         final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 properties \u003d loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         boolean closeOut \u003d false;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n                 closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n-        catch (RESyntaxException rese) {\n-            System.out.println(\"Unable to create an regexp object: \"\n-                               + rese.getMessage());\n-            rese.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-        catch (IOException ex) {\n-            System.out.println(\"I/O error occurred: \" + ex.getMessage());\n-            ex.printStackTrace(System.out);\n+        catch (Exception e) {\n+            System.out.println(\"Unable to create Checker: \"\n+                               + e.getMessage());\n+            e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "add2bdfb27494bff5fa9c305d9782f57c6170b18": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug 561616 (ant task should log errors, not infos)\n\nThis required a redesign of the AuditListener interface, the get/setOutputStream methoeds have been removed, as there might be listeners that have no or more than one OutputStream.\n\nThe DefaultLogger now differentiates between info messages (\"started checking file ...\", etc.) and error messages (style errors found by checkstyle) by writing the messages to two different OutputStreams.\n",
      "commitDate": 1025640517000,
      "commitName": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1022593183000,
      "commitNameOld": "34770c3eaa9ad06297c13fd43a55739c02c7d67d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 35.27,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,77 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n         Properties properties \u003d System.getProperties();\n         final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 properties \u003d loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n+        boolean closeOut \u003d false;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n+                closeOut \u003d true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n-            listener \u003d new XMLLogger(out);\n+            listener \u003d new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n-            listener \u003d new DefaultLogger(out);\n+            listener \u003d new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \"\n                                + rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "ef5716560b2b52a5fcd233ac9ad546a53749339f": {
      "type": "Ybodychange",
      "commitMessage": "RFE #557544, load properties from file on cmdline\n",
      "commitDate": 1021793938000,
      "commitName": "ef5716560b2b52a5fcd233ac9ad546a53749339f",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1019044792000,
      "commitNameOld": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 31.82,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,75 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n+        Properties properties \u003d System.getProperties();\n         final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n+            else if (\"-p\".equals(aArgs[i])) {\n+                properties \u003d loadProperties(new File(aArgs[++i]));\n+            }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(new Configuration(System.getProperties(),\n-                                              System.out));\n+            c \u003d new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "e200d9bf3d07b103e633d56215280e5e7d7a980b": {
      "type": "Ybodychange",
      "commitMessage": "545128: implemented \"-r\" recursive option and improved the argument handling\n",
      "commitDate": 1019044792000,
      "commitName": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1012826644000,
      "commitNameOld": "b779f3c1da7bacfe57900ccba7cd95de7ab54071",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 71.97,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n-        String[] files \u003d null;\n+        final ArrayList files \u003d new ArrayList();\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n+            else if (\"-r\".equals(aArgs[i])) {\n+                traverse(new File(aArgs[++i]), files);\n+            }\n             else {\n-                files \u003d new String[aArgs.length - i];\n-                System.arraycopy(aArgs, i, files, 0, files.length);\n-                break;\n+                files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(System.getProperties(),\n                                               System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        final int numErrs \u003d c.process(files);\n-\n+        final int numErrs \u003d\n+            c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5": {
      "type": "Ybodychange",
      "commitMessage": "Refactored Checker to not take a PrintStream. All errors are not logged to\nstandard output.\n",
      "commitDate": 1011788929000,
      "commitName": "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 999188004000,
      "commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 145.84,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,71 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format \u003d \"plain\";\n         String output \u003d null;\n         String[] files \u003d null;\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format \u003d aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output \u003d aArgs[++i];\n             }\n             else {\n                 files \u003d new String[aArgs.length - i];\n                 System.arraycopy(aArgs, i, files, 0, files.length);\n                 break;\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out \u003d System.out;\n         if (output !\u003d null) {\n             try {\n                 out \u003d new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener \u003d null;\n         if (\"xml\".equals(format)) {\n             listener \u003d new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener \u003d new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(System.getProperties(),\n-                                              System.out),\n-                            System.out);\n+                                              System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs \u003d c.process(files);\n \n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
      "type": "Ybodychange",
      "commitMessage": "started to incorporate logging events\n",
      "commitDate": 999188004000,
      "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 997020777000,
      "commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 25.08,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n+        // be brain dead about arguments parsing\n+        String format \u003d \"plain\";\n+        String output \u003d null;\n+        String[] files \u003d null;\n+        for (int i \u003d 0; i \u003c aArgs.length; i++) {\n+            if (\"-f\".equals(aArgs[i])) {\n+                format \u003d aArgs[++i];\n+            }\n+            else if (\"-o\".equals(aArgs[i])) {\n+                output \u003d aArgs[++i];\n+            }\n+            else {\n+                files \u003d new String[aArgs.length - i];\n+                System.arraycopy(aArgs, i, files, 0, files.length);\n+                break;\n+            }\n+        }\n+\n+        // create the appropriate listener\n+        OutputStream out \u003d System.out;\n+        if (output !\u003d null) {\n+            try {\n+                out \u003d new FileOutputStream(output);\n+            }\n+            catch (FileNotFoundException e) {\n+                System.out.println(\"Could not find file: \u0027\" + output + \"\u0027\");\n+                System.exit(1);\n+            }\n+        }\n+        AuditListener listener \u003d null;\n+        if (\"xml\".equals(format)) {\n+            listener \u003d new XMLLogger(out);\n+        }\n+        else if (\"plain\".equals(format)) {\n+            listener \u003d new DefaultLogger(out);\n+        }\n+        else {\n+            System.out.println(\"Invalid format: (\" + format +\n+                               \"). Must be \u0027plain\u0027 or \u0027xml\u0027.\");\n+            usage();\n+        }\n+\n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(System.getProperties(),\n                                               System.out),\n                             System.out);\n+            c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        int numErrors \u003d 0;\n-        for (int i \u003d 0; i \u003c aArgs.length; i++) {\n-            numErrors +\u003d c.process(aArgs[i]);\n-        }\n+        final int numErrs \u003d c.process(files);\n \n         c.destroy();\n-        System.exit(numErrors);\n+        System.exit(numErrs);\n     }\n\\ No newline at end of file\n"
    },
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
      "type": "Ybodychange",
      "commitMessage": "added support for caching\n",
      "commitDate": 997020777000,
      "commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 993799300000,
      "commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 37.29,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n             c \u003d new Checker(new Configuration(System.getProperties(),\n                                               System.out),\n                             System.out);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         int numErrors \u003d 0;\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             numErrors +\u003d c.process(aArgs[i]);\n         }\n \n+        c.destroy();\n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n"
    },
    "69138e40225407ef560fd9d06d2903de37c83c2c": {
      "type": "Ybodychange",
      "commitMessage": "refactored to use the new Configuration class.\n",
      "commitDate": 993799300000,
      "commitName": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 993733822000,
      "commitNameOld": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,31 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(System.getProperties(), System.out);\n+            c \u003d new Checker(new Configuration(System.getProperties(),\n+                                              System.out),\n+                            System.out);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n+        catch (IOException ex) {\n+            System.out.println(\"I/O error occurred: \" + ex.getMessage());\n+            ex.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n \n         int numErrors \u003d 0;\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             numErrors +\u003d c.process(aArgs[i]);\n         }\n \n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n"
    },
    "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9": {
      "type": "Ybodychange",
      "commitMessage": "changed for release 1.2\n",
      "commitDate": 993733822000,
      "commitName": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 993216264000,
      "commitNameOld": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length \u003d\u003d 0) {\n             usage();\n         }\n \n         Checker c \u003d null;\n         try {\n-            c \u003d new Checker(System.getProperties(), System.err);\n+            c \u003d new Checker(System.getProperties(), System.out);\n         }\n         catch (RESyntaxException rese) {\n-            System.err.println(\"Unable to create an regexp object: \" +\n+            System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n-            rese.printStackTrace(System.err);\n+            rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         int numErrors \u003d 0;\n         for (int i \u003d 0; i \u003c aArgs.length; i++) {\n             numErrors +\u003d c.process(aArgs[i]);\n         }\n \n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n"
    },
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": {
      "type": "Yintroduced",
      "commitMessage": "first cut\n",
      "commitDate": 993216264000,
      "commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthor": "Oliver Burn"
    }
  }
}