{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "JavadocMethodCheck.java",
  "functionName": "checkThrowsTags",
  "functionId": "checkThrowsTags___tags-List__JavadocTag____throwsList-List__ExceptionInfo____reportExpectedTags-boolean",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java",
  "functionStartLine": 875,
  "functionEndLine": 923,
  "changeHistory": [
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5",
    "aab0718232e060bd8f289770ab81780b3a2705a2",
    "bf9325be913ce46a1427232c455f4830b574ba44",
    "5f5142b2325051f9ed31130167c73d154d547211",
    "d220d7c3cc74490c7f2923f2ea85d00133afe98c",
    "6f1840f011cea3a523d9df1278d4a0af98e1d967",
    "66d73fe6189267fee3423e2e8d7fc2d68599a43f",
    "eb5896a4a1d66552f5100046413f15d62b485b62",
    "cee4f351944dc6bad1c0b91eb8aaa118eed59fcc",
    "89a51ba032fd9126651fa9efad31baf10c006ddf",
    "e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "d790eb1dc26141d6ce4c3637a31e06597a54e0e7",
    "8a7713b4f7890e2f6493eacc5806b5eb8cfbe767",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "788b41973d5747c7b4699a853b62168cf0001df6",
    "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0",
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94",
    "72be23f288369fdd9e562999bb9b0e2ff646c897",
    "753a3a0c9708a7c050efd1dad93c37b424cf5c73",
    "2acda3b12797a818467773758f1029f7057a271c",
    "15b8debf99b3b0c600084fccde54d9562bd48b71",
    "cd89321522d9bf7fc10547e743fb8bbb4c993791",
    "04ac5dd87c11a2bf7b908b45bbca7933382df515",
    "4e1f8ef98e9e43d6101a00bdecd040377472f852",
    "4cddf4771cd0b3bb2318912a06ae2ca8089e0f49",
    "28d1968038af94b1f169eca09a12f19164daac04",
    "58ce4c40970fc29d00e5740bc6098eb475668e86",
    "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf"
  ],
  "changeHistoryShort": {
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": "Ybodychange",
    "aab0718232e060bd8f289770ab81780b3a2705a2": "Ybodychange",
    "bf9325be913ce46a1427232c455f4830b574ba44": "Ybodychange",
    "5f5142b2325051f9ed31130167c73d154d547211": "Ybodychange",
    "d220d7c3cc74490c7f2923f2ea85d00133afe98c": "Ybodychange",
    "6f1840f011cea3a523d9df1278d4a0af98e1d967": "Ybodychange",
    "66d73fe6189267fee3423e2e8d7fc2d68599a43f": "Ybodychange",
    "eb5896a4a1d66552f5100046413f15d62b485b62": "Ybodychange",
    "cee4f351944dc6bad1c0b91eb8aaa118eed59fcc": "Ybodychange",
    "89a51ba032fd9126651fa9efad31baf10c006ddf": "Ymultichange(Yparameterchange,Ybodychange)",
    "e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "d790eb1dc26141d6ce4c3637a31e06597a54e0e7": "Ybodychange",
    "8a7713b4f7890e2f6493eacc5806b5eb8cfbe767": "Ybodychange",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": "Ybodychange",
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1": "Ybodychange",
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d": "Ymultichange(Yparameterchange,Ybodychange)",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "788b41973d5747c7b4699a853b62168cf0001df6": "Ybodychange",
    "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0": "Ybodychange",
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94": "Ybodychange",
    "72be23f288369fdd9e562999bb9b0e2ff646c897": "Ymultichange(Yparameterchange,Ybodychange)",
    "753a3a0c9708a7c050efd1dad93c37b424cf5c73": "Ybodychange",
    "2acda3b12797a818467773758f1029f7057a271c": "Ybodychange",
    "15b8debf99b3b0c600084fccde54d9562bd48b71": "Ybodychange",
    "cd89321522d9bf7fc10547e743fb8bbb4c993791": "Ybodychange",
    "04ac5dd87c11a2bf7b908b45bbca7933382df515": "Yfilerename",
    "4e1f8ef98e9e43d6101a00bdecd040377472f852": "Ybodychange",
    "4cddf4771cd0b3bb2318912a06ae2ca8089e0f49": "Ybodychange",
    "28d1968038af94b1f169eca09a12f19164daac04": "Ybodychange",
    "58ce4c40970fc29d00e5740bc6098eb475668e86": "Ybodychange",
    "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6": "Ybodychange",
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": 1474426326000,
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1473886714000,
      "commitNameOld": "25a37e5049b7816b34c552899841a978efc37a63",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n-        final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n+        final Set\u003cString\u003e foundThrows \u003d new HashSet\u003c\u003e();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             throwsList.stream().filter(exceptionInfo -\u003e !exceptionInfo.isFound())\n                 .forEach(exceptionInfo -\u003e {\n                     final Token token \u003d exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                         MSG_EXPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), token.getText());\n                 });\n         }\n     }\n\\ No newline at end of file\n"
    },
    "de022d2434e58dd633fd50a7f9bb50565a8767b5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3233: Resolve IntelijIdea inspection violations for java8 migration (#3434)\n\n",
      "commitDate": 1473337840000,
      "commitName": "de022d2434e58dd633fd50a7f9bb50565a8767b5",
      "commitAuthor": "Mariia Mykhailova",
      "commitDateOld": 1464356569000,
      "commitNameOld": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 103.95,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,50 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n-            for (ExceptionInfo exceptionInfo : throwsList) {\n-                if (!exceptionInfo.isFound()) {\n+            throwsList.stream().filter(exceptionInfo -\u003e !exceptionInfo.isFound())\n+                .forEach(exceptionInfo -\u003e {\n                     final Token token \u003d exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n-                            MSG_EXPECTED_TAG,\n-                            JavadocTagInfo.THROWS.getText(), token.getText());\n-                }\n-            }\n+                        MSG_EXPECTED_TAG,\n+                        JavadocTagInfo.THROWS.getText(), token.getText());\n+                });\n         }\n     }\n\\ No newline at end of file\n"
    },
    "aab0718232e060bd8f289770ab81780b3a2705a2": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2604: Update regexp pattern for LocalVariableName\n",
      "commitDate": 1449446571000,
      "commitName": "aab0718232e060bd8f289770ab81780b3a2705a2",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1448157067000,
      "commitNameOld": "bf9325be913ce46a1427232c455f4830b574ba44",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 14.92,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n-            for (ExceptionInfo ei : throwsList) {\n-                if (!ei.isFound()) {\n-                    final Token token \u003d ei.getName();\n+            for (ExceptionInfo exceptionInfo : throwsList) {\n+                if (!exceptionInfo.isFound()) {\n+                    final Token token \u003d exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n                             JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "bf9325be913ce46a1427232c455f4830b574ba44": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2639: adjust AbbreviationAsWordInName in checkstyle_checks.xml to catch unexpected abbreviations\n",
      "commitDate": 1448157067000,
      "commitName": "bf9325be913ce46a1427232c455f4830b574ba44",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1445493631000,
      "commitNameOld": "9e9b817c6558d1141617e52444716c0f802c1417",
      "commitAuthorOld": "John Erik Halse",
      "daysBetweenCommits": 30.83,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n+            final AbstractClassInfo documentedClassInfo \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n-                    || isInThrows(throwsList, documentedCI, foundThrows);\n+                    || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n-                    reqd \u003d !isUnchecked(documentedCI.getClazz());\n+                    reqd \u003d !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token token \u003d ei.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n                             JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5f5142b2325051f9ed31130167c73d154d547211": {
      "type": "Ybodychange",
      "commitMessage": "Issue #985: Fix PMD violations for ShortVariable rule\n",
      "commitDate": 1444185186000,
      "commitName": "5f5142b2325051f9ed31130167c73d154d547211",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1444139777000,
      "commitNameOld": "e2b4e687d7b8f9d6d5e1346d874b90e4567aff81",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n-                    final Token fi \u003d ei.getName();\n-                    log(fi.getLineNo(), fi.getColumnNo(),\n+                    final Token token \u003d ei.getName();\n+                    log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n-                        JavadocTagInfo.THROWS.getText(), fi.getText());\n+                            JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d220d7c3cc74490c7f2923f2ea85d00133afe98c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Fix typos in code\n\nFixes some `SpellCheckingInspection` inspection violations.\n\nDescription:\n\u003eSpellchecker inspection helps locate typos and misspelling in your code, comments and literals.\n",
      "commitDate": 1441412923000,
      "commitName": "d220d7c3cc74490c7f2923f2ea85d00133afe98c",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1441051115000,
      "commitNameOld": "49a0ee81710e0c43ed06a01f1d64ac7f5598a934",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 4.19,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found \u003d foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                        MSG_EXCPECTED_TAG,\n+                            MSG_EXPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "6f1840f011cea3a523d9df1278d4a0af98e1d967": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Refactoring of JavadocMethodCheck to reduce method\u0027s length\n",
      "commitDate": 1440682229000,
      "commitName": "6f1840f011cea3a523d9df1278d4a0af98e1d967",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1440677821000,
      "commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,54 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getFirstArg();\n             final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n-            boolean found \u003d foundThrows.contains(documentedEx);\n \n-            // First look for matches on the exception name\n-            ListIterator\u003cExceptionInfo\u003e throwIt \u003d throwsList.listIterator();\n-            while (!found \u0026\u0026 throwIt.hasNext()) {\n-                final ExceptionInfo ei \u003d throwIt.next();\n-\n-                if (ei.getName().getText().equals(\n-                        documentedCI.getName().getText())) {\n-                    found \u003d true;\n-                    ei.setFound();\n-                    foundThrows.add(documentedEx);\n-                }\n-            }\n-\n-            // Now match on the exception type\n-            throwIt \u003d throwsList.listIterator();\n-            while (!found \u0026\u0026 throwIt.hasNext()) {\n-                final ExceptionInfo ei \u003d throwIt.next();\n-\n-                if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n-                    found \u003d true;\n-                    ei.setFound();\n-                    foundThrows.add(documentedEx);\n-                }\n-                else if (allowThrowsTagsForSubclasses) {\n-                    found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n-                }\n-            }\n+            final boolean found \u003d foundThrows.contains(documentedEx)\n+                    || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "66d73fe6189267fee3423e2e8d7fc2d68599a43f": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MemberName and MethodName violations fixed\n",
      "commitDate": 1439560811000,
      "commitName": "66d73fe6189267fee3423e2e8d7fc2d68599a43f",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1439356761000,
      "commitNameOld": "3bd699bd593414d63c7139aa410f13ec8341a027",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 2.36,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n-            final String documentedEx \u003d tag.getArg1();\n-            final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n+            final String documentedEx \u003d tag.getFirstArg();\n+            final Token token \u003d new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator\u003cExceptionInfo\u003e throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText())) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n-                        JavadocTagInfo.THROWS.getText(), tag.getArg1());\n+                        JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "eb5896a4a1d66552f5100046413f15d62b485b62": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
      "commitDate": 1434649920000,
      "commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": 1432814346000,
      "commitNameOld": "835a5700d8d70436b198c80aba63f843da0b4dab",
      "commitAuthorOld": "Gustav Carlson",
      "daysBetweenCommits": 21.25,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            final ClassInfo documentedCI \u003d createClassInfo(token,\n+            final AbstractClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator\u003cExceptionInfo\u003e throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText())) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cee4f351944dc6bad1c0b91eb8aaa118eed59fcc": {
      "type": "Ybodychange",
      "commitMessage": "Refactored UTs, javadoc package, issue #537\n",
      "commitDate": 1424437366000,
      "commitName": "cee4f351944dc6bad1c0b91eb8aaa118eed59fcc",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1424294072000,
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e tags,\n             List\u003cExceptionInfo\u003e throwsList, boolean reportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator\u003cExceptionInfo\u003e throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt \u003d throwsList.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (allowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd \u0026\u0026 validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n-                        \"javadoc.unusedTag\",\n+                        MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags \u0026\u0026 reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                        \"javadoc.expectedTag\",\n+                        MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "89a51ba032fd9126651fa9efad31baf10c006ddf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, javadoc, #512\n",
      "commitDate": 1421677262000,
      "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215": {
      "type": "Ybodychange",
      "commitMessage": "Update for existing Check: JavadocMethodCheck #319\n",
      "commitDate": 1414021350000,
      "commitName": "e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215",
      "commitAuthor": "maxvetrenko",
      "commitDateOld": 1404651008000,
      "commitNameOld": "7dc94ba7ab9a4e330c088e0fbbd441f78628edb0",
      "commitAuthorOld": "Tobias Baum",
      "daysBetweenCommits": 108.45,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e aTags,\n             List\u003cExceptionInfo\u003e aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n-                if (reqd) {\n+                if (reqd \u0026\u0026 mValidateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "d790eb1dc26141d6ce4c3637a31e06597a54e0e7": {
      "type": "Ybodychange",
      "commitMessage": "Fix JavadocMethod  checking of @throws tags for methods that throw multiple non-runtime exceptions. Thanks to Daan Kets for patch #3039869.\n",
      "commitDate": 1285644884000,
      "commitName": "d790eb1dc26141d6ce4c3637a31e06597a54e0e7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1266029835000,
      "commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 227.03,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,82 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e aTags,\n             List\u003cExceptionInfo\u003e aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n-            final ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n+            // First look for matches on the exception name\n+            ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n+            while (!found \u0026\u0026 throwIt.hasNext()) {\n+                final ExceptionInfo ei \u003d throwIt.next();\n+\n+                if (ei.getName().getText().equals(\n+                        documentedCI.getName().getText()))\n+                {\n+                    found \u003d true;\n+                    ei.setFound();\n+                    foundThrows.add(documentedEx);\n+                }\n+            }\n+\n+            // Now match on the exception type\n+            throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8a7713b4f7890e2f6493eacc5806b5eb8cfbe767": {
      "type": "Ybodychange",
      "commitMessage": "record work on patch #2534038 from Travis for new annotation checks. Very good patch as usual from Travis. Shame on me for taking so long to apply it.\n",
      "commitDate": 1237805379000,
      "commitName": "8a7713b4f7890e2f6493eacc5806b5eb8cfbe767",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1237695418000,
      "commitNameOld": "216fcb79f9f5bbd05244364e926f261a90e697d1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e aTags,\n             List\u003cExceptionInfo\u003e aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n-                            \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n+                        \"javadoc.unusedTag\",\n+                        JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                            \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                        \"javadoc.expectedTag\",\n+                        JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": {
      "type": "Ybodychange",
      "commitMessage": "Drinking the \"Google Collections\" Kool-Aid.\n\nI like the reduced duplication.\n",
      "commitDate": 1208867287000,
      "commitName": "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1200295112000,
      "commitNameOld": "4d715df131a0c5ae3a9f2eae6ecf636ab52eda0e",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 99.21,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e aTags,\n             List\u003cExceptionInfo\u003e aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n-        final Set\u003cString\u003e foundThrows \u003d new HashSet\u003cString\u003e();\n+        final Set\u003cString\u003e foundThrows \u003d Sets.newHashSet();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1": {
      "type": "Ybodychange",
      "commitMessage": "Use the new syntactic sugar \"for loop\".\n\nEnd of the cosmetic changes.\n",
      "commitDate": 1197714527000,
      "commitName": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1197694270000,
      "commitNameOld": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,65 @@\n     private void checkThrowsTags(List\u003cJavadocTag\u003e aTags,\n             List\u003cExceptionInfo\u003e aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set\u003cString\u003e foundThrows \u003d new HashSet\u003cString\u003e();\n         final ListIterator\u003cJavadocTag\u003e tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n-            final ListIterator\u003cExceptionInfo\u003e throwIt \u003d aThrows.listIterator();\n-            while (throwIt.hasNext()) {\n-                final ExceptionInfo ei \u003d throwIt.next();\n+            for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": 1197694270000,
      "commitName": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": 1152243856000,
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1148305756000,
      "commitNameOld": "0a72322796c28266f07df8af6f7e000aa9cf0e48",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 45.58,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n         boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n-            Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n+            final Token token \u003d new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            ClassInfo documentedCI \u003d createClassInfo(token,\n+            final ClassInfo documentedCI \u003d createClassInfo(token,\n                     getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "788b41973d5747c7b4699a853b62168cf0001df6": {
      "type": "Ybodychange",
      "commitMessage": "Changes to make it possible to identify a module by an id, and then to\nsuppress messages based on the id. The motivation is to allow for finer\ngrained suppressions. For example, can enable multiple instances of the\nRegexp check, and suppress on the individual instance.\n",
      "commitDate": 1135859700000,
      "commitName": "788b41973d5747c7b4699a853b62168cf0001df6",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1134657492000,
      "commitNameOld": "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,66 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             Token token \u003d new Token(tag.getArg1(), tag.getLineNo(),\n                                     tag.getColumnNo());\n             ClassInfo documentedCI \u003d\n                 createClassInfo(token, getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n-                final Token fi \u003d ei.getName();\n-                final String declaredEx \u003d fi.getText();\n \n                 if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0": {
      "type": "Ybodychange",
      "commitMessage": "fix for 1379666\n",
      "commitDate": 1134657492000,
      "commitName": "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1131278053000,
      "commitNameOld": "ab1e3089135d74b0d8c3296d0074244ca89a55e2",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 39.11,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             Token token \u003d new Token(tag.getArg1(), tag.getLineNo(),\n                                     tag.getColumnNo());\n             ClassInfo documentedCI \u003d\n                 createClassInfo(token, getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 final Token fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n \n-                if (isSameType(declaredEx, documentedEx)) {\n+                if (documentedCI.getClazz() \u003d\u003d ei.getClazz()) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94": {
      "type": "Ybodychange",
      "commitMessage": "Fixed 1249707: AbstractTypeAwareCheck doesn\u0027t work with types from typeparm\n\nSome pretty big refactoring for typeaware checks performed.\nAlso added handling for type params.  Current handling algorithm\nhas some preconditions and restriction, but it works for most cases\n(not sure I\u0027ve covered all situation when type param will have name\nof real exception, but I do not think it is critical for now :)\n\nAlso, I\u0027ve added column number for JavadocTag (mainly to be able use\nClassInfo for it).  So, JavadocTypeCheck also affected.\n\nAnd I\u0027ve added new logger for TreeWalker (if we have loggers we should\nuse them :)\n",
      "commitDate": 1123248811000,
      "commitName": "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1120383479000,
      "commitNameOld": "b106eab0414affa16fbc0e2dfce511e3aed9d557",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 33.16,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,68 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n+            Token token \u003d new Token(tag.getArg1(), tag.getLineNo(),\n+                                    tag.getColumnNo());\n+            ClassInfo documentedCI \u003d\n+                createClassInfo(token, getCurrentClassName());\n             boolean found \u003d foundThrows.contains(documentedEx);\n-            Class documentedClass \u003d null;\n-            boolean classLoaded \u003d false;\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n-                final FullIdent fi \u003d ei.getName();\n+                final Token fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n \n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n-                    if (!classLoaded) {\n-                        documentedClass \u003d loadClassForTag(tag);\n-                        classLoaded \u003d true;\n-                    }\n-                    found \u003d isSubclass(documentedClass, ei.getClazz());\n+                    found \u003d isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n-                    if (!classLoaded) {\n-                        documentedClass \u003d loadClassForTag(tag);\n-                        classLoaded \u003d true;\n-                    }\n-                    reqd \u003d !isUnchecked(documentedClass);\n+                    reqd \u003d !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n-                    log(tag.getLineNo(), \"javadoc.unusedTag\", \"@throws\", tag\n-                        .getArg1());\n+                    log(tag.getLineNo(), tag.getColumnNo(),\n+                        \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n+\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags \u0026\u0026 aReportExpectedTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n-                    final FullIdent fi \u003d ei.getName();\n+                    final Token fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "72be23f288369fdd9e562999bb9b0e2ff646c897": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix for 855839 - JavadocMethod does not correctly treat {@inheritDoc}.\n",
      "commitDate": 1070909885000,
      "commitName": "72be23f288369fdd9e562999bb9b0e2ff646c897",
      "commitAuthor": "Oleg Sukhodolsky",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "753a3a0c9708a7c050efd1dad93c37b424cf5c73": {
      "type": "Ybodychange",
      "commitMessage": "Cleaned fix for 803577 :)\n",
      "commitDate": 1063252505000,
      "commitName": "753a3a0c9708a7c050efd1dad93c37b424cf5c73",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1063252431000,
      "commitNameOld": "2acda3b12797a818467773758f1029f7057a271c",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,71 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             Class documentedClass \u003d null;\n             boolean classLoaded \u003d false;\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 final FullIdent fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass \u003d loadClassForTag(tag);\n                         classLoaded \u003d true;\n                     }\n                     found \u003d isSubclass(documentedClass, ei.getClazz());\n-//                     if (found) {\n-//                         ei.setFound();\n-//                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass \u003d loadClassForTag(tag);\n                         classLoaded \u003d true;\n                     }\n                     reqd \u003d !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2acda3b12797a818467773758f1029f7057a271c": {
      "type": "Ybodychange",
      "commitMessage": "Fix for 803577 (allowThrowsTagsForSubclasses/allowMissingThrowsTag interfere)\n",
      "commitDate": 1063252431000,
      "commitName": "2acda3b12797a818467773758f1029f7057a271c",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1060246011000,
      "commitNameOld": "15b8debf99b3b0c600084fccde54d9562bd48b71",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 34.8,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             Class documentedClass \u003d null;\n             boolean classLoaded \u003d false;\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 final FullIdent fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass \u003d loadClassForTag(tag);\n                         classLoaded \u003d true;\n                     }\n                     found \u003d isSubclass(documentedClass, ei.getClazz());\n-                    if (found) {\n-                        ei.setFound();\n-                    }\n+//                     if (found) {\n+//                         ei.setFound();\n+//                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass \u003d loadClassForTag(tag);\n                         classLoaded \u003d true;\n                     }\n                     reqd \u003d !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "15b8debf99b3b0c600084fccde54d9562bd48b71": {
      "type": "Ybodychange",
      "commitMessage": "Fix for 784015 (Unable to get class information errors).\n",
      "commitDate": 1060246011000,
      "commitName": "15b8debf99b3b0c600084fccde54d9562bd48b71",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1059825751000,
      "commitNameOld": "cd89321522d9bf7fc10547e743fb8bbb4c993791",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 4.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,74 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             Class documentedClass \u003d null;\n-            if (!found\n-                \u0026\u0026 (mAllowThrowsTagsForSubclasses || mAllowUndeclaredRTE))\n-            {\n-                documentedClass \u003d resolveClass(documentedEx);\n-                if (documentedClass \u003d\u003d null) {\n-                    log(tag.getLineNo(), \"javadoc.classInfo\",\n-                        \"@throws\", documentedEx);\n-                }\n-            }\n+            boolean classLoaded \u003d false;\n \n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 final FullIdent fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses\n-                         \u0026\u0026 documentedClass !\u003d null)\n-                {\n-                    if (ei.isLoadable() \u0026\u0026 ei.getClazz() \u003d\u003d null) {\n-                        // if the class is not loaded yet.\n-                        // try to load it.\n-                        ei.setClazz(resolveClass(declaredEx));\n-                        if (!ei.isLoadable()) {\n-                            log(fi.getLineNo(), \"javadoc.classInfo\",\n-                                \"@throws\", declaredEx);\n-                        }\n+                else if (mAllowThrowsTagsForSubclasses) {\n+                    if (!classLoaded) {\n+                        documentedClass \u003d loadClassForTag(tag);\n+                        classLoaded \u003d true;\n                     }\n-\n                     found \u003d isSubclass(documentedClass, ei.getClazz());\n                     if (found) {\n                         ei.setFound();\n                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n-                if (mAllowUndeclaredRTE \u0026\u0026 documentedClass !\u003d null) {\n+                if (mAllowUndeclaredRTE) {\n+                    if (!classLoaded) {\n+                        documentedClass \u003d loadClassForTag(tag);\n+                        classLoaded \u003d true;\n+                    }\n                     reqd \u003d !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cd89321522d9bf7fc10547e743fb8bbb4c993791": {
      "type": "Ybodychange",
      "commitMessage": "Refactoring of RedundantThrows and JavadocMethod checks to minimize\nnumber of \"Unable to get class info\" errors.\n",
      "commitDate": 1059825751000,
      "commitName": "cd89321522d9bf7fc10547e743fb8bbb4c993791",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1058814489000,
      "commitNameOld": "6e1e8b738d29d67575fb3390864ea786f19725e3",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 11.7,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,86 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n+            Class documentedClass \u003d null;\n+            if (!found\n+                \u0026\u0026 (mAllowThrowsTagsForSubclasses || mAllowUndeclaredRTE))\n+            {\n+                documentedClass \u003d resolveClass(documentedEx);\n+                if (documentedClass \u003d\u003d null) {\n+                    log(tag.getLineNo(), \"javadoc.classInfo\",\n+                        \"@throws\", documentedEx);\n+                }\n+            }\n+\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n-                final FullIdent fi \u003d ei.getFullIdent();\n+                final FullIdent fi \u003d ei.getName();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses) {\n-                    final ClassResolver cr \u003d getClassResolver();\n-                    try {\n-                        final Class documentedClass \u003d cr.resolve(documentedEx);\n-                        try {\n-                            final Class declaredClass \u003d cr.resolve(declaredEx);\n-                            found \u003d\n-                                declaredClass.isAssignableFrom(documentedClass);\n-                            if (found) {\n-                                ei.setFound();\n-                            }\n-                        }\n-                        catch (ClassNotFoundException e) {\n-                            log(tag.getLineNo(), \"javadoc.classInfo\",\n+                else if (mAllowThrowsTagsForSubclasses\n+                         \u0026\u0026 documentedClass !\u003d null)\n+                {\n+                    if (ei.isLoadable() \u0026\u0026 ei.getClazz() \u003d\u003d null) {\n+                        // if the class is not loaded yet.\n+                        // try to load it.\n+                        ei.setClazz(resolveClass(declaredEx));\n+                        if (!ei.isLoadable()) {\n+                            log(fi.getLineNo(), \"javadoc.classInfo\",\n                                 \"@throws\", declaredEx);\n                         }\n                     }\n-                    catch (ClassNotFoundException e) {\n-                        log(tag.getLineNo(), \"javadoc.classInfo\",\n-                                      \"@throws\", documentedEx);\n+\n+                    found \u003d isSubclass(documentedClass, ei.getClazz());\n+                    if (found) {\n+                        ei.setFound();\n                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n-                if (mAllowUndeclaredRTE) {\n-                    final ClassResolver cr \u003d getClassResolver();\n-                    try {\n-                        final Class clazz \u003d cr.resolve(tag.getArg1());\n-                        reqd \u003d\n-                            !RuntimeException.class.isAssignableFrom(clazz)\n-                                \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n-                    }\n-                    catch (ClassNotFoundException e) {\n-                        log(tag.getLineNo(), \"javadoc.classInfo\",\n-                                      \"@throws\", tag.getArg1());\n-                    }\n+                if (mAllowUndeclaredRTE \u0026\u0026 documentedClass !\u003d null) {\n+                    reqd \u003d !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n-                    final FullIdent fi \u003d ei.getFullIdent();\n+                    final FullIdent fi \u003d ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "04ac5dd87c11a2bf7b908b45bbca7933382df515": {
      "type": "Yfilerename",
      "commitMessage": "Moving another Javadoc check to see what is involved.\nA suprisingly small amount. Love the Eclipse refactoring\nsupport having the smarts to do the CVS operations.\n",
      "commitDate": 1054648289000,
      "commitName": "04ac5dd87c11a2bf7b908b45bbca7933382df515",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1054647239000,
      "commitNameOld": "2ef6dc6a43ede89c5b5b9091dee83e1e58bb5edc",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "4e1f8ef98e9e43d6101a00bdecd040377472f852": {
      "type": "Ybodychange",
      "commitMessage": "One more option for JavadocMethodCheck\n(allowThrowsTagsForSubclasses, request 540383)\n",
      "commitDate": 1052504065000,
      "commitName": "4e1f8ef98e9e43d6101a00bdecd040377472f852",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1047612173000,
      "commitNameOld": "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 56.62,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,89 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n-        final Set foundThrows \u003d new HashSet();\n+        final Set foundThrows \u003d new HashSet(); //used for performance only\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n-                final FullIdent fi \u003d (FullIdent) throwIt.next();\n+                final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n+                final FullIdent fi \u003d ei.getFullIdent();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n-                    throwIt.remove();\n+                    ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n+                else if (mAllowThrowsTagsForSubclasses) {\n+                    final ClassResolver cr \u003d getClassResolver();\n+                    try {\n+                        final Class documentedClass \u003d cr.resolve(documentedEx);\n+                        try {\n+                            final Class declaredClass \u003d cr.resolve(declaredEx);\n+                            found \u003d \n+                                declaredClass.isAssignableFrom(documentedClass);\n+                            if (found) {\n+                                ei.setFound();\n+                            }\n+                        }\n+                        catch (ClassNotFoundException e) {\n+                            log(tag.getLineNo(), \"javadoc.classInfo\",\n+                                \"@throws\", declaredEx);\n+                        }\n+                    }\n+                    catch (ClassNotFoundException e) {\n+                        log(tag.getLineNo(), \"javadoc.classInfo\",\n+                                      \"@throws\", documentedEx);\n+                    }\n+                }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n-                    final ClassResolver cr \u003d\n-                        new ClassResolver(\n-                            getClassLoader(),\n-                            mPackageFullIdent.getText(),\n-                            mImports);\n+                    final ClassResolver cr \u003d getClassResolver();\n                     try {\n                         final Class clazz \u003d cr.resolve(tag.getArg1());\n                         reqd \u003d\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (throwIt.hasNext()) {\n-                final FullIdent fi \u003d (FullIdent) throwIt.next();\n-                log(fi.getLineNo(), fi.getColumnNo(),\n-                    \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                final ExceptionInfo ei \u003d (ExceptionInfo) throwIt.next();\n+                if (!ei.isFound()) {\n+                    final FullIdent fi \u003d ei.getFullIdent();\n+                    log(fi.getLineNo(), fi.getColumnNo(),\n+                        \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4cddf4771cd0b3bb2318912a06ae2ca8089e0f49": {
      "type": "Ybodychange",
      "commitMessage": "Patch from Simon Kitching to allow more configuration control over the\nJavadocMethodCheck.\n",
      "commitDate": 1047422998000,
      "commitName": "4cddf4771cd0b3bb2318912a06ae2ca8089e0f49",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1045363824000,
      "commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 23.83,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,67 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet();\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final FullIdent fi \u003d (FullIdent) throwIt.next();\n                 final String declaredEx \u003d fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr \u003d\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz \u003d cr.resolve(tag.getArg1());\n                         reqd \u003d\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n-        // Now dump out all throws without tags\n-        final ListIterator throwIt \u003d aThrows.listIterator();\n-        while (throwIt.hasNext()) {\n-            final FullIdent fi \u003d (FullIdent) throwIt.next();\n-            log(fi.getLineNo(), fi.getColumnNo(),\n-                \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+        // Now dump out all throws without tags :- unless\n+        // the user has chosen to suppress these problems\n+        if (!mAllowMissingThrowsTags) {\n+            final ListIterator throwIt \u003d aThrows.listIterator();\n+            while (throwIt.hasNext()) {\n+                final FullIdent fi \u003d (FullIdent) throwIt.next();\n+                log(fi.getLineNo(), fi.getColumnNo(),\n+                    \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "28d1968038af94b1f169eca09a12f19164daac04": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug #658805, Fully-qualified @throws claimed unused\n",
      "commitDate": 1041156037000,
      "commitName": "28d1968038af94b1f169eca09a12f19164daac04",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1040981493000,
      "commitNameOld": "58ce4c40970fc29d00e5740bc6098eb475668e86",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet();\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final FullIdent fi \u003d (FullIdent) throwIt.next();\n-                if (fi.getText().equals(documentedEx)) {\n+                final String declaredEx \u003d fi.getText();\n+                if (isSameType(declaredEx, documentedEx)) {\n                     found \u003d true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr \u003d\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz \u003d cr.resolve(tag.getArg1());\n                         reqd \u003d\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt \u003d aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi \u003d (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n"
    },
    "58ce4c40970fc29d00e5740bc6098eb475668e86": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug #648708, Misleading doc for checkUnusedThrows\nRenamed property checkUnusedThrows to allowUndeclaredRTE to better reflect the meaning of the property.\n",
      "commitDate": 1040981493000,
      "commitName": "58ce4c40970fc29d00e5740bc6098eb475668e86",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1040208936000,
      "commitNameOld": "95a5040ccc98d1138a82c9e0ebcfe983651219b6",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 8.94,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet();\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final FullIdent fi \u003d (FullIdent) throwIt.next();\n                 if (fi.getText().equals(documentedEx)) {\n                     found \u003d true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n-                if (mCheckUnusedThrows) {\n+                if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr \u003d\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz \u003d cr.resolve(tag.getArg1());\n                         reqd \u003d\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt \u003d aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi \u003d (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6": {
      "type": "Ybodychange",
      "commitMessage": "Please ensure you thoroughly test code before committing it. As a sanity test,\nensure that the target \"checkstyle.checkstyle\" will run! If in doubt, do not\ncommit, but instead said a patch to the devel mailing list for a review.\n\nFinished the port of the ClassResolver code. Even though it compiled, it had\nno chance of working due to class casting problems. They have not been\nfixed. Also needed to ensure the correct class loader is being used.\n",
      "commitDate": 1036555078000,
      "commitName": "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036551132000,
      "commitNameOld": "e7556f4af60fa1602c1b74289c6c64e1a83e4235",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,63 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows \u003d new HashSet();\n         final ListIterator tagIt \u003d aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag \u003d (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx \u003d tag.getArg1();\n             boolean found \u003d foundThrows.contains(documentedEx);\n             final ListIterator throwIt \u003d aThrows.listIterator();\n             while (!found \u0026\u0026 throwIt.hasNext()) {\n                 final FullIdent fi \u003d (FullIdent) throwIt.next();\n                 if (fi.getText().equals(documentedEx)) {\n                     found \u003d true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd \u003d true;\n                 if (mCheckUnusedThrows) {\n-                    final ClassResolver cr \u003d new ClassResolver(\n-                        Thread.currentThread().getContextClassLoader(),\n-                        mPackageFullIdent.getText(), mImports);\n+                    final ClassResolver cr \u003d\n+                        new ClassResolver(\n+                            getClassLoader(),\n+                            mPackageFullIdent.getText(),\n+                            mImports);\n                     try {\n                         final Class clazz \u003d cr.resolve(tag.getArg1());\n-                        reqd \u003d !RuntimeException.class.isAssignableFrom(clazz)\n-                            \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n+                        reqd \u003d\n+                            !RuntimeException.class.isAssignableFrom(clazz)\n+                                \u0026\u0026 !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt \u003d aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi \u003d (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c75f97dbc2123f550a1acc64886a8bebf4b888cf": {
      "type": "Yintroduced",
      "commitMessage": "Javadoc method check\n",
      "commitDate": 1036501994000,
      "commitName": "c75f97dbc2123f550a1acc64886a8bebf4b888cf",
      "commitAuthor": "Rick Giles"
    }
  }
}