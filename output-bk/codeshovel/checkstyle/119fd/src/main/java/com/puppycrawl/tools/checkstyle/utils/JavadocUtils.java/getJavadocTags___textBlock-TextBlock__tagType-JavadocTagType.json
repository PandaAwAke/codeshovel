{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "JavadocUtils.java",
  "functionName": "getJavadocTags",
  "functionId": "getJavadocTags___textBlock-TextBlock__tagType-JavadocTagType",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
  "functionStartLine": 96,
  "functionEndLine": 134,
  "changeHistory": [
    "d28a60c5529e182e1cdaea184415181e00b70d2a",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067",
    "ce196814d857a4244a80c51d5151cc35e90b6749",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
    "41740f2d68baba3ae185e8303038f841e7d6fc5a",
    "ed595de84fba2db507adaf01d04cb089a5e0bac5",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
    "9dbc71956635b56a20780d484454e177897b5788",
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
    "89a51ba032fd9126651fa9efad31baf10c006ddf",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "d8286130e83dc672d30cd00eddbf6b5f77112521",
    "7d097b6fa682f8dcfedd95da2db8fed980c51705"
  ],
  "changeHistoryShort": {
    "d28a60c5529e182e1cdaea184415181e00b70d2a": "Ybodychange",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067": "Ybodychange",
    "ce196814d857a4244a80c51d5151cc35e90b6749": "Ymultichange(Yparameterchange,Ybodychange)",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": "Ybodychange",
    "41740f2d68baba3ae185e8303038f841e7d6fc5a": "Ybodychange",
    "ed595de84fba2db507adaf01d04cb089a5e0bac5": "Yfilerename",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": "Ybodychange",
    "9dbc71956635b56a20780d484454e177897b5788": "Ybodychange",
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9": "Ybodychange",
    "89a51ba032fd9126651fa9efad31baf10c006ddf": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "d8286130e83dc672d30cd00eddbf6b5f77112521": "Ymultichange(Yparameterchange,Ybodychange)",
    "7d097b6fa682f8dcfedd95da2db8fed980c51705": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d28a60c5529e182e1cdaea184415181e00b70d2a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2840: UnusedImportsCheck - process javadoc tags that span lines\n",
      "commitDate": 1499733339000,
      "commitName": "d28a60c5529e182e1cdaea184415181e00b70d2a",
      "commitAuthor": "Nathan Naze",
      "commitDateOld": 1498523692000,
      "commitNameOld": "c0eb205f6ab7abff2c409a387c853a8b51646c79",
      "commitAuthorOld": "Piyush Sharma",
      "daysBetweenCommits": 14.0,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n-        final String[] text \u003d textBlock.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n+\n+        final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n+                                         || tagType \u003d\u003d JavadocTagType.BLOCK;\n+        final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n+                                          || tagType \u003d\u003d JavadocTagType.INLINE;\n+\n+        final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n+\n+        if (getBlockTags) {\n+            tags.addAll(BlockTagUtils.extractBlockTags(textBlock.getText()));\n+        }\n+\n+        if (getInlineTags) {\n+            tags.addAll(InlineTagUtils.extractInlineTags(textBlock.getText()));\n+        }\n+\n+        final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n-        for (int i \u003d 0; i \u003c text.length; i++) {\n-            final String textValue \u003d text[i];\n-            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n-            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n-                    \u0026\u0026 blockTagMatcher.find()) {\n-                final String tagName \u003d blockTagMatcher.group(1);\n-                String content \u003d textValue.substring(blockTagMatcher.end(1));\n-                if (content.endsWith(\"*/\")) {\n-                    content \u003d content.substring(0, content.length() - 2);\n-                }\n-                final int line \u003d textBlock.getStartLineNo() + i;\n-                int col \u003d blockTagMatcher.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d textBlock.getStartColNo();\n-                }\n-                if (JavadocTagInfo.isValidName(tagName)) {\n-                    tags.add(\n-                            new JavadocTag(line, col, tagName, content.trim()));\n-                }\n-                else {\n-                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n-                }\n+\n+        for (TagInfo tag : tags) {\n+            final int col \u003d tag.getPosition().getColumn();\n+\n+            // Add the starting line of the comment to the line number to get the actual line number\n+            // in the source.\n+            // Lines are one-indexed, so need a off-by-one correction.\n+            final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n+\n+            if (JavadocTagInfo.isValidName(tag.getName())) {\n+                validTags.add(\n+                    new JavadocTag(line, col, tag.getName(), tag.getValue()));\n             }\n-            // No block tag, so look for inline validTags\n-            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                lookForInlineTags(textBlock, i, tags, invalidTags);\n+            else {\n+                invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n             }\n         }\n-        return new JavadocTags(tags, invalidTags);\n+\n+        return new JavadocTags(validTags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": 1474426326000,
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1462710857000,
      "commitNameOld": "67e6b46e9fa424fbd0a2fba611a3a59b30727692",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 135.6,
      "commitsBetweenForRepo": 246,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final String[] text \u003d textBlock.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n-        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n+        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n+        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n             final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2631: Optimize JavadocUtils\n",
      "commitDate": 1450708286000,
      "commitName": "ed6c2ea1336f2b46b9f64dffc417f608c8de5067",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": 1445038509000,
      "commitNameOld": "ce196814d857a4244a80c51d5151cc35e90b6749",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 65.62,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,35 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final String[] text \u003d textBlock.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n-            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n+            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n-            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "ce196814d857a4244a80c51d5151cc35e90b6749": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Issue #2080: Fix typos in code\n",
      "commitDate": 1445038509000,
      "commitName": "ce196814d857a4244a80c51d5151cc35e90b6749",
      "commitAuthor": "Michal Kordas",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": {
      "type": "Ybodychange",
      "commitMessage": "Issue #985: Fix PMD violations for ShortVariable rule\n",
      "commitDate": 1444178762000,
      "commitName": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1442363057000,
      "commitNameOld": "e29dc4d398c136e8ec5a08e93bde7b805153835d",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 21.02,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n-            final String s \u003d text[i];\n-            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n+            final String textValue \u003d text[i];\n+            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n-                String content \u003d s.substring(blockTagMatcher.end(1));\n+                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(cmt, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "41740f2d68baba3ae185e8303038f841e7d6fc5a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Reducing JavadocUtils method length\n",
      "commitDate": 1440682230000,
      "commitName": "41740f2d68baba3ae185e8303038f841e7d6fc5a",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1440677821000,
      "commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,37 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                // Match Javadoc text after comment characters\n-                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n-                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n-                final String commentContents;\n-\n-                // offset including comment characters\n-                final int commentOffset;\n-\n-                if (commentMatcher.find()) {\n-                    commentContents \u003d commentMatcher.group(1);\n-                    commentOffset \u003d commentMatcher.start(1) - 1;\n-                }\n-                else {\n-                    // No leading asterisks, still valid\n-                    commentContents \u003d s;\n-                    commentOffset \u003d 0;\n-                }\n-                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n-                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n-                while (tagMatcher.find()) {\n-                    final String tagName \u003d tagMatcher.group(1);\n-                    final String tagValue \u003d tagMatcher.group(2).trim();\n-                    final int line \u003d cmt.getStartLineNo() + i;\n-                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n-                    if (i \u003d\u003d 0) {\n-                        col +\u003d cmt.getStartColNo();\n-                    }\n-                    if (JavadocTagInfo.isValidName(tagName)) {\n-                        tags.add(new JavadocTag(line, col, tagName,\n-                                tagValue));\n-                    }\n-                    else {\n-                        invalidTags.add(new InvalidJavadocTag(line, col,\n-                                tagName));\n-                    }\n-                    // else Error: Unexpected match count for inline Javadoc\n-                    // tag!\n-                }\n+                lookForInlineTags(cmt, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "ed595de84fba2db507adaf01d04cb089a5e0bac5": {
      "type": "Yfilerename",
      "commitMessage": "Utils classes have been moved to utils package. Issue #1898\n",
      "commitDate": 1440677821000,
      "commitName": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1440637702000,
      "commitNameOld": "f6113bb56d695719a8803274effb3596cb82120f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": {
      "type": "Ybodychange",
      "commitMessage": "Invert if statements with negated conditions. #1555\n\nFixes `NegatedIfElse` inspection violations.\n\nDescription:\n\u003eReports if statements which contain else branches and whose conditions are negated. Flipping the order of the if and else branches will usually increase the clarity of such statements.\n",
      "commitDate": 1439189206000,
      "commitName": "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1439008721000,
      "commitNameOld": "f1e80e4ecae727087ca135dfd02f72e2d6213efb",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n-                if (!commentMatcher.find()) {\n-                    commentContents \u003d s; // No leading asterisks, still valid\n-                    commentOffset \u003d 0;\n-                }\n-                else {\n+                if (commentMatcher.find()) {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n+                else {\n+                    commentContents \u003d s; // No leading asterisks, still valid\n+                    commentOffset \u003d 0;\n+                }\n                 final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     final String tagName \u003d tagMatcher.group(1);\n                     final String tagValue \u003d tagMatcher.group(2).trim();\n                     final int line \u003d cmt.getStartLineNo() + i;\n                     int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                     if (i \u003d\u003d 0) {\n                         col +\u003d cmt.getStartColNo();\n                     }\n                     if (JavadocTagInfo.isValidName(tagName)) {\n                         tags.add(new JavadocTag(line, col, tagName,\n                                 tagValue));\n                     }\n                     else {\n                         invalidTags.add(new InvalidJavadocTag(line, col,\n                                 tagName));\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "9dbc71956635b56a20780d484454e177897b5788": {
      "type": "Ybodychange",
      "commitMessage": "Add test case and refactor JavadocUtils. #1308\n",
      "commitDate": 1438024878000,
      "commitName": "9dbc71956635b56a20780d484454e177897b5788",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1436820360000,
      "commitNameOld": "e68f47ce99313c7dafade4ac4a55fccf12c09d5e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,70 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n-                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n-                        final String tagName \u003d tagMatcher.group(1);\n-                        final String tagValue \u003d tagMatcher.group(2).trim();\n-                        final int line \u003d cmt.getStartLineNo() + i;\n-                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n-                        if (i \u003d\u003d 0) {\n-                            col +\u003d cmt.getStartColNo();\n-                        }\n-                        if (JavadocTagInfo.isValidName(tagName)) {\n-                            tags.add(new JavadocTag(line, col, tagName,\n-                                    tagValue));\n-                        }\n-                        else {\n-                            invalidTags.add(new InvalidJavadocTag(line, col,\n-                                    tagName));\n-                        }\n+                    final String tagName \u003d tagMatcher.group(1);\n+                    final String tagValue \u003d tagMatcher.group(2).trim();\n+                    final int line \u003d cmt.getStartLineNo() + i;\n+                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n+                    if (i \u003d\u003d 0) {\n+                        col +\u003d cmt.getStartColNo();\n+                    }\n+                    if (JavadocTagInfo.isValidName(tagName)) {\n+                        tags.add(new JavadocTag(line, col, tagName,\n+                                tagValue));\n+                    }\n+                    else {\n+                        invalidTags.add(new InvalidJavadocTag(line, col,\n+                                tagName));\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c": {
      "type": "Ybodychange",
      "commitMessage": "Deleted cache from Utils class + unified setters with patterns\n\nIssue #845\n",
      "commitDate": 1427492342000,
      "commitName": "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": 1426881427000,
      "commitNameOld": "9f2bf96b2001eb2e3886950a41e076c8a01d57d8",
      "commitAuthorOld": "Damian Szczepanik",
      "daysBetweenCommits": 7.07,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,75 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d\n-                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n-                final Pattern commentPattern \u003d\n-                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n+                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n-                final Pattern tagPattern \u003d\n-                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n+                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n-            blockTagPattern \u003d\n-                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1425998782000,
      "commitNameOld": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n-                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n+                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9": {
      "type": "Ybodychange",
      "commitMessage": "Replace calls to equals() on enums with identity comparison\n\nThis replacement is safe because two enum constants are equal only when they have the same identity.\n",
      "commitDate": 1425998782000,
      "commitName": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1424294072000,
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.73,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((tagType.equals(JavadocTagType.ALL) || tagType\n-                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n+            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n+                    \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (tagType.equals(JavadocTagType.ALL)\n-                    || tagType.equals(JavadocTagType.INLINE))\n+            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n"
    },
    "89a51ba032fd9126651fa9efad31baf10c006ddf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, javadoc, #512\n",
      "commitDate": 1421677262000,
      "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "d8286130e83dc672d30cd00eddbf6b5f77112521": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Make the code \"checkstyle compliant\"\n",
      "commitDate": 1310435277000,
      "commitName": "d8286130e83dc672d30cd00eddbf6b5f77112521",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "7d097b6fa682f8dcfedd95da2db8fed980c51705": {
      "type": "Yintroduced",
      "commitMessage": "Initial import of patch #3267984.\nStill work to be done\n",
      "commitDate": 1310432296000,
      "commitName": "7d097b6fa682f8dcfedd95da2db8fed980c51705",
      "commitAuthor": "Oliver Burn"
    }
  }
}