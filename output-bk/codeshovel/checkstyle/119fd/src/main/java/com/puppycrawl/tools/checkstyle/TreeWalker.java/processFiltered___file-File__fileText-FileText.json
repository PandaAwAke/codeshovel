{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "TreeWalker.java",
  "functionName": "processFiltered",
  "functionId": "processFiltered___file-File__fileText-FileText",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
  "functionStartLine": 176,
  "functionEndLine": 199,
  "changeHistory": [
    "58327e1dd9707b09f82ae2d4d4ce14c253247154",
    "f994512712c08a16def4a3c5a0426b7ab1590cc9",
    "6d9e8ece85007117e048fef55469623b830f9446",
    "82979737c4201b4913ea30b9c9431e71783d1c02",
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242",
    "27e1e94244b6bb369c2ea7502c235260f49f78b0",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609",
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c",
    "5922d5a6730d7582d7d66121eb911ef9426f9e24",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
    "4d2e6647f9e8385749c382bcab5e64965a943178",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
    "c4928f486c67afa62e7e8fbd5d8f731be7186985",
    "82d8e91024a57a96fbb6410dacb29d6a3f582903",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
    "a2da840df3bcb4e251695f7fbf1a5d341142459d",
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47",
    "56743942d548686fb90ebd8b7a17fed5977e49dc",
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5",
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
    "1dacd5303bfe94b9d5476059b6a5676146d96708",
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
    "204c073294cdca6756bcd546d6af85a797ad7d79",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "a8b8375b1db65b131938111ff283baed771161ed",
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e",
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
    "17754d363645285e49bf4323a1af5762af47a8ea",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "788b41973d5747c7b4699a853b62168cf0001df6",
    "76374876692534687016dba762a465bf93039402",
    "748df52c1317e298203bf28e48545d3e50db59f1",
    "915c6568cf2cde57c3e92ee9786acb4808562671",
    "44e3d33fc25d44157486288d5c77de75156984cb",
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0",
    "6db0b3effd48f02d741b2202338d710b1b254910",
    "5ace399de6c8963584b1fbe08007721433c4bad3",
    "d216ec75255a120ce7c24e51da7df63a2b9864de",
    "784b3270054dd61d8c6dbe413bcedfc628063171",
    "2149a9c42dce7a3913cca83755c8f562b0442929",
    "9f6a98ac725727519c43f6496f020c2e595dac57",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
    "abff1a2489ea8af10e1bc0a335551262d22f44e7",
    "54a09706ec1db32435b09e6b6910813325558f8d",
    "82b2ba526976588d550cac698e512f8de6c1ffc6",
    "93390fbc8a6952bbb20571ac1b18a705814fc219",
    "822384a711290170148b43b5ae390dd4e8cfaf4f",
    "4cbd709c019cf1b69796858506d673f7b66d37c7",
    "51941dcf2475545cee7b754acd5e2494c53acf9c",
    "03f8352479400cd2c80511bfe0242932a4f00f11",
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
    "751257987b2ef5f301e2deb3b55302196e5015af",
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3",
    "7521f1897b007e3acc06ea3330df5124f4206589",
    "bbe51f6884ac0a961f55310e15ec90411709d970",
    "8f8879df46592e6e35658026c354b804ef328097",
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7",
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f",
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708",
    "030798a11d2d21330cbdddd159cdc1824492157a",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3"
  ],
  "changeHistoryShort": {
    "58327e1dd9707b09f82ae2d4d4ce14c253247154": "Ybodychange",
    "f994512712c08a16def4a3c5a0426b7ab1590cc9": "Ybodychange",
    "6d9e8ece85007117e048fef55469623b830f9446": "Ybodychange",
    "82979737c4201b4913ea30b9c9431e71783d1c02": "Ymultichange(Yparameterchange,Ybodychange)",
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242": "Ybodychange",
    "27e1e94244b6bb369c2ea7502c235260f49f78b0": "Ybodychange",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": "Ybodychange",
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609": "Ybodychange",
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c": "Ybodychange",
    "5922d5a6730d7582d7d66121eb911ef9426f9e24": "Ymultichange(Yexceptionschange,Ybodychange)",
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": "Ybodychange",
    "4d2e6647f9e8385749c382bcab5e64965a943178": "Ybodychange",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": "Ybodychange",
    "c4928f486c67afa62e7e8fbd5d8f731be7186985": "Ybodychange",
    "82d8e91024a57a96fbb6410dacb29d6a3f582903": "Ybodychange",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": "Ybodychange",
    "a2da840df3bcb4e251695f7fbf1a5d341142459d": "Ybodychange",
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47": "Ybodychange",
    "56743942d548686fb90ebd8b7a17fed5977e49dc": "Ybodychange",
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5": "Ybodychange",
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66": "Ybodychange",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": "Ybodychange",
    "1dacd5303bfe94b9d5476059b6a5676146d96708": "Ybodychange",
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21": "Ybodychange",
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": "Ybodychange",
    "204c073294cdca6756bcd546d6af85a797ad7d79": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "a8b8375b1db65b131938111ff283baed771161ed": "Ybodychange",
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e": "Ybodychange",
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "17754d363645285e49bf4323a1af5762af47a8ea": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "788b41973d5747c7b4699a853b62168cf0001df6": "Ybodychange",
    "76374876692534687016dba762a465bf93039402": "Ybodychange",
    "748df52c1317e298203bf28e48545d3e50db59f1": "Ybodychange",
    "915c6568cf2cde57c3e92ee9786acb4808562671": "Ybodychange",
    "44e3d33fc25d44157486288d5c77de75156984cb": "Ybodychange",
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0": "Ybodychange",
    "6db0b3effd48f02d741b2202338d710b1b254910": "Ybodychange",
    "5ace399de6c8963584b1fbe08007721433c4bad3": "Ybodychange",
    "d216ec75255a120ce7c24e51da7df63a2b9864de": "Ybodychange",
    "784b3270054dd61d8c6dbe413bcedfc628063171": "Ybodychange",
    "2149a9c42dce7a3913cca83755c8f562b0442929": "Ybodychange",
    "9f6a98ac725727519c43f6496f020c2e595dac57": "Ybodychange",
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": "Ybodychange",
    "abff1a2489ea8af10e1bc0a335551262d22f44e7": "Ymultichange(Ymovefromfile,Ybodychange)",
    "54a09706ec1db32435b09e6b6910813325558f8d": "Ymultichange(Yreturntypechange,Ybodychange)",
    "82b2ba526976588d550cac698e512f8de6c1ffc6": "Ybodychange",
    "93390fbc8a6952bbb20571ac1b18a705814fc219": "Ybodychange",
    "822384a711290170148b43b5ae390dd4e8cfaf4f": "Ymultichange(Yparameterchange,Ybodychange)",
    "4cbd709c019cf1b69796858506d673f7b66d37c7": "Ybodychange",
    "51941dcf2475545cee7b754acd5e2494c53acf9c": "Ybodychange",
    "03f8352479400cd2c80511bfe0242932a4f00f11": "Ybodychange",
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b": "Ybodychange",
    "751257987b2ef5f301e2deb3b55302196e5015af": "Ybodychange",
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3": "Ybodychange",
    "7521f1897b007e3acc06ea3330df5124f4206589": "Ybodychange",
    "bbe51f6884ac0a961f55310e15ec90411709d970": "Ybodychange",
    "8f8879df46592e6e35658026c354b804ef328097": "Ybodychange",
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7": "Ybodychange",
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f": "Ybodychange",
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24": "Ybodychange",
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708": "Ybodychange",
    "030798a11d2d21330cbdddd159cdc1824492157a": "Ybodychange",
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": "Ymultichange(Ymodifierchange,Ybodychange)",
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": "Ybodychange",
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "58327e1dd9707b09f82ae2d4d4ce14c253247154": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5436: Split TreeWalker to TreeWalker and JavaParser\n",
      "commitDate": 1516775986000,
      "commitName": "58327e1dd9707b09f82ae2d4d4ce14c253247154",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": 1515079236000,
      "commitNameOld": "0847a10b9430d9fb0a3f44df03e891da906bea47",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 19.64,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,24 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n-        if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-            final String msg \u003d \"%s occurred during the analysis of file %s.\";\n-            final String fileName \u003d file.getPath();\n-\n-            try {\n-                if (!ordinaryChecks.isEmpty()\n-                        || !commentChecks.isEmpty()) {\n-                    final FileContents contents \u003d new FileContents(fileText);\n-                    final DetailAST rootAST \u003d parse(contents);\n-\n-                    if (!ordinaryChecks.isEmpty()) {\n-                        walk(rootAST, contents, AstState.ORDINARY);\n-                    }\n-                    if (!commentChecks.isEmpty()) {\n-                        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-\n-                        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-                    }\n-                    if (filters.isEmpty()) {\n-                        addMessages(messages);\n-                    }\n-                    else {\n-                        final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d\n-                            getFilteredMessages(fileName, contents, rootAST);\n-                        addMessages(filteredMessages);\n-                    }\n-                    messages.clear();\n-                }\n+        if (CommonUtils.matchesFileExtension(file, getFileExtensions())\n+                \u0026\u0026 (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty())) {\n+            final FileContents contents \u003d new FileContents(fileText);\n+            final DetailAST rootAST \u003d JavaParser.parse(contents);\n+            if (!ordinaryChecks.isEmpty()) {\n+                walk(rootAST, contents, AstState.ORDINARY);\n             }\n-            catch (final TokenStreamRecognitionException tre) {\n-                final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n-                        \"TokenStreamRecognitionException\", fileName);\n-                throw new CheckstyleException(exceptionMsg, tre);\n+            if (!commentChecks.isEmpty()) {\n+                final DetailAST astWithComments \u003d JavaParser.appendHiddenCommentNodes(rootAST);\n+                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n             }\n-            catch (RecognitionException | TokenStreamException ex) {\n-                final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n-                        ex.getClass().getSimpleName(), fileName);\n-                throw new CheckstyleException(exceptionMsg, ex);\n+            if (filters.isEmpty()) {\n+                addMessages(messages);\n             }\n+            else {\n+                final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d\n+                    getFilteredMessages(file.getPath(), contents, rootAST);\n+                addMessages(filteredMessages);\n+            }\n+            messages.clear();\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f994512712c08a16def4a3c5a0426b7ab1590cc9": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4422: Implement XpathFilter\n",
      "commitDate": 1503501086000,
      "commitName": "f994512712c08a16def4a3c5a0426b7ab1590cc9",
      "commitAuthor": "Timur",
      "commitDateOld": 1503389155000,
      "commitNameOld": "2f5115bce66f153ddfa02306505c1e81af942ff5",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 1.3,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg \u003d \"%s occurred during the analysis of file %s.\";\n             final String fileName \u003d file.getPath();\n \n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileContents contents \u003d new FileContents(fileText);\n                     final DetailAST rootAST \u003d parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n-                    final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d\n-                            getFilteredMessages(fileName, contents);\n-                    addMessages(filteredMessages);\n+                    if (filters.isEmpty()) {\n+                        addMessages(messages);\n+                    }\n+                    else {\n+                        final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d\n+                            getFilteredMessages(fileName, contents, rootAST);\n+                        addMessages(filteredMessages);\n+                    }\n                     messages.clear();\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "6d9e8ece85007117e048fef55469623b830f9446": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4714: Make SuppressionCommentFilter and SuppressWithNearbyCommentFilter children of TreeWalker\n",
      "commitDate": 1500928695000,
      "commitName": "6d9e8ece85007117e048fef55469623b830f9446",
      "commitAuthor": "Timur",
      "commitDateOld": 1499432353000,
      "commitNameOld": "7fb0cf6870124032136b06eb7572a1de1b92e87a",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 17.32,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,38 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg \u003d \"%s occurred during the analysis of file %s.\";\n             final String fileName \u003d file.getPath();\n+\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileContents contents \u003d new FileContents(fileText);\n                     final DetailAST rootAST \u003d parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n+                    final SortedSet\u003cLocalizedMessage\u003e filteredMessages \u003d\n+                            getFilteredMessages(fileName, contents);\n+                    addMessages(filteredMessages);\n+                    messages.clear();\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "82979737c4201b4913ea30b9c9431e71783d1c02": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
      "commitDate": 1499372568000,
      "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
      "commitAuthor": "Timur",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "d72e6f7d0b9f339feef4309a9dada7fd381ba242": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4398: increase coverage of pitest-checkstyle-tree-walker profile to 89%\n",
      "commitDate": 1498141328000,
      "commitName": "d72e6f7d0b9f339feef4309a9dada7fd381ba242",
      "commitAuthor": "vasilyeva",
      "commitDateOld": 1497287515000,
      "commitNameOld": "4a087c020c2b97130e94f9292b94cb4bc1f6ed93",
      "commitAuthorOld": "sagar-shah94",
      "daysBetweenCommits": 9.88,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,34 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg \u003d \"%s occurred during the analysis of file %s.\";\n             final String fileName \u003d file.getPath();\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileText text \u003d FileText.fromLines(file, lines);\n                     final FileContents contents \u003d new FileContents(text);\n                     final DetailAST rootAST \u003d parse(contents);\n \n-                    getMessageCollector().reset();\n-\n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "27e1e94244b6bb369c2ea7502c235260f49f78b0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4393: ASTs to be generated and walked only when there are corresponding type of checks. No parsing if no checks are specified\n",
      "commitDate": 1496840526000,
      "commitName": "27e1e94244b6bb369c2ea7502c235260f49f78b0",
      "commitAuthor": "Piyush Sharma",
      "commitDateOld": 1492827278000,
      "commitNameOld": "de50d3465849b83d25910590e1f5f39a25fe6e2c",
      "commitAuthorOld": "Vladislav Lisetskii",
      "daysBetweenCommits": 46.45,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,36 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg \u003d \"%s occurred during the analysis of file %s.\";\n             final String fileName \u003d file.getPath();\n             try {\n-                final FileText text \u003d FileText.fromLines(file, lines);\n-                final FileContents contents \u003d new FileContents(text);\n-                final DetailAST rootAST \u003d parse(contents);\n+                if (!ordinaryChecks.isEmpty()\n+                        || !commentChecks.isEmpty()) {\n+                    final FileText text \u003d FileText.fromLines(file, lines);\n+                    final FileContents contents \u003d new FileContents(text);\n+                    final DetailAST rootAST \u003d parse(contents);\n \n-                getMessageCollector().reset();\n+                    getMessageCollector().reset();\n \n-                walk(rootAST, contents, AstState.ORDINARY);\n+                    if (!ordinaryChecks.isEmpty()) {\n+                        walk(rootAST, contents, AstState.ORDINARY);\n+                    }\n+                    if (!commentChecks.isEmpty()) {\n+                        final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n-                final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-\n-                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+                        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+                    }\n+                }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3143: forbid empty return statements and fixed violations",
      "commitDate": 1464356569000,
      "commitName": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthor": "rnveach",
      "commitDateOld": 1463431992000,
      "commitNameOld": "ecbeaa6e1df7cb021745e111b04395b9fbd509c7",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 10.7,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,30 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n         // check if already checked and passed the file\n-        if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-            return;\n-        }\n+        if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n+            final String msg \u003d \"%s occurred during the analysis of file %s.\";\n+            final String fileName \u003d file.getPath();\n+            try {\n+                final FileText text \u003d FileText.fromLines(file, lines);\n+                final FileContents contents \u003d new FileContents(text);\n+                final DetailAST rootAST \u003d parse(contents);\n \n-        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n-        final String fileName \u003d file.getPath();\n-        try {\n-            final FileText text \u003d FileText.fromLines(file, lines);\n-            final FileContents contents \u003d new FileContents(text);\n-            final DetailAST rootAST \u003d parse(contents);\n+                getMessageCollector().reset();\n \n-            getMessageCollector().reset();\n+                walk(rootAST, contents, AstState.ORDINARY);\n \n-            walk(rootAST, contents, AstState.ORDINARY);\n+                final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n-            final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n-\n-            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-        }\n-        catch (final TokenStreamRecognitionException tre) {\n-            final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n-                    \"TokenStreamRecognitionException\", fileName);\n-            throw new CheckstyleException(exceptionMsg, tre);\n-        }\n-        catch (RecognitionException | TokenStreamException ex) {\n-            final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n-                    ex.getClass().getSimpleName(), fileName);\n-            throw new CheckstyleException(exceptionMsg, ex);\n+                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+            }\n+            catch (final TokenStreamRecognitionException tre) {\n+                final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n+                        \"TokenStreamRecognitionException\", fileName);\n+                throw new CheckstyleException(exceptionMsg, tre);\n+            }\n+            catch (RecognitionException | TokenStreamException ex) {\n+                final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n+                        ex.getClass().getSimpleName(), fileName);\n+                throw new CheckstyleException(exceptionMsg, ex);\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d46c2cf0e9df06bb5f424dbd7645574f082f7609": {
      "type": "Ybodychange",
      "commitMessage": "Issue #569: Move TreeWalker cache to Checker\n",
      "commitDate": 1455040202000,
      "commitName": "d46c2cf0e9df06bb5f424dbd7645574f082f7609",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": 1454680863000,
      "commitNameOld": "cf96dd9adcf0c3c8f8f05a9ffdcb765cafe17479",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 4.16,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,32 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n         // check if already checked and passed the file\n-        final String fileName \u003d file.getPath();\n-        final long timestamp \u003d file.lastModified();\n-        if (cache !\u003d null\n-                \u0026\u0026 (cache.isInCache(fileName, timestamp)\n-                    || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n+        if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n-\n+        final String fileName \u003d file.getPath();\n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                     \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         }\n         catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n                     ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n-\n-        if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n-            cache.put(fileName, timestamp);\n-        }\n     }\n\\ No newline at end of file\n"
    },
    "be3e035ce39a610881cd2c1bfdce3eef101c2e3c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1217: fixes for violations from \u0027forbiddenapis\u0027 verification tool\n",
      "commitDate": 1444779430000,
      "commitName": "be3e035ce39a610881cd2c1bfdce3eef101c2e3c",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1444178762000,
      "commitNameOld": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 6.95,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n-            final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n-                     fileName);\n+            final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n+                    \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         }\n         catch (RecognitionException | TokenStreamException ex) {\n-            final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n+            final String exceptionMsg \u003d String.format(Locale.ROOT, msg,\n+                    ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "5922d5a6730d7582d7d66121eb911ef9426f9e24": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
      "commitDate": 1440997584000,
      "commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
      "commitAuthor": "Ruslan Diachenko",
      "subchanges": [
        "Yexceptionschange",
        "Ybodychange"
      ]
    },
    "46a52f84c014e4d25379f429f11ed3de11fe8ae7": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Rename methods returning boolean to use question word\n\nFixes some `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n\u003eReports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
      "commitDate": 1440827451000,
      "commitName": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1440705239000,
      "commitNameOld": "4d2e6647f9e8385749c382bcab5e64965a943178",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.41,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.isInCache(fileName, timestamp)\n-                    || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n+                    || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             final String message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4d2e6647f9e8385749c382bcab5e64965a943178": {
      "type": "Ybodychange",
      "commitMessage": "Rename boolean methods to start with question word. #1555\n\nFixes `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n\u003eReports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
      "commitDate": 1440705239000,
      "commitName": "4d2e6647f9e8385749c382bcab5e64965a943178",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1440679299000,
      "commitNameOld": "60ae95a6219d0e0765040ece0c3a8d439e1375ad",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n-                \u0026\u0026 (cache.inCache(fileName, timestamp)\n+                \u0026\u0026 (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             final String message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": {
      "type": "Ybodychange",
      "commitMessage": "Utils class has been splitted to CommonUtils and TokenUtils. Issue #1898\n",
      "commitDate": 1440677821000,
      "commitName": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1440677821000,
      "commitNameOld": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.inCache(fileName, timestamp)\n-                    || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n+                    || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             final String message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c4928f486c67afa62e7e8fbd5d8f731be7186985": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1555\n\nFixes `TooBroadScope` inspection violations.\n\nDescription:\n\u003eReports any variable declarations of which the scope can be narrowed. Especially useful for \"Pascal style\" declarations at the start of a method, but variables with too broad a scope are also often left over after refactorings.\n",
      "commitDate": 1439355282000,
      "commitName": "c4928f486c67afa62e7e8fbd5d8f731be7186985",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1439324041000,
      "commitNameOld": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,44 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n-            String message;\n-            message \u003d re.getMessage();\n+            final String message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "82d8e91024a57a96fbb6410dacb29d6a3f582903": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary qualifiers. #1555\n\nFixes `UnnecessarilyQualifiedStaticUsage` inspection violations.\n\nDescription:\n\u003eReports calls to static methods or accesses of static fields on the current class which are qualified with the class name. Such qualification is unnecessary, and may be safely removed.\n",
      "commitDate": 1439324041000,
      "commitName": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1439295539000,
      "commitNameOld": "1935bed5772c0a939b9168b81acd2ab5aa800538",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n-            final DetailAST rootAST \u003d TreeWalker.parse(contents);\n+            final DetailAST rootAST \u003d parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message;\n             message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": {
      "type": "Ybodychange",
      "commitMessage": "Remove unused assignments. #1555\n\nFixes UnusedAssignment inspection violations.\n\nDescription:\n\u003eThis inspection points out the cases where a variable value is never used after its assignment, i.e.:\n- the variable never gets read after assignment OR\n- the value is always overwritten with another assignment before the next variable read OR\n - the variable initializer is redundant (for one of the above two reasons) OR\n - the variable is never used.\n",
      "commitDate": 1439007161000,
      "commitName": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1438778391000,
      "commitNameOld": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 2.65,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n-            String message \u003d \"TokenStreamRecognitionException occured\";\n+            String message;\n             message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a2da840df3bcb4e251695f7fbf1a5d341142459d": {
      "type": "Ybodychange",
      "commitMessage": "100% UTs coverage for TreeWalker. #1294\n",
      "commitDate": 1438778391000,
      "commitName": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1438566538000,
      "commitNameOld": "6fd60de0a4363b806d37d4129d9a430f8f3dee6b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.45,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,45 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache !\u003d null\n                 \u0026\u0026 (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n-            if (re !\u003d null) {\n-                message \u003d re.getMessage();\n-            }\n+            message \u003d re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "ea9ff3965d9c657b5b7bd2d969e075f430635c47": {
      "type": "Ybodychange",
      "commitMessage": "100% UTs coverage for PropertyCacheFile. Refactoring of PropertyCacheFile. #1294\n",
      "commitDate": 1438103538000,
      "commitName": "ea9ff3965d9c657b5b7bd2d969e075f430635c47",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1436718750000,
      "commitNameOld": "8da777a68ad936f1a4e07d59cee17ecab2fc293e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 16.03,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n-        if (cache.alreadyChecked(fileName, timestamp)\n-                 || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n+        if (cache !\u003d null\n+                \u0026\u0026 (cache.inCache(fileName, timestamp)\n+                    || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n                 message \u003d re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n-        if (getMessageCollector().size() \u003d\u003d 0) {\n-            cache.checkedOk(fileName, timestamp);\n+        if (cache !\u003d null \u0026\u0026 getMessageCollector().size() \u003d\u003d 0) {\n+            cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "56743942d548686fb90ebd8b7a17fed5977e49dc": {
      "type": "Ybodychange",
      "commitMessage": "Extend ReturnCount Check to treat lambdas  separately. #1068\n",
      "commitDate": 1431839947000,
      "commitName": "56743942d548686fb90ebd8b7a17fed5977e49dc",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1431729119000,
      "commitNameOld": "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n                 message \u003d re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            LOG.error(exceptionMsg);\n+            LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "aeef83ee58cce5b5bf0f10a8793fc37514751ef5": {
      "type": "Ybodychange",
      "commitMessage": "Remove obsolete space from error message",
      "commitDate": 1430436070000,
      "commitName": "aeef83ee58cce5b5bf0f10a8793fc37514751ef5",
      "commitAuthor": "Michał Kordas",
      "commitDateOld": 1430353274000,
      "commitNameOld": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n-        final String msg \u003d \"%s occurred during the analysis of file %s .\";\n+        final String msg \u003d \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n                 message \u003d re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66": {
      "type": "Ybodychange",
      "commitMessage": "Fix AvoidStaticImport check violations in codebase, issue #979\n",
      "commitDate": 1430064836000,
      "commitName": "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1430008241000,
      "commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.66,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n-                 || !fileExtensionMatches(file, getFileExtensions()))\n+                 || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n                 message \u003d re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from \u0027logging-jakarta\u0027 ruleset, issue #871\n",
      "commitDate": 1428961380000,
      "commitName": "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1428792106000,
      "commitNameOld": "7dd24c8c35572b5db3e5c905d440e813cfe2538c",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n+            LOG.error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n                 message \u003d re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n+            LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1dacd5303bfe94b9d5476059b6a5676146d96708": {
      "type": "Ybodychange",
      "commitMessage": "Merged catch blocks into one where possible\n\nPull #825\n",
      "commitDate": 1427233706000,
      "commitName": "1dacd5303bfe94b9d5476059b6a5676146d96708",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": 1427151609000,
      "commitNameOld": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,48 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n-        catch (final RecognitionException re) {\n-            final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    re.getLine(),\n-                    re.getColumn(),\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {re.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n+            String message \u003d \"TokenStreamRecognitionException occured\";\n             if (re !\u003d null) {\n-                getMessageCollector().add(\n-                    new LocalizedMessage(\n-                        re.getLine(),\n-                        re.getColumn(),\n-                        Defn.CHECKSTYLE_BUNDLE,\n-                        \"general.exception\",\n-                        new String[] {re.getMessage()},\n-                        getId(),\n-                        this.getClass(), null));\n+                message \u003d re.getMessage();\n             }\n-            else {\n-                getMessageCollector().add(\n-                    new LocalizedMessage(\n-                        0,\n-                        Defn.CHECKSTYLE_BUNDLE,\n-                        \"general.exception\",\n-                        new String[]\n-                        {\"TokenStreamRecognitionException occured.\"},\n-                        getId(),\n-                        this.getClass(), null));\n-            }\n+            getMessageCollector().add(createLocalizedMessage(message));\n         }\n-        catch (final TokenStreamException te) {\n-            final String exceptionMsg \u003d String.format(msg,\n-                    \"TokenStreamException\", fileName);\n+        // RecognitionException and any other (need to check if needed)\n+        catch (Throwable ex) {\n+            final String exceptionMsg \u003d String.format(msg, ex.getClass().getSimpleName(), fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {te.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final Throwable err) {\n-            final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {\"\" + err},\n-                    getId(),\n-                    this.getClass(), null));\n+            getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "14e0b0ea52977de4a8d8ceb6bab1420e84093a21": {
      "type": "Ybodychange",
      "commitMessage": "Remove unwritten field, issue #778\n\nAll violations of Findbugs rule [UwF: Unwritten field](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_UNWRITTEN_FIELD) are fixed.\n",
      "commitDate": 1427151609000,
      "commitName": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1426571164000,
      "commitNameOld": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n-                 || !fileExtensionMatches(file, fileExtensions))\n+                 || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg \u003d String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
      "type": "Ybodychange",
      "commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
      "commitDate": 1426571164000,
      "commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1426454536000,
      "commitNameOld": "1c15b6a36baa68dc3f2ebdf9baac131e98bb9e04",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 1.35,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,97 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, fileExtensions))\n         {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg \u003d String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n-            err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "204c073294cdca6756bcd546d6af85a797ad7d79": {
      "type": "Ybodychange",
      "commitMessage": "Added file extensions property to Checker \u0026 TreeWalker, issue #25\n",
      "commitDate": 1422178221000,
      "commitName": "204c073294cdca6756bcd546d6af85a797ad7d79",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1421929605000,
      "commitNameOld": "95c1a081e0868fc3ac9faf05d09ca8b2bb06a5cc",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 2.88,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,98 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d file.getPath();\n         final long timestamp \u003d file.lastModified();\n-        if (cache.alreadyChecked(fileName, timestamp)) {\n+        if (cache.alreadyChecked(fileName, timestamp)\n+                 || !fileExtensionMatches(file, fileExtensions))\n+        {\n             return;\n         }\n \n         final String msg \u003d \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text \u003d FileText.fromLines(file, lines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg \u003d String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": 1421678312000,
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "a8b8375b1db65b131938111ff283baed771161ed": {
      "type": "Ybodychange",
      "commitMessage": "Logging of exceptions to console, issue #546\n",
      "commitDate": 1420821761000,
      "commitName": "a8b8375b1db65b131938111ff283baed771161ed",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1415151014000,
      "commitNameOld": "f2b19f10806dc89807888a772de34177c36c602b",
      "commitAuthorOld": "Vladimir Sitnikov",
      "daysBetweenCommits": 65.63,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,96 @@\n     protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n+        final String msg \u003d \"%s occurred during the analysis of file %s .\";\n+\n         try {\n             final FileText text \u003d FileText.fromLines(aFile, aLines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n-            Utils.getExceptionLogger()\n-                .debug(\"RecognitionException occured.\", re);\n+            final String exceptionMsg \u003d String.format(msg, \"RecognitionException\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n-            Utils.getExceptionLogger()\n-                .debug(\"TokenStreamRecognitionException occured.\", tre);\n+            final String exceptionMsg \u003d String.format(msg, \"TokenStreamRecognitionException\",\n+                     fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n-            Utils.getExceptionLogger()\n-                .debug(\"TokenStreamException occured.\", te);\n+            final String exceptionMsg \u003d String.format(msg,\n+                    \"TokenStreamException\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n+            final String exceptionMsg \u003d String.format(msg, \"Exception\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n-            Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "a24df47cafeab03fd65cf72b460aad3d2fafce3d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #49. Added support of single-line and block comments\n",
      "commitDate": 1413609550000,
      "commitName": "a24df47cafeab03fd65cf72b460aad3d2fafce3d",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1413609550000,
      "commitNameOld": "59014fa7539bdbaacda4325454964492db0c6109",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,91 @@\n     protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             final FileText text \u003d FileText.fromLines(aFile, aLines);\n             final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-            walk(rootAST, contents);\n+\n+            getMessageCollector().reset();\n+\n+            walk(rootAST, contents, AstState.ORDINARY);\n+\n+            final DetailAST astWithComments \u003d appendHiddenCommentNodes(rootAST);\n+\n+            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n+            err.printStackTrace();\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "3cd6646941eca3da7d3b9a221c88e4c1d214876e": {
      "type": "Ybodychange",
      "commitMessage": "Apply patch #2783226 that uses FileText as an implementation for\nList\u003cString\u003e to pass lines around\n",
      "commitDate": 1277730133000,
      "commitName": "3cd6646941eca3da7d3b9a221c88e4c1d214876e",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1266029835000,
      "commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 135.42,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n     protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            final FileContents contents \u003d new FileContents(fileName, aLines\n-                    .toArray(new String[aLines.size()]));\n+            final FileText text \u003d FileText.fromLines(aFile, aLines);\n+            final FileContents contents \u003d new FileContents(text);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "13b7c634337e38d20daa92ca9d5e069a2e72ec55": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
      "commitDate": 1226223447000,
      "commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Yrename",
        "Yparameterchange",
        "Ymodifierchange",
        "Ybodychange"
      ]
    },
    "17754d363645285e49bf4323a1af5762af47a8ea": {
      "type": "Ybodychange",
      "commitMessage": "snapshot of changes - need to refactor\n",
      "commitDate": 1216160862000,
      "commitName": "17754d363645285e49bf4323a1af5762af47a8ea",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1209181531000,
      "commitNameOld": "911065320fb39299f442ea08f775cfe08ba2a2ed",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 80.78,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (final FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n-                        this.getClass()));\n+                        this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n-                        this.getClass()));\n+                        this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": 1152243856000,
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1152243235000,
      "commitNameOld": "f4a92dad02a3a36b5e2e988bba04debb1e2c9db9",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (FileNotFoundException fnfe) {\n+        catch (final FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (IOException ioe) {\n+        catch (final IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (RecognitionException re) {\n+        catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (TokenStreamRecognitionException tre) {\n+        catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass()));\n             }\n         }\n-        catch (TokenStreamException te) {\n+        catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (Throwable err) {\n+        catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "788b41973d5747c7b4699a853b62168cf0001df6": {
      "type": "Ybodychange",
      "commitMessage": "Changes to make it possible to identify a module by an id, and then to\nsuppress messages based on the id. The motivation is to allow for finer\ngrained suppressions. For example, can enable multiple instances of the\nRegexp check, and suppress on the individual instance.\n",
      "commitDate": 1135859700000,
      "commitName": "788b41973d5747c7b4699a853b62168cf0001df6",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1134846213000,
      "commitNameOld": "78e9ce870170ca3ef88fd78f8e0af0681c958eb3",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 11.73,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n+                        getId(),\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n+                        getId(),\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n+                    getId(),\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "76374876692534687016dba762a465bf93039402": {
      "type": "Ybodychange",
      "commitMessage": "Accept Oleg\u0027s comments about NPEs, http://sourceforge.net/mailarchive/forum.php?thread_id\u003d5251578\u0026forum_id\u003d2864\n",
      "commitDate": 1091540711000,
      "commitName": "76374876692534687016dba762a465bf93039402",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1091199570000,
      "commitNameOld": "748df52c1317e298203bf28e48545d3e50db59f1",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 3.95,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,105 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n-                        new String[] {\"\"},\n+                        new String[]\n+                            {\"TokenStreamRecognitionException occured.\"},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "748df52c1317e298203bf28e48545d3e50db59f1": {
      "type": "Ybodychange",
      "commitMessage": "fixes possible null pointer exceptions, bad string compares\n",
      "commitDate": 1091199570000,
      "commitName": "748df52c1317e298203bf28e48545d3e50db59f1",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1090411333000,
      "commitNameOld": "3b5e5d728bf1b8d222c538f7cfc92cab0805eb1f",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 9.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n-                        new String[] {re.getMessage()},\n+                        new String[] {\"\"},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "915c6568cf2cde57c3e92ee9786acb4808562671": {
      "type": "Ybodychange",
      "commitMessage": "Added charset property to TreeWalker and StrictDuplicateCode check (addresses bug 975346)\n",
      "commitDate": 1087904564000,
      "commitName": "915c6568cf2cde57c3e92ee9786acb4808562671",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1087857052000,
      "commitNameOld": "44e3d33fc25d44157486288d5c77de75156984cb",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines \u003d Utils.getLines(fileName);\n+            final String[] lines \u003d Utils.getLines(fileName, getCharset());\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re \u003d tre.recog;\n             if (re !\u003d null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "44e3d33fc25d44157486288d5c77de75156984cb": {
      "type": "Ybodychange",
      "commitMessage": "Better information for unexpected char, RFE 666188\n",
      "commitDate": 1087857052000,
      "commitName": "44e3d33fc25d44157486288d5c77de75156984cb",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1074114639000,
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 159.06,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n-                    0,\n+                    re.getLine(),\n+                    re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n+        catch (TokenStreamRecognitionException tre) {\n+            Utils.getExceptionLogger()\n+                .debug(\"TokenStreamRecognitionException occured.\", tre);\n+            final RecognitionException re \u003d tre.recog;\n+            if (re !\u003d null) {\n+                getMessageCollector().add(\n+                    new LocalizedMessage(\n+                        re.getLine(),\n+                        re.getColumn(),\n+                        Defn.CHECKSTYLE_BUNDLE,\n+                        \"general.exception\",\n+                        new String[] {re.getMessage()},\n+                        this.getClass()));\n+            }\n+            else {\n+                getMessageCollector().add(\n+                    new LocalizedMessage(\n+                        0,\n+                        Defn.CHECKSTYLE_BUNDLE,\n+                        \"general.exception\",\n+                        new String[] {re.getMessage()},\n+                        this.getClass()));\n+            }\n+        }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0": {
      "type": "Ybodychange",
      "commitMessage": "Added exception logging (see request 753883)\n",
      "commitDate": 1062563740000,
      "commitName": "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1057402055000,
      "commitNameOld": "6db0b3effd48f02d741b2202338d710b1b254910",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 59.74,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,79 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n+            Utils.getExceptionLogger()\n+                .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n+            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n+            Utils.getExceptionLogger()\n+                .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamException te) {\n+            Utils.getExceptionLogger()\n+                .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n+            Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "6db0b3effd48f02d741b2202338d710b1b254910": {
      "type": "Ybodychange",
      "commitMessage": "Code cleanup to force the class name for the cause of the message to be\nlogged. Required as part of changes I am making for RFE 756416.\n",
      "commitDate": 1057402055000,
      "commitName": "6db0b3effd48f02d741b2202338d710b1b254910",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1056711878000,
      "commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.99,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,71 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.fileNotFound\", null));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.fileNotFound\",\n+                    null,\n+                    this.getClass()));\n         }\n         catch (IOException ioe) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {ioe.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {ioe.getMessage()},\n+                    this.getClass()));\n         }\n         catch (RecognitionException re) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {re.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {re.getMessage()},\n+                    this.getClass()));\n         }\n         catch (TokenStreamException te) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {te.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {te.getMessage()},\n+                    this.getClass()));\n         }\n         catch (Throwable err) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {\"\" + err}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {\"\" + err},\n+                    this.getClass()));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "5ace399de6c8963584b1fbe08007721433c4bad3": {
      "type": "Ybodychange",
      "commitMessage": "Another quality patch from Oleg Sukhodolsky to fix TranslationCheck Test\nbug. (bug 720925).\n",
      "commitDate": 1051172333000,
      "commitName": "5ace399de6c8963584b1fbe08007721433c4bad3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1050655805000,
      "commitNameOld": "55fcf189eb1c1c4d776ce3b3ad7835fb404b21d8",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.98,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,55 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n-        getMessageCollector().reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {te.getMessage()}));\n         }\n         catch (Throwable err) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {\"\" + err}));\n         }\n \n         if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            getMessageDispatcher().fireErrors(\n-                fileName, getMessageCollector().getMessages());\n+            fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "d216ec75255a120ce7c24e51da7df63a2b9864de": {
      "type": "Ybodychange",
      "commitMessage": "Major refactorings to allow the use of SeverityLevels in FileSetChecks\nas well as in Checks and to simplify logging of messages in FileSetChecks.\n\nIntroduction of a new class called AbstractViolationReporter, from which\nboth Check and FileSetCheck are derived.\n\nSeverity is passed to submodules by means of the Contextualizable\nmechanism. This means that the user can f.ex. set severity to INFO\nin a TreeWalker and all Checks below that TreeWalker will use severity INFO.\n",
      "commitDate": 1048708350000,
      "commitName": "d216ec75255a120ce7c24e51da7df63a2b9864de",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1046456671000,
      "commitNameOld": "784b3270054dd61d8c6dbe413bcedfc628063171",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 26.06,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,57 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n-        mMessages.reset();\n+        getMessageCollector().reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.fileNotFound\", null));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n-            mMessages.add(new LocalizedMessage(\n-                              0, Defn.CHECKSTYLE_BUNDLE,\n-                              \"general.exception\",\n-                              new String[] {ioe.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {re.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {te.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {te.getMessage()}));\n         }\n         catch (Throwable err) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {\"\" + err}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {\"\" + err}));\n         }\n \n-        if (mMessages.size() \u003d\u003d 0) {\n+        if (getMessageCollector().size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n-                fileName, mMessages.getMessages());\n+                fileName, getMessageCollector().getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "784b3270054dd61d8c6dbe413bcedfc628063171": {
      "type": "Ybodychange",
      "commitMessage": "Handle all parse errors,esp.those throws by the ANTLR parser on a\nsyntax error (see bug request id 694111).\n",
      "commitDate": 1046456671000,
      "commitName": "784b3270054dd61d8c6dbe413bcedfc628063171",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1045363824000,
      "commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 12.65,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,53 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n+        catch (Throwable err) {\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {\"\" + err}));\n+        }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "2149a9c42dce7a3913cca83755c8f562b0442929": {
      "type": "Ybodychange",
      "commitMessage": "removed todo items that have already been resolved\n",
      "commitDate": 1040983106000,
      "commitName": "2149a9c42dce7a3913cca83755c8f562b0442929",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1040923304000,
      "commitNameOld": "2a71cac7e02c012add5e75f35aaf6aca7c561401",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,48 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            // TODO: this dependency on the checkstyle package is not good. It\n-            // introduces a circular dependency between packages.\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "9f6a98ac725727519c43f6496f020c2e595dac57": {
      "type": "Ybodychange",
      "commitMessage": "Added a flag - something needs to be done about\ndependencies\n",
      "commitDate": 1039259567000,
      "commitName": "9f6a98ac725727519c43f6496f020c2e595dac57",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1039182011000,
      "commitNameOld": "53e4d78c1934b2681c70d560c8805b1e83199fa5",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,50 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n+            // TODO: this dependency on the checkstyle package is not good. It\n+            // introduces a circular dependency between packages.\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
      "type": "Ybodychange",
      "commitMessage": "avalonization\n",
      "commitDate": 1038680984000,
      "commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1037771766000,
      "commitNameOld": "6568a9b88220366da3fc9e58fc9de93af9a6520d",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n-            walk(rootAST, contents, mConfig.getClassLoader());\n+            walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                     fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n"
    },
    "abff1a2489ea8af10e1bc0a335551262d22f44e7": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
      "commitDate": 1037737306000,
      "commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        "Ymovefromfile",
        "Ybodychange"
      ]
    },
    "54a09706ec1db32435b09e6b6910813325558f8d": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
      "commitDate": 1037733445000,
      "commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        "Yreturntypechange",
        "Ybodychange"
      ]
    },
    "82b2ba526976588d550cac698e512f8de6c1ffc6": {
      "type": "Ybodychange",
      "commitMessage": "Moved stripping of basedir to the event handling routines.\nThis separates concerns in parse(File) as a preparation for moving that method to TreeWalker.\nIt also fixes bug #622290 (package name reported incorrectly) once I integrate PackageHtmlCheck.\n",
      "commitDate": 1037521490000,
      "commitName": "82b2ba526976588d550cac698e512f8de6c1ffc6",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1037520335000,
      "commitNameOld": "93390fbc8a6952bbb20571ac1b18a705814fc219",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,48 @@\n     private int process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n-        // Create a stripped down version\n-        final String stripped;\n-        final String basedir \u003d mConfig.getBasedir();\n-        if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n-            stripped \u003d fileName;\n-        }\n-        else {\n-            // making the assumption that there is text after basedir\n-            final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n-            stripped \u003d fileName.substring(basedir.length() + skipSep);\n-        }\n-\n         mMessages.reset();\n         try {\n-            fireFileStarted(stripped);\n+            fireFileStarted(fileName);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n             final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            fireErrors(stripped, mMessages.getMessages());\n+            fireErrors(fileName, mMessages.getMessages());\n         }\n \n-        fireFileFinished(stripped);\n+        fireFileFinished(fileName);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n"
    },
    "93390fbc8a6952bbb20571ac1b18a705814fc219": {
      "type": "Ybodychange",
      "commitMessage": "moved parse() from Checker to TreeWalker\n",
      "commitDate": 1037520335000,
      "commitName": "93390fbc8a6952bbb20571ac1b18a705814fc219",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1037515736000,
      "commitNameOld": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     private int process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName \u003d aFile.getPath();\n         final long timestamp \u003d aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !fileName.startsWith(basedir)) {\n             stripped \u003d fileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d fileName.substring(basedir.length() + skipSep);\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d Utils.getLines(fileName);\n             final FileContents contents \u003d new FileContents(fileName, lines);\n-            final DetailAST rootAST \u003d parse(contents);\n+            final DetailAST rootAST \u003d TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n"
    },
    "822384a711290170148b43b5ae390dd4e8cfaf4f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
      "commitDate": 1037515736000,
      "commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
      "commitAuthor": "Lars Kühne",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "4cbd709c019cf1b69796858506d673f7b66d37c7": {
      "type": "Ybodychange",
      "commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
      "commitDate": 1037161281000,
      "commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1036555078000,
      "commitNameOld": "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.02,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,60 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n-        LocalizedMessage[] errors;\n+        mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d Utils.getLines(aFileName);\n-            try {\n-                // try the 1.4 grammar first, this will succeed for\n-                // all code that compiles without any warnings in JDK 1.4,\n-                // that should cover most cases\n-                VerifierSingleton.getInstance().reset();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar \u003d new StringArrayReader(lines);\n-                final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n-                jl.setFilename(aFileName);\n-                final GeneratedJava14Recognizer jr \u003d\n-                    new SilentJava14Recognizer(jl);\n-                jr.setFilename(aFileName);\n-                jr.setASTNodeClass(MyCommonAST.class.getName());\n-                jr.compilationUnit();\n-            }\n-            catch (RecognitionException re) {\n-                // Parsing might have failed because the checked\n-                // file contains \"assert\" as an identifier. Retry with a\n-                // grammar that treats \"assert\" as an identifier\n-                // and not as a keyword\n-\n-                // Arghh - the pain - duplicate code!\n-                VerifierSingleton.getInstance().reset();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar \u003d new StringArrayReader(lines);\n-                final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n-                jl.setFilename(aFileName);\n-                final GeneratedJavaRecognizer jr \u003d\n-                    new GeneratedJavaRecognizer(jl);\n-                jr.setFilename(aFileName);\n-                jr.setASTNodeClass(MyCommonAST.class.getName());\n-                jr.compilationUnit();\n-            }\n-            errors \u003d VerifierSingleton.getInstance().getMessages();\n+            final FileContents contents \u003d new FileContents(aFileName, lines);\n+            final DetailAST rootAST \u003d parse(contents);\n+            mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n-            errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.fileNotFound\", null)};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n-            errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {ioe.getMessage()})};\n+            mMessages.add(new LocalizedMessage(\n+                              0, Defn.CHECKSTYLE_BUNDLE,\n+                              \"general.exception\",\n+                              new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n-            errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {re.getMessage()})};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n-            errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {te.getMessage()})};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {te.getMessage()}));\n         }\n \n-        if (errors.length \u003d\u003d 0) {\n+        if (mMessages.size() \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            fireErrors(stripped, errors);\n+            fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n-        return errors.length;\n+        return mMessages.size();\n     }\n\\ No newline at end of file\n"
    },
    "51941dcf2475545cee7b754acd5e2494c53acf9c": {
      "type": "Ybodychange",
      "commitMessage": "added TreeViewer to help with development.\n",
      "commitDate": 1033948354000,
      "commitName": "51941dcf2475545cee7b754acd5e2494c53acf9c",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1033462046000,
      "commitNameOld": "eb7b7bfd3e63a926c3f3b2801d519caa0e1fffc3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.63,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n-            final String[] lines \u003d getLines(aFileName);\n+            final String[] lines \u003d Utils.getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "03f8352479400cd2c80511bfe0242932a4f00f11": {
      "type": "Ybodychange",
      "commitMessage": "Got the unit tests to pass again. They highlighted a bug in the recent\nchanges, and once again prove they are worth the effort. ;-)\n",
      "commitDate": 1032426477000,
      "commitName": "03f8352479400cd2c80511bfe0242932a4f00f11",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1032325714000,
      "commitNameOld": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,94 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.fileNotFound\", null, null)};\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "4880b50a3a89db93e7e7c1b8bae8036ec06e186b": {
      "type": "Ybodychange",
      "commitMessage": "improved resource bundle handling:\n- plugins can use their own bundle (location determined automatically)\n- return the message key if ResourceBundle is not available\n- added log helper methods in Check.java\n",
      "commitDate": 1032325714000,
      "commitName": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1032266010000,
      "commitNameOld": "672b27dd5551de63a1fb08d8ea80376d70f2aa60",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.fileNotFound\", null)};\n+                new LocalizedMessage(0, \"general.fileNotFound\", null, null)};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "751257987b2ef5f301e2deb3b55302196e5015af": {
      "type": "Ybodychange",
      "commitMessage": "Refactored the logging out of Verifier. Also fixed all gump errors.\n",
      "commitDate": 1029158302000,
      "commitName": "751257987b2ef5f301e2deb3b55302196e5015af",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1029154257000,
      "commitNameOld": "ecc852d48b9d26398926b255e3cd68572119c106",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n-                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n-                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "c682b5725d22afc38bf19d9667b23a7deab6d8c3": {
      "type": "Ybodychange",
      "commitMessage": "Major rework to support localized error messages. Inspired by patch 580410. At\nthe moment it is not possible to override the system locale, this probably\nshould be added.\n",
      "commitDate": 1028988900000,
      "commitName": "c682b5725d22afc38bf19d9667b23a7deab6d8c3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1025937329000,
      "commitNameOld": "7521f1897b007e3acc06ea3330df5124f4206589",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 35.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir \u003d mConfig.getBasedir();\n         if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n             stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n-        LineText[] errors;\n+        LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n-            errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n+            errors \u003d new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n-            errors \u003d new LineText[] {\n-                new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n+            errors \u003d new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n-            errors \u003d new LineText[] {\n-                new LineText(0,\n-                             \"Got a RecognitionException -\" + re.getMessage())};\n+            errors \u003d new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n-            errors \u003d new LineText[] {\n-                new LineText(0,\n-                             \"Got a TokenStreamException -\" + te.getMessage())};\n+            errors \u003d new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {te.getMessage()})};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "7521f1897b007e3acc06ea3330df5124f4206589": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug where reported file names were not correct when checkstyle.basedir ended with File.separator\n",
      "commitDate": 1025937329000,
      "commitName": "7521f1897b007e3acc06ea3330df5124f4206589",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1025640517000,
      "commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n-        if ((mConfig.getBasedir() \u003d\u003d null)\n-            || !aFileName.startsWith(mConfig.getBasedir()))\n-        {\n+        final String basedir \u003d mConfig.getBasedir();\n+        if ((basedir \u003d\u003d null) || !aFileName.startsWith(basedir)) {\n             stripped \u003d aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n-            stripped \u003d aFileName.substring(mConfig.getBasedir().length() + 1);\n+            final int skipSep \u003d basedir.endsWith(File.separator) ? 0 : 1;\n+            stripped \u003d aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "bbe51f6884ac0a961f55310e15ec90411709d970": {
      "type": "Ybodychange",
      "commitMessage": "571161: Added support for basedir attribute.\n",
      "commitDate": 1025488656000,
      "commitName": "bbe51f6884ac0a961f55310e15ec90411709d970",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1021438966000,
      "commitNameOld": "032b3801aa80bff181235ddd05244d07cc5f43f8",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 46.87,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,88 @@\n     private int process(String aFileName)\n     {\n+        // check if already checked and passed the file\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n+        // Create a stripped down version\n+        final String stripped;\n+        if ((mConfig.getBasedir() \u003d\u003d null)\n+            || !aFileName.startsWith(mConfig.getBasedir()))\n+        {\n+            stripped \u003d aFileName;\n+        }\n+        else {\n+            // making the assumption that there is text after basedir\n+            stripped \u003d aFileName.substring(mConfig.getBasedir().length() + 1);\n+        }\n+\n         LineText[] errors;\n         try {\n-            fireFileStarted(aFileName);\n+            fireFileStarted(stripped);\n             final String[] lines \u003d getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            fireErrors(aFileName, errors);\n+            fireErrors(stripped, errors);\n         }\n \n-        fireFileFinished(aFileName);\n+        fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "8f8879df46592e6e35658026c354b804ef328097": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug with the parser falling back when failing on assert\nstatements. Found with problems with imports.\n",
      "commitDate": 1020164209000,
      "commitName": "8f8879df46592e6e35658026c354b804ef328097",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1019718220000,
      "commitNameOld": "6970485b88600343de72af03a6bf87cf78e6cf55",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines \u003d getLines(aFileName);\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n-\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "190c0e5ca6cff056a136bc2c17f7678eb10686c7": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug introduced during cleanup of duplicate code:\nReader cannot be reused by fallback lexer, it would\nnever see the characters that have been consumed before\nthe RecognitionException in the first parsing attempt.\n\nAlso added comment why the JDK 1.4 grammar is tried first.\n",
      "commitDate": 1016569562000,
      "commitName": "190c0e5ca6cff056a136bc2c17f7678eb10686c7",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1016566509000,
      "commitNameOld": "dd476d336818a95e58163cd1c4f8cb00be239eae",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,74 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines \u003d getLines(aFileName);\n-            final Reader sar \u003d new StringArrayReader(lines);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             try {\n+                // try the 1.4 grammar first, this will succeed for\n+                // all code that compiles without any warnings in JDK 1.4,\n+                // that should cover most cases\n+\n+                final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n-                // filecontains \"assert\" statement. Retry with a\n+                // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n+                final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "b671e6bb1c0652cfc1ccd07355cac99df584eb2f": {
      "type": "Ybodychange",
      "commitMessage": "Removed some duplicate code, as I also feel the pain. I like the patch, but\nI question using the Java14 lexer/recognizer first. Is this because most of\nthe time it will succeed (especially with 1.4 source:-). Be great if a\ncomment could be added to the code.\n",
      "commitDate": 1016101246000,
      "commitName": "b671e6bb1c0652cfc1ccd07355cac99df584eb2f",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1016086749000,
      "commitNameOld": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,69 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines \u003d getLines(aFileName);\n+            final Reader sar \u003d new StringArrayReader(lines);\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n             try {\n-                VerifierSingleton.getInstance().clearMessages();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr \u003d\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n-\n                 // Parsing might have failed because the checked\n                 // filecontains \"assert\" statement. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n-\n-                VerifierSingleton.getInstance().clearMessages();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar \u003d new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr \u003d\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24": {
      "type": "Ybodychange",
      "commitMessage": "added support for jdk 1.4 assert statements\n\ngrammar changes inspired by John Pybus on the antlr-interest mailing list,\nsee http://groups.yahoo.com/group/antlr-interest/message/4968\n\nthe changes to Checker.java are not very clean, but I don\u0027t see a better\nsolution unless the ANTLR api is improved (compilationUnit() should be an\nabstract member of Parser, error reporting should be pluggable)\n",
      "commitDate": 1016086749000,
      "commitName": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1015361584000,
      "commitNameOld": "ec1e3e834918a32d63025d60175189b3437769d7",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 8.39,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,74 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines \u003d getLines(aFileName);\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar \u003d new StringArrayReader(lines);\n-            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n-            jl.setFilename(aFileName);\n-            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n-            jr.setFilename(aFileName);\n-            jr.setASTNodeClass(MyCommonAST.class.getName());\n-            jr.compilationUnit();\n+            try {\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n+                final Reader sar \u003d new StringArrayReader(lines);\n+                final GeneratedJava14Lexer jl \u003d new GeneratedJava14Lexer(sar);\n+                jl.setFilename(aFileName);\n+                final GeneratedJava14Recognizer jr \u003d\n+                    new SilentJava14Recognizer(jl);\n+                jr.setFilename(aFileName);\n+                jr.setASTNodeClass(MyCommonAST.class.getName());\n+                jr.compilationUnit();\n+            }\n+            catch (RecognitionException re) {\n+\n+                // Parsing might have failed because the checked\n+                // filecontains \"assert\" statement. Retry with a\n+                // grammar that treats \"assert\" as an identifier\n+                // and not as a keyword\n+\n+                // Arghh - the pain - duplicate code!\n+\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n+                final Reader sar \u003d new StringArrayReader(lines);\n+                final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n+                jl.setFilename(aFileName);\n+                final GeneratedJavaRecognizer jr \u003d\n+                    new GeneratedJavaRecognizer(jl);\n+                jr.setFilename(aFileName);\n+                jr.setASTNodeClass(MyCommonAST.class.getName());\n+                jr.compilationUnit();\n+            }\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "f8ea4c69a2228c5aca6c0b6e08a39a613d157708": {
      "type": "Ybodychange",
      "commitMessage": "Removed all evidence of the java.tree.g file.\n",
      "commitDate": 1010972022000,
      "commitName": "f8ea4c69a2228c5aca6c0b6e08a39a613d157708",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1010302836000,
      "commitNameOld": "edf2c95634cd0c657465723eb0dc2e6f1834eeba",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 7.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,51 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines \u003d getLines(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar \u003d new StringArrayReader(lines);\n-            final AST ast \u003d getAST(aFileName, sar);\n-            processAST(ast);\n+            final GeneratedJavaLexer jl \u003d new GeneratedJavaLexer(sar);\n+            jl.setFilename(aFileName);\n+            final GeneratedJavaRecognizer jr \u003d new GeneratedJavaRecognizer(jl);\n+            jr.setFilename(aFileName);\n+            jr.setASTNodeClass(MyCommonAST.class.getName());\n+            jr.compilationUnit();\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "030798a11d2d21330cbdddd159cdc1824492157a": {
      "type": "Ybodychange",
      "commitMessage": "incorporate performance patch\n",
      "commitDate": 1004532139000,
      "commitName": "030798a11d2d21330cbdddd159cdc1824492157a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 999188004000,
      "commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 61.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,47 @@\n     private int process(String aFileName)\n     {\n         final File f \u003d new File(aFileName);\n         final long timestamp \u003d f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n+            final String[] lines \u003d getLines(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(getLines(aFileName));\n-            final AST ast \u003d getAST(aFileName);\n+            VerifierSingleton.getInstance().setLines(lines);\n+            final Reader sar \u003d new StringArrayReader(lines);\n+            final AST ast \u003d getAST(aFileName, sar);\n             processAST(ast);\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length \u003d\u003d 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "started to incorporate logging events\n",
      "commitDate": 999188004000,
      "commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        "Ymodifierchange",
        "Ybodychange"
      ]
    },
    "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
      "type": "Ybodychange",
      "commitMessage": "added support for caching\n",
      "commitDate": 997020777000,
      "commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 993799300000,
      "commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 37.29,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,42 @@\n     int process(String aFileName)\n     {\n+        final long timestamp \u003d new File(aFileName).lastModified();\n+        if (mCache.alreadyChecked(aFileName, timestamp)) {\n+            return 0;\n+        }\n+\n         LineText[] errors;\n         try {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(getLines(aFileName));\n             final AST ast \u003d getAST(aFileName);\n             processAST(ast);\n             errors \u003d VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors \u003d new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors \u003d new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" +\n                              re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors \u003d new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n-        displayErrors(aFileName, errors);\n+        if (errors.length \u003d\u003d 0) {\n+            mCache.checkedOk(aFileName, timestamp);\n+        }\n+        else {\n+            displayErrors(aFileName, errors);\n+        }\n         return errors.length;\n     }\n\\ No newline at end of file\n"
    },
    "0fd69594a4c3e82f92f93f0371791da66938f8c3": {
      "type": "Yintroduced",
      "commitMessage": "first cut\n",
      "commitDate": 993216264000,
      "commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
      "commitAuthor": "Oliver Burn"
    }
  }
}