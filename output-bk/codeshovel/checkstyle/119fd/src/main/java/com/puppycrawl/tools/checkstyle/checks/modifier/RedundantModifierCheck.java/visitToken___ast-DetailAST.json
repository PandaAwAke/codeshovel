{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "RedundantModifierCheck.java",
  "functionName": "visitToken",
  "functionId": "visitToken___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java",
  "functionStartLine": 161,
  "functionEndLine": 188,
  "changeHistory": [
    "b1eced12b2be801d2f68de4e1f404e1c04b10ae8",
    "b415ce007ba73732ecfaa9ed7d4ec6dc65f4d354",
    "f66dcdbd9439aa413c6240287dadcc9ccf2c8ea3",
    "07b24dd81c7648f093f2a789a7fa288d8e7eeef4",
    "da6ebe6de41b7a5afc6f6746ff0c2382c2a4be0f",
    "4d6e2376db89b69167de867bfc28f8d8624a6b78",
    "2f7481ee4e20ae785298c31ec2f979752dd7eb03",
    "ce59d6abb3385213248b188f5b80f9e9a2ca3507",
    "e030d1463c307836bbb201a202d15e81a41bcb0b",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "0b98c0389e2cf745cb125a89dece57538fc672b7",
    "0fcae24380f86386ada6b2bb017c2ffe98ecb17e",
    "4ee80e78985574cd236662fef3266a3c4b24fea9",
    "0aab6d6243c3675a978940eebb1f18a9d633929f",
    "373c90a1090537de5b8151c6088534a63744edb2",
    "cf3879aa537cc597ac74aa762ba89b15883a4b39",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "70774706483eb0f9d04500cb64f4ce4c995b56f8",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
    "91db1968e34b4f777ab146e37a827c20b35e5c52",
    "c2d3932843e70e4bb5df7161800aca248f9af778",
    "bc66e150c2654deb6dcf1806b02e8f816e533d83",
    "6125beffc437f970eae276b4a6542265c6547784",
    "3ed2fd68f81f6200362f4babc9595b29f437ddd9",
    "4b2f2e628d9423efee0bb720ad88aa8ab30b07fa",
    "9a05522373905e39aa764009d1c543092c14f691",
    "84eddc36730c1eca845257201c71a0d1fb2d40cf",
    "85db5df9c1941b1c6046769baaace4d253834e3e"
  ],
  "changeHistoryShort": {
    "b1eced12b2be801d2f68de4e1f404e1c04b10ae8": "Ybodychange",
    "b415ce007ba73732ecfaa9ed7d4ec6dc65f4d354": "Ybodychange",
    "f66dcdbd9439aa413c6240287dadcc9ccf2c8ea3": "Ybodychange",
    "07b24dd81c7648f093f2a789a7fa288d8e7eeef4": "Ybodychange",
    "da6ebe6de41b7a5afc6f6746ff0c2382c2a4be0f": "Ybodychange",
    "4d6e2376db89b69167de867bfc28f8d8624a6b78": "Ybodychange",
    "2f7481ee4e20ae785298c31ec2f979752dd7eb03": "Ybodychange",
    "ce59d6abb3385213248b188f5b80f9e9a2ca3507": "Ybodychange",
    "e030d1463c307836bbb201a202d15e81a41bcb0b": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "0b98c0389e2cf745cb125a89dece57538fc672b7": "Ybodychange",
    "0fcae24380f86386ada6b2bb017c2ffe98ecb17e": "Ymultichange(Yparameterchange,Ybodychange)",
    "4ee80e78985574cd236662fef3266a3c4b24fea9": "Ybodychange",
    "0aab6d6243c3675a978940eebb1f18a9d633929f": "Ybodychange",
    "373c90a1090537de5b8151c6088534a63744edb2": "Ybodychange",
    "cf3879aa537cc597ac74aa762ba89b15883a4b39": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "70774706483eb0f9d04500cb64f4ce4c995b56f8": "Ybodychange",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": "Ybodychange",
    "91db1968e34b4f777ab146e37a827c20b35e5c52": "Ybodychange",
    "c2d3932843e70e4bb5df7161800aca248f9af778": "Ybodychange",
    "bc66e150c2654deb6dcf1806b02e8f816e533d83": "Yfilerename",
    "6125beffc437f970eae276b4a6542265c6547784": "Ybodychange",
    "3ed2fd68f81f6200362f4babc9595b29f437ddd9": "Ybodychange",
    "4b2f2e628d9423efee0bb720ad88aa8ab30b07fa": "Ybodychange",
    "9a05522373905e39aa764009d1c543092c14f691": "Ybodychange",
    "84eddc36730c1eca845257201c71a0d1fb2d40cf": "Ybodychange",
    "85db5df9c1941b1c6046769baaace4d253834e3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b1eced12b2be801d2f68de4e1f404e1c04b10ae8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3322: added RedundantModifiers for final in abstract methods",
      "commitDate": 1470314986000,
      "commitName": "b1eced12b2be801d2f68de4e1f404e1c04b10ae8",
      "commitAuthor": "rnveach",
      "commitDateOld": 1469589545000,
      "commitNameOld": "b415ce007ba73732ecfaa9ed7d4ec6dc65f4d354",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 8.4,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,28 @@\n     public void visitToken(DetailAST ast) {\n         if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n-        else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n-            if (isEnumMember(ast)) {\n-                checkEnumConstructorModifiers(ast);\n-            }\n-            else {\n-                checkClassConstructorModifiers(ast);\n-            }\n-        }\n         else if (ast.getType() \u003d\u003d TokenTypes.ENUM_DEF) {\n             checkEnumDef(ast);\n         }\n-        else if (isInterfaceOrAnnotationMember(ast)) {\n-            processInterfaceOrAnnotation(ast);\n-        }\n-        else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n-            processMethods(ast);\n-        }\n-        else if (ast.getType() \u003d\u003d TokenTypes.RESOURCE) {\n-            processResources(ast);\n+        else {\n+            if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n+                if (isEnumMember(ast)) {\n+                    checkEnumConstructorModifiers(ast);\n+                }\n+                else {\n+                    checkClassConstructorModifiers(ast);\n+                }\n+            }\n+            else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n+                processMethods(ast);\n+            }\n+            else if (ast.getType() \u003d\u003d TokenTypes.RESOURCE) {\n+                processResources(ast);\n+            }\n+\n+            if (isInterfaceOrAnnotationMember(ast)) {\n+                processInterfaceOrAnnotation(ast);\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "b415ce007ba73732ecfaa9ed7d4ec6dc65f4d354": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3323: added try-with-resources to RedundantModifierCheck",
      "commitDate": 1469589545000,
      "commitName": "b415ce007ba73732ecfaa9ed7d4ec6dc65f4d354",
      "commitAuthor": "rnveach",
      "commitDateOld": 1458221995000,
      "commitNameOld": "167dd96d8ca503a472bf003f187191d6b0ce586c",
      "commitAuthorOld": "Rasmus Kaj",
      "daysBetweenCommits": 131.57,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,25 @@\n     public void visitToken(DetailAST ast) {\n         if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n             if (isEnumMember(ast)) {\n                 checkEnumConstructorModifiers(ast);\n             }\n             else {\n                 checkClassConstructorModifiers(ast);\n             }\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.ENUM_DEF) {\n             checkEnumDef(ast);\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n+        else if (ast.getType() \u003d\u003d TokenTypes.RESOURCE) {\n+            processResources(ast);\n+        }\n     }\n\\ No newline at end of file\n"
    },
    "f66dcdbd9439aa413c6240287dadcc9ccf2c8ea3": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1530: Detect nested enums marked as static in RedundantModifier\ncheck",
      "commitDate": 1441287944000,
      "commitName": "f66dcdbd9439aa413c6240287dadcc9ccf2c8ea3",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": 1441045466000,
      "commitNameOld": "2b861bd6e16584e22bb115ff7abd65c35072eb92",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 2.81,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,22 @@\n     public void visitToken(DetailAST ast) {\n         if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n             if (isEnumMember(ast)) {\n                 checkEnumConstructorModifiers(ast);\n             }\n             else {\n                 checkClassConstructorModifiers(ast);\n             }\n         }\n+        else if (ast.getType() \u003d\u003d TokenTypes.ENUM_DEF) {\n+            checkEnumDef(ast);\n+        }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "07b24dd81c7648f093f2a789a7fa288d8e7eeef4": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Fix various typos\n\nFixes some `SpellCheckingInspection` inspection violations.\n\nDescription:\n\u003eSpellchecker inspection helps locate typos and misspelling in your code, comments and literals.\n",
      "commitDate": 1440827623000,
      "commitName": "07b24dd81c7648f093f2a789a7fa288d8e7eeef4",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1440784341000,
      "commitNameOld": "da6ebe6de41b7a5afc6f6746ff0c2382c2a4be0f",
      "commitAuthorOld": "liscju",
      "daysBetweenCommits": 0.5,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n     public void visitToken(DetailAST ast) {\n         if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n             if (isEnumMember(ast)) {\n                 checkEnumConstructorModifiers(ast);\n             }\n             else {\n-                checkClassContructorModifiers(ast);\n+                checkClassConstructorModifiers(ast);\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "da6ebe6de41b7a5afc6f6746ff0c2382c2a4be0f": {
      "type": "Ybodychange",
      "commitMessage": "Detect public constructors in non-public classes in RedundantModifier,\nfixes issue #1537\n",
      "commitDate": 1440784341000,
      "commitName": "da6ebe6de41b7a5afc6f6746ff0c2382c2a4be0f",
      "commitAuthor": "liscju",
      "commitDateOld": 1440040911000,
      "commitNameOld": "efa16e17bf710b7b24af828296c2337612912ba9",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,19 @@\n     public void visitToken(DetailAST ast) {\n         if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n-        else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF\n-                \u0026\u0026 isEnumMember(ast)) {\n-            checkEnumConstructorModifiers(ast);\n+        else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n+            if (isEnumMember(ast)) {\n+                checkEnumConstructorModifiers(ast);\n+            }\n+            else {\n+                checkClassContructorModifiers(ast);\n+            }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4d6e2376db89b69167de867bfc28f8d8624a6b78": {
      "type": "Ybodychange",
      "commitMessage": "Move constants to left side of comparison. #1555\n\nFixes `ConstantOnLHSOfComparison` inspection violations.\n\nDescription:\n\u003eReports on comparison operations with constant values on their left-hand side. Some coding conventions specify that constants should be on the right-hand side of comparisons.\n",
      "commitDate": 1439084780000,
      "commitName": "4d6e2376db89b69167de867bfc28f8d8624a6b78",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1438566537000,
      "commitNameOld": "1ce6badd8f1852081fee56fd6184ecfe8c128c69",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 6.0,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n     public void visitToken(DetailAST ast) {\n-        if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n+        if (ast.getType() \u003d\u003d TokenTypes.INTERFACE_DEF) {\n             checkInterfaceModifiers(ast);\n         }\n-        else if (TokenTypes.CTOR_DEF \u003d\u003d ast.getType()\n+        else if (ast.getType() \u003d\u003d TokenTypes.CTOR_DEF\n                 \u0026\u0026 isEnumMember(ast)) {\n             checkEnumConstructorModifiers(ast);\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2f7481ee4e20ae785298c31ec2f979752dd7eb03": {
      "type": "Ybodychange",
      "commitMessage": "Make RedundantModifier checks if enum constructor has redundant private\nmodifier, fixes part of #1242\n",
      "commitDate": 1437797642000,
      "commitName": "2f7481ee4e20ae785298c31ec2f979752dd7eb03",
      "commitAuthor": "liscju",
      "commitDateOld": 1436212430000,
      "commitNameOld": "ce59d6abb3385213248b188f5b80f9e9a2ca3507",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 18.35,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,15 @@\n     public void visitToken(DetailAST ast) {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n-            final DetailAST modifiers \u003d\n-                ast.findFirstToken(TokenTypes.MODIFIERS);\n-\n-            for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n-                final DetailAST modifier \u003d\n-                        modifiers.findFirstToken(tokenType);\n-                if (modifier !\u003d null) {\n-                    log(modifier.getLineNo(), modifier.getColumnNo(),\n-                            MSG_KEY, modifier.getText());\n-                }\n-            }\n+            checkInterfaceModifiers(ast);\n+        }\n+        else if (TokenTypes.CTOR_DEF \u003d\u003d ast.getType()\n+                \u0026\u0026 isEnumMember(ast)) {\n+            checkEnumConstructorModifiers(ast);\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "ce59d6abb3385213248b188f5b80f9e9a2ca3507": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1286: \u0027RedundantModifierCheck\u0027 was refactored, UT coverage improved\n",
      "commitDate": 1436212430000,
      "commitName": "ce59d6abb3385213248b188f5b80f9e9a2ca3507",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1434344165000,
      "commitNameOld": "e030d1463c307836bbb201a202d15e81a41bcb0b",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 21.62,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,21 @@\n     public void visitToken(DetailAST ast) {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n             final DetailAST modifiers \u003d\n                 ast.findFirstToken(TokenTypes.MODIFIERS);\n-            if (null !\u003d modifiers) {\n-                for (final int tokenType : new int[] {\n-                    TokenTypes.LITERAL_STATIC,\n-                    TokenTypes.ABSTRACT, }) {\n-                    final DetailAST modifier \u003d\n-                            modifiers.findFirstToken(tokenType);\n-                    if (null !\u003d modifier) {\n-                        log(modifier.getLineNo(), modifier.getColumnNo(),\n-                                MSG_KEY, modifier.getText());\n-                    }\n+\n+            for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n+                final DetailAST modifier \u003d\n+                        modifiers.findFirstToken(tokenType);\n+                if (modifier !\u003d null) {\n+                    log(modifier.getLineNo(), modifier.getColumnNo(),\n+                            MSG_KEY, modifier.getText());\n                 }\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "e030d1463c307836bbb201a202d15e81a41bcb0b": {
      "type": "Ybodychange",
      "commitMessage": "RedundantModifierCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434344165000,
      "commitName": "e030d1463c307836bbb201a202d15e81a41bcb0b",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431863229000,
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 28.71,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,24 @@\n     public void visitToken(DetailAST ast) {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n             final DetailAST modifiers \u003d\n                 ast.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, }) {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 MSG_KEY, modifier.getText());\n                     }\n                 }\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n-            final DetailAST modifiers \u003d ast.findFirstToken(TokenTypes.MODIFIERS);\n-            DetailAST modifier \u003d modifiers.getFirstChild();\n-            while (modifier !\u003d null) {\n-\n-                // javac does not allow final or static in interface methods\n-                // order annotation fields hence no need to check that this\n-                // is not a method or annotation field\n-\n-                final int type \u003d modifier.getType();\n-                if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n-                    || type \u003d\u003d TokenTypes.LITERAL_STATIC\n-                            \u0026\u0026 ast.getType() !\u003d TokenTypes.METHOD_DEF\n-                    || type \u003d\u003d TokenTypes.ABSTRACT\n-                    || type \u003d\u003d TokenTypes.FINAL) {\n-                    log(modifier.getLineNo(), modifier.getColumnNo(),\n-                            MSG_KEY, modifier.getText());\n-                    break;\n-                }\n-\n-                modifier \u003d modifier.getNextSibling();\n-            }\n+            processInterfaceOrAnnotation(ast);\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n-            final DetailAST modifiers \u003d\n-                            ast.findFirstToken(TokenTypes.MODIFIERS);\n-            // private method?\n-            boolean checkFinal \u003d\n-                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n-            // declared in a final class?\n-            DetailAST parent \u003d ast.getParent();\n-            while (parent !\u003d null) {\n-                if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n-                    final DetailAST classModifiers \u003d\n-                        parent.findFirstToken(TokenTypes.MODIFIERS);\n-                    checkFinal |\u003d\n-                        classModifiers.branchContains(TokenTypes.FINAL);\n-                    break;\n-                }\n-                parent \u003d parent.getParent();\n-            }\n-            if (checkFinal \u0026\u0026 !isAnnotatedWithSafeVarargs(ast)) {\n-                DetailAST modifier \u003d modifiers.getFirstChild();\n-                while (modifier !\u003d null) {\n-                    final int type \u003d modifier.getType();\n-                    if (type \u003d\u003d TokenTypes.FINAL) {\n-                        log(modifier.getLineNo(), modifier.getColumnNo(),\n-                                MSG_KEY, modifier.getText());\n-                        break;\n-                    }\n-                    modifier \u003d modifier.getNextSibling();\n-                }\n-            }\n+            processMethods(ast);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1424437366000,
      "commitNameOld": "0b98c0389e2cf745cb125a89dece57538fc672b7",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n     public void visitToken(DetailAST ast)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n             final DetailAST modifiers \u003d\n                 ast.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, })\n                 {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 MSG_KEY, modifier.getText());\n                     }\n                 }\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             final DetailAST modifiers \u003d ast.findFirstToken(TokenTypes.MODIFIERS);\n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n-                if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n-                    || ((type \u003d\u003d TokenTypes.LITERAL_STATIC)\n-                            \u0026\u0026 ast.getType() !\u003d TokenTypes.METHOD_DEF)\n-                    || (type \u003d\u003d TokenTypes.ABSTRACT)\n-                    || (type \u003d\u003d TokenTypes.FINAL))\n+                if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n+                    || type \u003d\u003d TokenTypes.LITERAL_STATIC\n+                            \u0026\u0026 ast.getType() !\u003d TokenTypes.METHOD_DEF\n+                    || type \u003d\u003d TokenTypes.ABSTRACT\n+                    || type \u003d\u003d TokenTypes.FINAL)\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             MSG_KEY, modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             ast.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d ast.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal \u0026\u0026 !isAnnotatedWithSafeVarargs(ast)) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 MSG_KEY, modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "0b98c0389e2cf745cb125a89dece57538fc672b7": {
      "type": "Ybodychange",
      "commitMessage": "Refactored UTs, modifier package, issue #537\n",
      "commitDate": 1424437366000,
      "commitName": "0b98c0389e2cf745cb125a89dece57538fc672b7",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1424294072000,
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n     public void visitToken(DetailAST ast)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d ast.getType()) {\n             final DetailAST modifiers \u003d\n                 ast.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, })\n                 {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n-                                \"redundantModifier\", modifier.getText());\n+                                MSG_KEY, modifier.getText());\n                     }\n                 }\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(ast)) {\n             final DetailAST modifiers \u003d ast.findFirstToken(TokenTypes.MODIFIERS);\n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || ((type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                             \u0026\u0026 ast.getType() !\u003d TokenTypes.METHOD_DEF)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n-                            \"redundantModifier\", modifier.getText());\n+                            MSG_KEY, modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             ast.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d ast.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal \u0026\u0026 !isAnnotatedWithSafeVarargs(ast)) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n-                                \"redundantModifier\", modifier.getText());\n+                                MSG_KEY, modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "0fcae24380f86386ada6b2bb017c2ffe98ecb17e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, modifier, #512\n",
      "commitDate": 1421678144000,
      "commitName": "0fcae24380f86386ada6b2bb017c2ffe98ecb17e",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "4ee80e78985574cd236662fef3266a3c4b24fea9": {
      "type": "Ybodychange",
      "commitMessage": "Redundant Modifier Check, fixed false-positive Redundant modifier final error for @SafeVarargs method issue #301\n",
      "commitDate": 1418556472000,
      "commitName": "4ee80e78985574cd236662fef3266a3c4b24fea9",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1418104131000,
      "commitNameOld": "0aab6d6243c3675a978940eebb1f18a9d633929f",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 5.24,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d aAST.getType()) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, })\n                 {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                     }\n                 }\n             }\n         }\n         else if (isInterfaceOrAnnotationMember(aAST)) {\n             final DetailAST modifiers \u003d aAST.findFirstToken(TokenTypes.MODIFIERS);\n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || ((type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                             \u0026\u0026 aAST.getType() !\u003d TokenTypes.METHOD_DEF)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n-            if (checkFinal) {\n+            if (checkFinal \u0026\u0026 !isAnnotatedWithSafeVarargs(aAST)) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "0aab6d6243c3675a978940eebb1f18a9d633929f": {
      "type": "Ybodychange",
      "commitMessage": "Redundant Modifier Check fixed bug with warning on final variables in default methods issue #364\n",
      "commitDate": 1418104131000,
      "commitName": "0aab6d6243c3675a978940eebb1f18a9d633929f",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1412964919000,
      "commitNameOld": "373c90a1090537de5b8151c6088534a63744edb2",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 59.48,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,75 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d aAST.getType()) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, })\n                 {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                     }\n                 }\n             }\n         }\n-        else if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n-            final DetailAST modifiers \u003d\n-                aAST.findFirstToken(TokenTypes.MODIFIERS);\n-\n+        else if (isInterfaceOrAnnotationMember(aAST)) {\n+            final DetailAST modifiers \u003d aAST.findFirstToken(TokenTypes.MODIFIERS);\n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || ((type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                             \u0026\u0026 aAST.getType() !\u003d TokenTypes.METHOD_DEF)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "373c90a1090537de5b8151c6088534a63744edb2": {
      "type": "Ybodychange",
      "commitMessage": "#282 fixed. Since Java 8 we can have methods body in interfaces.\n",
      "commitDate": 1412964919000,
      "commitName": "373c90a1090537de5b8151c6088534a63744edb2",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": 1410559976000,
      "commitNameOld": "cf3879aa537cc597ac74aa762ba89b15883a4b39",
      "commitAuthorOld": "ychulovskyy",
      "daysBetweenCommits": 27.83,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,77 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d aAST.getType()) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n                 for (final int tokenType : new int[] {\n                     TokenTypes.LITERAL_STATIC,\n                     TokenTypes.ABSTRACT, })\n                 {\n                     final DetailAST modifier \u003d\n                             modifiers.findFirstToken(tokenType);\n                     if (null !\u003d modifier) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                     }\n                 }\n             }\n         }\n         else if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n+                    || ((type \u003d\u003d TokenTypes.LITERAL_STATIC)\n+                            \u0026\u0026 aAST.getType() !\u003d TokenTypes.METHOD_DEF)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n-                    || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "cf3879aa537cc597ac74aa762ba89b15883a4b39": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue #29 Abstract Interface Should not be Allowed in RedundantModifier\n",
      "commitDate": 1410559976000,
      "commitName": "cf3879aa537cc597ac74aa762ba89b15883a4b39",
      "commitAuthor": "ychulovskyy",
      "commitDateOld": 1393953491000,
      "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthorOld": "Ivan Sopov",
      "daysBetweenCommits": 192.2,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,76 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (TokenTypes.INTERFACE_DEF \u003d\u003d aAST.getType()) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n             if (null !\u003d modifiers) {\n-                final DetailAST modifier \u003d\n-                    modifiers.findFirstToken(TokenTypes.LITERAL_STATIC);\n-                if (null !\u003d modifier) {\n-                    log(modifier.getLineNo(), modifier.getColumnNo(),\n-                        \"redundantModifier\", modifier.getText());\n+                for (final int tokenType : new int[] {\n+                    TokenTypes.LITERAL_STATIC,\n+                    TokenTypes.ABSTRACT, })\n+                {\n+                    final DetailAST modifier \u003d\n+                            modifiers.findFirstToken(tokenType);\n+                    if (null !\u003d modifier) {\n+                        log(modifier.getLineNo(), modifier.getColumnNo(),\n+                                \"redundantModifier\", modifier.getText());\n+                    }\n                 }\n             }\n         }\n         else if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "70774706483eb0f9d04500cb64f4ce4c995b56f8": {
      "type": "Ybodychange",
      "commitMessage": "Enhanced RedundantModifier to support detecting inner interface declarations that are declared as static. Raised in bug #3222810.\n",
      "commitDate": 1301626838000,
      "commitName": "70774706483eb0f9d04500cb64f4ce4c995b56f8",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1266029835000,
      "commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 412.0,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,71 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n+        if (TokenTypes.INTERFACE_DEF \u003d\u003d aAST.getType()) {\n+            final DetailAST modifiers \u003d\n+                aAST.findFirstToken(TokenTypes.MODIFIERS);\n+            if (null !\u003d modifiers) {\n+                final DetailAST modifier \u003d\n+                    modifiers.findFirstToken(TokenTypes.LITERAL_STATIC);\n+                if (null !\u003d modifier) {\n+                    log(modifier.getLineNo(), modifier.getColumnNo(),\n+                        \"redundantModifier\", modifier.getText());\n+                }\n+            }\n+        }\n+        else if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": {
      "type": "Ybodychange",
      "commitMessage": "Inspired by patch# 2111354 - changes to remove casting. Neat trick\n",
      "commitDate": 1221737656000,
      "commitName": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1200296548000,
      "commitNameOld": "fd90bd5aa5cd623b08a2e44ef05e8fac8045d333",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 248.16,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n-            DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n+            DetailAST modifier \u003d modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(), modifier.getColumnNo(),\n                             \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n-                modifier \u003d (DetailAST) modifier.getNextSibling();\n+                modifier \u003d modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n-                DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n+                DetailAST modifier \u003d modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(), modifier.getColumnNo(),\n                                 \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n-                    modifier \u003d (DetailAST) modifier.getNextSibling();\n+                    modifier \u003d modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "91db1968e34b4f777ab146e37a827c20b35e5c52": {
      "type": "Ybodychange",
      "commitMessage": "Using varargs for logging.\n",
      "commitDate": 1198147874000,
      "commitName": "91db1968e34b4f777ab146e37a827c20b35e5c52",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1198131671000,
      "commitNameOld": "f38d8abd42c3e824635e542e6031b3da1997c02e",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,59 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n                     || (type \u003d\u003d TokenTypes.ABSTRACT)\n                     || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n                     || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n-                    log(modifier.getLineNo(),\n-                        modifier.getColumnNo(),\n-                        \"redundantModifier\",\n-                        new String[] {modifier.getText()});\n+                    log(modifier.getLineNo(), modifier.getColumnNo(),\n+                            \"redundantModifier\", modifier.getText());\n                     break;\n                 }\n \n                 modifier \u003d (DetailAST) modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n-                        log(modifier.getLineNo(),\n-                            modifier.getColumnNo(),\n-                            \"redundantModifier\",\n-                            new String[] {modifier.getText()});\n+                        log(modifier.getLineNo(), modifier.getColumnNo(),\n+                                \"redundantModifier\", modifier.getText());\n                         break;\n                     }\n                     modifier \u003d (DetailAST) modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "c2d3932843e70e4bb5df7161800aca248f9af778": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the use of ()\u0027s\n",
      "commitDate": 1152242806000,
      "commitName": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1130786628000,
      "commitNameOld": "1aee9d55cc5bd8cca011e17369f6e370efcc85bb",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 248.34,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n     public void visitToken(DetailAST aAST)\n     {\n         if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n                 // order annotation fields hence no need to check that this\n                 // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n-                if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n-                    || type \u003d\u003d TokenTypes.ABSTRACT\n-                    || type \u003d\u003d TokenTypes.LITERAL_STATIC\n-                    || type \u003d\u003d TokenTypes.FINAL)\n+                if ((type \u003d\u003d TokenTypes.LITERAL_PUBLIC)\n+                    || (type \u003d\u003d TokenTypes.ABSTRACT)\n+                    || (type \u003d\u003d TokenTypes.LITERAL_STATIC)\n+                    || (type \u003d\u003d TokenTypes.FINAL))\n                 {\n                     log(modifier.getLineNo(),\n                         modifier.getColumnNo(),\n                         \"redundantModifier\",\n                         new String[] {modifier.getText()});\n                     break;\n                 }\n \n                 modifier \u003d (DetailAST) modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(),\n                             modifier.getColumnNo(),\n                             \"redundantModifier\",\n                             new String[] {modifier.getText()});\n                         break;\n                     }\n                     modifier \u003d (DetailAST) modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "bc66e150c2654deb6dcf1806b02e8f816e533d83": {
      "type": "Yfilerename",
      "commitMessage": "All these changes are because I wanted to fix a small documentation\nbug. Ended up having to move the RedundantModifierCheck around.\n",
      "commitDate": 1111580108000,
      "commitName": "bc66e150c2654deb6dcf1806b02e8f816e533d83",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1111411700000,
      "commitNameOld": "6602b4c4612bde592d04560bfb778561291974d7",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.95,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "6125beffc437f970eae276b4a6542265c6547784": {
      "type": "Ybodychange",
      "commitMessage": "Initial Java 1.5 support\n",
      "commitDate": 1096311350000,
      "commitName": "6125beffc437f970eae276b4a6542265c6547784",
      "commitAuthor": "Michael Studman",
      "commitDateOld": 1074114639000,
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 256.91,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        if (ScopeUtils.inInterfaceBlock(aAST)) {\n+        if (ScopeUtils.inInterfaceOrAnnotationBlock(aAST)) {\n             final DetailAST modifiers \u003d\n                 aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n             DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n             while (modifier !\u003d null) {\n \n                 // javac does not allow final or static in interface methods\n-                // hence no need to check that this is not a method\n+                // order annotation fields hence no need to check that this\n+                // is not a method or annotation field\n \n                 final int type \u003d modifier.getType();\n                 if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n                     || type \u003d\u003d TokenTypes.ABSTRACT\n                     || type \u003d\u003d TokenTypes.LITERAL_STATIC\n                     || type \u003d\u003d TokenTypes.FINAL)\n                 {\n                     log(modifier.getLineNo(),\n                         modifier.getColumnNo(),\n                         \"redundantModifier\",\n                         new String[] {modifier.getText()});\n                     break;\n                 }\n \n                 modifier \u003d (DetailAST) modifier.getNextSibling();\n             }\n         }\n         else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n             final DetailAST modifiers \u003d\n                             aAST.findFirstToken(TokenTypes.MODIFIERS);\n             // private method?\n             boolean checkFinal \u003d\n                 modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n             // declared in a final class?\n             DetailAST parent \u003d aAST.getParent();\n             while (parent !\u003d null) {\n                 if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n                     final DetailAST classModifiers \u003d\n                         parent.findFirstToken(TokenTypes.MODIFIERS);\n                     checkFinal |\u003d\n                         classModifiers.branchContains(TokenTypes.FINAL);\n                     break;\n                 }\n                 parent \u003d parent.getParent();\n             }\n             if (checkFinal) {\n                 DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n                 while (modifier !\u003d null) {\n                     final int type \u003d modifier.getType();\n                     if (type \u003d\u003d TokenTypes.FINAL) {\n                         log(modifier.getLineNo(),\n                             modifier.getColumnNo(),\n                             \"redundantModifier\",\n                             new String[] {modifier.getText()});\n                         break;\n                     }\n                     modifier \u003d (DetailAST) modifier.getNextSibling();\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "3ed2fd68f81f6200362f4babc9595b29f437ddd9": {
      "type": "Ybodychange",
      "commitMessage": "Enhanced RedundantModifier to check that all private methods and all methods in a\n          final class do not contain modifier final (discussed in request 775011)\n",
      "commitDate": 1058814313000,
      "commitName": "3ed2fd68f81f6200362f4babc9595b29f437ddd9",
      "commitAuthor": "Rick Giles",
      "commitDateOld": 1055144900000,
      "commitNameOld": "889587fdd22ba03ea670e404d36810e9af113c9d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 42.47,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,62 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        if (!ScopeUtils.inInterfaceBlock(aAST)) {\n-            return;\n-        }\n+        if (ScopeUtils.inInterfaceBlock(aAST)) {\n+            final DetailAST modifiers \u003d\n+                aAST.findFirstToken(TokenTypes.MODIFIERS);\n \n-        DetailAST modifiers \u003d aAST.findFirstToken(TokenTypes.MODIFIERS);\n+            DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n+            while (modifier !\u003d null) {\n \n-        DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n-        while (modifier !\u003d null) {\n+                // javac does not allow final or static in interface methods\n+                // hence no need to check that this is not a method\n \n-            // javac does not allow final or static in interface methods\n-            // hence no need to check that this is not a method\n+                final int type \u003d modifier.getType();\n+                if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n+                    || type \u003d\u003d TokenTypes.ABSTRACT\n+                    || type \u003d\u003d TokenTypes.LITERAL_STATIC\n+                    || type \u003d\u003d TokenTypes.FINAL)\n+                {\n+                    log(modifier.getLineNo(),\n+                        modifier.getColumnNo(),\n+                        \"redundantModifier\",\n+                        new String[] {modifier.getText()});\n+                    break;\n+                }\n \n-            final int type \u003d modifier.getType();\n-            if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n-                || type \u003d\u003d TokenTypes.ABSTRACT\n-                || type \u003d\u003d TokenTypes.LITERAL_STATIC\n-                || type \u003d\u003d TokenTypes.FINAL)\n-            {\n-                log(modifier.getLineNo(),\n-                    modifier.getColumnNo(),\n-                    \"redundantModifier\",\n-                    new String[] {modifier.getText()});\n-                break;\n+                modifier \u003d (DetailAST) modifier.getNextSibling();\n             }\n-\n-            modifier \u003d (DetailAST) modifier.getNextSibling();\n+        }\n+        else if (aAST.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n+            final DetailAST modifiers \u003d\n+                            aAST.findFirstToken(TokenTypes.MODIFIERS);\n+            // private method?\n+            boolean checkFinal \u003d\n+                modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n+            // declared in a final class?\n+            DetailAST parent \u003d aAST.getParent();\n+            while (parent !\u003d null) {\n+                if (parent.getType() \u003d\u003d TokenTypes.CLASS_DEF) {\n+                    final DetailAST classModifiers \u003d\n+                        parent.findFirstToken(TokenTypes.MODIFIERS);\n+                    checkFinal |\u003d\n+                        classModifiers.branchContains(TokenTypes.FINAL);\n+                    break;\n+                }\n+                parent \u003d parent.getParent();\n+            }\n+            if (checkFinal) {\n+                DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n+                while (modifier !\u003d null) {\n+                    final int type \u003d modifier.getType();\n+                    if (type \u003d\u003d TokenTypes.FINAL) {\n+                        log(modifier.getLineNo(),\n+                            modifier.getColumnNo(),\n+                            \"redundantModifier\",\n+                            new String[] {modifier.getText()});\n+                        break;\n+                    }\n+                    modifier \u003d (DetailAST) modifier.getNextSibling();\n+                }\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "4b2f2e628d9423efee0bb720ad88aa8ab30b07fa": {
      "type": "Ybodychange",
      "commitMessage": "changed RedundantModifierCheck to allow token configuration and to simplify implementation\n",
      "commitDate": 1042963273000,
      "commitName": "4b2f2e628d9423efee0bb720ad88aa8ab30b07fa",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1041160558000,
      "commitNameOld": "9a05522373905e39aa764009d1c543092c14f691",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 20.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,30 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        switch (aAST.getType()) {\n-        case TokenTypes.INTERFACE_DEF:\n-            mInInterface.push(Boolean.TRUE);\n-            break;\n-        case TokenTypes.CLASS_DEF:\n-            mInInterface.push(Boolean.FALSE);\n-            break;\n-        case TokenTypes.MODIFIERS:\n-\n-            // modifiers of the interface itself (public interface X)\n-            // will be below the INTERFACE_DEF node. Example:\n-\n-            // public interface X {void y();}\n-\n-            // INTERFACE_DEF\n-            // + MODIFIERS\n-            //   + public\n-            // + OBJ_BLOCK\n-            //   + ...\n-\n-            if (inInterfaceBlock(aAST)) {\n-                DetailAST ast \u003d (DetailAST) aAST.getFirstChild();\n-                while (ast !\u003d null) {\n-\n-                    // javac does not allow final in interface methods\n-                    // hence no need to check that this is not a method\n-\n-                    final int type \u003d ast.getType();\n-                    if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n-                            || type \u003d\u003d TokenTypes.ABSTRACT\n-                            || type \u003d\u003d TokenTypes.FINAL)\n-                    {\n-                            String modifier \u003d ast.getText();\n-                            log(ast.getLineNo(),\n-                                    ast.getColumnNo(),\n-                                    \"redundantModifier\",\n-                                    new String[] {modifier});\n-                            break;\n-                    }\n-\n-                    ast \u003d (DetailAST) ast.getNextSibling();\n-                }\n-            }\n-            break;\n-        default:\n+        if (!ScopeUtils.inInterfaceBlock(aAST)) {\n             return;\n         }\n+\n+        DetailAST modifiers \u003d aAST.findFirstToken(TokenTypes.MODIFIERS);\n+\n+        DetailAST modifier \u003d (DetailAST) modifiers.getFirstChild();\n+        while (modifier !\u003d null) {\n+\n+            // javac does not allow final or static in interface methods\n+            // hence no need to check that this is not a method\n+\n+            final int type \u003d modifier.getType();\n+            if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n+                || type \u003d\u003d TokenTypes.ABSTRACT\n+                || type \u003d\u003d TokenTypes.LITERAL_STATIC\n+                || type \u003d\u003d TokenTypes.FINAL)\n+            {\n+                log(modifier.getLineNo(),\n+                    modifier.getColumnNo(),\n+                    \"redundantModifier\",\n+                    new String[] {modifier.getText()});\n+                break;\n+            }\n+\n+            modifier \u003d (DetailAST) modifier.getNextSibling();\n+        }\n     }\n\\ No newline at end of file\n"
    },
    "9a05522373905e39aa764009d1c543092c14f691": {
      "type": "Ybodychange",
      "commitMessage": "response to rfe #651121, Redundant field modifiers in interface:\nadded final to list of redundant modifiers\nimproved tests RedundantModifierTest to cover constants\n",
      "commitDate": 1041160558000,
      "commitName": "9a05522373905e39aa764009d1c543092c14f691",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1040238290000,
      "commitNameOld": "65d0c68b6c0048eb4a8a637573ddc532752ef34a",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 10.67,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,50 @@\n     public void visitToken(DetailAST aAST)\n     {\n         switch (aAST.getType()) {\n         case TokenTypes.INTERFACE_DEF:\n             mInInterface.push(Boolean.TRUE);\n             break;\n         case TokenTypes.CLASS_DEF:\n             mInInterface.push(Boolean.FALSE);\n             break;\n         case TokenTypes.MODIFIERS:\n \n             // modifiers of the interface itself (public interface X)\n             // will be below the INTERFACE_DEF node. Example:\n \n             // public interface X {void y();}\n \n             // INTERFACE_DEF\n             // + MODIFIERS\n             //   + public\n             // + OBJ_BLOCK\n             //   + ...\n \n             if (inInterfaceBlock(aAST)) {\n                 DetailAST ast \u003d (DetailAST) aAST.getFirstChild();\n                 while (ast !\u003d null) {\n-                    String modifier \u003d ast.getText();\n-                    if (\"public\".equals(modifier)\n-                        || \"abstract\".equals(modifier))\n+\n+                    // javac does not allow final in interface methods\n+                    // hence no need to check that this is not a method\n+\n+                    final int type \u003d ast.getType();\n+                    if (type \u003d\u003d TokenTypes.LITERAL_PUBLIC\n+                            || type \u003d\u003d TokenTypes.ABSTRACT\n+                            || type \u003d\u003d TokenTypes.FINAL)\n                     {\n-                        log(ast.getLineNo(),\n-                            ast.getColumnNo(),\n-                            \"redundantModifier\",\n-                            new String[] {modifier});\n+                            String modifier \u003d ast.getText();\n+                            log(ast.getLineNo(),\n+                                    ast.getColumnNo(),\n+                                    \"redundantModifier\",\n+                                    new String[] {modifier});\n+                            break;\n                     }\n+\n                     ast \u003d (DetailAST) ast.getNextSibling();\n                 }\n             }\n             break;\n         default:\n             return;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "84eddc36730c1eca845257201c71a0d1fb2d40cf": {
      "type": "Ybodychange",
      "commitMessage": "Added a new class TokenTypes that contains all the type constants. This class\nbreaks the circular dependencies - the cost is needing to maintain this class\nwhen a new grammar is introduced.\n",
      "commitDate": 1035008886000,
      "commitName": "84eddc36730c1eca845257201c71a0d1fb2d40cf",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1034552460000,
      "commitNameOld": "63664e0b012593e18c5bb93ba528f27fd93fe0d4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.28,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     public void visitToken(DetailAST aAST)\n     {\n         switch (aAST.getType()) {\n-        case INTERFACE_DEF:\n+        case TokenTypes.INTERFACE_DEF:\n             mInInterface.push(Boolean.TRUE);\n             break;\n-        case CLASS_DEF:\n+        case TokenTypes.CLASS_DEF:\n             mInInterface.push(Boolean.FALSE);\n             break;\n-        case MODIFIERS:\n+        case TokenTypes.MODIFIERS:\n \n             // modifiers of the interface itself (public interface X)\n             // will be below the INTERFACE_DEF node. Example:\n \n             // public interface X {void y();}\n \n             // INTERFACE_DEF\n             // + MODUFIERS\n             //   + public\n             // + OBJ_BLOCK\n             //   + ...\n \n             if (inInterfaceBlock(aAST)) {\n                 DetailAST ast \u003d (DetailAST) aAST.getFirstChild();\n                 while (ast !\u003d null) {\n                     String modifier \u003d ast.getText();\n                     if (\"public\".equals(modifier)\n                         || \"abstract\".equals(modifier))\n                     {\n                         log(ast.getLineNo(),\n                             ast.getColumnNo(),\n                             \"redundantModifier\",\n                             new String[] {modifier});\n                     }\n                     ast \u003d (DetailAST) ast.getNextSibling();\n                 }\n             }\n             break;\n         default:\n             return;\n         }\n     }\n\\ No newline at end of file\n"
    },
    "85db5df9c1941b1c6046769baaace4d253834e3e": {
      "type": "Yintroduced",
      "commitMessage": "check for redundant modifier\n",
      "commitDate": 1032760565000,
      "commitName": "85db5df9c1941b1c6046769baaace4d253834e3e",
      "commitAuthor": "Lars Kühne"
    }
  }
}