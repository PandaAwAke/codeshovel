{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "IllegalInstantiationCheck.java",
  "functionName": "getIllegalInstantiation",
  "functionId": "getIllegalInstantiation___className-String",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
  "functionStartLine": 222,
  "functionEndLine": 253,
  "changeHistory": [
    "327c0bc843612486ab4ded32a2f01038e1271fd0",
    "46378dadb508320f14737a44c75a832dc5c8120c",
    "23c8774d2e2fd245de1e5df02758fd23702c565e",
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5",
    "d64bdf0caa867be3913f2665ef4fcc654524937e",
    "dba746ba9387bee04ed362254abb5d9ed35169cd",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "08638b5f739d9929698860048c052da2d5f80209",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "c2d3932843e70e4bb5df7161800aca248f9af778",
    "5d7063c660b241bce251f1a8c89394619f2791fb",
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8",
    "9920857810ecc9efdbca19e2749b75abc0cbbf14",
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3"
  ],
  "changeHistoryShort": {
    "327c0bc843612486ab4ded32a2f01038e1271fd0": "Ybodychange",
    "46378dadb508320f14737a44c75a832dc5c8120c": "Ybodychange",
    "23c8774d2e2fd245de1e5df02758fd23702c565e": "Ybodychange",
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5": "Ybodychange",
    "d64bdf0caa867be3913f2665ef4fcc654524937e": "Ybodychange",
    "dba746ba9387bee04ed362254abb5d9ed35169cd": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "08638b5f739d9929698860048c052da2d5f80209": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "c2d3932843e70e4bb5df7161800aca248f9af778": "Ybodychange",
    "5d7063c660b241bce251f1a8c89394619f2791fb": "Ybodychange",
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8": "Ybodychange",
    "9920857810ecc9efdbca19e2749b75abc0cbbf14": "Yfilerename",
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866": "Ybodychange",
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "327c0bc843612486ab4ded32a2f01038e1271fd0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3254: UT to verify all property types and values in XDocs",
      "commitDate": 1515029424000,
      "commitName": "327c0bc843612486ab4ded32a2f01038e1271fd0",
      "commitAuthor": "rnveach",
      "commitDateOld": 1514928265000,
      "commitNameOld": "dabb75d43c7e02317565dde4c5e60f380d3b16b8",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private String getIllegalInstantiation(String className) {\n         String fullClassName \u003d null;\n \n-        if (illegalClasses.contains(className)) {\n+        if (classes.contains(className)) {\n             fullClassName \u003d className;\n         }\n         else {\n             final int pkgNameLen;\n \n             if (pkgName \u003d\u003d null) {\n                 pkgNameLen \u003d 0;\n             }\n             else {\n                 pkgNameLen \u003d pkgName.length();\n             }\n \n-            for (String illegal : illegalClasses) {\n+            for (String illegal : classes) {\n                 if (isStandardClass(className, illegal)\n                         || isSamePackage(className, pkgNameLen, illegal)) {\n                     fullClassName \u003d illegal;\n                 }\n                 else {\n                     fullClassName \u003d checkImportStatements(className);\n                 }\n \n                 if (fullClassName !\u003d null) {\n                     break;\n                 }\n             }\n         }\n         return fullClassName;\n     }\n\\ No newline at end of file\n"
    },
    "46378dadb508320f14737a44c75a832dc5c8120c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: ReturnCount violation fixed for IllegalInstantiationCheck\n",
      "commitDate": 1440740265000,
      "commitName": "46378dadb508320f14737a44c75a832dc5c8120c",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1440739752000,
      "commitNameOld": "cc7aeaec906dc3c864477e3050510009b2a946ee",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,32 @@\n     private String getIllegalInstantiation(String className) {\n-        if (illegalClasses.contains(className)) {\n-            return className;\n-        }\n-        final int pkgNameLen;\n+        String fullClassName \u003d null;\n \n-        if (pkgName \u003d\u003d null) {\n-            pkgNameLen \u003d 0;\n+        if (illegalClasses.contains(className)) {\n+            fullClassName \u003d className;\n         }\n         else {\n-            pkgNameLen \u003d pkgName.length();\n-        }\n+            final int pkgNameLen;\n \n-        for (String illegal : illegalClasses) {\n+            if (pkgName \u003d\u003d null) {\n+                pkgNameLen \u003d 0;\n+            }\n+            else {\n+                pkgNameLen \u003d pkgName.length();\n+            }\n \n-            if (isStandardClass(className, illegal)) {\n-                return illegal;\n-            }\n-            if (isSamePackage(className, pkgNameLen, illegal)) {\n-                return illegal;\n-            }\n-            final String importArg \u003d checkImportStatements(className);\n-            if (importArg !\u003d null) {\n-                return importArg;\n+            for (String illegal : illegalClasses) {\n+                if (isStandardClass(className, illegal)\n+                        || isSamePackage(className, pkgNameLen, illegal)) {\n+                    fullClassName \u003d illegal;\n+                }\n+                else {\n+                    fullClassName \u003d checkImportStatements(className);\n+                }\n+\n+                if (fullClassName !\u003d null) {\n+                    break;\n+                }\n             }\n         }\n-        return null;\n+        return fullClassName;\n     }\n\\ No newline at end of file\n"
    },
    "23c8774d2e2fd245de1e5df02758fd23702c565e": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: AvoidInlineConditional violations fixed\n",
      "commitDate": 1439784080000,
      "commitName": "23c8774d2e2fd245de1e5df02758fd23702c565e",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": 1439356761000,
      "commitNameOld": "3bd699bd593414d63c7139aa410f13ec8341a027",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,28 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n+        final int pkgNameLen;\n \n-        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n+        if (pkgName \u003d\u003d null) {\n+            pkgNameLen \u003d 0;\n+        }\n+        else {\n+            pkgNameLen \u003d pkgName.length();\n+        }\n \n         for (String illegal : illegalClasses) {\n \n             if (isStandardClass(className, illegal)) {\n                 return illegal;\n             }\n             if (isSamePackage(className, pkgNameLen, illegal)) {\n                 return illegal;\n             }\n             final String importArg \u003d checkImportStatements(className);\n             if (importArg !\u003d null) {\n                 return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1293: Improved coverage for IllegalInstantiationCheck\n",
      "commitDate": 1439087559000,
      "commitName": "16ae5032c5e25ad35475c9a0f2de578ea6e640e5",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1439011061000,
      "commitNameOld": "4fd298b00126d60147dce7631c6e0d3e0921f82f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,22 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n-        final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n \n-            final int illegalLen \u003d illegal.length();\n-            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {\n+            if (isStandardClass(className, illegal)) {\n                 return illegal;\n             }\n-            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {\n+            if (isSamePackage(className, pkgNameLen, illegal)) {\n                 return illegal;\n             }\n             final String importArg \u003d checkImportStatements(className);\n             if (importArg !\u003d null) {\n                 return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "d64bdf0caa867be3913f2665ef4fcc654524937e": {
      "type": "Ybodychange",
      "commitMessage": "IllegalInstantiationCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434261690000,
      "commitName": "d64bdf0caa867be3913f2665ef4fcc654524937e",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431863229000,
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,24 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n+\n             final int illegalLen \u003d illegal.length();\n-\n-            // class from java.lang\n-            if (illegalLen - JAVA_LANG.length() \u003d\u003d clsNameLen\n-                \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(JAVA_LANG)) {\n-                // java.lang needs no import, but a class without import might\n-                // also come from the same file or be in the same package.\n-                // E.g. if a class defines an inner class \"Boolean\",\n-                // the expression \"new Boolean()\" refers to that class,\n-                // not to java.lang.Boolean\n-\n-                final boolean isSameFile \u003d classNames.contains(className);\n-\n-                boolean isSamePackage \u003d false;\n-                try {\n-                    final ClassLoader classLoader \u003d getClassLoader();\n-                    if (classLoader !\u003d null) {\n-                        final String fqName \u003d pkgName + \".\" + className;\n-                        classLoader.loadClass(fqName);\n-                        // no ClassNotFoundException, fqName is a known class\n-                        isSamePackage \u003d true;\n-                    }\n-                }\n-                catch (final ClassNotFoundException ex) {\n-                    // not a class from the same package\n-                    isSamePackage \u003d false;\n-                }\n-\n-                if (!(isSameFile || isSamePackage)) {\n-                    return illegal;\n-                }\n-            }\n-\n-            // class from same package\n-\n-            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n-            // \"illegalInsts.contains(className)\" check above\n-\n-            // the test is the \"no garbage\" version of\n-            // illegal.equals(pkgName + \".\" + className)\n-            if (pkgName !\u003d null\n-                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n-                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n-                \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(pkgName)) {\n+            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {\n                 return illegal;\n             }\n-            // import statements\n-            for (FullIdent importLineText : imports) {\n-                final String importArg \u003d importLineText.getText();\n-                if (importArg.endsWith(\".*\")) {\n-                    final String fqClass \u003d\n-                        importArg.substring(0, importArg.length() - 1)\n-                        + className;\n-                    // assume that illegalInsts only contain existing classes\n-                    // or else we might create a false alarm here\n-                    if (illegalClasses.contains(fqClass)) {\n-                        return fqClass;\n-                    }\n-                }\n-                else {\n-                    if (Utils.baseClassname(importArg).equals(className)\n-                        \u0026\u0026 illegalClasses.contains(importArg)) {\n-                        return importArg;\n-                    }\n-                }\n+            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {\n+                return illegal;\n+            }\n+            final String importArg \u003d checkImportStatements(className);\n+            if (importArg !\u003d null) {\n+                return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "dba746ba9387bee04ed362254abb5d9ed35169cd": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from PrematureDeclaration rule. #948\n",
      "commitDate": 1431536292000,
      "commitName": "dba746ba9387bee04ed362254abb5d9ed35169cd",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1430523168000,
      "commitNameOld": "31421dcdda3b3534f2fcc5c6e88a8fdbc5d15311",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 11.73,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,84 @@\n     private String getIllegalInstantiation(String className)\n     {\n-        final String javlang \u003d \"java.lang.\";\n-\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (illegalLen - javlang.length() \u003d\u003d clsNameLen\n+            if (illegalLen - JAVA_LANG.length() \u003d\u003d clsNameLen\n                 \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(javlang))\n+                \u0026\u0026 illegal.startsWith(JAVA_LANG))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (pkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(pkgName + \".\" + className)\n             if (pkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(className)\n                         \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1424437367000,
      "commitNameOld": "27149f3504a2f350b74f456a9bffbae76a460060",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n     private String getIllegalInstantiation(String className)\n     {\n         final String javlang \u003d \"java.lang.\";\n \n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n-        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n+        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n+            if (illegalLen - javlang.length() \u003d\u003d clsNameLen\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(javlang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (pkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(pkgName + \".\" + className)\n-            if ((pkgName !\u003d null)\n-                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n-                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n+            if (pkgName !\u003d null\n+                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n+                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(className)\n                         \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, coding, #512\n",
      "commitDate": 1421677214000,
      "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "08638b5f739d9929698860048c052da2d5f80209": {
      "type": "Ybodychange",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": 1197700618000,
      "commitName": "08638b5f739d9929698860048c052da2d5f80209",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1169909494000,
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 321.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,86 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n-        final Iterator illIter \u003d mIllegalClasses.iterator();\n-        while (illIter.hasNext()) {\n-            final String illegal \u003d (String) illIter.next();\n+        for (String illegal : mIllegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if ((mPkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n-            final Iterator importIter \u003d mImports.iterator();\n-            while (importIter.hasNext()) {\n-                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n+            for (FullIdent importLineText : mImports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": 1152243856000,
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1152242806000,
      "commitNameOld": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n-                catch (ClassNotFoundException ex) {\n+                catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if ((mPkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "c2d3932843e70e4bb5df7161800aca248f9af778": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the use of ()\u0027s\n",
      "commitDate": 1152242806000,
      "commitName": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1130786628000,
      "commitNameOld": "1aee9d55cc5bd8cca011e17369f6e370efcc85bb",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 248.34,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n-            if (mPkgName !\u003d null\n-                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n-                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n+            if ((mPkgName !\u003d null)\n+                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n+                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "5d7063c660b241bce251f1a8c89394619f2791fb": {
      "type": "Ybodychange",
      "commitMessage": "Tighten up code\n",
      "commitDate": 1093527252000,
      "commitName": "5d7063c660b241bce251f1a8c89394619f2791fb",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1074114639000,
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 224.68,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n-                boolean isSameFile \u003d mClassNames.contains(aClassName);\n+                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug #772832, Confusion about class named \u0027Boolean\u0027\n",
      "commitDate": 1059916964000,
      "commitName": "bb1db4938ccae0f7149461ea372398fb8a53f2a8",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1056375080000,
      "commitNameOld": "32f5f97181f9049af5411a5b8f151b51f1c5f165",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 40.99,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n-                return illegal;\n+                // java.lang needs no import, but a class without import might\n+                // also come from the same file or be in the same package.\n+                // E.g. if a class defines an inner class \"Boolean\",\n+                // the expression \"new Boolean()\" refers to that class,\n+                // not to java.lang.Boolean\n+\n+                boolean isSameFile \u003d mClassNames.contains(aClassName);\n+\n+                boolean isSamePackage \u003d false;\n+                try {\n+                    final ClassLoader classLoader \u003d getClassLoader();\n+                    if (classLoader !\u003d null) {\n+                        final String fqName \u003d mPkgName + \".\" + aClassName;\n+                        classLoader.loadClass(fqName);\n+                        // no ClassNotFoundException, fqName is a known class\n+                        isSamePackage \u003d true;\n+                    }\n+                }\n+                catch (ClassNotFoundException ex) {\n+                    // not a class from the same package\n+                    isSamePackage \u003d false;\n+                }\n+\n+                if (!(isSameFile || isSamePackage)) {\n+                    return illegal;\n+                }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "9920857810ecc9efdbca19e2749b75abc0cbbf14": {
      "type": "Yfilerename",
      "commitMessage": "Refactored the Coding checks\n",
      "commitDate": 1055680780000,
      "commitName": "9920857810ecc9efdbca19e2749b75abc0cbbf14",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1055612861000,
      "commitNameOld": "e464c231eccec72f964131d9aeb5e49982c4b3bb",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866": {
      "type": "Ybodychange",
      "commitMessage": "Refactored out ugly copy/paste code.\n",
      "commitDate": 1047612173000,
      "commitName": "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1045363824000,
      "commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 26.02,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 return illegal;\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n-                    if (basename(importArg).equals(aClassName)\n+                    if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n"
    },
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3": {
      "type": "Yintroduced",
      "commitMessage": "ported the illegal instantiations check\nstill need to remove the old code\n",
      "commitDate": 1033328618000,
      "commitName": "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3",
      "commitAuthor": "Lars Kühne"
    }
  }
}