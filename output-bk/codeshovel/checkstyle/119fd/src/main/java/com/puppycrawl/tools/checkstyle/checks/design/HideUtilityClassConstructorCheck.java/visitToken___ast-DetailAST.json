{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/ncbradley/codeshovel-repos/checkstyle/.git",
  "startCommitName": "119fd4fb33bef9f5c66fc950396669af842c21a3",
  "sourceFileName": "HideUtilityClassConstructorCheck.java",
  "functionName": "visitToken",
  "functionId": "visitToken___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java",
  "functionStartLine": 62,
  "functionEndLine": 91,
  "changeHistory": [
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
    "bf9325be913ce46a1427232c455f4830b574ba44",
    "23a1b6253f6296c1a3888361953da47f2808ca3d",
    "7874cc4909f6e5104f42060528b9069669993533",
    "dd6b080a16e0933b3d19305f84ba01c8893839f3",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "e912c46b5bb5c085323930bd1e500b180c1bea8d",
    "50c9bb69bcd93e6fbf272670e8b9d95f2f451c5f",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "b142c593512c9ef1179f4254ec406c23d180ed2f",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
    "6abdc24080fe87995f39bd54bed99976dace4652",
    "0759e2257417baf28eb663636cd788f807ce953d",
    "9cbee6a57e6ad5167c3d9406f272fd44350f5e1d",
    "865ba5284aace7651f93dc81b0c196d1316a9fdd",
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb",
    "066696714bd522b26177f6be814bac334e57b332",
    "3a75454e8dce5c5d5b2d43e80b4a4ed5dbceece3",
    "32d19d680144540a83c5dde5588f5a7ac302f8e1",
    "669def894ec6fa19946acd3b586508aed450a4de"
  ],
  "changeHistoryShort": {
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": "Ybodychange",
    "bf9325be913ce46a1427232c455f4830b574ba44": "Ybodychange",
    "23a1b6253f6296c1a3888361953da47f2808ca3d": "Ybodychange",
    "7874cc4909f6e5104f42060528b9069669993533": "Ybodychange",
    "dd6b080a16e0933b3d19305f84ba01c8893839f3": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "e912c46b5bb5c085323930bd1e500b180c1bea8d": "Ybodychange",
    "50c9bb69bcd93e6fbf272670e8b9d95f2f451c5f": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "b142c593512c9ef1179f4254ec406c23d180ed2f": "Ybodychange",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": "Ybodychange",
    "6abdc24080fe87995f39bd54bed99976dace4652": "Ybodychange",
    "0759e2257417baf28eb663636cd788f807ce953d": "Ybodychange",
    "9cbee6a57e6ad5167c3d9406f272fd44350f5e1d": "Ybodychange",
    "865ba5284aace7651f93dc81b0c196d1316a9fdd": "Ybodychange",
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb": "Ybodychange",
    "066696714bd522b26177f6be814bac334e57b332": "Ybodychange",
    "3a75454e8dce5c5d5b2d43e80b4a4ed5dbceece3": "Ybodychange",
    "32d19d680144540a83c5dde5588f5a7ac302f8e1": "Yfilerename",
    "669def894ec6fa19946acd3b586508aed450a4de": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3143: forbid empty return statements and fixed violations",
      "commitDate": 1464356569000,
      "commitName": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthor": "rnveach",
      "commitDateOld": 1454680863000,
      "commitNameOld": "cf96dd9adcf0c3c8f8f05a9ffdcb765cafe17479",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 111.99,
      "commitsBetweenForRepo": 276,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,30 @@\n     public void visitToken(DetailAST ast) {\n-        if (isAbstract(ast)) {\n-            // abstract class could not have private constructor\n-            return;\n-        }\n-        final boolean hasStaticModifier \u003d isStatic(ast);\n+        // abstract class could not have private constructor\n+        if (!isAbstract(ast)) {\n+            final boolean hasStaticModifier \u003d isStatic(ast);\n \n-        final Details details \u003d new Details(ast);\n-        details.invoke();\n+            final Details details \u003d new Details(ast);\n+            details.invoke();\n \n-        final boolean hasDefaultCtor \u003d details.isHasDefaultCtor();\n-        final boolean hasPublicCtor \u003d details.isHasPublicCtor();\n-        final boolean hasMethodOrField \u003d details.isHasMethodOrField();\n-        final boolean hasNonStaticMethodOrField \u003d details.isHasNonStaticMethodOrField();\n-        final boolean hasNonPrivateStaticMethodOrField \u003d\n-                details.isHasNonPrivateStaticMethodOrField();\n+            final boolean hasDefaultCtor \u003d details.isHasDefaultCtor();\n+            final boolean hasPublicCtor \u003d details.isHasPublicCtor();\n+            final boolean hasMethodOrField \u003d details.isHasMethodOrField();\n+            final boolean hasNonStaticMethodOrField \u003d details.isHasNonStaticMethodOrField();\n+            final boolean hasNonPrivateStaticMethodOrField \u003d\n+                    details.isHasNonPrivateStaticMethodOrField();\n \n-        final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n+            final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n-        // figure out if class extends java.lang.object directly\n-        // keep it simple for now and get a 99% solution\n-        final boolean extendsJlo \u003d\n-            ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n+            // figure out if class extends java.lang.object directly\n+            // keep it simple for now and get a 99% solution\n+            final boolean extendsJlo \u003d\n+                ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n-        final boolean isUtilClass \u003d extendsJlo \u0026\u0026 hasMethodOrField\n-            \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n+            final boolean isUtilClass \u003d extendsJlo \u0026\u0026 hasMethodOrField\n+                \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n-        if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n-            log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n+            if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n+                log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n+            }\n         }\n     }\n\\ No newline at end of file\n"
    },
    "bf9325be913ce46a1427232c455f4830b574ba44": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2639: adjust AbbreviationAsWordInName in checkstyle_checks.xml to catch unexpected abbreviations\n",
      "commitDate": 1448157067000,
      "commitName": "bf9325be913ce46a1427232c455f4830b574ba44",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1441045466000,
      "commitNameOld": "2b861bd6e16584e22bb115ff7abd65c35072eb92",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 82.31,
      "commitsBetweenForRepo": 552,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     public void visitToken(DetailAST ast) {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n         final boolean hasStaticModifier \u003d isStatic(ast);\n \n         final Details details \u003d new Details(ast);\n         details.invoke();\n \n         final boolean hasDefaultCtor \u003d details.isHasDefaultCtor();\n         final boolean hasPublicCtor \u003d details.isHasPublicCtor();\n         final boolean hasMethodOrField \u003d details.isHasMethodOrField();\n         final boolean hasNonStaticMethodOrField \u003d details.isHasNonStaticMethodOrField();\n         final boolean hasNonPrivateStaticMethodOrField \u003d\n                 details.isHasNonPrivateStaticMethodOrField();\n \n         final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n-        final boolean extendsJLO \u003d\n+        final boolean extendsJlo \u003d\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n-        final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n+        final boolean isUtilClass \u003d extendsJlo \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "23a1b6253f6296c1a3888361953da47f2808ca3d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Fix for \u0027Don\u0027t use trailing comments\u0027 (partial)\n",
      "commitDate": 1440158741000,
      "commitName": "23a1b6253f6296c1a3888361953da47f2808ca3d",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": 1440040911000,
      "commitNameOld": "efa16e17bf710b7b24af828296c2337612912ba9",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 1.36,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     public void visitToken(DetailAST ast) {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n         final boolean hasStaticModifier \u003d isStatic(ast);\n \n         final Details details \u003d new Details(ast);\n         details.invoke();\n \n         final boolean hasDefaultCtor \u003d details.isHasDefaultCtor();\n         final boolean hasPublicCtor \u003d details.isHasPublicCtor();\n         final boolean hasMethodOrField \u003d details.isHasMethodOrField();\n         final boolean hasNonStaticMethodOrField \u003d details.isHasNonStaticMethodOrField();\n         final boolean hasNonPrivateStaticMethodOrField \u003d\n                 details.isHasNonPrivateStaticMethodOrField();\n \n         final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n-        final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n+        final boolean extendsJLO \u003d\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "7874cc4909f6e5104f42060528b9069669993533": {
      "type": "Ybodychange",
      "commitMessage": "HideUtilityClassConstructorCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": 1434344165000,
      "commitName": "7874cc4909f6e5104f42060528b9069669993533",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1431863229000,
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 28.71,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,31 @@\n     public void visitToken(DetailAST ast) {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n-\n-        final DetailAST objBlock \u003d ast.findFirstToken(TokenTypes.OBJBLOCK);\n-        DetailAST child \u003d objBlock.getFirstChild();\n         final boolean hasStaticModifier \u003d isStatic(ast);\n-        boolean hasMethodOrField \u003d false;\n-        boolean hasNonStaticMethodOrField \u003d false;\n-        boolean hasNonPrivateStaticMethodOrField \u003d false;\n-        boolean hasDefaultCtor \u003d true;\n-        boolean hasPublicCtor \u003d false;\n \n-        while (child !\u003d null) {\n-            final int type \u003d child.getType();\n-            if (type \u003d\u003d TokenTypes.METHOD_DEF\n-                    || type \u003d\u003d TokenTypes.VARIABLE_DEF) {\n-                hasMethodOrField \u003d true;\n-                final DetailAST modifiers \u003d\n-                    child.findFirstToken(TokenTypes.MODIFIERS);\n-                final boolean isStatic \u003d\n-                    modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n-                final boolean isPrivate \u003d\n-                    modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n+        final Details details \u003d new Details(ast);\n+        details.invoke();\n \n-                if (!isStatic \u0026\u0026 !isPrivate) {\n-                    hasNonStaticMethodOrField \u003d true;\n-                }\n-                if (isStatic \u0026\u0026 !isPrivate) {\n-                    hasNonPrivateStaticMethodOrField \u003d true;\n-                }\n-            }\n-            if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n-                hasDefaultCtor \u003d false;\n-                final DetailAST modifiers \u003d\n-                    child.findFirstToken(TokenTypes.MODIFIERS);\n-                if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n-                    \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED)) {\n-                    // treat package visible as public\n-                    // for the purpose of this Check\n-                    hasPublicCtor \u003d true;\n-                }\n-\n-            }\n-            child \u003d child.getNextSibling();\n-        }\n+        final boolean hasDefaultCtor \u003d details.isHasDefaultCtor();\n+        final boolean hasPublicCtor \u003d details.isHasPublicCtor();\n+        final boolean hasMethodOrField \u003d details.isHasMethodOrField();\n+        final boolean hasNonStaticMethodOrField \u003d details.isHasNonStaticMethodOrField();\n+        final boolean hasNonPrivateStaticMethodOrField \u003d\n+                details.isHasNonPrivateStaticMethodOrField();\n \n         final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "dd6b080a16e0933b3d19305f84ba01c8893839f3": {
      "type": "Ybodychange",
      "commitMessage": "all TODO/FIXME were removed , some of them converted to issues\n",
      "commitDate": 1429810711000,
      "commitName": "dd6b080a16e0933b3d19305f84ba01c8893839f3",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": 1426023398000,
      "commitNameOld": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 43.83,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,66 @@\n     public void visitToken(DetailAST ast)\n     {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n \n         final DetailAST objBlock \u003d ast.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d objBlock.getFirstChild();\n         final boolean hasStaticModifier \u003d isStatic(ast);\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasNonPrivateStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n                 final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n                 if (isStatic \u0026\u0026 !isPrivate) {\n                     hasNonPrivateStaticMethodOrField \u003d true;\n                 }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n-        // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n-        // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": 1426023398000,
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": 1424437367000,
      "commitNameOld": "e912c46b5bb5c085323930bd1e500b180c1bea8d",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n     public void visitToken(DetailAST ast)\n     {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n \n         final DetailAST objBlock \u003d ast.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d objBlock.getFirstChild();\n         final boolean hasStaticModifier \u003d isStatic(ast);\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasNonPrivateStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n                 final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n                 if (isStatic \u0026\u0026 !isPrivate) {\n                     hasNonPrivateStaticMethodOrField \u003d true;\n                 }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d child.getNextSibling();\n         }\n \n-        final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n+        final boolean hasAccessibleCtor \u003d hasDefaultCtor || hasPublicCtor;\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n-        if (isUtilClass \u0026\u0026 (hasAccessibleCtor \u0026\u0026 !hasStaticModifier)) {\n+        if (isUtilClass \u0026\u0026 hasAccessibleCtor \u0026\u0026 !hasStaticModifier) {\n             log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "e912c46b5bb5c085323930bd1e500b180c1bea8d": {
      "type": "Ybodychange",
      "commitMessage": "Refactored UTs, design package, issue #537\n",
      "commitDate": 1424437367000,
      "commitName": "e912c46b5bb5c085323930bd1e500b180c1bea8d",
      "commitAuthor": "alexkravin",
      "commitDateOld": 1424294072000,
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n     public void visitToken(DetailAST ast)\n     {\n         if (isAbstract(ast)) {\n             // abstract class could not have private constructor\n             return;\n         }\n \n         final DetailAST objBlock \u003d ast.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d objBlock.getFirstChild();\n         final boolean hasStaticModifier \u003d isStatic(ast);\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasNonPrivateStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n                 final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n                 if (isStatic \u0026\u0026 !isPrivate) {\n                     hasNonPrivateStaticMethodOrField \u003d true;\n                 }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             ast.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n             \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 (hasAccessibleCtor \u0026\u0026 !hasStaticModifier)) {\n-            log(ast.getLineNo(), ast.getColumnNo(), \"hide.utility.class\");\n+            log(ast.getLineNo(), ast.getColumnNo(), MSG_KEY);\n         }\n     }\n\\ No newline at end of file\n"
    },
    "50c9bb69bcd93e6fbf272670e8b9d95f2f451c5f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, design, #512\n",
      "commitDate": 1421677275000,
      "commitName": "50c9bb69bcd93e6fbf272670e8b9d95f2f451c5f",
      "commitAuthor": "alexkravin",
      "subchanges": [
        "Yparameterchange",
        "Ybodychange"
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": 1393953491000,
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": 1393482905000,
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "b142c593512c9ef1179f4254ec406c23d180ed2f": {
      "type": "Ybodychange",
      "commitMessage": "Fix HideUtilityClassConstructor to handle empty and inner classes. Thanks to Roman Ivanov for patch #3045720.\n",
      "commitDate": 1286414375000,
      "commitName": "b142c593512c9ef1179f4254ec406c23d180ed2f",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1285817783000,
      "commitNameOld": "6f46bd4e83204417edf9605f97098bb9d34da728",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 6.91,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,68 @@\n     public void visitToken(DetailAST aAST)\n     {\n+        if (isAbstract(aAST)) {\n+            // abstract class could not have private constructor\n+            return;\n+        }\n+\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d objBlock.getFirstChild();\n+        final boolean hasStaticModifier \u003d isStatic(aAST);\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n+        boolean hasNonPrivateStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n                 final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n+                if (isStatic \u0026\u0026 !isPrivate) {\n+                    hasNonPrivateStaticMethodOrField \u003d true;\n+                }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n-        final boolean isUtilClass \u003d\n-            extendsJLO \u0026\u0026 hasMethodOrField \u0026\u0026 !hasNonStaticMethodOrField;\n+        final boolean isUtilClass \u003d extendsJLO \u0026\u0026 hasMethodOrField\n+            \u0026\u0026 !hasNonStaticMethodOrField \u0026\u0026 hasNonPrivateStaticMethodOrField;\n \n-        if (isUtilClass \u0026\u0026 hasAccessibleCtor) {\n+        if (isUtilClass \u0026\u0026 (hasAccessibleCtor \u0026\u0026 !hasStaticModifier)) {\n             log(aAST.getLineNo(), aAST.getColumnNo(), \"hide.utility.class\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": {
      "type": "Ybodychange",
      "commitMessage": "Inspired by patch# 2111354 - changes to remove casting. Neat trick\n",
      "commitDate": 1221737656000,
      "commitName": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1207478230000,
      "commitNameOld": "6abdc24080fe87995f39bd54bed99976dace4652",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 165.04,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n-        DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n+        DetailAST child \u003d objBlock.getFirstChild();\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n                 final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n-            child \u003d (DetailAST) child.getNextSibling();\n+            child \u003d child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d\n             extendsJLO \u0026\u0026 hasMethodOrField \u0026\u0026 !hasNonStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor) {\n             log(aAST.getLineNo(), aAST.getColumnNo(), \"hide.utility.class\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "6abdc24080fe87995f39bd54bed99976dace4652": {
      "type": "Ybodychange",
      "commitMessage": "make local variables final.\n",
      "commitDate": 1207478230000,
      "commitName": "6abdc24080fe87995f39bd54bed99976dace4652",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1200296548000,
      "commitNameOld": "fd90bd5aa5cd623b08a2e44ef05e8fac8045d333",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 83.12,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethodOrField \u003d false;\n         boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n-            int type \u003d child.getType();\n+            final int type \u003d child.getType();\n             if (type \u003d\u003d TokenTypes.METHOD_DEF\n                     || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n             {\n                 hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n-                boolean isStatic \u003d\n+                final boolean isStatic \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n-                boolean isPrivate \u003d\n+                final boolean isPrivate \u003d\n                     modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n \n                 if (!isStatic \u0026\u0026 !isPrivate) {\n                     hasNonStaticMethodOrField \u003d true;\n                 }\n             }\n             if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         final boolean isUtilClass \u003d\n             extendsJLO \u0026\u0026 hasMethodOrField \u0026\u0026 !hasNonStaticMethodOrField;\n \n         if (isUtilClass \u0026\u0026 hasAccessibleCtor) {\n             log(aAST.getLineNo(), aAST.getColumnNo(), \"hide.utility.class\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "0759e2257417baf28eb663636cd788f807ce953d": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug #1762702, false alarm in HideUtilityClassConstructor check when class has only static methods but contains non static fields\n",
      "commitDate": 1185744607000,
      "commitName": "0759e2257417baf28eb663636cd788f807ce953d",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1169909494000,
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 183.28,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,58 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n-        boolean hasMethod \u003d false;\n-        boolean hasNonStaticMethod \u003d false;\n+        boolean hasMethodOrField \u003d false;\n+        boolean hasNonStaticMethodOrField \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n-            if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n-                hasMethod \u003d true;\n+            int type \u003d child.getType();\n+            if (type \u003d\u003d TokenTypes.METHOD_DEF\n+                    || type \u003d\u003d TokenTypes.VARIABLE_DEF)\n+            {\n+                hasMethodOrField \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n-                if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n-                    hasNonStaticMethod \u003d true;\n+                boolean isStatic \u003d\n+                    modifiers.branchContains(TokenTypes.LITERAL_STATIC);\n+                boolean isPrivate \u003d\n+                    modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\n+\n+                if (!isStatic \u0026\u0026 !isPrivate) {\n+                    hasNonStaticMethodOrField \u003d true;\n                 }\n             }\n-            if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n+            if (type \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n-        if (extendsJLO\n-                \u0026\u0026 hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor)\n-        {\n+        final boolean isUtilClass \u003d\n+            extendsJLO \u0026\u0026 hasMethodOrField \u0026\u0026 !hasNonStaticMethodOrField;\n+\n+        if (isUtilClass \u0026\u0026 hasAccessibleCtor) {\n             log(aAST.getLineNo(), aAST.getColumnNo(), \"hide.utility.class\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "9cbee6a57e6ad5167c3d9406f272fd44350f5e1d": {
      "type": "Ybodychange",
      "commitMessage": "i18n support for HideUtilityClassCtor and ArrayTypeStyle checks (bug 1262825)\n",
      "commitDate": 1126182755000,
      "commitName": "9cbee6a57e6ad5167c3d9406f272fd44350f5e1d",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1124261720000,
      "commitNameOld": "865ba5284aace7651f93dc81b0c196d1316a9fdd",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 22.23,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,49 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethod \u003d false;\n         boolean hasNonStaticMethod \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 hasMethod \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n                     hasNonStaticMethod \u003d true;\n                 }\n             }\n             if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n             aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         if (extendsJLO\n                 \u0026\u0026 hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor)\n         {\n-            log(aAST.getLineNo(), aAST.getColumnNo(),\n-                \"Utility classes should not have \"\n-                + \"a public or default constructor.\");\n+            log(aAST.getLineNo(), aAST.getColumnNo(), \"hide.utility.class\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "865ba5284aace7651f93dc81b0c196d1316a9fdd": {
      "type": "Ybodychange",
      "commitMessage": "Changes for grammer to keep as much text in AST tree as we can.\nFor now I do nothing with this/super in (SUPER_)CTOR_CALL.\nShould think more about this.\n\nAlso I\u0027ve changed grammer to not generate extends/implement cleases\nif there is no such in the code.\n\nMade some refactoring for build.xml to make possible to redirect build\noutput to custom directory (and we used too much hardcoded paths there\n:)\n\nIt looks like this is my last commit before vacation, so I hope\nI will break nothing :)\n",
      "commitDate": 1124261720000,
      "commitName": "865ba5284aace7651f93dc81b0c196d1316a9fdd",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": 1105267857000,
      "commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 219.84,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,51 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethod \u003d false;\n         boolean hasNonStaticMethod \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 hasMethod \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n                     hasNonStaticMethod \u003d true;\n                 }\n             }\n             if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n-        final DetailAST extendsClause \u003d\n-                aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n-                extendsClause.getFirstChild() \u003d\u003d null;\n+            aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE) \u003d\u003d null;\n \n         if (extendsJLO\n                 \u0026\u0026 hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor)\n         {\n             log(aAST.getLineNo(), aAST.getColumnNo(),\n                 \"Utility classes should not have \"\n                 + \"a public or default constructor.\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb": {
      "type": "Ybodychange",
      "commitMessage": "Tighten up code\n",
      "commitDate": 1093528034000,
      "commitName": "2f70947ed74ab968324fdcf83f808ff1d88df1fb",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1074114639000,
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 224.69,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n+        final DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethod \u003d false;\n         boolean hasNonStaticMethod \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 hasMethod \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n                     hasNonStaticMethod \u003d true;\n                 }\n             }\n             if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         // figure out if class extends java.lang.object directly\n         // keep it simple for now and get a 99% solution\n         // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n         // consider \"import org.omg.CORBA.*\"\n         final DetailAST extendsClause \u003d\n                 aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n         final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n                 extendsClause.getFirstChild() \u003d\u003d null;\n \n         if (extendsJLO\n                 \u0026\u0026 hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor)\n         {\n             log(aAST.getLineNo(), aAST.getColumnNo(),\n                 \"Utility classes should not have \"\n                 + \"a public or default constructor.\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "066696714bd522b26177f6be814bac334e57b332": {
      "type": "Ybodychange",
      "commitMessage": "bugfix for #824754, HideUtilityConstructor should not apply to subclasses\n",
      "commitDate": 1067206200000,
      "commitName": "066696714bd522b26177f6be814bac334e57b332",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": 1056458140000,
      "commitNameOld": "3a75454e8dce5c5d5b2d43e80b4a4ed5dbceece3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 124.4,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,53 @@\n     public void visitToken(DetailAST aAST)\n     {\n         DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethod \u003d false;\n         boolean hasNonStaticMethod \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 hasMethod \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n                     hasNonStaticMethod \u003d true;\n                 }\n             }\n             if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n         final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n-        if (hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor) {\n+        // figure out if class extends java.lang.object directly\n+        // keep it simple for now and get a 99% solution\n+        // TODO: check for \"extends java.lang.Object\" and \"extends Object\"\n+        // consider \"import org.omg.CORBA.*\"\n+        final DetailAST extendsClause \u003d\n+                aAST.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n+        final boolean extendsJLO \u003d // J.Lo even made it into in our sources :-)\n+                extendsClause.getFirstChild() \u003d\u003d null;\n+\n+        if (extendsJLO\n+                \u0026\u0026 hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor)\n+        {\n             log(aAST.getLineNo(), aAST.getColumnNo(),\n                 \"Utility classes should not have \"\n                 + \"a public or default constructor.\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "3a75454e8dce5c5d5b2d43e80b4a4ed5dbceece3": {
      "type": "Ybodychange",
      "commitMessage": "Added CyclomaticComplexityCheck from Simon Harris.\nRefactored quite a bit\n",
      "commitDate": 1056458140000,
      "commitName": "3a75454e8dce5c5d5b2d43e80b4a4ed5dbceece3",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1055144900000,
      "commitNameOld": "889587fdd22ba03ea670e404d36810e9af113c9d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 15.2,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     public void visitToken(DetailAST aAST)\n     {\n         DetailAST objBlock \u003d aAST.findFirstToken(TokenTypes.OBJBLOCK);\n         DetailAST child \u003d (DetailAST) objBlock.getFirstChild();\n         boolean hasMethod \u003d false;\n         boolean hasNonStaticMethod \u003d false;\n         boolean hasDefaultCtor \u003d true;\n         boolean hasPublicCtor \u003d false;\n \n         while (child !\u003d null) {\n             if (child.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 hasMethod \u003d true;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_STATIC)) {\n                     hasNonStaticMethod \u003d true;\n                 }\n             }\n             if (child.getType() \u003d\u003d TokenTypes.CTOR_DEF) {\n                 hasDefaultCtor \u003d false;\n                 final DetailAST modifiers \u003d\n                     child.findFirstToken(TokenTypes.MODIFIERS);\n                 if (!modifiers.branchContains(TokenTypes.LITERAL_PRIVATE)\n                     \u0026\u0026 !modifiers.branchContains(TokenTypes.LITERAL_PROTECTED))\n                 {\n                     // treat package visible as public\n                     // for the purpose of this Check\n                     hasPublicCtor \u003d true;\n                 }\n \n             }\n             child \u003d (DetailAST) child.getNextSibling();\n         }\n \n-        boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n+        final boolean hasAccessibleCtor \u003d (hasDefaultCtor || hasPublicCtor);\n \n         if (hasMethod \u0026\u0026 !hasNonStaticMethod \u0026\u0026 hasAccessibleCtor) {\n             log(aAST.getLineNo(), aAST.getColumnNo(),\n                 \"Utility classes should not have \"\n                 + \"a public or default constructor.\");\n         }\n     }\n\\ No newline at end of file\n"
    },
    "32d19d680144540a83c5dde5588f5a7ac302f8e1": {
      "type": "Yfilerename",
      "commitMessage": "Refactored the Design checks\n",
      "commitDate": 1054770724000,
      "commitName": "32d19d680144540a83c5dde5588f5a7ac302f8e1",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": 1054742916000,
      "commitNameOld": "679f818267161d9501a73ffdcc0d991537233633",
      "commitAuthorOld": "Rick Giles",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": ""
    },
    "669def894ec6fa19946acd3b586508aed450a4de": {
      "type": "Yintroduced",
      "commitMessage": "finally added all the new checks that I built during feature freeze\nneed to do more tests and write docs\n",
      "commitDate": 1045545548000,
      "commitName": "669def894ec6fa19946acd3b586508aed450a4de",
      "commitAuthor": "Lars Kühne"
    }
  }
}